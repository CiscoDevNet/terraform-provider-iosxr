//go:build ignore
// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports
import (
	"context"
	"fmt"
	"reflect"
	"sort"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/CiscoDevNet/terraform-provider-iosxr/internal/provider/helpers"
	"github.com/tidwall/sjson"
	"github.com/tidwall/gjson"
	"github.com/netascode/xmldot"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/netascode/go-netconf"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin types

{{- $name := camelCase .Name}}
type {{camelCase .Name}} struct {
	Device types.String `tfsdk:"device"`
	Id     types.String `tfsdk:"id"`
{{- if and (not .NoDelete) (not .NoDeleteAttributes)}}
	DeleteMode types.String `tfsdk:"delete_mode"`
{{- end}}
{{- range .Attributes}}
{{- if or (eq .Type "List") (eq .Type "Set")}}
	{{toGoName .TfName}} []{{$name}}{{toGoName .TfName}} `tfsdk:"{{.TfName}}"`
{{- else if or (eq .Type "StringList") (eq .Type "Int64List")}}
	{{toGoName .TfName}} types.List `tfsdk:"{{.TfName}}"`
{{- else if or (eq .Type "StringSet") (eq .Type "Int64Set")}}
	{{toGoName .TfName}} types.Set `tfsdk:"{{.TfName}}"`
{{- else}}
	{{toGoName .TfName}} types.{{.Type}} `tfsdk:"{{.TfName}}"`
{{- end}}
{{- end}}
}

type {{camelCase .Name}}Data struct {
	Device types.String `tfsdk:"device"`
	Id     types.String `tfsdk:"id"`
{{- range .Attributes}}
{{- if or (eq .Type "List") (eq .Type "Set")}}
	{{toGoName .TfName}} []{{$name}}{{toGoName .TfName}} `tfsdk:"{{.TfName}}"`
{{- else if or (eq .Type "StringList") (eq .Type "Int64List")}}
	{{toGoName .TfName}} types.List `tfsdk:"{{.TfName}}"`
{{- else if or (eq .Type "StringSet") (eq .Type "Int64Set")}}
	{{toGoName .TfName}} types.Set `tfsdk:"{{.TfName}}"`
{{- else}}
	{{toGoName .TfName}} types.{{.Type}} `tfsdk:"{{.TfName}}"`
{{- end}}
{{- end}}
}

{{- range .Attributes}}
{{- $cname := toGoName .TfName}}
{{- if or (eq .Type "List") (eq .Type "Set")}}
type {{$name}}{{toGoName .TfName}} struct {
{{- range .Attributes}}
{{- if or (eq .Type "List") (eq .Type "Set")}}
	{{toGoName .TfName}} []{{$name}}{{$cname}}{{toGoName .TfName}} `tfsdk:"{{.TfName}}"`
{{- else if or (eq .Type "StringList") (eq .Type "Int64List")}}
	{{toGoName .TfName}} types.List `tfsdk:"{{.TfName}}"`
{{- else if or (eq .Type "StringSet") (eq .Type "Int64Set")}}
	{{toGoName .TfName}} types.Set `tfsdk:"{{.TfName}}"`
{{- else}}
	{{toGoName .TfName}} types.{{.Type}} `tfsdk:"{{.TfName}}"`
{{- end}}
{{- end}}
}
{{- end}}
{{- end}}

{{- range .Attributes}}
{{- $cname := toGoName .TfName}}
{{- if or (eq .Type "List") (eq .Type "Set")}}
{{- range .Attributes}}
{{- $ccname := toGoName .TfName}}
{{- if or (eq .Type "List") (eq .Type "Set")}}
type {{$name}}{{$cname}}{{toGoName .TfName}} struct {
{{- range .Attributes}}
{{- if and .TfName .Type}}
{{- if or (eq .Type "List") (eq .Type "Set")}}
	{{toGoName .TfName}} []{{$name}}{{$cname}}{{$ccname}}{{toGoName .TfName}} `tfsdk:"{{.TfName}}"`
{{- else if or (eq .Type "StringList") (eq .Type "Int64List")}}
	{{toGoName .TfName}} types.List `tfsdk:"{{.TfName}}"`
{{- else if or (eq .Type "StringSet") (eq .Type "Int64Set")}}
	{{toGoName .TfName}} types.Set `tfsdk:"{{.TfName}}"`
{{- else}}
	{{toGoName .TfName}} types.{{.Type}} `tfsdk:"{{.TfName}}"`
{{- end}}
{{- end}}
{{- end}}
}
{{- end}}
{{- end}}
{{- end}}
{{- end}}

{{- range .Attributes}}
{{- $cname := toGoName .TfName}}
{{- if or (eq .Type "List") (eq .Type "Set")}}
{{- range .Attributes}}
{{- $ccname := toGoName .TfName}}
{{- if or (eq .Type "List") (eq .Type "Set")}}
{{- range .Attributes}}
{{- $cccname := toGoName .TfName}}
{{- if or (eq .Type "List") (eq .Type "Set")}}
type {{$name}}{{$cname}}{{$ccname}}{{toGoName .TfName}} struct {
{{- range .Attributes}}
{{- if and .TfName .Type}}
{{- if or (eq .Type "List") (eq .Type "Set")}}
	{{toGoName .TfName}} []{{$name}}{{$cname}}{{$ccname}}{{$cccname}}{{toGoName .TfName}} `tfsdk:"{{.TfName}}"`
{{- else if or (eq .Type "StringList") (eq .Type "Int64List")}}
	{{toGoName .TfName}} types.List `tfsdk:"{{.TfName}}"`
{{- else if or (eq .Type "StringSet") (eq .Type "Int64Set")}}
	{{toGoName .TfName}} types.Set `tfsdk:"{{.TfName}}"`
{{- else}}
	{{toGoName .TfName}} types.{{.Type}} `tfsdk:"{{.TfName}}"`
{{- end}}
{{- end}}
{{- end}}
}
{{- end}}
{{- end}}
{{- end}}
{{- end}}
{{- end}}
{{- end}}

{{- range .Attributes}}
{{- $cname := toGoName .TfName}}
{{- if or (eq .Type "List") (eq .Type "Set")}}
{{- range .Attributes}}
{{- $ccname := toGoName .TfName}}
{{- if or (eq .Type "List") (eq .Type "Set")}}
{{- range .Attributes}}
{{- $cccname := toGoName .TfName}}
{{- if or (eq .Type "List") (eq .Type "Set")}}
{{- range .Attributes}}
{{- if or (eq .Type "List") (eq .Type "Set")}}
type {{$name}}{{$cname}}{{$ccname}}{{$cccname}}{{toGoName .TfName}} struct {
{{- range .Attributes}}
{{- if and .TfName .Type}}
{{- if or (eq .Type "StringList") (eq .Type "Int64List")}}
	{{toGoName .TfName}} types.List `tfsdk:"{{.TfName}}"`
{{- else if or (eq .Type "StringSet") (eq .Type "Int64Set")}}
	{{toGoName .TfName}} types.Set `tfsdk:"{{.TfName}}"`
{{- else if not (or (eq .Type "List") (eq .Type "Set"))}}
	{{toGoName .TfName}} types.{{.Type}} `tfsdk:"{{.TfName}}"`
{{- end}}
{{- end}}
{{- end}}
}
{{- end}}
{{- end}}
{{- end}}
{{- end}}
{{- end}}
{{- end}}
{{- end}}
{{- end}}

// End of section. //template:end types

// Section below is generated&owned by "gen/generator.go". //template:begin getPath

func (data {{camelCase .Name}}) getPath() string {
{{- if hasId .Attributes}}
	return fmt.Sprintf("{{toGnmiPath .Path}}"{{range .Attributes}}{{if or .Id .Reference}}, data.{{toGoName .TfName}}.Value{{.Type}}(){{end}}{{end}})
{{- else}}
	return "{{toGnmiPath .Path}}"
{{- end}}
}

func (data {{camelCase .Name}}Data) getPath() string {
{{- if hasId .Attributes}}
	return fmt.Sprintf("{{toGnmiPath .Path}}"{{range .Attributes}}{{if or .Id .Reference}}, data.{{toGoName .TfName}}.Value{{.Type}}(){{end}}{{end}})
{{- else}}
	return "{{toGnmiPath .Path}}"
{{- end}}
}

// getXPath returns the XPath for NETCONF operations
func (data {{camelCase .Name}}) getXPath() string {
	path := "{{.Path}}"
{{- if hasId .Attributes}}
	path = fmt.Sprintf(path{{range .Attributes}}{{if or .Id .Reference}}{{if eq .Type "Int64"}}, data.{{toGoName .TfName}}.ValueInt64(){{else}}, fmt.Sprintf("%v", data.{{toGoName .TfName}}.Value{{.Type}}()){{end}}{{end}}{{end}})
{{- end}}
	return path
}

func (data {{camelCase .Name}}Data) getXPath() string {
	path := "{{.Path}}"
{{- if hasId .Attributes}}
	path = fmt.Sprintf(path{{range .Attributes}}{{if or .Id .Reference}}{{if eq .Type "Int64"}}, data.{{toGoName .TfName}}.ValueInt64(){{else}}, fmt.Sprintf("%v", data.{{toGoName .TfName}}.Value{{.Type}}()){{end}}{{end}}{{end}})
{{- end}}
	return path
}

// End of section. //template:end getPath

// Section below is generated&owned by "gen/generator.go". //template:begin toBody

func (data {{camelCase .Name}}) toBody(ctx context.Context) string {
	body := "{}"
	{{- range .Attributes}}
	{{- if and (not .Reference) (ne .Type "List") (ne .Type "Set")}}
	if !data.{{toGoName .TfName}}.IsNull() && !data.{{toGoName .TfName}}.IsUnknown() {
		{{- if eq .Type "Int64"}}
		body, _ = sjson.Set(body, "{{toDotPath .XPath}}", strconv.FormatInt(data.{{toGoName .TfName}}.ValueInt64(), 10))
		{{- else if and (eq .Type "Bool") (eq .TypeYangBool "empty")}}
		if data.{{toGoName .TfName}}.ValueBool() {
			body, _ = sjson.Set(body, "{{toDotPath .XPath}}", []interface{}{nil})
		}
		{{- else if and (eq .Type "Bool") (eq .TypeYangBool "presence")}}
		if data.{{toGoName .TfName}}.ValueBool() {
			body, _ = sjson.Set(body, "{{toDotPath .XPath}}", map[string]string{})
		}
		{{- else if and (eq .Type "Bool") (eq .TypeYangBool "boolean")}}
		body, _ = sjson.Set(body, "{{toDotPath .XPath}}", data.{{toGoName .TfName}}.ValueBool())
		{{- else if eq .Type "String"}}
		body, _ = sjson.Set(body, "{{toDotPath .XPath}}", data.{{toGoName .TfName}}.ValueString())
		{{- else if or (eq .Type "StringList") (eq .Type "StringSet")}}
		var values []string
		data.{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
		body, _ = sjson.Set(body, "{{toDotPath .XPath}}", values)
		{{- else if or (eq .Type "Int64List") (eq .Type "Int64Set")}}
		var values []int
		data.{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
		body, _ = sjson.Set(body, "{{toDotPath .XPath}}", values)
		{{- end}}
	}
	{{- end}}
	{{- end}}
	{{- range .Attributes}}
	{{- if or (eq .Type "List") (eq .Type "Set")}}
	{{- $list := toDotPath .XPath }}
	if len(data.{{toGoName .TfName}}) > 0 {
		body, _ = sjson.Set(body, "{{toDotPath .XPath}}", []interface{}{})
		for index, item := range data.{{toGoName .TfName}} {
			{{- range .Attributes}}
			{{- if and (ne .Type "List") (ne .Type "Set")}}
			if !item.{{toGoName .TfName}}.IsNull() && !item.{{toGoName .TfName}}.IsUnknown() {
				{{- if eq .Type "Int64"}}
				body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{toDotPath .XPath}}", strconv.FormatInt(item.{{toGoName .TfName}}.ValueInt64(), 10))
				{{- else if and (eq .Type "Bool") (eq .TypeYangBool "empty")}}
				if item.{{toGoName .TfName}}.ValueBool() {
					body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{toDotPath .XPath}}", []interface{}{nil})
				}
				{{- else if and (eq .Type "Bool") (eq .TypeYangBool "presence")}}
				if item.{{toGoName .TfName}}.ValueBool() {
					body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{toDotPath .XPath}}", map[string]string{})
				}
				{{- else if and (eq .Type "Bool") (eq .TypeYangBool "boolean")}}
				body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{toDotPath .XPath}}", item.{{toGoName .TfName}}.ValueBool())
				{{- else if eq .Type "String"}}
				body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{toDotPath .XPath}}", item.{{toGoName .TfName}}.ValueString())
				{{- else if or (eq .Type "StringList") (eq .Type "StringSet")}}
				var values []string
				item.{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
				body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{toDotPath .XPath}}", values)
				{{- else if or (eq .Type "Int64List") (eq .Type "Int64Set")}}
				var values []int
				item.{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
				body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{toDotPath .XPath}}", values)
				{{- end}}
			}
			{{- end}}
			{{- end}}
			{{- range .Attributes}}
			{{- if or (eq .Type "List") (eq .Type "Set")}}
			{{- $clist := toDotPath .XPath }}
			if len(item.{{toGoName .TfName}}) > 0 {
				body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{toDotPath .XPath}}", []interface{}{})
				for cindex, citem := range item.{{toGoName .TfName}} {
					{{- range .Attributes}}
					{{- if and (ne .Type "List") (ne .Type "Set")}}
					if !citem.{{toGoName .TfName}}.IsNull() && !citem.{{toGoName .TfName}}.IsUnknown() {
						{{- if eq .Type "Int64"}}
						body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{toDotPath .XPath}}", strconv.FormatInt(citem.{{toGoName .TfName}}.ValueInt64(), 10))
						{{- else if and (eq .Type "Bool") (eq .TypeYangBool "empty")}}
						if citem.{{toGoName .TfName}}.ValueBool() {
							body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{toDotPath .XPath}}", []interface{}{nil})
						}
						{{- else if and (eq .Type "Bool") (eq .TypeYangBool "presence")}}
						if citem.{{toGoName .TfName}}.ValueBool() {
							body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{toDotPath .XPath}}", map[string]string{})
						}
						{{- else if and (eq .Type "Bool") (eq .TypeYangBool "boolean")}}
						body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{toDotPath .XPath}}", citem.{{toGoName .TfName}}.ValueBool())
						{{- else if eq .Type "String"}}
						body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{toDotPath .XPath}}", citem.{{toGoName .TfName}}.ValueString())
						{{- else if or (eq .Type "StringList") (eq .Type "StringSet")}}
						var values []string
						citem.{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
						body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{toDotPath .XPath}}", values)
						{{- else if or (eq .Type "Int64List") (eq .Type "Int64Set")}}
						var values []int
						citem.{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
						body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{toDotPath .XPath}}", values)
						{{- end}}
					}
					{{- end}}
					{{- end}}
					{{- range .Attributes}}
					{{- if or (eq .Type "List") (eq .Type "Set")}}
					{{- $cclist := toDotPath .XPath }}
					if len(citem.{{toGoName .TfName}}) > 0 {
						body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{toDotPath .XPath}}", []interface{}{})
						for ccindex, ccitem := range citem.{{toGoName .TfName}} {
							{{- range .Attributes}}
							{{- if and (ne .Type "List") (ne .Type "Set")}}
							if !ccitem.{{toGoName .TfName}}.IsNull() && !ccitem.{{toGoName .TfName}}.IsUnknown() {
								{{- if eq .Type "Int64"}}
								body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{$cclist}}"+"."+strconv.Itoa(ccindex)+"."+"{{toDotPath .XPath}}", strconv.FormatInt(ccitem.{{toGoName .TfName}}.ValueInt64(), 10))
								{{- else if and (eq .Type "Bool") (eq .TypeYangBool "empty")}}
								if ccitem.{{toGoName .TfName}}.ValueBool() {
									body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{$cclist}}"+"."+strconv.Itoa(ccindex)+"."+"{{toDotPath .XPath}}", []interface{}{nil})
								}
								{{- else if and (eq .Type "Bool") (eq .TypeYangBool "presence")}}
								if ccitem.{{toGoName .TfName}}.ValueBool() {
									body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{$cclist}}"+"."+strconv.Itoa(ccindex)+"."+"{{toDotPath .XPath}}", map[string]string{})
								}
								{{- else if and (eq .Type "Bool") (eq .TypeYangBool "boolean")}}
								body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{$cclist}}"+"."+strconv.Itoa(ccindex)+"."+"{{toDotPath .XPath}}", ccitem.{{toGoName .TfName}}.ValueBool())
								{{- else if eq .Type "String"}}
								body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{$cclist}}"+"."+strconv.Itoa(ccindex)+"."+"{{toDotPath .XPath}}", ccitem.{{toGoName .TfName}}.ValueString())
								{{- else if or (eq .Type "StringList") (eq .Type "StringSet")}}
								var values []string
								ccitem.{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
								body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{$cclist}}"+"."+strconv.Itoa(ccindex)+"."+"{{toDotPath .XPath}}", values)
								{{- else if or (eq .Type "Int64List") (eq .Type "Int64Set")}}
								var values []int
								ccitem.{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
								body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{$cclist}}"+"."+strconv.Itoa(ccindex)+"."+"{{toDotPath .XPath}}", values)
								{{- end}}
							}
							{{- end}}
							{{- end}}
							{{- range .Attributes}}
							{{- if or (eq .Type "List") (eq .Type "Set")}}
							{{- $ccclist := toDotPath .XPath }}
							if len(ccitem.{{toGoName .TfName}}) > 0 {
								body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{$cclist}}"+"."+strconv.Itoa(ccindex)+"."+"{{toDotPath .XPath}}", []interface{}{})
								for cccindex, cccitem := range ccitem.{{toGoName .TfName}} {
									{{- range .Attributes}}
									{{- if and (ne .Type "List") (ne .Type "Set")}}
									if !cccitem.{{toGoName .TfName}}.IsNull() && !cccitem.{{toGoName .TfName}}.IsUnknown() {
										{{- if eq .Type "Int64"}}
										body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{$cclist}}"+"."+strconv.Itoa(ccindex)+"."+"{{$ccclist}}"+"."+strconv.Itoa(cccindex)+"."+"{{toDotPath .XPath}}", strconv.FormatInt(cccitem.{{toGoName .TfName}}.ValueInt64(), 10))
										{{- else if and (eq .Type "Bool") (eq .TypeYangBool "empty")}}
										if cccitem.{{toGoName .TfName}}.ValueBool() {
											body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{$cclist}}"+"."+strconv.Itoa(ccindex)+"."+"{{$ccclist}}"+"."+strconv.Itoa(cccindex)+"."+"{{toDotPath .XPath}}", []interface{}{nil})
										}
										{{- else if and (eq .Type "Bool") (eq .TypeYangBool "presence")}}
										if cccitem.{{toGoName .TfName}}.ValueBool() {
											body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{$cclist}}"+"."+strconv.Itoa(ccindex)+"."+"{{$ccclist}}"+"."+strconv.Itoa(cccindex)+"."+"{{toDotPath .XPath}}", map[string]string{})
										}
										{{- else if and (eq .Type "Bool") (eq .TypeYangBool "boolean")}}
										body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{$cclist}}"+"."+strconv.Itoa(ccindex)+"."+"{{$ccclist}}"+"."+strconv.Itoa(cccindex)+"."+"{{toDotPath .XPath}}", cccitem.{{toGoName .TfName}}.ValueBool())
										{{- else if eq .Type "String"}}
										body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{$cclist}}"+"."+strconv.Itoa(ccindex)+"."+"{{$ccclist}}"+"."+strconv.Itoa(cccindex)+"."+"{{toDotPath .XPath}}", cccitem.{{toGoName .TfName}}.ValueString())
										{{- else if or (eq .Type "StringList") (eq .Type "StringSet")}}
										var values []string
										cccitem.{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
										body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{$cclist}}"+"."+strconv.Itoa(ccindex)+"."+"{{$ccclist}}"+"."+strconv.Itoa(cccindex)+"."+"{{toDotPath .XPath}}", values)
										{{- else if or (eq .Type "Int64List") (eq .Type "Int64Set")}}
										var values []int
										cccitem.{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
										body, _ = sjson.Set(body, "{{$list}}"+"."+strconv.Itoa(index)+"."+"{{$clist}}"+"."+strconv.Itoa(cindex)+"."+"{{$cclist}}"+"."+strconv.Itoa(ccindex)+"."+"{{$ccclist}}"+"."+strconv.Itoa(cccindex)+"."+"{{toDotPath .XPath}}", values)
										{{- end}}
									}
									{{- end}}
									{{- end}}
								}
							}
							{{- end}}
							{{- end}}
						}
					}
					{{- end}}
					{{- end}}
				}
			}
			{{- end}}
			{{- end}}
		}
	}
	{{- end}}
	{{- end}}
	return body
}

// End of section. //template:end toBody

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBody

func (data *{{camelCase .Name}}) updateFromBody(ctx context.Context, res []byte) {
	{{- range .Attributes}}
	{{- if and (not .Reference) (not .Id) (not .WriteOnly)}}
	{{- if eq .Type "Int64"}}
	if value := gjson.GetBytes(res, "{{toDotPath .XPath}}"); value.Exists() && !data.{{toGoName .TfName}}.IsNull() {
		data.{{toGoName .TfName}} = types.Int64Value(value.Int())
	} else {
		data.{{toGoName .TfName}} = types.Int64Null()
	}
	{{- else if eq .Type "Bool"}}
	{{- if eq .TypeYangBool "boolean"}}
	if value := gjson.GetBytes(res, "{{toDotPath .XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = types.BoolValue(value.Bool())
	} else if data.{{toGoName .TfName}}.IsNull() {
		data.{{toGoName .TfName}} = types.BoolNull()
	}
	{{- else}}
	if value := gjson.GetBytes(res, "{{toDotPath .XPath}}"); value.Exists() {
		if !data.{{toGoName .TfName}}.IsNull() {
			data.{{toGoName .TfName}} = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.{{toGoName .TfName}}.IsNull() {
			data.{{toGoName .TfName}} = types.BoolNull()
		}
	}
	{{- end}}
	{{- else if eq .Type "String"}}
	if value := gjson.GetBytes(res, "{{toDotPath .XPath}}"); value.Exists() && !data.{{toGoName .TfName}}.IsNull() {
		data.{{toGoName .TfName}} = types.StringValue(value.String())
	} else {
		data.{{toGoName .TfName}} = types.StringNull()
	}
	{{- else if eq .Type "StringList"}}
	if value := gjson.GetBytes(res, "{{toDotPath .XPath}}"); value.Exists() && !data.{{toGoName .TfName}}.IsNull() {
		data.{{toGoName .TfName}} = helpers.GetStringList(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.ListNull(types.StringType)
	}
	{{- else if eq .Type "Int64List"}}
	if value := gjson.GetBytes(res, "{{toDotPath .XPath}}"); value.Exists() && !data.{{toGoName .TfName}}.IsNull() {
		data.{{toGoName .TfName}} = helpers.GetInt64List(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.ListNull(types.Int64Type)
	}
	{{- else if eq .Type "StringSet"}}
	if value := gjson.GetBytes(res, "{{toDotPath .XPath}}"); value.Exists() && !data.{{toGoName .TfName}}.IsNull() {
		data.{{toGoName .TfName}} = helpers.GetStringSet(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.SetNull(types.StringType)
	}
	{{- else if eq .Type "Int64Set"}}
	if value := gjson.GetBytes(res, "{{toDotPath .XPath}}"); value.Exists() && !data.{{toGoName .TfName}}.IsNull() {
		data.{{toGoName .TfName}} = helpers.GetInt64Set(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.SetNull(types.Int64Type)
	}
	{{- else if or (eq .Type "List") (eq .Type "Set")}}
	{{- $list := (toGoName .TfName)}}
	{{- $listPath := (toDotPath .XPath)}}
	for i := range data.{{$list}} {
		keys := [...]string{ {{range .Attributes}}{{if .Id}}"{{.YangName}}", {{end}}{{end}} }
		keyValues := [...]string{ {{range .Attributes}}{{if .Id}}{{if eq .Type "Int64"}}strconv.FormatInt(data.{{$list}}[i].{{toGoName .TfName}}.ValueInt64(), 10), {{else if eq .Type "Bool"}}strconv.FormatBool(data.{{$list}}[i].{{toGoName .TfName}}.ValueBool()), {{else}}data.{{$list}}[i].{{toGoName .TfName}}.Value{{.Type}}(), {{end}}{{end}}{{end}} }

		var r gjson.Result
		gjson.GetBytes(res, "{{$listPath}}").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)

		{{- range .Attributes}}
		{{- if not .WriteOnly}}
		{{- if eq .Type "Int64"}}
		if value := r.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{toGoName .TfName}}.IsNull() {
			data.{{$list}}[i].{{toGoName .TfName}} = types.Int64Value(value.Int())
		} else {
			data.{{$list}}[i].{{toGoName .TfName}} = types.Int64Null()
		}
		{{- else if eq .Type "Bool"}}
		{{- if eq .TypeYangBool "boolean"}}
		if value := r.Get("{{toDotPath .XPath}}"); value.Exists() {
			data.{{$list}}[i].{{toGoName .TfName}} = types.BoolValue(value.Bool())
		} else if data.{{$list}}[i].{{toGoName .TfName}}.IsNull() {
			data.{{$list}}[i].{{toGoName .TfName}} = types.BoolNull()
		}
		{{- else}}
		if value := r.Get("{{toDotPath .XPath}}"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.{{$list}}[i].{{toGoName .TfName}}.IsNull() && !data.{{$list}}[i].{{toGoName .TfName}}.ValueBool() {
				// Keep false value from state even though element exists on device
				data.{{$list}}[i].{{toGoName .TfName}} = types.BoolValue(false)
			} else if !data.{{$list}}[i].{{toGoName .TfName}}.IsNull() {
				data.{{$list}}[i].{{toGoName .TfName}} = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.{{$list}}[i].{{toGoName .TfName}}.IsNull() {
				data.{{$list}}[i].{{toGoName .TfName}} = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.{{$list}}[i].{{toGoName .TfName}} = types.BoolValue(false)
			}
		}
		{{- end}}
		{{- else if eq .Type "String"}}
		if value := r.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{toGoName .TfName}}.IsNull() {
			data.{{$list}}[i].{{toGoName .TfName}} = types.StringValue(value.String())
		} else {
			data.{{$list}}[i].{{toGoName .TfName}} = types.StringNull()
		}
		{{- else if eq .Type "StringList"}}
		if value := r.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{toGoName .TfName}}.IsNull() {
			data.{{$list}}[i].{{toGoName .TfName}} = helpers.GetStringList(value.Array())
		} else {
			data.{{$list}}[i].{{toGoName .TfName}} = types.ListNull(types.StringType)
		}
		{{- else if eq .Type "Int64List"}}
		if value := r.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{toGoName .TfName}}.IsNull() {
			data.{{$list}}[i].{{toGoName .TfName}} = helpers.GetInt64List(value.Array())
		} else {
			data.{{$list}}[i].{{toGoName .TfName}} = types.ListNull(types.Int64Type)
		}
		{{- else if eq .Type "StringSet"}}
		if value := r.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{toGoName .TfName}}.IsNull() {
			data.{{$list}}[i].{{toGoName .TfName}} = helpers.GetStringSet(value.Array())
		} else {
			data.{{$list}}[i].{{toGoName .TfName}} = types.SetNull(types.StringType)
		}
		{{- else if eq .Type "Int64Set"}}
		if value := r.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{toGoName .TfName}}.IsNull() {
			data.{{$list}}[i].{{toGoName .TfName}} = helpers.GetInt64Set(value.Array())
		} else {
			data.{{$list}}[i].{{toGoName .TfName}} = types.SetNull(types.Int64Type)
		}
		{{- else if or (eq .Type "List") (eq .Type "Set")}}
		{{- $clist := (toGoName .TfName)}}
		{{- $clistPath := (toDotPath .XPath)}}
		for ci := range data.{{$list}}[i].{{$clist}} {
			keys := [...]string{ {{range .Attributes}}{{if .Id}}"{{.YangName}}", {{end}}{{end}} }
			keyValues := [...]string{ {{range .Attributes}}{{if .Id}}{{if eq .Type "Int64"}}strconv.FormatInt(data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.ValueInt64(), 10), {{else if eq .Type "Bool"}}strconv.FormatBool(data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.ValueBool()), {{else}}data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.Value{{.Type}}(), {{end}}{{end}}{{end}} }

			var cr gjson.Result
			r.Get("{{$clistPath}}").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)

			{{- range .Attributes}}
			{{- if not .WriteOnly}}
		{{- if eq .Type "Int64"}}
		if value := cr.Get("{{toDotPath .XPath}}"); value.Exists() {
			data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.Int64Value(value.Int())
		} else if data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.IsNull() {
			data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.Int64Null()
		}
		{{- else if eq .Type "Bool"}}
		{{- if eq .TypeYangBool "boolean"}}
		if value := cr.Get("{{toDotPath .XPath}}"); value.Exists() {
			data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.BoolValue(value.Bool())
		} else if data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.IsNull() {
			data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.BoolNull()
		}
		{{- else}}
		if value := cr.Get("{{toDotPath .XPath}}"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			if !data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.IsNull() && !data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.ValueBool() {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.BoolValue(false)
			} else if !data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.IsNull() {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.IsNull() {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.BoolNull()
			} else {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.BoolValue(false)
			}
		}
		{{- end}}
			{{- else if eq .Type "String"}}
			if value := cr.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.IsNull() {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.StringValue({{if .ReadRaw}}value.Raw{{else}}value.String(){{end}})
			} else {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.StringNull()
			}
			{{- else if eq .Type "StringList"}}
			if value := cr.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.IsNull() {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = helpers.GetStringList(value.Array())
			} else {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.ListNull(types.StringType)
			}
			{{- else if eq .Type "Int64List"}}
			if value := cr.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.IsNull() {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = helpers.GetInt64List(value.Array())
			} else {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.ListNull(types.Int64Type)
			}
			{{- else if eq .Type "StringSet"}}
			if value := cr.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.IsNull() {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = helpers.GetStringSet(value.Array())
			} else {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.SetNull(types.StringType)
			}
			{{- else if eq .Type "Int64Set"}}
			if value := cr.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.IsNull() {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = helpers.GetInt64Set(value.Array())
			} else {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.SetNull(types.Int64Type)
			}
			{{- else if or (eq .Type "List") (eq .Type "Set")}}
			{{- $cclist := (toGoName .TfName)}}
			{{- $cclistPath := (toDotPath .XPath)}}
			for cci := range data.{{$list}}[i].{{$clist}}[ci].{{$cclist}} {
				keys := [...]string{ {{range .Attributes}}{{if .Id}}"{{.YangName}}", {{end}}{{end}} }
				keyValues := [...]string{ {{range .Attributes}}{{if .Id}}{{if eq .Type "Int64"}}strconv.FormatInt(data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.ValueInt64(), 10), {{else if eq .Type "Bool"}}strconv.FormatBool(data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.ValueBool()), {{else}}data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.Value{{.Type}}(), {{end}}{{end}}{{end}} }

				var ccr gjson.Result
				cr.Get("{{$cclistPath}}").ForEach(
					func(_, v gjson.Result) bool {
						found := false
						for ik := range keys {
							if v.Get(keys[ik]).String() == keyValues[ik] {
								found = true
								continue
							}
							found = false
							break
						}
						if found {
							ccr = v
							return false
						}
						return true
					},
				)

				{{- range .Attributes}}
				{{- if not .WriteOnly}}
				{{- if eq .Type "Int64"}}
				if value := ccr.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.IsNull() {
					data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}} = types.Int64Value(value.Int())
				} else {
					data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}} = types.Int64Null()
				}
			{{- else if eq .Type "Bool"}}
			{{- if eq .TypeYangBool "boolean"}}
			if value := ccr.Get("{{toDotPath .XPath}}"); value.Exists() {
				data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}} = types.BoolValue(value.Bool())
			} else if data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.IsNull() {
				data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}} = types.BoolNull()
			}
			{{- else}}
			if value := ccr.Get("{{toDotPath .XPath}}"); value.Exists() {
				// For presence-based booleans: if state has explicit false, preserve it
				if !data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.IsNull() && !data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.ValueBool() {
					data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}} = types.BoolValue(false)
				} else if !data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.IsNull() {
					data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}} = types.BoolValue(true)
				}
			} else {
				// Element doesn't exist on device
				if data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.IsNull() {
					data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}} = types.BoolNull()
				} else {
					data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}} = types.BoolValue(false)
				}
			}
			{{- end}}
				{{- else if eq .Type "String"}}
				if value := ccr.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.IsNull() {
					data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}} = types.StringValue({{if .ReadRaw}}value.Raw{{else}}value.String(){{end}})
				} else {
					data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}} = types.StringNull()
				}
				{{- else if eq .Type "StringList"}}
				if value := ccr.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.IsNull() {
					data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}} = helpers.GetStringList(value.Array())
				} else {
					data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}} = types.ListNull(types.StringType)
				}
				{{- else if eq .Type "Int64List"}}
				if value := ccr.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.IsNull() {
					data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}} = helpers.GetInt64List(value.Array())
				} else {
					data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}} = types.ListNull(types.Int64Type)
				}
				{{- else if eq .Type "StringSet"}}
				if value := ccr.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.IsNull() {
					data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}} = helpers.GetStringSet(value.Array())
				} else {
					data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}} = types.SetNull(types.StringType)
				}
				{{- else if eq .Type "Int64Set"}}
				if value := ccr.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.IsNull() {
					data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}} = helpers.GetInt64Set(value.Array())
				} else {
					data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}} = types.SetNull(types.Int64Type)
				}
				{{- else if or (eq .Type "List") (eq .Type "Set")}}
				{{- $ccclist := (toGoName .TfName)}}
				{{- $ccclistPath := (toDotPath .XPath)}}
				for ccci := range data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}} {
					keys := [...]string{ {{range .Attributes}}{{if .Id}}"{{.YangName}}", {{end}}{{end}} }
					keyValues := [...]string{ {{range .Attributes}}{{if .Id}}{{if eq .Type "Int64"}}strconv.FormatInt(data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}}.ValueInt64(), 10), {{else if eq .Type "Bool"}}strconv.FormatBool(data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}}.ValueBool()), {{else}}data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}}.Value{{.Type}}(), {{end}}{{end}}{{end}} }

					var cccr gjson.Result
					ccr.Get("{{$ccclistPath}}").ForEach(
						func(_, v gjson.Result) bool {
							found := false
							for ik := range keys {
								if v.Get(keys[ik]).String() == keyValues[ik] {
									found = true
									continue
								}
								found = false
								break
							}
							if found {
								cccr = v
								return false
							}
							return true
						},
					)

					{{- range .Attributes}}
					{{- if not .WriteOnly}}
					{{- if and (ne .Type "List") (ne .Type "Set")}}
					{{- if eq .Type "Int64"}}
					if value := cccr.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}}.IsNull() {
						data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}} = types.Int64Value(value.Int())
					} else {
						data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}} = types.Int64Null()
					}
					{{- else if eq .Type "Bool"}}
					if value := cccr.Get("{{toDotPath .XPath}}"); !data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}}.IsNull() {
						{{- if eq .TypeYangBool "boolean"}}
						if value.Exists() {
							data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}} = types.BoolValue(value.Bool())
						}
						{{- else}}
						if value.Exists() {
							data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}} = types.BoolValue(true)
						}
						{{- end}}
					} else {
						data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}} = types.BoolNull()
					}
					{{- else if eq .Type "String"}}
					if value := cccr.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}}.IsNull() {
						data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}} = types.StringValue({{if .ReadRaw}}value.Raw{{else}}value.String(){{end}})
					} else {
						data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}} = types.StringNull()
					}
					{{- else if eq .Type "StringList"}}
					if value := cccr.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}}.IsNull() {
						data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}} = helpers.GetStringList(value.Array())
					} else {
						data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}} = types.ListNull(types.StringType)
					}
					{{- else if eq .Type "Int64List"}}
					if value := cccr.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}}.IsNull() {
						data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}} = helpers.GetInt64List(value.Array())
					} else {
						data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}} = types.ListNull(types.Int64Type)
					}
					{{- else if eq .Type "StringSet"}}
					if value := cccr.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}}.IsNull() {
						data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}} = helpers.GetStringSet(value.Array())
					} else {
						data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}} = types.SetNull(types.StringType)
					}
					{{- else if eq .Type "Int64Set"}}
					if value := cccr.Get("{{toDotPath .XPath}}"); value.Exists() && !data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}}.IsNull() {
						data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}} = helpers.GetInt64Set(value.Array())
					} else {
						data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}} = types.SetNull(types.Int64Type)
					}
					{{- end}}
					{{- end}}
					{{- end}}
					{{- end}}
				}
				{{- end}}
				{{- end}}
				{{- end}}
			}
			{{- end}}
			{{- end}}
			{{- end}}
		}
		{{- end}}
		{{- end}}
		{{- end}}
	}
	{{- end}}
	{{- end}}
	{{- end}}
}

// End of section. //template:end updateFromBody

// Section below is generated&owned by "gen/generator.go". //template:begin fromBody

func (data *{{camelCase .Name}}) fromBody(ctx context.Context, res gjson.Result) {
	{{- $name := camelCase .Name}}
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	{{- range .Attributes}}
	{{- $cname := toGoName .TfName}}
	{{- if and (not .Reference) (not .Id) (not .WriteOnly)}}
	{{- if eq .Type "Int64"}}
	if value := res.Get(prefix+"{{toDotPath .XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = types.Int64Value(value.Int())
	}
	{{- else if eq .Type "Bool"}}
	if value := res.Get(prefix+"{{toDotPath .XPath}}"); value.Exists() {
		{{- if eq .TypeYangBool "boolean"}}
		data.{{toGoName .TfName}} = types.BoolValue(value.Bool())
		{{- else}}
		data.{{toGoName .TfName}} = types.BoolValue(true)
		{{- end}}
	} else {
		data.{{toGoName .TfName}} = types.BoolNull()
	}
	{{- else if eq .Type "String"}}
	if value := res.Get(prefix+"{{toDotPath .XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = types.StringValue(value.String())
	}
	{{- else if eq .Type "StringList"}}
	if value := res.Get(prefix+"{{toDotPath .XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = helpers.GetStringList(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.ListNull(types.StringType)
	}
	{{- else if eq .Type "Int64List"}}
	if value := res.Get(prefix+"{{toDotPath .XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = helpers.GetInt64List(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.ListNull(types.Int64Type)
	}
	{{- else if eq .Type "StringSet"}}
	if value := res.Get(prefix+"{{toDotPath .XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = helpers.GetStringSet(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.SetNull(types.StringType)
	}
	{{- else if eq .Type "Int64Set"}}
	if value := res.Get(prefix+"{{toDotPath .XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = helpers.GetInt64Set(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.SetNull(types.Int64Type)
	}
	{{- else if or (eq .Type "List") (eq .Type "Set")}}
	if value := res.Get(prefix+"{{toDotPath .XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = make([]{{$name}}{{toGoName .TfName}}, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := {{$name}}{{toGoName .TfName}}{}
			{{- range .Attributes}}
			{{- if not .WriteOnly}}
			{{- if eq .Type "Int64"}}
			if cValue := v.Get("{{toDotPath .XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = types.Int64Value(cValue.Int())
			}
			{{- else if eq .Type "Bool"}}
			if cValue := v.Get("{{toDotPath .XPath}}"); cValue.Exists() {
				{{- if eq .TypeYangBool "boolean"}}
				item.{{toGoName .TfName}} = types.BoolValue(cValue.Bool())
				{{- else}}
				item.{{toGoName .TfName}} = types.BoolValue(true)
				{{- end}}
			} else {
				{{- if eq .TypeYangBool "boolean"}}
				item.{{toGoName .TfName}} = types.BoolValue(false)
				{{- else}}
				item.{{toGoName .TfName}} = types.BoolValue(false)
				{{- end}}
			}
			{{- else if eq .Type "String"}}
			if cValue := v.Get("{{toDotPath .XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = types.StringValue({{if .ReadRaw}}cValue.Raw{{else}}cValue.String(){{end}})
			}
			{{- else if eq .Type "StringList"}}
			if cValue := v.Get("{{toDotPath .XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = helpers.GetStringList(cValue.Array())
			} else {
				item.{{toGoName .TfName}} = types.ListNull(types.StringType)
			}
			{{- else if eq .Type "Int64List"}}
			if cValue := v.Get("{{toDotPath .XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = helpers.GetInt64List(cValue.Array())
			} else {
				item.{{toGoName .TfName}} = types.ListNull(types.Int64Type)
			}
			{{- else if eq .Type "List"}}
			{{- $ccname := toGoName .TfName}}
			if cValue := v.Get("{{toDotPath .XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = make([]{{$name}}{{$cname}}{{toGoName .TfName}}, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := {{$name}}{{$cname}}{{toGoName .TfName}}{}
				{{- range .Attributes}}
				{{- if not .WriteOnly}}
				{{- if eq .Type "Int64"}}
				if ccValue := cv.Get("{{toDotPath .XPath}}"); ccValue.Exists() {
					cItem.{{toGoName .TfName}} = types.Int64Value(ccValue.Int())
				}
				{{- else if eq .Type "Bool"}}
				if ccValue := cv.Get("{{toDotPath .XPath}}"); ccValue.Exists() {
					{{- if eq .TypeYangBool "boolean"}}
					cItem.{{toGoName .TfName}} = types.BoolValue(ccValue.Bool())
					{{- else}}
					cItem.{{toGoName .TfName}} = types.BoolValue(true)
					{{- end}}
				} else {
					cItem.{{toGoName .TfName}} = types.BoolValue(false)
				}
					{{- else if eq .Type "String"}}
					if ccValue := cv.Get("{{toDotPath .XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = types.StringValue({{if .ReadRaw}}ccValue.Raw{{else}}ccValue.String(){{end}})
					}
					{{- else if eq .Type "StringList"}}
					if ccValue := cv.Get("{{toDotPath .XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = helpers.GetStringList(ccValue.Array())
					} else {
						cItem.{{toGoName .TfName}} = types.ListNull(types.StringType)
					}
					{{- else if eq .Type "Int64List"}}
					if ccValue := cv.Get("{{toDotPath .XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = helpers.GetInt64List(ccValue.Array())
					} else {
						cItem.{{toGoName .TfName}} = types.ListNull(types.Int64Type)
					}
				{{- else if eq .Type "List"}}
				{{- $cccname := toGoName .TfName}}
				if ccValue := cv.Get("{{toDotPath .XPath}}"); ccValue.Exists() {
					cItem.{{toGoName .TfName}} = make([]{{$name}}{{$cname}}{{$ccname}}{{toGoName .TfName}}, 0)
					ccValue.ForEach(func(cck, ccv gjson.Result) bool {
						ccItem := {{$name}}{{$cname}}{{$ccname}}{{toGoName .TfName}}{}
					{{- range .Attributes}}
					{{- if and (not .WriteOnly) .TfName .Type}}
					{{- if eq .Type "Int64"}}
					if cccValue := ccv.Get("{{toDotPath .XPath}}"); cccValue.Exists() {
						ccItem.{{toGoName .TfName}} = types.Int64Value(cccValue.Int())
					}
					{{- else if eq .Type "Bool"}}
					if cccValue := ccv.Get("{{toDotPath .XPath}}"); cccValue.Exists() {
						{{- if eq .TypeYangBool "boolean"}}
						ccItem.{{toGoName .TfName}} = types.BoolValue(cccValue.Bool())
						{{- else}}
						ccItem.{{toGoName .TfName}} = types.BoolValue(true)
						{{- end}}
					} else {
						ccItem.{{toGoName .TfName}} = types.BoolValue(false)
					}
						{{- else if eq .Type "String"}}
						if cccValue := ccv.Get("{{toDotPath .XPath}}"); cccValue.Exists() {
							ccItem.{{toGoName .TfName}} = types.StringValue({{if .ReadRaw}}cccValue.Raw{{else}}cccValue.String(){{end}})
						}
						{{- else if eq .Type "StringList"}}
						if cccValue := ccv.Get("{{toDotPath .XPath}}"); cccValue.Exists() {
							ccItem.{{toGoName .TfName}} = helpers.GetStringList(cccValue.Array())
						} else {
							ccItem.{{toGoName .TfName}} = types.ListNull(types.StringType)
						}
						{{- else if eq .Type "Int64List"}}
						if cccValue := ccv.Get("{{toDotPath .XPath}}"); cccValue.Exists() {
							ccItem.{{toGoName .TfName}} = helpers.GetInt64List(cccValue.Array())
						} else {
							ccItem.{{toGoName .TfName}} = types.ListNull(types.Int64Type)
						}
						{{- else if eq .Type "List"}}
						if cccValue := ccv.Get("{{toDotPath .XPath}}"); cccValue.Exists() {
							ccItem.{{toGoName .TfName}} = make([]{{$name}}{{$cname}}{{$ccname}}{{$cccname}}{{toGoName .TfName}}, 0)
							cccValue.ForEach(func(ccck, cccv gjson.Result) bool {
								cccItem := {{$name}}{{$cname}}{{$ccname}}{{$cccname}}{{toGoName .TfName}}{}
								{{- range .Attributes}}
								{{- if and (not .WriteOnly) .TfName .Type}}
								{{- if eq .Type "Int64"}}
								if ccccValue := cccv.Get("{{toDotPath .XPath}}"); ccccValue.Exists() {
									cccItem.{{toGoName .TfName}} = types.Int64Value(ccccValue.Int())
								}
								{{- else if eq .Type "Bool"}}
								if ccccValue := cccv.Get("{{toDotPath .XPath}}"); ccccValue.Exists() {
									{{- if eq .TypeYangBool "boolean"}}
									cccItem.{{toGoName .TfName}} = types.BoolValue(ccccValue.Bool())
									{{- else}}
									cccItem.{{toGoName .TfName}} = types.BoolValue(true)
									{{- end}}
								} else {
									cccItem.{{toGoName .TfName}} = types.BoolNull()
								}
								{{- else if eq .Type "String"}}
								if ccccValue := cccv.Get("{{toDotPath .XPath}}"); ccccValue.Exists() {
									cccItem.{{toGoName .TfName}} = types.StringValue({{if .ReadRaw}}ccccValue.Raw{{else}}ccccValue.String(){{end}})
								}
								{{- else if eq .Type "StringList"}}
								if ccccValue := cccv.Get("{{toDotPath .XPath}}"); ccccValue.Exists() {
									cccItem.{{toGoName .TfName}} = helpers.GetStringList(ccccValue.Array())
								} else {
									cccItem.{{toGoName .TfName}} = types.ListNull(types.StringType)
								}
								{{- else if eq .Type "Int64List"}}
								if ccccValue := cccv.Get("{{toDotPath .XPath}}"); ccccValue.Exists() {
									cccItem.{{toGoName .TfName}} = helpers.GetInt64List(ccccValue.Array())
								} else {
									cccItem.{{toGoName .TfName}} = types.ListNull(types.Int64Type)
								}
								{{- end}}
								{{- end}}
								{{- end}}
								ccItem.{{toGoName .TfName}} = append(ccItem.{{toGoName .TfName}}, cccItem)
								return true
							})
						}
						{{- end}}
						{{- end}}
						{{- end}}
						cItem.{{toGoName .TfName}} = append(cItem.{{toGoName .TfName}}, ccItem)
						return true
					})
				}
				{{- end}}
				{{- end}}
				{{- end}}
				item.{{toGoName .TfName}} = append(item.{{toGoName .TfName}}, cItem)
				return true
			})
		}
		{{- end}}
			{{- end}}
			{{- end}}
			data.{{toGoName .TfName}} = append(data.{{toGoName .TfName}}, item)
			return true
		})
	}
	{{- end}}
	{{- end}}
	{{- end}}
}

// End of section. //template:end fromBody

// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyData

func (data *{{camelCase .Name}}Data) fromBody(ctx context.Context, res gjson.Result) {
	{{- $name := camelCase .Name}}
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	{{- range .Attributes}}
	{{- $cname := toGoName .TfName}}
	{{- if and (not .Reference) (not .Id)}}
	{{- if eq .Type "Int64"}}
	if value := res.Get(prefix+"{{toDotPath .XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = types.Int64Value(value.Int())
	}
	{{- else if eq .Type "Bool"}}
	if value := res.Get(prefix+"{{toDotPath .XPath}}"); value.Exists() {
		{{- if eq .TypeYangBool "boolean"}}
		data.{{toGoName .TfName}} = types.BoolValue(value.Bool())
		{{- else}}
		data.{{toGoName .TfName}} = types.BoolValue(true)
		{{- end}}
	} else {
		data.{{toGoName .TfName}} = types.BoolNull()
	}
	{{- else if eq .Type "String"}}
	if value := res.Get(prefix+"{{toDotPath .XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = types.StringValue(value.String())
	}
	{{- else if eq .Type "StringList"}}
	if value := res.Get(prefix+"{{toDotPath .XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = helpers.GetStringList(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.ListNull(types.StringType)
	}
	{{- else if eq .Type "Int64List"}}
	if value := res.Get(prefix+"{{toDotPath .XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = helpers.GetInt64List(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.ListNull(types.Int64Type)
	}
	{{- else if eq .Type "StringSet"}}
	if value := res.Get(prefix+"{{toDotPath .XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = helpers.GetStringSet(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.SetNull(types.StringType)
	}
	{{- else if eq .Type "Int64Set"}}
	if value := res.Get(prefix+"{{toDotPath .XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = helpers.GetInt64Set(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.SetNull(types.Int64Type)
	}
	{{- else if or (eq .Type "List") (eq .Type "Set")}}
	if value := res.Get(prefix+"{{toDotPath .XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = make([]{{$name}}{{toGoName .TfName}}, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := {{$name}}{{toGoName .TfName}}{}
			{{- range .Attributes}}
			{{- if eq .Type "Int64"}}
			if cValue := v.Get("{{toDotPath .XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = types.Int64Value(cValue.Int())
			}
			{{- else if eq .Type "Bool"}}
			if cValue := v.Get("{{toDotPath .XPath}}"); cValue.Exists() {
				{{- if eq .TypeYangBool "boolean"}}
				item.{{toGoName .TfName}} = types.BoolValue(cValue.Bool())
				{{- else}}
				item.{{toGoName .TfName}} = types.BoolValue(true)
				{{- end}}
			} else {
				item.{{toGoName .TfName}} = types.BoolNull()
			}
			{{- else if eq .Type "String"}}
			if cValue := v.Get("{{toDotPath .XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = types.StringValue({{if .ReadRaw}}cValue.Raw{{else}}cValue.String(){{end}})
			}
			{{- else if eq .Type "StringList"}}
			if cValue := v.Get("{{toDotPath .XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = helpers.GetStringList(cValue.Array())
			} else {
				item.{{toGoName .TfName}} = types.ListNull(types.StringType)
			}
			{{- else if eq .Type "Int64List"}}
			if cValue := v.Get("{{toDotPath .XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = helpers.GetInt64List(cValue.Array())
			} else {
				item.{{toGoName .TfName}} = types.ListNull(types.Int64Type)
			}
			{{- else if eq .Type "List"}}
			{{- $ccname := toGoName .TfName}}
			if cValue := v.Get("{{toDotPath .XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = make([]{{$name}}{{$cname}}{{toGoName .TfName}}, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := {{$name}}{{$cname}}{{toGoName .TfName}}{}
					{{- range .Attributes}}
					{{- if eq .Type "Int64"}}
					if ccValue := cv.Get("{{toDotPath .XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = types.Int64Value(ccValue.Int())
					}
					{{- else if eq .Type "Bool"}}
					if ccValue := cv.Get("{{toDotPath .XPath}}"); ccValue.Exists() {
						{{- if eq .TypeYangBool "boolean"}}
						cItem.{{toGoName .TfName}} = types.BoolValue(ccValue.Bool())
						{{- else}}
						cItem.{{toGoName .TfName}} = types.BoolValue(true)
						{{- end}}
					} else {
						cItem.{{toGoName .TfName}} = types.BoolNull()
					}
					{{- else if eq .Type "String"}}
					if ccValue := cv.Get("{{toDotPath .XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = types.StringValue({{if .ReadRaw}}ccValue.Raw{{else}}ccValue.String(){{end}})
					}
					{{- else if eq .Type "StringList"}}
					if ccValue := cv.Get("{{toDotPath .XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = helpers.GetStringList(ccValue.Array())
					} else {
						cItem.{{toGoName .TfName}} = types.ListNull(types.StringType)
					}
					{{- else if eq .Type "Int64List"}}
					if ccValue := cv.Get("{{toDotPath .XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = helpers.GetInt64List(ccValue.Array())
					} else {
						cItem.{{toGoName .TfName}} = types.ListNull(types.Int64Type)
					}
					{{- else if eq .Type "List"}}
					{{- $cccname := toGoName .TfName}}
					if ccValue := cv.Get("{{toDotPath .XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = make([]{{$name}}{{$cname}}{{$ccname}}{{toGoName .TfName}}, 0)
						ccValue.ForEach(func(cck, ccv gjson.Result) bool {
							ccItem := {{$name}}{{$cname}}{{$ccname}}{{toGoName .TfName}}{}
							{{- range .Attributes}}
							{{- if eq .Type "Int64"}}
							if cccValue := ccv.Get("{{toDotPath .XPath}}"); cccValue.Exists() {
								ccItem.{{toGoName .TfName}} = types.Int64Value(cccValue.Int())
							}
							{{- else if eq .Type "Bool"}}
							if cccValue := ccv.Get("{{toDotPath .XPath}}"); cccValue.Exists() {
								{{- if eq .TypeYangBool "boolean"}}
								ccItem.{{toGoName .TfName}} = types.BoolValue(cccValue.Bool())
								{{- else}}
								ccItem.{{toGoName .TfName}} = types.BoolValue(true)
								{{- end}}
							} else {
								ccItem.{{toGoName .TfName}} = types.BoolNull()
							}
							{{- else if eq .Type "String"}}
							if cccValue := ccv.Get("{{toDotPath .XPath}}"); cccValue.Exists() {
								ccItem.{{toGoName .TfName}} = types.StringValue({{if .ReadRaw}}cccValue.Raw{{else}}cccValue.String(){{end}})
							}
							{{- else if eq .Type "StringList"}}
							if cccValue := ccv.Get("{{toDotPath .XPath}}"); cccValue.Exists() {
								ccItem.{{toGoName .TfName}} = helpers.GetStringList(cccValue.Array())
							} else {
								ccItem.{{toGoName .TfName}} = types.ListNull(types.StringType)
							}
							{{- else if eq .Type "Int64List"}}
							if cccValue := ccv.Get("{{toDotPath .XPath}}"); cccValue.Exists() {
								ccItem.{{toGoName .TfName}} = helpers.GetInt64List(cccValue.Array())
							} else {
								ccItem.{{toGoName .TfName}} = types.ListNull(types.Int64Type)
							}
							{{- else if eq .Type "List"}}
							if cccValue := ccv.Get("{{toDotPath .XPath}}"); cccValue.Exists() {
								ccItem.{{toGoName .TfName}} = make([]{{$name}}{{$cname}}{{$ccname}}{{$cccname}}{{toGoName .TfName}}, 0)
								cccValue.ForEach(func(ccck, cccv gjson.Result) bool {
									cccItem := {{$name}}{{$cname}}{{$ccname}}{{$cccname}}{{toGoName .TfName}}{}
									{{- range .Attributes}}
									{{- if eq .Type "Int64"}}
									if ccccValue := cccv.Get("{{toDotPath .XPath}}"); ccccValue.Exists() {
										cccItem.{{toGoName .TfName}} = types.Int64Value(ccccValue.Int())
									}
									{{- else if eq .Type "Bool"}}
									if ccccValue := cccv.Get("{{toDotPath .XPath}}"); ccccValue.Exists() {
										{{- if eq .TypeYangBool "boolean"}}
										cccItem.{{toGoName .TfName}} = types.BoolValue(ccccValue.Bool())
										{{- else}}
										cccItem.{{toGoName .TfName}} = types.BoolValue(true)
										{{- end}}
									} else {
										{{- if eq .TypeYangBool "boolean"}}
										cccItem.{{toGoName .TfName}} = types.BoolNull()
										{{- else}}
										cccItem.{{toGoName .TfName}} = types.BoolValue(false)
										{{- end}}
									}
									{{- else if eq .Type "String"}}
									if ccccValue := cccv.Get("{{toDotPath .XPath}}"); ccccValue.Exists() {
										cccItem.{{toGoName .TfName}} = types.StringValue({{if .ReadRaw}}ccccValue.Raw{{else}}ccccValue.String(){{end}})
									}
									{{- else if eq .Type "StringList"}}
									if ccccValue := cccv.Get("{{toDotPath .XPath}}"); ccccValue.Exists() {
										cccItem.{{toGoName .TfName}} = helpers.GetStringList(ccccValue.Array())
									} else {
										cccItem.{{toGoName .TfName}} = types.ListNull(types.StringType)
									}
									{{- else if eq .Type "Int64List"}}
									if ccccValue := cccv.Get("{{toDotPath .XPath}}"); ccccValue.Exists() {
										cccItem.{{toGoName .TfName}} = helpers.GetInt64List(cccValue.Array())
									} else {
										cccItem.{{toGoName .TfName}} = types.ListNull(types.Int64Type)
									}
									{{- end}}
									{{- end}}
									ccItem.{{toGoName .TfName}} = append(ccItem.{{toGoName .TfName}}, cccItem)
									return true
								})
							}
							{{- end}}
							{{- end}}
							cItem.{{toGoName .TfName}} = append(cItem.{{toGoName .TfName}}, ccItem)
							return true
						})
					}
					{{- end}}
					{{- end}}
					item.{{toGoName .TfName}} = append(item.{{toGoName .TfName}}, cItem)
					return true
				})
			}
			{{- end}}
			{{- end}}
			data.{{toGoName .TfName}} = append(data.{{toGoName .TfName}}, item)
			return true
		})
	}
	{{- end}}
	{{- end}}
	{{- end}}
}

// End of section. //template:end fromBodyData

// Section below is generated&owned by "gen/generator.go". //template:begin getDeletedItems

func (data *{{camelCase .Name}}) getDeletedItems(ctx context.Context, state {{camelCase .Name}}) []string {
	deletedItems := make([]string, 0)
	{{- range reverseAttributes .Attributes}}
	{{- if and (not .Reference) (not .Id) (ne .Type "List") (ne .Type "Set") (not .NoDelete)}}
	if !state.{{toGoName .TfName}}.IsNull() && data.{{toGoName .TfName}}.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/{{getDeletePath .}}", state.getPath()))
	}
	{{- else if or (eq .Type "List") (eq .Type "Set")}}
	{{- $xpath := .XPath}}
	for i := range state.{{toGoName .TfName}} {
		{{- $list := (toGoName .TfName)}}
		keys := [...]string{ {{range .Attributes}}{{if .Id}}"{{getDeletePath .}}", {{end}}{{end}} }
		stateKeyValues := [...]string{ {{range .Attributes}}{{if .Id}}{{if eq .Type "Int64"}}strconv.FormatInt(state.{{$list}}[i].{{toGoName .TfName}}.ValueInt64(), 10), {{else if eq .Type "Bool"}}strconv.FormatBool(state.{{$list}}[i].{{toGoName .TfName}}.ValueBool()), {{else}}state.{{$list}}[i].{{toGoName .TfName}}.Value{{.Type}}(), {{end}}{{end}}{{end}} }
		keyString := ""
		for ki := range keys {
			keyString += "["+keys[ki]+"="+stateKeyValues[ki]+"]"
		}

		emptyKeys := true
		{{- range .Attributes}}
		{{- if .Id}}
		if !reflect.ValueOf(state.{{$list}}[i].{{toGoName .TfName}}.Value{{.Type}}()).IsZero() {
			emptyKeys = false
		}
		{{- end}}
		{{- end}}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.{{toGoName .TfName}} {
			found = true
			{{- range .Attributes}}
			{{- if .Id}}
			if state.{{$list}}[i].{{toGoName .TfName}}.Value{{.Type}}() != data.{{$list}}[j].{{toGoName .TfName}}.Value{{.Type}}() {
				found = false
			}
		{{- end}}
		{{- end}}
		if found {
			{{- range reverseAttributes .Attributes}}
			{{- if and (not .Reference) (not .Id) (ne .Type "List") (ne .Type "Set") (not .NoDelete)}}
			if !state.{{$list}}[i].{{toGoName .TfName}}.IsNull() && data.{{$list}}[j].{{toGoName .TfName}}.IsNull() {
				deletedItems = append(deletedItems, fmt.Sprintf("%v/{{$xpath}}%v/{{getDeletePath .}}", state.getPath(), keyString))
			}
				{{- else if or (eq .Type "List") (eq .Type "Set")}}
				{{- $cxpath := .XPath}}
				for ci := range state.{{$list}}[i].{{toGoName .TfName}} {
					{{- $clist := (toGoName .TfName)}}
					ckeys := [...]string{ {{range .Attributes}}{{if .Id}}"{{getDeletePath .}}", {{end}}{{end}} }
					cstateKeyValues := [...]string{ {{range .Attributes}}{{if .Id}}{{if eq .Type "Int64"}}strconv.FormatInt(state.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.ValueInt64(), 10), {{else if eq .Type "Bool"}}strconv.FormatBool(state.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.ValueBool()), {{else}}state.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.Value{{.Type}}(), {{end}}{{end}}{{end}} }
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "["+ckeys[cki]+"="+cstateKeyValues[cki]+"]"
					}

					cemptyKeys := true
					{{- range .Attributes}}
					{{- if .Id}}
					if !reflect.ValueOf(state.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.Value{{.Type}}()).IsZero() {
						cemptyKeys = false
					}
					{{- end}}
					{{- end}}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.{{$list}}[j].{{toGoName .TfName}} {
						found = true
						{{- range .Attributes}}
						{{- if .Id}}
						if state.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.Value{{.Type}}() != data.{{$list}}[j].{{$clist}}[cj].{{toGoName .TfName}}.Value{{.Type}}() {
							found = false
						}
					{{- end}}
					{{- end}}
					if found {
						{{- range reverseAttributes .Attributes}}
						{{- if and (not .Reference) (not .Id) (ne .Type "List") (ne .Type "Set") (not .NoDelete)}}
						if !state.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.IsNull() && data.{{$list}}[j].{{$clist}}[cj].{{toGoName .TfName}}.IsNull() {
							deletedItems = append(deletedItems, fmt.Sprintf("%v/{{$xpath}}%v/{{$cxpath}}%v/{{getDeletePath .}}", state.getPath(), keyString, ckeyString))
						}
						{{- else if or (eq .Type "List") (eq .Type "Set")}}
						{{- $ccxpath := .XPath}}
						for cci := range state.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} {
							{{- $cclist := (toGoName .TfName)}}
							cckeys := [...]string{ {{range .Attributes}}{{if .Id}}"{{getDeletePath .}}", {{end}}{{end}} }
							ccstateKeyValues := [...]string{ {{range .Attributes}}{{if .Id}}{{if eq .Type "Int64"}}strconv.FormatInt(state.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.ValueInt64(), 10), {{else if eq .Type "Bool"}}strconv.FormatBool(state.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.ValueBool()), {{else}}state.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.Value{{.Type}}(), {{end}}{{end}}{{end}} }
							cckeyString := ""
							for ccki := range cckeys {
								cckeyString += "["+cckeys[ccki]+"="+ccstateKeyValues[ccki]+"]"
							}

							ccemptyKeys := true
							{{- range .Attributes}}
							{{- if .Id}}
							if !reflect.ValueOf(state.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.Value{{.Type}}()).IsZero() {
								ccemptyKeys = false
							}
							{{- end}}
							{{- end}}
							if ccemptyKeys {
								continue
							}

							found := false
							for ccj := range data.{{$list}}[j].{{$clist}}[cj].{{toGoName .TfName}} {
								found = true
								{{- range .Attributes}}
								{{- if .Id}}
								if state.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.Value{{.Type}}() != data.{{$list}}[j].{{$clist}}[cj].{{$cclist}}[ccj].{{toGoName .TfName}}.Value{{.Type}}() {
									found = false
								}
							{{- end}}
							{{- end}}
							if found {
								{{- range reverseAttributes .Attributes}}
								{{- if and (not .Reference) (not .Id) (ne .Type "List") (ne .Type "Set") (not .NoDelete)}}
								if !state.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.IsNull() && data.{{$list}}[j].{{$clist}}[cj].{{$cclist}}[ccj].{{toGoName .TfName}}.IsNull() {
									deletedItems = append(deletedItems, fmt.Sprintf("%v/{{$xpath}}%v/{{$cxpath}}%v/{{$ccxpath}}%v/{{getDeletePath .}}", state.getPath(), keyString, ckeyString, cckeyString))
								}
								{{- else if or (eq .Type "List") (eq .Type "Set")}}
								{{- $cccxpath := .XPath}}
								for ccci := range state.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}} {
									{{- $ccclist := (toGoName .TfName)}}
									ccckeys := [...]string{ {{range .Attributes}}{{if .Id}}"{{getDeletePath .}}", {{end}}{{end}} }
									cccstateKeyValues := [...]string{ {{range .Attributes}}{{if .Id}}{{if eq .Type "Int64"}}strconv.FormatInt(state.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}}.ValueInt64(), 10), {{else if eq .Type "Bool"}}strconv.FormatBool(state.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}}.ValueBool()), {{else}}state.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}}.Value{{.Type}}(), {{end}}{{end}}{{end}} }
									ccckeyString := ""
									for cccki := range ccckeys {
										ccckeyString += "["+ccckeys[cccki]+"="+cccstateKeyValues[cccki]+"]"
									}

									cccemptyKeys := true
									{{- range .Attributes}}
									{{- if .Id}}
									if !reflect.ValueOf(state.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}}.Value{{.Type}}()).IsZero() {
										cccemptyKeys = false
									}
									{{- end}}
									{{- end}}
									if cccemptyKeys {
										continue
									}

									found := false
									for cccj := range data.{{$list}}[j].{{$clist}}[cj].{{$cclist}}[ccj].{{toGoName .TfName}} {
										found = true
										{{- range .Attributes}}
										{{- if .Id}}
										if state.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}}.Value{{.Type}}() != data.{{$list}}[j].{{$clist}}[cj].{{$cclist}}[ccj].{{$ccclist}}[cccj].{{toGoName .TfName}}.Value{{.Type}}() {
											found = false
										}
									{{- end}}
									{{- end}}
									if found {
										{{- range reverseAttributes .Attributes}}
										{{- if and (not .Reference) (not .Id) (ne .Type "List") (ne .Type "Set") (not .NoDelete)}}
										if !state.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}}.IsNull() && data.{{$list}}[j].{{$clist}}[cj].{{$cclist}}[ccj].{{$ccclist}}[cccj].{{toGoName .TfName}}.IsNull() {
											deletedItems = append(deletedItems, fmt.Sprintf("%v/{{$xpath}}%v/{{$cxpath}}%v/{{$ccxpath}}%v/{{$cccxpath}}%v/{{getDeletePath .}}", state.getPath(), keyString, ckeyString, cckeyString, ccckeyString))
										}
											{{- end}}
											{{- end}}
											break
										}
									}
									if !found {
										deletedItems = append(deletedItems, fmt.Sprintf("%v/{{$xpath}}%v/{{$cxpath}}%v/{{$ccxpath}}%v/{{getDeletePath .}}%v", state.getPath(), keyString, ckeyString, cckeyString, ccckeyString))
									}
								}
									{{- end}}
									{{- end}}
									break
								}
							}
							if !found {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/{{$xpath}}%v/{{$cxpath}}%v/{{getDeletePath .}}%v", state.getPath(), keyString, ckeyString, cckeyString))
							}
						}
						{{- end}}
						{{- end}}
						break
					}
				}
				if !found {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/{{$xpath}}%v/{{getDeletePath .}}%v", state.getPath(), keyString, ckeyString))
				}
			}
			{{- end}}
			{{- end}}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/{{getDeletePath .}}%v", state.getPath(), keyString))
		}
	}
	{{- end}}
	{{- end}}
	return deletedItems
}

// End of section. //template:end getDeletedItems

// Section below is generated&owned by "gen/generator.go". //template:begin getEmptyLeafsDelete

func (data *{{camelCase .Name}}) getEmptyLeafsDelete(ctx context.Context, state *{{camelCase .Name}}) []string {
	emptyLeafsDelete := make([]string, 0)
	{{- range reverseAttributes .Attributes}}
	{{- if and (eq .Type "Bool") (ne .TypeYangBool "boolean")}}
	// Only delete if state has true and plan has false
	if !data.{{toGoName .TfName}}.IsNull() && !data.{{toGoName .TfName}}.ValueBool() {
		if state != nil && !state.{{toGoName .TfName}}.IsNull() && state.{{toGoName .TfName}}.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/{{getDeletePath .}}", data.getXPath()))
		}
	}
	{{- end}}
	{{- if or (eq .Type "List") (eq .Type "Set")}}
	{{- $xpath := .XPath}}
	for i := range data.{{toGoName .TfName}} {
		{{- $list := (toGoName .TfName)}}
		keys := [...]string{ {{range .Attributes}}{{if .Id}}"{{getDeletePath .}}", {{end}}{{end}} }
		keyValues := [...]string{ {{range .Attributes}}{{if .Id}}{{if eq .Type "Int64"}}strconv.FormatInt(data.{{$list}}[i].{{toGoName .TfName}}.ValueInt64(), 10), {{else if eq .Type "Bool"}}strconv.FormatBool(data.{{$list}}[i].{{toGoName .TfName}}.ValueBool()), {{else}}data.{{$list}}[i].{{toGoName .TfName}}.Value{{.Type}}(), {{end}}{{end}}{{end}} }
		keyString := ""
		for ki := range keys {
			keyString += "["+keys[ki]+"="+keyValues[ki]+"]"
		}
		{{- range reverseAttributes .Attributes}}
		{{- if and (eq .Type "Bool") (ne .TypeYangBool "boolean")}}
		// Only delete if state has true and plan has false
		if !data.{{$list}}[i].{{toGoName .TfName}}.IsNull() && !data.{{$list}}[i].{{toGoName .TfName}}.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.{{$list}}) && !state.{{$list}}[i].{{toGoName .TfName}}.IsNull() && state.{{$list}}[i].{{toGoName .TfName}}.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/{{$xpath}}%v/{{getDeletePath .}}", data.getXPath(), keyString))
			}
		}
		{{- end}}
		{{- if or (eq .Type "List") (eq .Type "Set")}}
		{{- $cxpath := .XPath}}
		for ci := range data.{{$list}}[i].{{toGoName .TfName}} {
			{{- $clist := (toGoName .TfName)}}
			ckeys := [...]string{ {{range .Attributes}}{{if .Id}}"{{getDeletePath .}}", {{end}}{{end}} }
			ckeyValues := [...]string{ {{range .Attributes}}{{if .Id}}{{if eq .Type "Int64"}}strconv.FormatInt(data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.ValueInt64(), 10), {{else if eq .Type "Bool"}}strconv.FormatBool(data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.ValueBool()), {{else}}data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.Value{{.Type}}(), {{end}}{{end}}{{end}} }
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "["+ckeys[cki]+"="+ckeyValues[cki]+"]"
			}
			{{- range reverseAttributes .Attributes}}
			{{- if and (eq .Type "Bool") (ne .TypeYangBool "boolean")}}
			// Only delete if state has true and plan has false
			if !data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.IsNull() && !data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.{{$list}}) && ci < len(state.{{$list}}[i].{{$clist}}) && !state.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.IsNull() && state.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/{{$xpath}}%v/{{$cxpath}}%v/{{getDeletePath .}}", data.getXPath(), keyString, ckeyString))
				}
			}
			{{- end}}
			{{- if or (eq .Type "List") (eq .Type "Set")}}
			{{- $ccxpath := .XPath}}
			for cci := range data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} {
				{{- $cclist := (toGoName .TfName)}}
				cckeys := [...]string{ {{range .Attributes}}{{if .Id}}"{{getDeletePath .}}", {{end}}{{end}} }
				cckeyValues := [...]string{ {{range .Attributes}}{{if .Id}}{{if eq .Type "Int64"}}strconv.FormatInt(data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.ValueInt64(), 10), {{else if eq .Type "Bool"}}strconv.FormatBool(data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.ValueBool()), {{else}}data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.Value{{.Type}}(), {{end}}{{end}}{{end}} }
				cckeyString := ""
				for ccki := range cckeys {
					cckeyString += "["+cckeys[ccki]+"="+cckeyValues[ccki]+"]"
				}
			{{- range reverseAttributes .Attributes}}
			{{- if and (eq .Type "Bool") (ne .TypeYangBool "boolean")}}
			if !data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.IsNull() && !data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}}.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/{{$xpath}}%v/{{$cxpath}}%v/{{$ccxpath}}%v/{{getDeletePath .}}", data.getPath(), keyString, ckeyString, cckeyString))
			}
			{{- end}}
			{{- if or (eq .Type "List") (eq .Type "Set")}}
			{{- $cccxpath := .XPath}}
			for ccci := range data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{toGoName .TfName}} {
				{{- $ccclist := (toGoName .TfName)}}
				ccckeys := [...]string{ {{range .Attributes}}{{if .Id}}"{{getDeletePath .}}", {{end}}{{end}} }
				ccckeyValues := [...]string{ {{range .Attributes}}{{if .Id}}{{if eq .Type "Int64"}}strconv.FormatInt(data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}}.ValueInt64(), 10), {{else if eq .Type "Bool"}}strconv.FormatBool(data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}}.ValueBool()), {{else}}data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}}.Value{{.Type}}(), {{end}}{{end}}{{end}} }
				ccckeyString := ""
				for cccki := range ccckeys {
					ccckeyString += "["+ccckeys[cccki]+"="+ccckeyValues[cccki]+"]"
				}
				{{- range reverseAttributes .Attributes}}
				{{- if and (eq .Type "Bool") (ne .TypeYangBool "boolean")}}
				if !data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}}.IsNull() && !data.{{$list}}[i].{{$clist}}[ci].{{$cclist}}[cci].{{$ccclist}}[ccci].{{toGoName .TfName}}.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/{{$xpath}}%v/{{$cxpath}}%v/{{$ccxpath}}%v/{{$cccxpath}}%v/{{getDeletePath .}}", data.getPath(), keyString, ckeyString, cckeyString, ccckeyString))
				}
				{{- end}}
				{{- end}}
			}
			{{- end}}
			{{- end}}
		}
		{{- end}}
		{{- end}}
		}
		{{- end}}
		{{- end}}
	}
	{{- end}}
	{{- end}}
	return emptyLeafsDelete
}

// End of section. //template:end getEmptyLeafsDelete

// Section below is generated&owned by "gen/generator.go". //template:begin getDeletePaths

func (data *{{camelCase .Name}}) getDeletePaths(ctx context.Context) []string {
	var deletePaths []string
	{{- range reverseAttributes .Attributes}}
	{{- if and (not .Reference) (not .Id) (ne .Type "List") (ne .Type "Set") (not .NoDelete)}}
	if !data.{{toGoName .TfName}}.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/{{getDeletePath .}}", data.getPath()))
	}
	{{- else if and (or (eq .Type "List") (eq .Type "Set")) (not .NoDelete)}}
	for i := range data.{{toGoName .TfName}} {
		{{- $list := (toGoName .TfName)}}
		keyValues := [...]string{ {{range .Attributes}}{{if .Id}}{{if eq .Type "Int64"}}strconv.FormatInt(data.{{$list}}[i].{{toGoName .TfName}}.ValueInt64(), 10), {{else if eq .Type "Bool"}}strconv.FormatBool(data.{{$list}}[i].{{toGoName .TfName}}.ValueBool()), {{else}}data.{{$list}}[i].{{toGoName .TfName}}.Value{{.Type}}(), {{end}}{{end}}{{end}} }

		deletePaths = append(deletePaths, fmt.Sprintf("%v/{{getDeletePath .}}=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	{{- end}}
	{{- end}}

	return deletePaths
}

// End of section. //template:end getDeletePaths

// Section below is generated&owned by "gen/generator.go". //template:begin toBodyXML

func (data {{camelCase .Name}}) toBodyXML(ctx context.Context) string {
	body := netconf.Body{}
	{{- range .Attributes}}
	{{- if and (not .Reference) (ne .Type "List") (ne .Type "Set")}}
	if !data.{{toGoName .TfName}}.IsNull() && !data.{{toGoName .TfName}}.IsUnknown() {
		{{- if eq .Type "Int64"}}
		body = helpers.SetFromXPath(body, data.getXPath() + "/{{.XPath}}", strconv.FormatInt(data.{{toGoName .TfName}}.ValueInt64(), 10))
		{{- else if eq .Type "Float64"}}
		body = helpers.SetFromXPath(body, data.getXPath() + "/{{.XPath}}", strconv.FormatFloat(data.{{toGoName .TfName}}.ValueFloat64(), 'f', 1, 64))
		{{- else if and (eq .Type "Bool") (ne .TypeYangBool "boolean")}}
		if data.{{toGoName .TfName}}.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath() + "/{{.XPath}}", "")
		}
		{{- else if and (eq .Type "Bool") (eq .TypeYangBool "boolean")}}
		body = helpers.SetFromXPath(body, data.getXPath() + "/{{.XPath}}", data.{{toGoName .TfName}}.ValueBool())
		{{- else if eq .Type "String"}}
		body = helpers.SetFromXPath(body, data.getXPath() + "/{{.XPath}}", data.{{toGoName .TfName}}.ValueString())
		{{- else if or (eq .Type "StringList") (eq .Type "StringSet")}}
		var values []string
		data.{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
		for _, v := range values {
			body = helpers.AppendFromXPath(body, data.getXPath() + "/{{.XPath}}", v)
		}
		{{- else if or (eq .Type "Int64List") (eq .Type "Int64Set")}}
		var values []int
		data.{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
		for _, v := range values {
			body = helpers.AppendFromXPath(body, data.getXPath() + "/{{.XPath}}", v)
		}
		{{- end}}
	}
	{{- else if or (eq .Type "List") (eq .Type "Set")}}
	if len(data.{{toGoName .TfName}}) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.{{toGoName .TfName}} {
			cBody := netconf.Body{}
			{{- range .Attributes}}
			{{- if and (ne .Type "List") (ne .Type "Set")}}
			if !item.{{toGoName .TfName}}.IsNull() && !item.{{toGoName .TfName}}.IsUnknown() {
				{{- if eq .Type "Int64"}}
				cBody = helpers.SetFromXPath(cBody, "{{.XPath}}", strconv.FormatInt(item.{{toGoName .TfName}}.ValueInt64(), 10))
				{{- else if eq .Type "Float64"}}
				cBody = helpers.SetFromXPath(cBody, "{{.XPath}}", strconv.FormatFloat(item.{{toGoName .TfName}}.ValueFloat64(), 'f', 1, 64))
				{{- else if and (eq .Type "Bool") (ne .TypeYangBool "boolean")}}
				if item.{{toGoName .TfName}}.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "{{.XPath}}", "")
				}
				{{- else if and (eq .Type "Bool") (eq .TypeYangBool "boolean")}}
				cBody = helpers.SetFromXPath(cBody, "{{.XPath}}", item.{{toGoName .TfName}}.ValueBool())
				{{- else if eq .Type "String"}}
				cBody = helpers.SetFromXPath(cBody, "{{.XPath}}", item.{{toGoName .TfName}}.ValueString())
				{{- else if or (eq .Type "StringList") (eq .Type "StringSet")}}
				var values []string
				item.{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
				for _, v := range values {
					cBody = helpers.AppendFromXPath(cBody, "{{.XPath}}", v)
				}
				{{- else if or (eq .Type "Int64List") (eq .Type "Int64Set")}}
				var values []int
				item.{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
				for _, v := range values {
					cBody = helpers.AppendFromXPath(cBody, "{{.XPath}}", v)
				}
				{{- end}}
			}
			{{- else if or (eq .Type "List") (eq .Type "Set")}}
			if len(item.{{toGoName .TfName}}) > 0 {
				for _, citem := range item.{{toGoName .TfName}} {
					ccBody := netconf.Body{}
					_ = citem // Suppress unused variable warning when all attributes are IDs
					{{- range .Attributes}}
					{{- if and (not .Id) (ne .Type "List") (ne .Type "Set")}}
					if !citem.{{toGoName .TfName}}.IsNull() && !citem.{{toGoName .TfName}}.IsUnknown() {
						{{- if eq .Type "Int64"}}
						ccBody = helpers.SetFromXPath(ccBody, "{{.XPath}}", strconv.FormatInt(citem.{{toGoName .TfName}}.ValueInt64(), 10))
						{{- else if eq .Type "Float64"}}
						ccBody = helpers.SetFromXPath(ccBody, "{{.XPath}}", strconv.FormatFloat(citem.{{toGoName .TfName}}.ValueFloat64(), 'f', 1, 64))
						{{- else if and (eq .Type "Bool") (ne .TypeYangBool "boolean")}}
						if citem.{{toGoName .TfName}}.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "{{.XPath}}", "")
						}
						{{- else if and (eq .Type "Bool") (eq .TypeYangBool "boolean")}}
						ccBody = helpers.SetFromXPath(ccBody, "{{.XPath}}", citem.{{toGoName .TfName}}.ValueBool())
						{{- else if eq .Type "String"}}
						ccBody = helpers.SetFromXPath(ccBody, "{{.XPath}}", citem.{{toGoName .TfName}}.ValueString())
						{{- else if or (eq .Type "StringList") (eq .Type "StringSet")}}
						var values []string
						citem.{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
						for _, v := range values {
							ccBody = helpers.AppendFromXPath(ccBody, "{{.XPath}}", v)
						}
						{{- else if or (eq .Type "Int64List") (eq .Type "Int64Set")}}
						var values []int
						citem.{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
						for _, v := range values {
							ccBody = helpers.AppendFromXPath(ccBody, "{{.XPath}}", v)
						}
						{{- end}}
					}
					{{- else if or (eq .Type "List") (eq .Type "Set")}}
					if len(citem.{{toGoName .TfName}}) > 0 {
						for _, ccitem := range citem.{{toGoName .TfName}} {
							cccBody := netconf.Body{}
							_ = ccitem // Suppress unused variable warning
							{{- range .Attributes}}
							{{- if and (not .Id) (ne .Type "List") (ne .Type "Set")}}
							if !ccitem.{{toGoName .TfName}}.IsNull() && !ccitem.{{toGoName .TfName}}.IsUnknown() {
								{{- if eq .Type "Int64"}}
								cccBody = helpers.SetFromXPath(cccBody, "{{.XPath}}", strconv.FormatInt(ccitem.{{toGoName .TfName}}.ValueInt64(), 10))
								{{- else if eq .Type "Float64"}}
								cccBody = helpers.SetFromXPath(cccBody, "{{.XPath}}", strconv.FormatFloat(ccitem.{{toGoName .TfName}}.ValueFloat64(), 'f', 1, 64))
								{{- else if and (eq .Type "Bool") (ne .TypeYangBool "boolean")}}
								if ccitem.{{toGoName .TfName}}.ValueBool() {
									cccBody = helpers.SetFromXPath(cccBody, "{{.XPath}}", "")
								}
								{{- else if and (eq .Type "Bool") (eq .TypeYangBool "boolean")}}
								cccBody = helpers.SetFromXPath(cccBody, "{{.XPath}}", ccitem.{{toGoName .TfName}}.ValueBool())
								{{- else if eq .Type "String"}}
								cccBody = helpers.SetFromXPath(cccBody, "{{.XPath}}", ccitem.{{toGoName .TfName}}.ValueString())
								{{- else if or (eq .Type "StringList") (eq .Type "StringSet")}}
								var values []string
								ccitem.{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
								for _, v := range values {
									cccBody = helpers.AppendFromXPath(cccBody, "{{.XPath}}", v)
								}
								{{- else if or (eq .Type "Int64List") (eq .Type "Int64Set")}}
								var values []int
								ccitem.{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
								for _, v := range values {
									cccBody = helpers.AppendFromXPath(cccBody, "{{.XPath}}", v)
								}
								{{- end}}
							}
							{{- end}}
							{{- end}}
							ccBody = helpers.AppendRawFromXPath(ccBody, "{{.XPath}}", cccBody.Res())
						}
					}
					{{- end}}
					{{- end}}
					cBody = helpers.SetRawFromXPath(cBody, "{{.XPath}}", ccBody.Res())
				}
			}
			{{- end}}
			{{- end}}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"{{.XPath}}", cBody.Res())
		}
	}
	{{- end}}
	{{- end}}
	bodyString, err := body.String()
	if err != nil {
		tflog.Error(ctx, fmt.Sprintf("Error converting body to string: %s", err))
	}
	return bodyString
}

// End of section. //template:end toBodyXML

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBodyXML

func (data *{{camelCase .Name}}) updateFromBodyXML(ctx context.Context, res xmldot.Result) {
	{{- range .Attributes}}
	{{- if and (not .Reference) (not .WriteOnly)}}
	{{- if eq .Type "Int64"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = types.Int64Value(value.Int())
	} else if data.{{toGoName .TfName}}.IsNull() {
		data.{{toGoName .TfName}} = types.Int64Null()
	}
	{{- else if eq .Type "Float64"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = types.Float64Value(value.Float())
	} else if data.{{toGoName .TfName}}.IsNull() {
		data.{{toGoName .TfName}} = types.Float64Null()
	}
	{{- else if eq .Type "Bool"}}
	{{- if eq .TypeYangBool "boolean"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = types.BoolValue(value.Bool())
	} else if data.{{toGoName .TfName}}.IsNull() {
		data.{{toGoName .TfName}} = types.BoolNull()
	}
	{{- else}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.{{toGoName .TfName}}.IsNull() {
			data.{{toGoName .TfName}} = types.BoolNull()
		}
	}
	{{- end}}
	{{- else if eq .Type "String"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = types.StringValue({{if .ReadRaw}}value.Raw{{else}}value.String(){{end}})
	} else if data.{{toGoName .TfName}}.IsNull() {
		data.{{toGoName .TfName}} = types.StringNull()
	}
	{{- else if eq .Type "StringList"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = helpers.GetStringListXML(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.ListNull(types.StringType)
	}
	{{- else if eq .Type "Int64List"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = helpers.GetInt64ListXML(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.ListNull(types.Int64Type)
	}
	{{- else if eq .Type "StringSet"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = helpers.GetStringSetXML(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.SetNull(types.StringType)
	}
	{{- else if eq .Type "Int64Set"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = helpers.GetInt64SetXML(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.SetNull(types.Int64Type)
	}
	{{- else if or (eq .Type "List") (eq .Type "Set")}}
	{{- $list := (toGoName .TfName)}}
	for i := range data.{{$list}} {
		keys := [...]string{ {{range .Attributes}}{{if .Id}}"{{.XPath}}", {{end}}{{end}} }
		keyValues := [...]string{ {{range .Attributes}}{{if .Id}}{{if eq .Type "Int64"}}strconv.FormatInt(data.{{$list}}[i].{{toGoName .TfName}}.ValueInt64(), 10), {{else if eq .Type "Bool"}}strconv.FormatBool(data.{{$list}}[i].{{toGoName .TfName}}.ValueBool()), {{else}}data.{{$list}}[i].{{toGoName .TfName}}.Value{{.Type}}(), {{end}}{{end}}{{end}} }

		var r xmldot.Result
		helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)

		{{- range .Attributes}}
		{{- if not .WriteOnly}}
		{{- if eq .Type "Int64"}}
		if value := helpers.GetFromXPath(r, "{{.XPath}}"); value.Exists() {
			data.{{$list}}[i].{{toGoName .TfName}} = types.Int64Value(value.Int())
		} else if data.{{$list}}[i].{{toGoName .TfName}}.IsNull() {
			data.{{$list}}[i].{{toGoName .TfName}} = types.Int64Null()
		}
		{{- else if eq .Type "Float64"}}
		if value := helpers.GetFromXPath(r, "{{.XPath}}"); value.Exists() {
			data.{{$list}}[i].{{toGoName .TfName}} = types.Float64Value(value.Float())
		} else if data.{{$list}}[i].{{toGoName .TfName}}.IsNull() {
			data.{{$list}}[i].{{toGoName .TfName}} = types.Float64Null()
		}
		{{- else if eq .Type "Bool"}}
		if value := helpers.GetFromXPath(r, "{{.XPath}}"); value.Exists() {
			{{- if eq .TypeYangBool "boolean"}}
			data.{{$list}}[i].{{toGoName .TfName}} = types.BoolValue(value.Bool())
			{{- else}}
			data.{{$list}}[i].{{toGoName .TfName}} = types.BoolValue(true)
			{{- end}}
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.{{$list}}[i].{{toGoName .TfName}}.IsNull() {
				data.{{$list}}[i].{{toGoName .TfName}} = types.BoolNull()
			}
		}
		{{- else if eq .Type "String"}}
		if value := helpers.GetFromXPath(r, "{{.XPath}}"); value.Exists() {
			data.{{$list}}[i].{{toGoName .TfName}} = types.StringValue(value.String())
		} else if data.{{$list}}[i].{{toGoName .TfName}}.IsNull() {
			data.{{$list}}[i].{{toGoName .TfName}} = types.StringNull()
		}
		{{- else if eq .Type "StringList"}}
		if childElements := helpers.GetAllChildElements(r, "{{.XPath}}"); len(childElements) > 0 {
			data.{{$list}}[i].{{toGoName .TfName}} = helpers.GetStringListXML(childElements)
		}
		{{- else if eq .Type "Int64List"}}
		if childElements := helpers.GetAllChildElements(r, "{{.XPath}}"); len(childElements) > 0 {
			data.{{$list}}[i].{{toGoName .TfName}} = helpers.GetInt64ListXML(childElements)
		}
		{{- else if eq .Type "StringSet"}}
		if childElements := helpers.GetAllChildElements(r, "{{.XPath}}"); len(childElements) > 0 {
			data.{{$list}}[i].{{toGoName .TfName}} = helpers.GetStringSetXML(childElements)
		}
		{{- else if eq .Type "Int64Set"}}
		if childElements := helpers.GetAllChildElements(r, "{{.XPath}}"); len(childElements) > 0 {
			data.{{$list}}[i].{{toGoName .TfName}} = helpers.GetInt64SetXML(childElements)
		}
		{{- else if or (eq .Type "List") (eq .Type "Set")}}
		{{- $clist := (toGoName .TfName)}}
		for ci := range data.{{$list}}[i].{{$clist}} {
			keys := [...]string{ {{range .Attributes}}{{if .Id}}"{{.XPath}}", {{end}}{{end}} }
			keyValues := [...]string{ {{range .Attributes}}{{if .Id}}{{if eq .Type "Int64"}}strconv.FormatInt(data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.ValueInt64(), 10), {{else if eq .Type "Bool"}}strconv.FormatBool(data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.ValueBool()), {{else}}data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.Value{{.Type}}(), {{end}}{{end}}{{end}} }

			var cr xmldot.Result
			helpers.GetFromXPath(r, "{{.XPath}}").ForEach(
				func(_ int, v xmldot.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)

			{{- range .Attributes}}
			{{- if not .WriteOnly}}
			{{- if eq .Type "Int64"}}
			if value := helpers.GetFromXPath(cr, "{{.XPath}}"); value.Exists() {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.Int64Value(value.Int())
			} else {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.Int64Null()
			}
			{{- else if eq .Type "Float64"}}
			if value := helpers.GetFromXPath(cr, "{{.XPath}}"); value.Exists() {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.Float64Value(value.Float())
			} else {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.Float64Null()
			}
				{{- else if eq .Type "Bool"}}
				{{- if eq .TypeYangBool "boolean"}}
				if value := helpers.GetFromXPath(cr, "{{.XPath}}"); value.Exists() {
					data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.BoolValue(value.Bool())
				} else if data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.IsNull() {
					data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.BoolNull()
				}
					{{- else}}
					if value := helpers.GetFromXPath(cr, "{{.XPath}}"); value.Exists() {
						if !data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.IsNull() {
							data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.BoolValue(true)
						}
					} else {
						// For presence-based booleans, only set to false if the attribute is null in state
						if data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.IsNull() {
							data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.BoolNull()
						}
					}
					{{- end}}
			{{- else if eq .Type "String"}}
			if value := helpers.GetFromXPath(cr, "{{.XPath}}"); value.Exists() {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.StringValue(value.String())
			} else {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.StringNull()
			}
			{{- else if eq .Type "StringList"}}
			if value := helpers.GetFromXPath(cr, "{{.XPath}}"); value.Exists() {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = helpers.GetStringListXML(value.Array())
			} else {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.ListNull(types.StringType)
			}
			{{- else if eq .Type "Int64List"}}
			if value := helpers.GetFromXPath(cr, "{{.XPath}}"); value.Exists() {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = helpers.GetInt64ListXML(value.Array())
			} else {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.ListNull(types.Int64Type)
			}
			{{- else if eq .Type "StringSet"}}
			if value := helpers.GetFromXPath(cr, "{{.XPath}}"); value.Exists() {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = helpers.GetStringSetXML(value.Array())
			} else {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.SetNull(types.StringType)
			}
			{{- else if eq .Type "Int64Set"}}
			if value := helpers.GetFromXPath(cr, "{{.XPath}}"); value.Exists() {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = helpers.GetInt64SetXML(value.Array())
			} else {
				data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}} = types.SetNull(types.Int64Type)
			}
			{{- end}}
			{{- end}}
			{{- end}}
		}
		{{- end}}
		{{- end}}
		{{- end}}
	}
	{{- end}}
	{{- end}}
	{{- end}}
}

// End of section. //template:end updateFromBodyXML

// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyXML

func (data *{{camelCase .Name}}) fromBodyXML(ctx context.Context, res xmldot.Result) {
	{{- $name := camelCase .Name}}
	{{- range .Attributes}}
	{{- $cname := toGoName .TfName}}
	{{- if and (not .Reference) (not .Id)}}
	{{- if eq .Type "Int64"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = types.Int64Value(value.Int())
	}
	{{- else if eq .Type "Float64"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = types.Float64Value(value.Float())
	}
	{{- else if eq .Type "Bool"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		{{- if eq .TypeYangBool "boolean"}}
		data.{{toGoName .TfName}} = types.BoolValue(value.Bool())
		{{- else}}
		data.{{toGoName .TfName}} = types.BoolValue(true)
		{{- end}}
	} else {
		data.{{toGoName .TfName}} = types.BoolNull()
	}
	{{- else if eq .Type "String"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = types.StringValue({{if .ReadRaw}}value.Raw{{else}}value.String(){{end}})
	}
	{{- else if eq .Type "StringList"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = helpers.GetStringListXML(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.ListNull(types.StringType)
	}
	{{- else if eq .Type "Int64List"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = helpers.GetInt64ListXML(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.ListNull(types.Int64Type)
	}
	{{- else if eq .Type "StringSet"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = helpers.GetStringSetXML(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.SetNull(types.StringType)
	}
	{{- else if eq .Type "Int64Set"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = helpers.GetInt64SetXML(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.SetNull(types.Int64Type)
	}
	{{- else if or (eq .Type "List") (eq .Type "Set")}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = make([]{{$name}}{{toGoName .TfName}}, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := {{$name}}{{toGoName .TfName}}{}
			{{- range .Attributes}}
			{{- if eq .Type "Int64"}}
			if cValue := helpers.GetFromXPath(v, "{{.XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = types.Int64Value(cValue.Int())
			}
			{{- else if eq .Type "Float64"}}
			if cValue := helpers.GetFromXPath(v, "{{.XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = types.Float64Value(cValue.Float())
			}
			{{- else if eq .Type "Bool"}}
			if cValue := helpers.GetFromXPath(v, "{{.XPath}}"); cValue.Exists() {
				{{- if eq .TypeYangBool "boolean"}}
				item.{{toGoName .TfName}} = types.BoolValue(cValue.Bool())
				{{- else}}
				item.{{toGoName .TfName}} = types.BoolValue(true)
				{{- end}}
			} else {
				item.{{toGoName .TfName}} = types.BoolNull()
			}
			{{- else if eq .Type "String"}}
			if cValue := helpers.GetFromXPath(v, "{{.XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = types.StringValue({{if .ReadRaw}}cValue.Raw{{else}}cValue.String(){{end}})
			}
			{{- else if eq .Type "StringList"}}
			if cValue := helpers.GetFromXPath(v, "{{.XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = helpers.GetStringListXML(cValue.Array())
			} else {
				item.{{toGoName .TfName}} = types.ListNull(types.StringType)
			}
			{{- else if eq .Type "Int64List"}}
			if cValue := helpers.GetFromXPath(v, "{{.XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = helpers.GetInt64ListXML(cValue.Array())
			} else {
				item.{{toGoName .TfName}} = types.ListNull(types.Int64Type)
			}
			{{- else if eq .Type "StringSet"}}
			if cValue := helpers.GetFromXPath(v, "{{.XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = helpers.GetStringSetXML(cValue.Array())
			} else {
				item.{{toGoName .TfName}} = types.SetNull(types.StringType)
			}
			{{- else if eq .Type "Int64Set"}}
			if cValue := helpers.GetFromXPath(v, "{{.XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = helpers.GetInt64SetXML(cValue.Array())
			} else {
				item.{{toGoName .TfName}} = types.SetNull(types.Int64Type)
			}
			{{- else if or (eq .Type "List") (eq .Type "Set")}}
			{{- $ccname := toGoName .TfName}}
			if cValue := helpers.GetFromXPath(v, "{{.XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = make([]{{$name}}{{$cname}}{{toGoName .TfName}}, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := {{$name}}{{$cname}}{{toGoName .TfName}}{}
					{{- range .Attributes}}
					{{- if eq .Type "Int64"}}
					if ccValue := helpers.GetFromXPath(cv, "{{.XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = types.Int64Value(ccValue.Int())
					}
					{{- else if eq .Type "Float64"}}
					if ccValue := helpers.GetFromXPath(cv, "{{.XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = types.Float64Value(ccValue.Float())
					}
					{{- else if eq .Type "Bool"}}
					if ccValue := helpers.GetFromXPath(cv, "{{.XPath}}"); ccValue.Exists() {
						{{- if eq .TypeYangBool "boolean"}}
						cItem.{{toGoName .TfName}} = types.BoolValue(ccValue.Bool())
						{{- else}}
						cItem.{{toGoName .TfName}} = types.BoolValue(true)
						{{- end}}
					} else {
						cItem.{{toGoName .TfName}} = types.BoolNull()
					}
					{{- else if eq .Type "String"}}
					if ccValue := helpers.GetFromXPath(cv, "{{.XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = types.StringValue({{if .ReadRaw}}ccValue.Raw{{else}}ccValue.String(){{end}})
					}
					{{- else if eq .Type "StringList"}}
					if ccValue := helpers.GetFromXPath(cv, "{{.XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = helpers.GetStringListXML(ccValue.Array())
					} else {
						cItem.{{toGoName .TfName}} = types.ListNull(types.StringType)
					}
					{{- else if eq .Type "Int64List"}}
					if ccValue := helpers.GetFromXPath(cv, "{{.XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = helpers.GetInt64ListXML(ccValue.Array())
					} else {
						cItem.{{toGoName .TfName}} = types.ListNull(types.Int64Type)
					}
					{{- else if eq .Type "StringSet"}}
					if ccValue := helpers.GetFromXPath(cv, "{{.XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = helpers.GetStringSetXML(ccValue.Array())
					} else {
						cItem.{{toGoName .TfName}} = types.SetNull(types.StringType)
					}
					{{- else if eq .Type "Int64Set"}}
					if ccValue := helpers.GetFromXPath(cv, "{{.XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = helpers.GetInt64SetXML(ccValue.Array())
					} else {
						cItem.{{toGoName .TfName}} = types.SetNull(types.Int64Type)
					}
					{{- else if eq .Type "List"}}
					{{- $cccname := toGoName .TfName}}
					if ccValue := helpers.GetFromXPath(cv, "{{.XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = make([]{{$name}}{{$cname}}{{$ccname}}{{toGoName .TfName}}, 0)
						ccValue.ForEach(func(_ int, ccv xmldot.Result) bool {
							ccItem := {{$name}}{{$cname}}{{$ccname}}{{toGoName .TfName}}{}
							{{- range .Attributes}}
							{{- if and (not .WriteOnly) .TfName .Type}}
							{{- if eq .Type "Int64"}}
							if cccValue := helpers.GetFromXPath(ccv, "{{.XPath}}"); cccValue.Exists() {
								ccItem.{{toGoName .TfName}} = types.Int64Value(cccValue.Int())
							}
							{{- else if eq .Type "Float64"}}
							if cccValue := helpers.GetFromXPath(ccv, "{{.XPath}}"); cccValue.Exists() {
								ccItem.{{toGoName .TfName}} = types.Float64Value(cccValue.Float())
							}
							{{- else if eq .Type "Bool"}}
							if cccValue := helpers.GetFromXPath(ccv, "{{.XPath}}"); cccValue.Exists() {
								{{- if eq .TypeYangBool "boolean"}}
								ccItem.{{toGoName .TfName}} = types.BoolValue(cccValue.Bool())
								{{- else}}
								ccItem.{{toGoName .TfName}} = types.BoolValue(true)
								{{- end}}
							} else {
								{{- if eq .TypeYangBool "boolean"}}
								ccItem.{{toGoName .TfName}} = types.BoolNull()
								{{- else}}
								ccItem.{{toGoName .TfName}} = types.BoolValue(false)
								{{- end}}
							}
							{{- else if eq .Type "String"}}
							if cccValue := helpers.GetFromXPath(ccv, "{{.XPath}}"); cccValue.Exists() {
								ccItem.{{toGoName .TfName}} = types.StringValue({{if .ReadRaw}}cccValue.Raw{{else}}cccValue.String(){{end}})
							}
							{{- else if eq .Type "StringList"}}
							if cccValue := helpers.GetFromXPath(ccv, "{{.XPath}}"); cccValue.Exists() {
								ccItem.{{toGoName .TfName}} = helpers.GetStringListXML(cccValue.Array())
							} else {
								ccItem.{{toGoName .TfName}} = types.ListNull(types.StringType)
							}
							{{- else if eq .Type "Int64List"}}
							if cccValue := helpers.GetFromXPath(ccv, "{{.XPath}}"); cccValue.Exists() {
								ccItem.{{toGoName .TfName}} = helpers.GetInt64ListXML(cccValue.Array())
							} else {
								ccItem.{{toGoName .TfName}} = types.ListNull(types.Int64Type)
							}
							{{- else if eq .Type "List"}}
							if cccValue := helpers.GetFromXPath(ccv, "{{.XPath}}"); cccValue.Exists() {
								ccItem.{{toGoName .TfName}} = make([]{{$name}}{{$cname}}{{$ccname}}{{$cccname}}{{toGoName .TfName}}, 0)
								cccValue.ForEach(func(_ int, cccv xmldot.Result) bool {
									cccItem := {{$name}}{{$cname}}{{$ccname}}{{$cccname}}{{toGoName .TfName}}{}
									{{- range .Attributes}}
									{{- if and (not .WriteOnly) .TfName .Type}}
									{{- if eq .Type "Int64"}}
									if ccccValue := helpers.GetFromXPath(cccv, "{{.XPath}}"); ccccValue.Exists() {
										cccItem.{{toGoName .TfName}} = types.Int64Value(ccccValue.Int())
									}
									{{- else if eq .Type "Float64"}}
									if ccccValue := helpers.GetFromXPath(cccv, "{{.XPath}}"); ccccValue.Exists() {
										cccItem.{{toGoName .TfName}} = types.Float64Value(ccccValue.Float())
									}
									{{- else if eq .Type "Bool"}}
									if ccccValue := helpers.GetFromXPath(cccv, "{{.XPath}}"); ccccValue.Exists() {
										{{- if eq .TypeYangBool "boolean"}}
										cccItem.{{toGoName .TfName}} = types.BoolValue(ccccValue.Bool())
										{{- else}}
										cccItem.{{toGoName .TfName}} = types.BoolValue(true)
										{{- end}}
									} else {
										cccItem.{{toGoName .TfName}} = types.BoolNull()
									}
									{{- else if eq .Type "String"}}
									if ccccValue := helpers.GetFromXPath(cccv, "{{.XPath}}"); ccccValue.Exists() {
										cccItem.{{toGoName .TfName}} = types.StringValue({{if .ReadRaw}}ccccValue.Raw{{else}}ccccValue.String(){{end}})
									}
									{{- else if eq .Type "StringList"}}
									if ccccValue := helpers.GetFromXPath(cccv, "{{.XPath}}"); ccccValue.Exists() {
										cccItem.{{toGoName .TfName}} = helpers.GetStringListXML(ccccValue.Array())
									} else {
										cccItem.{{toGoName .TfName}} = types.ListNull(types.StringType)
									}
									{{- else if eq .Type "Int64List"}}
									if ccccValue := helpers.GetFromXPath(cccv, "{{.XPath}}"); ccccValue.Exists() {
										cccItem.{{toGoName .TfName}} = helpers.GetInt64ListXML(ccccValue.Array())
									} else {
										cccItem.{{toGoName .TfName}} = types.ListNull(types.Int64Type)
									}
									{{- end}}
									{{- end}}
									{{- end}}
									ccItem.{{toGoName .TfName}} = append(ccItem.{{toGoName .TfName}}, cccItem)
									return true
								})
							}
							{{- end}}
							{{- end}}
							{{- end}}
							cItem.{{toGoName .TfName}} = append(cItem.{{toGoName .TfName}}, ccItem)
							return true
						})
					}
					{{- end}}
					{{- end}}
					item.{{toGoName .TfName}} = append(item.{{toGoName .TfName}}, cItem)
					return true
				})
			}
			{{- end}}
			{{- end}}
			data.{{toGoName .TfName}} = append(data.{{toGoName .TfName}}, item)
			return true
		})
	}
	{{- end}}
	{{- end}}
	{{- end}}
}

// End of section. //template:end fromBodyXML

// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyDataXML

func (data *{{camelCase .Name}}Data) fromBodyXML(ctx context.Context, res xmldot.Result) {
	{{- $name := camelCase .Name}}
	{{- range .Attributes}}
	{{- $cname := toGoName .TfName}}
	{{- if and (not .Reference) (not .Id)}}
	{{- if eq .Type "Int64"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = types.Int64Value(value.Int())
	}
	{{- else if eq .Type "Float64"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = types.Float64Value(value.Float())
	}
	{{- else if eq .Type "Bool"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		{{- if eq .TypeYangBool "boolean"}}
		data.{{toGoName .TfName}} = types.BoolValue(value.Bool())
		{{- else}}
		data.{{toGoName .TfName}} = types.BoolValue(true)
		{{- end}}
	} else {
		data.{{toGoName .TfName}} = types.BoolValue(false)
	}
	{{- else if eq .Type "String"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = types.StringValue({{if .ReadRaw}}value.Raw{{else}}value.String(){{end}})
	}
	{{- else if eq .Type "StringList"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = helpers.GetStringListXML(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.ListNull(types.StringType)
	}
	{{- else if eq .Type "Int64List"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = helpers.GetInt64ListXML(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.ListNull(types.Int64Type)
	}
	{{- else if eq .Type "StringSet"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = helpers.GetStringSetXML(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.SetNull(types.StringType)
	}
	{{- else if eq .Type "Int64Set"}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = helpers.GetInt64SetXML(value.Array())
	} else {
		data.{{toGoName .TfName}} = types.SetNull(types.Int64Type)
	}
	{{- else if or (eq .Type "List") (eq .Type "Set")}}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/{{.XPath}}"); value.Exists() {
		data.{{toGoName .TfName}} = make([]{{$name}}{{toGoName .TfName}}, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := {{$name}}{{toGoName .TfName}}{}
			{{- range .Attributes}}
			{{- if eq .Type "Int64"}}
			if cValue := helpers.GetFromXPath(v, "{{.XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = types.Int64Value(cValue.Int())
			}
			{{- else if eq .Type "Float64"}}
			if cValue := helpers.GetFromXPath(v, "{{.XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = types.Float64Value(cValue.Float())
			}
		{{- else if eq .Type "Bool"}}
		if cValue := helpers.GetFromXPath(v, "{{.XPath}}"); cValue.Exists() {
			{{- if eq .TypeYangBool "boolean"}}
			item.{{toGoName .TfName}} = types.BoolValue(cValue.Bool())
			{{- else}}
			item.{{toGoName .TfName}} = types.BoolValue(true)
			{{- end}}
		} else {
			item.{{toGoName .TfName}} = types.BoolValue(false)
		}
		{{- else if eq .Type "String"}}
			if cValue := helpers.GetFromXPath(v, "{{.XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = types.StringValue({{if .ReadRaw}}cValue.Raw{{else}}cValue.String(){{end}})
			}
			{{- else if eq .Type "StringList"}}
			if cValue := helpers.GetFromXPath(v, "{{.XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = helpers.GetStringListXML(cValue.Array())
			} else {
				item.{{toGoName .TfName}} = types.ListNull(types.StringType)
			}
			{{- else if eq .Type "Int64List"}}
			if cValue := helpers.GetFromXPath(v, "{{.XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = helpers.GetInt64ListXML(cValue.Array())
			} else {
				item.{{toGoName .TfName}} = types.ListNull(types.Int64Type)
			}
			{{- else if eq .Type "StringSet"}}
			if cValue := helpers.GetFromXPath(v, "{{.XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = helpers.GetStringSetXML(cValue.Array())
			} else {
				item.{{toGoName .TfName}} = types.SetNull(types.StringType)
			}
			{{- else if eq .Type "Int64Set"}}
			if cValue := helpers.GetFromXPath(v, "{{.XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = helpers.GetInt64SetXML(cValue.Array())
			} else {
				item.{{toGoName .TfName}} = types.SetNull(types.Int64Type)
			}
			{{- else if or (eq .Type "List") (eq .Type "Set")}}
			if cValue := helpers.GetFromXPath(v, "{{.XPath}}"); cValue.Exists() {
				item.{{toGoName .TfName}} = make([]{{$name}}{{$cname}}{{toGoName .TfName}}, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := {{$name}}{{$cname}}{{toGoName .TfName}}{}
					{{- range .Attributes}}
					{{- if eq .Type "Int64"}}
					if ccValue := helpers.GetFromXPath(cv, "{{.XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = types.Int64Value(ccValue.Int())
					}
					{{- else if eq .Type "Float64"}}
					if ccValue := helpers.GetFromXPath(cv, "{{.XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = types.Float64Value(ccValue.Float())
					}
					{{- else if eq .Type "Bool"}}
					if ccValue := helpers.GetFromXPath(cv, "{{.XPath}}"); ccValue.Exists() {
						{{- if eq .TypeYangBool "boolean"}}
						cItem.{{toGoName .TfName}} = types.BoolValue(ccValue.Bool())
						{{- else}}
						cItem.{{toGoName .TfName}} = types.BoolValue(true)
						{{- end}}
					} else {
						{{- if eq .TypeYangBool "boolean"}}
		cItem.{{toGoName .TfName}} = types.BoolNull()
		{{- end}}
					}
					{{- else if eq .Type "String"}}
					if ccValue := helpers.GetFromXPath(cv, "{{.XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = types.StringValue({{if .ReadRaw}}ccValue.Raw{{else}}ccValue.String(){{end}})
					}
					{{- else if eq .Type "StringList"}}
					if ccValue := helpers.GetFromXPath(cv, "{{.XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = helpers.GetStringListXML(ccValue.Array())
					} else {
						cItem.{{toGoName .TfName}} = types.ListNull(types.StringType)
					}
					{{- else if eq .Type "Int64List"}}
					if ccValue := helpers.GetFromXPath(cv, "{{.XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = helpers.GetInt64ListXML(ccValue.Array())
					} else {
						cItem.{{toGoName .TfName}} = types.ListNull(types.Int64Type)
					}
					{{- else if eq .Type "StringSet"}}
					if ccValue := helpers.GetFromXPath(cv, "{{.XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = helpers.GetStringSetXML(ccValue.Array())
					} else {
						cItem.{{toGoName .TfName}} = types.SetNull(types.StringType)
					}
					{{- else if eq .Type "Int64Set"}}
					if ccValue := helpers.GetFromXPath(cv, "{{.XPath}}"); ccValue.Exists() {
						cItem.{{toGoName .TfName}} = helpers.GetInt64SetXML(ccValue.Array())
					} else {
						cItem.{{toGoName .TfName}} = types.SetNull(types.Int64Type)
					}
					{{- end}}
					{{- end}}
					item.{{toGoName .TfName}} = append(item.{{toGoName .TfName}}, cItem)
					return true
				})
			}
			{{- end}}
			{{- end}}
			data.{{toGoName .TfName}} = append(data.{{toGoName .TfName}}, item)
			return true
		})
	}
	{{- end}}
	{{- end}}
	{{- end}}
}

// End of section. //template:end fromBodyDataXML

// Section below is generated&owned by "gen/generator.go". //template:begin addDeletedItemsXML

func (data *{{camelCase .Name}}) addDeletedItemsXML(ctx context.Context, state {{camelCase .Name}}, body string) string {
	deleteXml := ""
	deletedPaths := make(map[string]bool)
	_ = deletedPaths // Avoid unused variable error when no delete_parent attributes exist
	{{- range reverseAttributes .Attributes}}
	{{- if or (eq .Type "StringList") (eq .Type "Int64List") (eq .Type "StringSet") (eq .Type "Int64Set")}}
	if !state.{{toGoName .TfName}}.IsNull() {
		if data.{{toGoName .TfName}}.IsNull() {
			var values []string
			state.{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
			for _, v := range values {
				deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/{{.XPath}}[.=%v]", v))
			}
		} else {
			var dataValues, stateValues []{{ if or (eq .Type "StringList") (eq .Type "StringSet") }}string{{else}}int{{end}}
			data.{{toGoName .TfName}}.ElementsAs(ctx, &dataValues, false)
			state.{{toGoName .TfName}}.ElementsAs(ctx, &stateValues, false)
			for _, v := range stateValues {
				found := false
				for _, vv := range dataValues {
					if v == vv {
						found = true
						break
					}
				}
				if !found {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/{{.XPath}}[.=%v]", v))
				}
			}
		}
	}
	{{- else if and (not .Reference) (not .Id) (ne .Type "List") (ne .Type "Set") (not .NoDelete)}}
	{{- if eq .Type "Bool"}}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.{{toGoName .TfName}}.IsNull() && state.{{toGoName .TfName}}.ValueBool() && data.{{toGoName .TfName}}.IsNull() {
	{{- else}}
	if !state.{{toGoName .TfName}}.IsNull() && data.{{toGoName .TfName}}.IsNull() {
	{{- end}}
		{{- if or .DeleteParent .DeleteGrandparent}}
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath()+"/{{getDeletePath .}}"
		predicates := make(map[string]string)
		{{- $currentPath := getDeletePath .}}
		{{- $currentAttr := .}}
		{{- range $attr := $.Attributes}}
		{{- if and (ne $attr.TfName $currentAttr.TfName) (or $attr.DeleteParent $attr.DeleteGrandparent) (eq (getDeletePath $attr) $currentPath)}}
		{{- $lastElement := getLastPathElement $attr.XPath}}
		if !state.{{toGoName $attr.TfName}}.IsNull() {
			predicates["{{$lastElement}}"] = fmt.Sprintf("%v", state.{{toGoName $attr.TfName}}.Value{{$attr.Type}}())
		}
		{{- end}}
		{{- end}}
		{{- $lastElement := getLastPathElement .XPath}}
		predicates["{{$lastElement}}"] = fmt.Sprintf("%v", state.{{toGoName .TfName}}.Value{{.Type}}())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
		{{- else}}
		deletePath := state.getXPath()+"/{{getDeletePath .}}"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
		{{- end}}
	}
	{{- else if or (eq .Type "List") (eq .Type "Set")}}
	{{- $xpath := .XPath}}
	for i := range state.{{toGoName .TfName}} {
		{{- $list := (toGoName .TfName)}}
		stateKeys := [...]string{ {{range .Attributes}}{{if .Id}}"{{.XPath}}", {{end}}{{end}} }
		stateKeyValues := [...]string{ {{range .Attributes}}{{if .Id}}{{if eq .Type "Int64"}}strconv.FormatInt(state.{{$list}}[i].{{toGoName .TfName}}.ValueInt64(), 10), {{else if eq .Type "Bool"}}strconv.FormatBool(state.{{$list}}[i].{{toGoName .TfName}}.ValueBool()), {{else}}state.{{$list}}[i].{{toGoName .TfName}}.Value{{.Type}}(), {{end}}{{end}}{{end}} }
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		{{- range .Attributes}}
		{{- if .Id}}
		if !reflect.ValueOf(state.{{$list}}[i].{{toGoName .TfName}}.Value{{.Type}}()).IsZero() {
			emptyKeys = false
		}
		{{- end}}
		{{- end}}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.{{toGoName .TfName}} {
			found = true
			{{- range .Attributes}}
			{{- if .Id}}
			if state.{{$list}}[i].{{toGoName .TfName}}.Value{{.Type}}() != data.{{$list}}[j].{{toGoName .TfName}}.Value{{.Type}}() {
				found = false
			}
			{{- end}}
			{{- end}}
			if found {
				{{- range reverseAttributes .Attributes}}
				{{- if or (eq .Type "StringList") (eq .Type "Int64List") (eq .Type "StringSet") (eq .Type "Int64Set")}}
				if !state.{{$list}}[i].{{toGoName .TfName}}.IsNull() {
					if data.{{$list}}[j].{{toGoName .TfName}}.IsNull() {
						var values []string
						state.{{$list}}[i].{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
						for _, v := range values {
							deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/{{$xpath}}%v/{{.XPath}}[.=%v]", predicates, v))
						}
					} else {
						var dataValues, stateValues []{{ if or (eq .Type "StringList") (eq .Type "StringSet") }}string{{else}}int{{end}}
						data.{{$list}}[i].{{toGoName .TfName}}.ElementsAs(ctx, &dataValues, false)
						state.{{$list}}[j].{{toGoName .TfName}}.ElementsAs(ctx, &stateValues, false)
						for _, v := range stateValues {
							found := false
							for _, vv := range dataValues {
								if v == vv {
									found = true
									break
								}
							}
									if !found {
										deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/{{$xpath}}%v/{{.XPath}}[.=%v]", predicates, v))
									}
					}
				}
			}
			{{- else if and (not .Reference) (not .Id) (ne .Type "List") (ne .Type "Set") (not .NoDelete)}}
			{{- if eq .Type "Bool"}}
			// For boolean fields, only delete if state was true (presence container was set)
			if !state.{{$list}}[i].{{toGoName .TfName}}.IsNull() && state.{{$list}}[i].{{toGoName .TfName}}.ValueBool() && data.{{$list}}[j].{{toGoName .TfName}}.IsNull() {
			{{- else}}
			if !state.{{$list}}[i].{{toGoName .TfName}}.IsNull() && data.{{$list}}[j].{{toGoName .TfName}}.IsNull() {
			{{- end}}
				deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/{{$xpath}}%v/{{getDeletePath .}}", predicates))
			}
			{{- else if or (eq .Type "List") (eq .Type "Set")}}
			{{- $cXpath := .XPath}}
			for ci := range state.{{$list}}[i].{{toGoName .TfName}} {
				{{- $clist := (toGoName .TfName)}}
					cstateKeys := [...]string{ {{range .Attributes}}{{if .Id}}"{{.XPath}}", {{end}}{{end}} }
					cstateKeyValues := [...]string{ {{range .Attributes}}{{if .Id}}{{if eq .Type "Int64"}}strconv.FormatInt(state.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.ValueInt64(), 10), {{else if eq .Type "Bool"}}strconv.FormatBool(state.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.ValueBool()), {{else}}state.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.Value{{.Type}}(), {{end}}{{end}}{{end}} }
					cpredicates := ""
					for i := range cstateKeys {
						cpredicates += fmt.Sprintf("[%s='%s']", cstateKeys[i], cstateKeyValues[i])
					}

					cemptyKeys := true
					{{- range .Attributes}}
					{{- if .Id}}
					if !reflect.ValueOf(state.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.Value{{.Type}}()).IsZero() {
						cemptyKeys = false
					}
					{{- end}}
					{{- end}}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.{{$list}}[j].{{toGoName .TfName}} {
						found = true
						{{- range .Attributes}}
						{{- if .Id}}
						if state.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.Value{{.Type}}() != data.{{$list}}[j].{{$clist}}[cj].{{toGoName .TfName}}.Value{{.Type}}() {
							found = false
						}
						{{- end}}
						{{- end}}
						if found {
							{{- range reverseAttributes .Attributes}}
							{{- if or (eq .Type "StringList") (eq .Type "Int64List") (eq .Type "StringSet") (eq .Type "Int64Set")}}
							if !state.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.IsNull() {
								if data.{{$list}}[j].{{$clist}}[cj].{{toGoName .TfName}}.IsNull() {
									var values []string
									state.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
									for _, v := range values {
										deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/{{$xpath}}%v/{{$cXpath}}%v/{{.XPath}}[.=%v]", predicates, cpredicates, v))
									}
								} else {
									var dataValues, stateValues []{{ if or (eq .Type "StringList") (eq .Type "StringSet") }}string{{else}}int{{end}}
									data.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.ElementsAs(ctx, &dataValues, false)
									state.{{$list}}[j].{{$clist}}[cj].{{toGoName .TfName}}.ElementsAs(ctx, &stateValues, false)
									for _, v := range stateValues {
										found := false
										for _, vv := range dataValues {
											if v == vv {
												found = true
												break
											}
										}
										if !found {
											deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/{{$xpath}}%v/{{$cXpath}}%v/{{.XPath}}=[.%v]", predicates, cpredicates, v))
										}
									}
								}
							}
							{{- else if and (not .Reference) (not .Id) (ne .Type "List") (ne .Type "Set") (not .NoDelete)}}
							{{- if eq .Type "Bool"}}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.IsNull() && state.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.ValueBool() && data.{{$list}}[j].{{$clist}}[cj].{{toGoName .TfName}}.IsNull() {
							{{- else}}
							if !state.{{$list}}[i].{{$clist}}[ci].{{toGoName .TfName}}.IsNull() && data.{{$list}}[j].{{$clist}}[cj].{{toGoName .TfName}}.IsNull() {
							{{- end}}
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/{{$xpath}}%v/{{$cXpath}}%v/{{getDeletePath .}}", predicates, cpredicates))
							}
							{{- end}}
							{{- end}}
							break
						}
					}
					if !found {
						deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/{{$xpath}}%v/{{.XPath}}%v", predicates, cpredicates))
					}
				}
				{{- end}}
				{{- end}}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/{{.XPath}}%v", predicates))
		}
	}
	{{- end}}
	{{- end}}

	b := netconf.NewBody(deleteXml)
	b = helpers.CleanupRedundantRemoveOperations(b)
	return b.Res()
}

// End of section. //template:end addDeletedItemsXML

// Section below is generated&owned by "gen/generator.go". //template:begin addDeletePathsXML

func (data *{{camelCase .Name}}) addDeletePathsXML(ctx context.Context, body string) string {
	b := netconf.NewBody(body)
	{{- range reverseAttributes .Attributes}}
	{{- if and (or (eq .Type "StringList") (eq .Type "StringSet")) (not .NoDelete)}}
	if !data.{{toGoName .TfName}}.IsNull() {
		var values []string
		data.{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
		for _, v := range values {
			b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/{{.XPath}}[.=%v]", v))
		}
	}
	{{- else if and (or (eq .Type "Int64List") (eq .Type "Int64Set")) (not .NoDelete)}}
	if !data.{{toGoName .TfName}}.IsNull() {
		var values []int64
		data.{{toGoName .TfName}}.ElementsAs(ctx, &values, false)
		for _, v := range values {
			b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/{{.XPath}}[.=%v]", v))
		}
	}
	{{- else if and (not .Reference) (not .Id) (ne .Type "List") (ne .Type "Set") (not .NoDelete)}}
	if !data.{{toGoName .TfName}}.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/{{getDeletePath .}}")
	}
	{{- else if and (or (eq .Type "List") (eq .Type "Set")) (not .NoDelete)}}
	for i := range data.{{toGoName .TfName}} {
		{{- $list := (toGoName .TfName)}}
		keys := [...]string{ {{range .Attributes}}{{if .Id}}"{{.XPath}}", {{end}}{{end}} }
		keyValues := [...]string{ {{range .Attributes}}{{if .Id}}{{if eq .Type "Int64"}}strconv.FormatInt(data.{{$list}}[i].{{toGoName .TfName}}.ValueInt64(), 10), {{else if eq .Type "Bool"}}strconv.FormatBool(data.{{$list}}[i].{{toGoName .TfName}}.ValueBool()), {{else}}data.{{$list}}[i].{{toGoName .TfName}}.Value{{.Type}}(), {{end}}{{end}}{{end}} }
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/{{getDeletePath .}}%v", predicates))
	}
	{{- end}}
	{{- end}}

	b = helpers.CleanupRedundantRemoveOperations(b)
	return b.Res()
}

// End of section. //template:end addDeletePathsXML

