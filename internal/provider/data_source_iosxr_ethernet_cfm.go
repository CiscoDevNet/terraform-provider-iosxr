// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports
import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin model

// Ensure the implementation satisfies the expected interfaces.
var (
	_ datasource.DataSource              = &EthernetCFMDataSource{}
	_ datasource.DataSourceWithConfigure = &EthernetCFMDataSource{}
)

func NewEthernetCFMDataSource() datasource.DataSource {
	return &EthernetCFMDataSource{}
}

type EthernetCFMDataSource struct {
	data *IosxrProviderData
}

func (d *EthernetCFMDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_ethernet_cfm"
}

func (d *EthernetCFMDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "This data source can read the Ethernet CFM configuration.",

		Attributes: map[string]schema.Attribute{
			"device": schema.StringAttribute{
				MarkdownDescription: "A device name from the provider configuration.",
				Optional:            true,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "The path of the retrieved object.",
				Computed:            true,
			},
			"traceroute_cache_hold_time": schema.Int64Attribute{
				MarkdownDescription: "Traceroute cache hold-time",
				Computed:            true,
			},
			"traceroute_cache_size": schema.Int64Attribute{
				MarkdownDescription: "Traceroute cache size (number of replies)",
				Computed:            true,
			},
			"domains": schema.ListNestedAttribute{
				MarkdownDescription: "Configuration for a particular Maintenance Domain",
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"domain_name": schema.StringAttribute{
							MarkdownDescription: "Domain name",
							Computed:            true,
						},
						"level": schema.Int64Attribute{
							MarkdownDescription: "Maintenance Domain Level",
							Computed:            true,
						},
						"id_dns": schema.StringAttribute{
							MarkdownDescription: "DNS Name",
							Computed:            true,
						},
						"id_mac_address": schema.StringAttribute{
							MarkdownDescription: "MAC Address",
							Computed:            true,
						},
						"id_mac_address_integer": schema.Int64Attribute{
							MarkdownDescription: "2 Octet integer",
							Computed:            true,
						},
						"id_null": schema.BoolAttribute{
							MarkdownDescription: "No MDID value",
							Computed:            true,
						},
						"id_string": schema.StringAttribute{
							MarkdownDescription: "String",
							Computed:            true,
						},
						"services": schema.ListNestedAttribute{
							MarkdownDescription: "Per service configuration",
							Computed:            true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"service_name": schema.StringAttribute{
										MarkdownDescription: "Service name",
										Computed:            true,
									},
									"bridge_group": schema.StringAttribute{
										MarkdownDescription: "Bridge Domain Group Name",
										Computed:            true,
									},
									"bridge_domain": schema.StringAttribute{
										MarkdownDescription: "Bridge Domain Name",
										Computed:            true,
									},
									"down_meps": schema.BoolAttribute{
										MarkdownDescription: "Down MEPs; no MIPs permitted",
										Computed:            true,
									},
									"flexible_xconnect_vlan_aware_evi": schema.Int64Attribute{
										MarkdownDescription: "EVPN ID",
										Computed:            true,
									},
									"flexible_xconnect_vlan_unaware_name": schema.StringAttribute{
										MarkdownDescription: "VLAN-unaware Flexible Cross Connect name",
										Computed:            true,
									},
									"xconnect_mp2mp_group": schema.StringAttribute{
										MarkdownDescription: "Cross Connect Group",
										Computed:            true,
									},
									"xconnect_mp2mp_name": schema.StringAttribute{
										MarkdownDescription: "Cross Connect Name",
										Computed:            true,
									},
									"xconnect_mp2mp_ce_id": schema.Int64Attribute{
										MarkdownDescription: "Local Customer Edge Identifier",
										Computed:            true,
									},
									"xconnect_mp2mp_remote_ce_id": schema.Int64Attribute{
										MarkdownDescription: "Remote Customer Edge Identifier",
										Computed:            true,
									},
									"xconnect_p2p_group_name": schema.StringAttribute{
										MarkdownDescription: "Cross Connect Group",
										Computed:            true,
									},
									"xconnect_p2p_xc_name": schema.StringAttribute{
										MarkdownDescription: "Cross Connect Name",
										Computed:            true,
									},
									"id_icc_based_icc": schema.StringAttribute{
										MarkdownDescription: "ITU Carrier Code (ICC)",
										Computed:            true,
									},
									"id_icc_based_umc": schema.StringAttribute{
										MarkdownDescription: "Unique MEG ID Code (UMC)",
										Computed:            true,
									},
									"id_vlan_id": schema.Int64Attribute{
										MarkdownDescription: "VLAN ID",
										Computed:            true,
									},
									"id_number": schema.Int64Attribute{
										MarkdownDescription: "Number",
										Computed:            true,
									},
									"id_string": schema.StringAttribute{
										MarkdownDescription: "String",
										Computed:            true,
									},
									"id_vpn_id_oui": schema.Int64Attribute{
										MarkdownDescription: "3 byte VPN OUI, HHH",
										Computed:            true,
									},
									"id_vpn_id_index": schema.Int64Attribute{
										MarkdownDescription: "4 byte VPN Index, HHHH",
										Computed:            true,
									},
									"tags": schema.StringAttribute{
										MarkdownDescription: "The number of tags to use when sending CFM packets from up MEPs in this service",
										Computed:            true,
									},
									"mip_auto_create_all": schema.BoolAttribute{
										MarkdownDescription: "Create MIPs on all interfaces",
										Computed:            true,
									},
									"mip_auto_create_lower_mep_only": schema.BoolAttribute{
										MarkdownDescription: "Create MIPs only on interfaces with a MEP at a lower level",
										Computed:            true,
									},
									"mip_auto_create_ccm_learning": schema.BoolAttribute{
										MarkdownDescription: "Enable CCM learning at MIPs created in this service",
										Computed:            true,
									},
									"efd": schema.BoolAttribute{
										MarkdownDescription: "Enable EFD to bring down ports when MEPs detect errors",
										Computed:            true,
									},
									"efd_protection_switching": schema.BoolAttribute{
										MarkdownDescription: "Enable protection switching notifications when triggering EFD",
										Computed:            true,
									},
									"continuity_check_interval": schema.StringAttribute{
										MarkdownDescription: "The number of tags to use when sending CFM packets from up MEPs in this service",
										Computed:            true,
									},
									"continuity_check_interval_loss_threshold": schema.Int64Attribute{
										MarkdownDescription: "Set the continuity-check loss threshold",
										Computed:            true,
									},
									"continuity_check_archive_hold_time": schema.Int64Attribute{
										MarkdownDescription: "Set the continuity-check archive hold time",
										Computed:            true,
									},
									"continuity_check_loss_auto_traceroute": schema.BoolAttribute{
										MarkdownDescription: "Automatically trigger a traceroute when a MEP times out",
										Computed:            true,
									},
									"maximum_meps": schema.Int64Attribute{
										MarkdownDescription: "Limit the number of MEPs in the Maintenance Association",
										Computed:            true,
									},
									"ais_transmission_interval": schema.StringAttribute{
										MarkdownDescription: "Specify the AIS transmission interval",
										Computed:            true,
									},
									"ais_transmission_cos": schema.Int64Attribute{
										MarkdownDescription: "Specify CoS bits for AIS messages",
										Computed:            true,
									},
									"log_continuity_check_mep_changes": schema.BoolAttribute{
										MarkdownDescription: "Enable logging on peer MEP state changes",
										Computed:            true,
									},
									"log_continuity_check_errors": schema.BoolAttribute{
										MarkdownDescription: "Enable logging when continuity-check errors are detected",
										Computed:            true,
									},
									"log_crosscheck_errors": schema.BoolAttribute{
										MarkdownDescription: "Enable logging when crosscheck errors are detected",
										Computed:            true,
									},
									"log_ais": schema.BoolAttribute{
										MarkdownDescription: "Enable logging when AIS or LCK messages are received",
										Computed:            true,
									},
									"log_csf": schema.BoolAttribute{
										MarkdownDescription: "Enable logging of CSF events",
										Computed:            true,
									},
									"log_efd": schema.BoolAttribute{
										MarkdownDescription: "Enable logging of EFD events",
										Computed:            true,
									},
									"mep_crosschecks": schema.ListNestedAttribute{
										MarkdownDescription: "Specify crosscheck config for a given MEP ID",
										Computed:            true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"mep_id": schema.Int64Attribute{
													MarkdownDescription: "Specify crosscheck config for a given MEP ID",
													Computed:            true,
												},
												"mac_address": schema.StringAttribute{
													MarkdownDescription: "Expected MAC Address for the specified MEP",
													Computed:            true,
												},
											},
										},
									},
									"mep_crosscheck_auto": schema.BoolAttribute{
										MarkdownDescription: "Treat all remote MEPs for which CCMs are received as cross-check MEPs",
										Computed:            true,
									},
									"report_defects_none": schema.BoolAttribute{
										MarkdownDescription: "No defects reported",
										Computed:            true,
									},
									"report_defects_all": schema.BoolAttribute{
										MarkdownDescription: "All defects reported, including received RDI",
										Computed:            true,
									},
									"report_defects_ieee_xcon": schema.BoolAttribute{
										MarkdownDescription: "Report only DefXconCCM",
										Computed:            true,
									},
									"report_defects_ieee_error_xcon": schema.BoolAttribute{
										MarkdownDescription: "Above defects reported, plus DefErrorCCM",
										Computed:            true,
									},
									"report_defects_ieee_remote_error_xcon": schema.BoolAttribute{
										MarkdownDescription: "Above defects reported, plus DefRemoteCCM",
										Computed:            true,
									},
									"report_defects_ieee_mac_remote_error_xcon": schema.BoolAttribute{
										MarkdownDescription: "Above defects reported, plus DefMACStatus (default)",
										Computed:            true,
									},
									"report_defects_wrong_maid": schema.BoolAttribute{
										MarkdownDescription: "CCMs received with an incorrect MAID",
										Computed:            true,
									},
									"report_defects_wrong_level": schema.BoolAttribute{
										MarkdownDescription: "CCMs received with an incorrect level",
										Computed:            true,
									},
									"report_defects_our_mac": schema.BoolAttribute{
										MarkdownDescription: "CCMs received with our MAC address",
										Computed:            true,
									},
									"report_defects_our_mepid": schema.BoolAttribute{
										MarkdownDescription: "CCMs received with our MEP-ID",
										Computed:            true,
									},
									"report_defects_wrong_interval": schema.BoolAttribute{
										MarkdownDescription: "CCMs received with an incorrect CCM interval",
										Computed:            true,
									},
									"report_defects_missing": schema.BoolAttribute{
										MarkdownDescription: "Some CCMs from a crosscheck peer MEP are missing",
										Computed:            true,
									},
									"report_defects_peer_port_down": schema.BoolAttribute{
										MarkdownDescription: "A peer port is down (equivalent to DefMACStatus)",
										Computed:            true,
									},
									"report_defects_rdi": schema.BoolAttribute{
										MarkdownDescription: "CCMs containing the RDI bit received",
										Computed:            true,
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func (d *EthernetCFMDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, _ *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.data = req.ProviderData.(*IosxrProviderData)
}

// End of section. //template:end model

// Section below is generated&owned by "gen/generator.go". //template:begin read

func (d *EthernetCFMDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var config EthernetCFMData

	// Read config
	diags := req.Config.Get(ctx, &config)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	device, ok := d.data.Devices[config.Device.ValueString()]
	if !ok {
		resp.Diagnostics.AddAttributeError(path.Root("device"), "Invalid device", fmt.Sprintf("Device '%s' does not exist in provider configuration.", config.Device.ValueString()))
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("%s: Beginning Read", config.getPath()))

	if device.Managed {
		if !d.data.ReuseConnection {
			defer device.Client.Disconnect()
		}
		getResp, err := device.Client.Get(ctx, []string{config.getPath()})
		if err != nil {
			resp.Diagnostics.AddError("Unable to apply gNMI Get operation", err.Error())
			return
		}

		// Defensive bounds checking for response structure
		if len(getResp.Notifications) == 0 {
			resp.Diagnostics.AddError("Invalid gNMI response",
				"Response contains no notifications")
			return
		}
		if len(getResp.Notifications[0].Update) == 0 {
			resp.Diagnostics.AddError("Invalid gNMI response",
				"Response notification contains no updates")
			return
		}

		respBody := getResp.Notifications[0].Update[0].Val.GetJsonIetfVal()
		config.fromBody(ctx, respBody)
	}

	config.Id = types.StringValue(config.getPath())

	tflog.Debug(ctx, fmt.Sprintf("%s: Read finished successfully", config.getPath()))

	diags = resp.State.Set(ctx, &config)
	resp.Diagnostics.Append(diags...)
}

// End of section. //template:end read
