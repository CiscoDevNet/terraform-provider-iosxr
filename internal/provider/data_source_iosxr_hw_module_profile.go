// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports
import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/tidwall/gjson"

	"github.com/CiscoDevNet/terraform-provider-iosxr/internal/provider/helpers"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin model

// Ensure the implementation satisfies the expected interfaces.
var (
	_ datasource.DataSource              = &HWModuleProfileDataSource{}
	_ datasource.DataSourceWithConfigure = &HWModuleProfileDataSource{}
)

func NewHWModuleProfileDataSource() datasource.DataSource {
	return &HWModuleProfileDataSource{}
}

type HWModuleProfileDataSource struct {
	data *IosxrProviderData
}

func (d *HWModuleProfileDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_hw_module_profile"
}

func (d *HWModuleProfileDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "This data source can read the HW Module Profile configuration.",

		Attributes: map[string]schema.Attribute{
			"device": schema.StringAttribute{
				MarkdownDescription: "A device name from the provider configuration.",
				Optional:            true,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "The path of the retrieved object.",
				Computed:            true,
			},
			"profile_load_balance_algorithm_layer2": schema.BoolAttribute{
				MarkdownDescription: "Layer 2 optimized.",
				Computed:            true,
			},
			"profile_load_balance_algorithm_ip_tunnel": schema.BoolAttribute{
				MarkdownDescription: "IP tunnel optimized.",
				Computed:            true,
			},
			"profile_load_balance_algorithm_mpls_safe_speculative_parsing": schema.BoolAttribute{
				MarkdownDescription: "MPLS safe Speculative parsing.",
				Computed:            true,
			},
			"profile_load_balance_algorithm_l3_only": schema.BoolAttribute{
				MarkdownDescription: "L3 Header only Hash.",
				Computed:            true,
			},
			"profile_load_balance_algorithm_gtp": schema.BoolAttribute{
				MarkdownDescription: "GTP optimized.",
				Computed:            true,
			},
			"profile_load_balance_algorithm_gtp_mpls": schema.BoolAttribute{
				MarkdownDescription: "GTP over MPLS optimized hash.",
				Computed:            true,
			},
			"profile_load_balance_algorithm_mpls_lsr_ler": schema.BoolAttribute{
				MarkdownDescription: "mpls-lsr-ler.",
				Computed:            true,
			},
			"profile_load_balance_algorithm_mpls_lsr_ler_optimized": schema.BoolAttribute{
				MarkdownDescription: "mpls-lsr-ler-optimized.",
				Computed:            true,
			},
			"profile_load_balance_algorithm_fat_based_hash": schema.BoolAttribute{
				MarkdownDescription: "FAT label based hash in l2vpn session on decap node. Reload is required for this option",
				Computed:            true,
			},
			"profile_load_balance_algorithm_pppoe": schema.BoolAttribute{
				MarkdownDescription: "PPPoE session based optimized hash. Reload is required for this option",
				Computed:            true,
			},
			"profile_load_balance_algorithm_pppoe_decap_fatbased_hashing": schema.BoolAttribute{
				MarkdownDescription: "PPPoE session based optimized hash with FAT label based hash. Reload is required for this option",
				Computed:            true,
			},
			"profile_load_balance_algorithm_inner_l2_field": schema.BoolAttribute{
				MarkdownDescription: "inner-l2-field.",
				Computed:            true,
			},
			"profile_load_balance_algorithm_hash_polynomial_index": schema.Int64Attribute{
				MarkdownDescription: "hash polynomial index",
				Computed:            true,
			},
			"profile_bundle_hash_index_locations": schema.ListNestedAttribute{
				MarkdownDescription: "Location of bundle-hash polynomial config",
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"location_name": schema.StringAttribute{
							MarkdownDescription: "Location of bundle-hash polynomial config",
							Computed:            true,
						},
						"location_name2": schema.StringAttribute{
							MarkdownDescription: "Location of bundle-hash polynomial config",
							Computed:            true,
						},
						"index": schema.StringAttribute{
							MarkdownDescription: "Configure hash index",
							Computed:            true,
						},
					},
				},
			},
			"profile_bundle_hash_ignore_ingress_port": schema.BoolAttribute{
				MarkdownDescription: "Disable ingress port during bundle hash computation",
				Computed:            true,
			},
			"profile_bundle_hash_per_packet_round_robin": schema.BoolAttribute{
				MarkdownDescription: "Enable per-packet round robin loadbalancing for all bundles in system",
				Computed:            true,
			},
			"profile_qos_max_classmap_size": schema.StringAttribute{
				MarkdownDescription: "max class map size",
				Computed:            true,
			},
			"profile_qos_max_classmap_size_locations": schema.ListNestedAttribute{
				MarkdownDescription: "Location of QoS config",
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"location_name": schema.StringAttribute{
							MarkdownDescription: "Location of QoS config",
							Computed:            true,
						},
						"max_classmap_size": schema.StringAttribute{
							MarkdownDescription: "max class map size",
							Computed:            true,
						},
					},
				},
			},
			"profile_qos_qosg_dscp_mark_enable_first": schema.Int64Attribute{
				MarkdownDescription: "Enable both 'set qos-group' and 'set dscp/precedence' actions in the same ingress QoS policy",
				Computed:            true,
			},
			"profile_qos_qosg_dscp_mark_enable_second": schema.Int64Attribute{
				MarkdownDescription: "Second DSCP/Precedence value",
				Computed:            true,
			},
			"profile_qos_free_buffer_int_threshold_set": schema.Int64Attribute{
				MarkdownDescription: "Configure free buffer interrupt threshold",
				Computed:            true,
			},
			"profile_qos_free_buffer_int_threshold_clear": schema.Int64Attribute{
				MarkdownDescription: "clear value in percent (must be more than set value)",
				Computed:            true,
			},
			"profile_qos_hqos_enable": schema.BoolAttribute{
				MarkdownDescription: "Enable Hierarchical QoS",
				Computed:            true,
			},
			"profile_qos_stats_collection": schema.BoolAttribute{
				MarkdownDescription: "Enable QoS stats push model",
				Computed:            true,
			},
			"profile_qos_ecn_marking_stats": schema.BoolAttribute{
				MarkdownDescription: "Enable ECN marking stats mode",
				Computed:            true,
			},
			"profile_qos_shared_policer_per_class_stats": schema.BoolAttribute{
				MarkdownDescription: "Enable shared policer (per class stats) mode",
				Computed:            true,
			},
			"profile_qos_wred_stats_enable": schema.BoolAttribute{
				MarkdownDescription: "Enable Wred egress stats",
				Computed:            true,
			},
			"profile_qos_lag_scheduler": schema.BoolAttribute{
				MarkdownDescription: "Enable QoS Lag Scheduler",
				Computed:            true,
			},
			"profile_qos_conform_aware_policer": schema.BoolAttribute{
				MarkdownDescription: "Configure Conform Aware Policer mode",
				Computed:            true,
			},
			"profile_qos_arp_isis_priority_enable": schema.BoolAttribute{
				MarkdownDescription: "Prioritize ISIS and ARP packets",
				Computed:            true,
			},
			"profile_qos_gre_exp_classification_enable": schema.BoolAttribute{
				MarkdownDescription: "Enable Ingress EXP classification for MPLSoGRE",
				Computed:            true,
			},
			"profile_qos_egress_compensation_setting_force": schema.BoolAttribute{
				MarkdownDescription: "Forcefully allows to configure non-unique egress compensation values ignoring ASIC limitation (not recommended).",
				Computed:            true,
			},
			"profile_qos_policer_scale": schema.StringAttribute{
				MarkdownDescription: "Max policer scale [48000, 64000]",
				Computed:            true,
			},
			"profile_qos_nif_hp_fifo_reserve_percent": schema.Int64Attribute{
				MarkdownDescription: "Reserve NIF FIFOs (percentage) for High Priority traffic.",
				Computed:            true,
			},
			"profile_qos_nif_hp_fifo_reserve_locations": schema.ListNestedAttribute{
				MarkdownDescription: "Location of QoS config",
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"location_name": schema.StringAttribute{
							MarkdownDescription: "Location of QoS config",
							Computed:            true,
						},
						"percent": schema.Int64Attribute{
							MarkdownDescription: "Reserve NIF FIFOs (percentage) for High Priority traffic.",
							Computed:            true,
						},
					},
				},
			},
			"npu_native_mode_enable": schema.BoolAttribute{
				MarkdownDescription: "Enable NPUs to operate in native mode",
				Computed:            true,
			},
			"netflow_ipfix315_enable": schema.BoolAttribute{
				MarkdownDescription: "IPFIX 315 enable ",
				Computed:            true,
			},
			"netflow_ipfix315_enable_locations": schema.ListNestedAttribute{
				MarkdownDescription: "Location of NETFLOW config",
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"location_name": schema.StringAttribute{
							MarkdownDescription: "Location of NETFLOW config",
							Computed:            true,
						},
						"location_name2": schema.StringAttribute{
							MarkdownDescription: "Location of NETFLOW config",
							Computed:            true,
						},
					},
				},
			},
			"netflow_sflow_enable": schema.BoolAttribute{
				MarkdownDescription: "SFLOW enable ",
				Computed:            true,
			},
			"netflow_sflow_enable_locations": schema.ListNestedAttribute{
				MarkdownDescription: "Location of NETFLOW config",
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"location_name": schema.StringAttribute{
							MarkdownDescription: "Location of NETFLOW config",
							Computed:            true,
						},
						"location_name2": schema.StringAttribute{
							MarkdownDescription: "Location of NETFLOW config",
							Computed:            true,
						},
					},
				},
			},
			"stats_acl_permit": schema.BoolAttribute{
				MarkdownDescription: "Enable ACL permit stats.",
				Computed:            true,
			},
			"stats_qos_enhanced": schema.BoolAttribute{
				MarkdownDescription: "Enable enhanced QoS stats.",
				Computed:            true,
			},
			"stats_ingress_sr": schema.BoolAttribute{
				MarkdownDescription: "Enable ingress SR stats profile counter.",
				Computed:            true,
			},
			"stats_enhanced_sr_policy": schema.BoolAttribute{
				MarkdownDescription: "Enable Enhanced_SR_Policy_Scale stats profile counter.",
				Computed:            true,
			},
			"stats_ingress_sr_mspw": schema.BoolAttribute{
				MarkdownDescription: "Enable ingress SR & MSPW stats profile counter.",
				Computed:            true,
			},
			"stats_tx_scale_enhanced": schema.BoolAttribute{
				MarkdownDescription: "Enable enhanced TX stats scale (Non L2 stats).",
				Computed:            true,
			},
			"stats_tx_scale_enhanced_acl_permit": schema.BoolAttribute{
				MarkdownDescription: "Enable ACL permit stats.",
				Computed:            true,
			},
			"stats_tx_scale_enhanced_qos_enhanced": schema.BoolAttribute{
				MarkdownDescription: "Enable enhanced QoS stats.",
				Computed:            true,
			},
			"stats_tx_scale_enhanced_ingress_sr": schema.BoolAttribute{
				MarkdownDescription: "Enable ingress SR stats profile counter.",
				Computed:            true,
			},
			"srv6_mode_base": schema.BoolAttribute{
				MarkdownDescription: "Base SRv6 (Format-1) support only",
				Computed:            true,
			},
			"srv6_mode_base_and_micro_segment_f3216": schema.BoolAttribute{
				MarkdownDescription: "Base (F1) and F3216 co-existence support",
				Computed:            true,
			},
			"srv6_mode_micro_segment_format_f3216": schema.BoolAttribute{
				MarkdownDescription: "32-bit block and 16-bit IDs",
				Computed:            true,
			},
			"srv6_mode_micro_segment_format_f3216_path_mtu": schema.BoolAttribute{
				MarkdownDescription: "Path MTU Discovery for the SRv6 profile",
				Computed:            true,
			},
			"srv6_encapsulation_l2_traffic_class_propagate": schema.BoolAttribute{
				MarkdownDescription: "Propagate traffic-class from incoming packet/frame or use qos-group from input policy-map",
				Computed:            true,
			},
			"srv6_encapsulation_l2_traffic_class_value": schema.Int64Attribute{
				MarkdownDescription: "Traffic-class value (specified as 2 hexadecimal nibbles)",
				Computed:            true,
			},
			"srv6_encapsulation_l3_traffic_class_propagate": schema.BoolAttribute{
				MarkdownDescription: "Propagate traffic-class from incoming packet",
				Computed:            true,
			},
			"srv6_encapsulation_l3_traffic_class_policy_map": schema.BoolAttribute{
				MarkdownDescription: "Set traffic-class DSCP to qos-group selected by input policy-map",
				Computed:            true,
			},
			"srv6_encapsulation_l3_traffic_class_value": schema.Int64Attribute{
				MarkdownDescription: "Traffic-class value (specified as 2 hexadecimal nibbles)",
				Computed:            true,
			},
			"srv6_encapsulation_l3_traffic_class_with_hoplimit_propagate": schema.BoolAttribute{
				MarkdownDescription: "Propagate traffic-class and hop-limit from incoming packet",
				Computed:            true,
			},
			"offload_one": schema.BoolAttribute{
				MarkdownDescription: "BFDv6 and Bsync",
				Computed:            true,
			},
			"offload_two": schema.BoolAttribute{
				MarkdownDescription: "BFDv6 and Route download",
				Computed:            true,
			},
			"offload_three": schema.BoolAttribute{
				MarkdownDescription: "Route download and Bsync",
				Computed:            true,
			},
			"offload_four": schema.BoolAttribute{
				MarkdownDescription: "BFDv6 and PM-HW-Offload",
				Computed:            true,
			},
			"sr_policy_v6_null_label_autopush": schema.BoolAttribute{
				MarkdownDescription: "Configure IPV6 NULL label autopush for SR policy",
				Computed:            true,
			},
			"oam_sat_enable": schema.BoolAttribute{
				MarkdownDescription: "enable SAT feature",
				Computed:            true,
			},
			"oam_four8byte_cfm_maid_enable": schema.BoolAttribute{
				MarkdownDescription: "Enable 48byte cfm maid feature",
				Computed:            true,
			},
			"fib_bgp_pic_multipath_core_enable": schema.BoolAttribute{
				MarkdownDescription: "Enable pic core in forwarding chain",
				Computed:            true,
			},
			"bgp_mp_pic_auto_protect_enable": schema.BoolAttribute{
				MarkdownDescription: "Enable pic core in forwarding chain",
				Computed:            true,
			},
		},
	}
}

func (d *HWModuleProfileDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, _ *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.data = req.ProviderData.(*IosxrProviderData)
}

// End of section. //template:end model

// Section below is generated&owned by "gen/generator.go". //template:begin read

func (d *HWModuleProfileDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var config HWModuleProfileData

	// Read config
	diags := req.Config.Get(ctx, &config)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	device, ok := d.data.Devices[config.Device.ValueString()]
	if !ok {
		resp.Diagnostics.AddAttributeError(path.Root("device"), "Invalid device", fmt.Sprintf("Device '%s' does not exist in provider configuration.", config.Device.ValueString()))
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("%s: Beginning Read", config.getPath()))

	if device.Managed {
		if device.Protocol == "gnmi" {
			// Ensure connection is healthy (reconnect if stale)
			if err := helpers.EnsureGnmiConnection(ctx, device.GnmiClient, d.data.ReuseConnection); err != nil {
				resp.Diagnostics.AddError("gNMI Connection Error", fmt.Sprintf("Failed to ensure connection: %s", err))
				return
			}

			defer helpers.CloseGnmiConnection(ctx, device.GnmiClient, d.data.ReuseConnection)
			getResp, err := device.GnmiClient.Get(ctx, []string{config.getPath()})
			if err != nil {
				resp.Diagnostics.AddError("Unable to apply gNMI Get operation", err.Error())
				return
			}

			// Defensive bounds checking for response structure
			if len(getResp.Notifications) == 0 {
				resp.Diagnostics.AddError("Invalid gNMI response",
					"Response contains no notifications")
				return
			}
			if len(getResp.Notifications[0].Update) == 0 {
				resp.Diagnostics.AddError("Invalid gNMI response",
					"Response notification contains no updates")
				return
			}

			update := getResp.Notifications[0].Update[0]
			if update.Val == nil {
				tflog.Debug(ctx, fmt.Sprintf("%s: gNMI Get returned nil Val, path exists but no data returned by device", config.getPath()))
				// When Val is nil, the device confirmed the path exists but didn't return data
				// This is a known behavior for netconf-yang-agent after configuration
				// The presence of the path indicates the service is configured and enabled
				// Return the configured values (these are the values that were set during Create)
				// For other resources, if Val is nil, use fromBody with empty JSON
				config.fromBody(ctx, gjson.Parse("{}"))
			} else {
				respBody := update.Val.GetJsonIetfVal()
				tflog.Debug(ctx, fmt.Sprintf("%s: gNMI Get respBody: %s", config.getPath(), string(respBody)))
				config.fromBody(ctx, gjson.ParseBytes(respBody))
			}
		} else {
			// Serialize NETCONF operations when reuse disabled (concurrent reads allowed when reuse enabled)
			locked := helpers.AcquireNetconfLock(&device.NetconfOpMutex, device.ReuseConnection, false)
			if locked {
				defer device.NetconfOpMutex.Unlock()
			}
			defer helpers.CloseNetconfConnection(ctx, device.NetconfClient, device.ReuseConnection)

			// Ensure connection is healthy (reconnect if stale)
			if err := helpers.EnsureNetconfConnection(ctx, device.NetconfClient, device.ReuseConnection); err != nil {
				resp.Diagnostics.AddError("NETCONF Connection Error", fmt.Sprintf("Failed to ensure connection: %s", err))
				return
			}

			filter := helpers.GetSubtreeFilter(config.getXPath())
			res, err := device.NetconfClient.GetConfig(ctx, "running", filter)
			if err != nil {
				resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Failed to retrieve object (%s), got error: %s", config.getPath(), err))
				return
			}

			config.fromBodyXML(ctx, res.Res)
		}
	}

	config.Id = types.StringValue(config.getPath())

	tflog.Debug(ctx, fmt.Sprintf("%s: Read finished successfully", config.getPath()))

	diags = resp.State.Set(ctx, &config)
	resp.Diagnostics.Append(diags...)
}

// End of section. //template:end read
