// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports
import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/tidwall/gjson"

	"github.com/CiscoDevNet/terraform-provider-iosxr/internal/provider/helpers"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin model

// Ensure the implementation satisfies the expected interfaces.
var (
	_ datasource.DataSource              = &RouterBGPVRFNeighborAddressFamilyDataSource{}
	_ datasource.DataSourceWithConfigure = &RouterBGPVRFNeighborAddressFamilyDataSource{}
)

func NewRouterBGPVRFNeighborAddressFamilyDataSource() datasource.DataSource {
	return &RouterBGPVRFNeighborAddressFamilyDataSource{}
}

type RouterBGPVRFNeighborAddressFamilyDataSource struct {
	data *IosxrProviderData
}

func (d *RouterBGPVRFNeighborAddressFamilyDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_router_bgp_vrf_neighbor_address_family"
}

func (d *RouterBGPVRFNeighborAddressFamilyDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "This data source can read the Router BGP VRF Neighbor Address Family configuration.",

		Attributes: map[string]schema.Attribute{
			"device": schema.StringAttribute{
				MarkdownDescription: "A device name from the provider configuration.",
				Optional:            true,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "The path of the retrieved object.",
				Computed:            true,
			},
			"as_number": schema.StringAttribute{
				MarkdownDescription: "bgp as-number",
				Required:            true,
			},
			"vrf_name": schema.StringAttribute{
				MarkdownDescription: "VRF name - maximum length 32 characters",
				Required:            true,
			},
			"address": schema.StringAttribute{
				MarkdownDescription: "IPaddress",
				Required:            true,
			},
			"af_name": schema.StringAttribute{
				MarkdownDescription: "Enter Address Family command mode",
				Required:            true,
			},
			"encapsulation_type": schema.StringAttribute{
				MarkdownDescription: "Specify encapsulation type",
				Computed:            true,
			},
			"weight": schema.Int64Attribute{
				MarkdownDescription: "Set default weight for routes from this neighbor",
				Computed:            true,
			},
			"multipath": schema.BoolAttribute{
				MarkdownDescription: "Paths from this neighbor is eligible for multipath",
				Computed:            true,
			},
			"use_af_group": schema.StringAttribute{
				MarkdownDescription: "Inherit configuration for this address-family from an af-group",
				Computed:            true,
			},
			"capability_orf_prefix": schema.StringAttribute{
				MarkdownDescription: "Capability to RECEIVE the ORF from this neighbor",
				Computed:            true,
			},
			"additional_paths_send": schema.BoolAttribute{
				MarkdownDescription: "Additional paths Send capability",
				Computed:            true,
			},
			"additional_paths_send_disable": schema.BoolAttribute{
				MarkdownDescription: "Prevent additional-paths receive from being inherited from the parent",
				Computed:            true,
			},
			"additional_paths_receive": schema.BoolAttribute{
				MarkdownDescription: "Additional paths Send capability",
				Computed:            true,
			},
			"additional_paths_receive_disable": schema.BoolAttribute{
				MarkdownDescription: "Prevent additional-paths receive from being inherited from the parent",
				Computed:            true,
			},
			"default_originate": schema.BoolAttribute{
				MarkdownDescription: "Originate default route to this neighbor",
				Computed:            true,
			},
			"default_originate_route_policy": schema.StringAttribute{
				MarkdownDescription: "Route policy to specify criteria to originate default",
				Computed:            true,
			},
			"default_originate_inheritance_disable": schema.BoolAttribute{
				MarkdownDescription: "Prevent default-originate being inherited from a parent group",
				Computed:            true,
			},
			"maximum_prefix_limit": schema.Int64Attribute{
				MarkdownDescription: "maximum no. of prefix limit",
				Computed:            true,
			},
			"maximum_prefix_threshold": schema.Int64Attribute{
				MarkdownDescription: "Threshold value (%) at which to generate a warning msg",
				Computed:            true,
			},
			"maximum_prefix_restart": schema.Int64Attribute{
				MarkdownDescription: "Restart time interval",
				Computed:            true,
			},
			"maximum_prefix_discard_extra_paths": schema.BoolAttribute{
				MarkdownDescription: "Discard extra paths when limit is exceeded",
				Computed:            true,
			},
			"maximum_prefix_warning_only": schema.BoolAttribute{
				MarkdownDescription: "Only give warning message when limit is exceeded",
				Computed:            true,
			},
			"next_hop_self": schema.BoolAttribute{
				MarkdownDescription: "Disable the next hop calculation for this neighbor",
				Computed:            true,
			},
			"next_hop_self_inheritance_disable": schema.BoolAttribute{
				MarkdownDescription: "Prevent next-hop-self from being inherited from the parent",
				Computed:            true,
			},
			"next_hop_unchanged": schema.BoolAttribute{
				MarkdownDescription: "Do not overwrite next hop before advertising to eBGP peers",
				Computed:            true,
			},
			"next_hop_unchanged_multipath": schema.BoolAttribute{
				MarkdownDescription: "Do not overwrite nexthop before advertising multipaths",
				Computed:            true,
			},
			"next_hop_unchanged_inheritance_disable": schema.BoolAttribute{
				MarkdownDescription: "Prevent next-hop-unchanged from being inherited from the parent",
				Computed:            true,
			},
			"route_policy_in": schema.StringAttribute{
				MarkdownDescription: "Apply route policy to inbound routes",
				Computed:            true,
			},
			"route_policy_out": schema.StringAttribute{
				MarkdownDescription: "Apply route policy to outbound routes",
				Computed:            true,
			},
			"orf_route_policy": schema.StringAttribute{
				MarkdownDescription: "Route policy to specify ORF and inbound filter",
				Computed:            true,
			},
			"cluster_id_allow_equal": schema.BoolAttribute{
				MarkdownDescription: "Accept routes with first cluster-id in list is same as the router's cluster id",
				Computed:            true,
			},
			"cluster_id_allow_equal_disable": schema.BoolAttribute{
				MarkdownDescription: "Prevent the configuration from being inherited.",
				Computed:            true,
			},
			"replace_private_as": schema.BoolAttribute{
				MarkdownDescription: "Replace private AS number from outbound updates",
				Computed:            true,
			},
			"replace_private_as_internal": schema.BoolAttribute{
				MarkdownDescription: "remove only if all ASes in the path are private",
				Computed:            true,
			},
			"remove_private_as_inbound": schema.BoolAttribute{
				MarkdownDescription: "Remove private AS number from inbound updates",
				Computed:            true,
			},
			"remove_private_as_inbound_inheritance_disable": schema.BoolAttribute{
				MarkdownDescription: "Prevent remove-private-AS from being inherited from the parent",
				Computed:            true,
			},
			"remove_private_as_inbound_entire_aspath": schema.BoolAttribute{
				MarkdownDescription: "remove only if all ASes in the path are private",
				Computed:            true,
			},
			"remove_private_as": schema.BoolAttribute{
				MarkdownDescription: "Remove private AS number from outbound updates",
				Computed:            true,
			},
			"remove_private_as_entire_aspath": schema.BoolAttribute{
				MarkdownDescription: "remove only if all ASes in the path are private",
				Computed:            true,
			},
			"remove_private_as_inheritance_disable": schema.BoolAttribute{
				MarkdownDescription: "Prevent remove-private-AS from being inherited from the parent",
				Computed:            true,
			},
			"remove_private_as_internal": schema.BoolAttribute{
				MarkdownDescription: "remove only if all ASes in the path are private",
				Computed:            true,
			},
			"route_reflector_client": schema.BoolAttribute{
				MarkdownDescription: "Configure a neighbor as Route Reflector client",
				Computed:            true,
			},
			"route_reflector_client_inheritance_disable": schema.BoolAttribute{
				MarkdownDescription: "Prevent route-reflector-client from being inherited from the parent",
				Computed:            true,
			},
			"send_community_ebgp": schema.BoolAttribute{
				MarkdownDescription: "Send community attribute to this external neighbor",
				Computed:            true,
			},
			"send_community_ebgp_inheritance_disable": schema.BoolAttribute{
				MarkdownDescription: "Prevent send-community-ebgp from being inherited from the parent",
				Computed:            true,
			},
			"send_community_gshut_ebgp": schema.BoolAttribute{
				MarkdownDescription: "Allow the g-shut community to be sent to this external neighbor",
				Computed:            true,
			},
			"send_community_gshut_ebgp_inheritance_disable": schema.BoolAttribute{
				MarkdownDescription: "Prevent send-community-gshut-ebgp from being inherited from the parent",
				Computed:            true,
			},
			"send_extended_community_ebgp": schema.BoolAttribute{
				MarkdownDescription: "Send extended community attribute to this external neighbor",
				Computed:            true,
			},
			"send_extended_community_ebgp_inheritance_disable": schema.BoolAttribute{
				MarkdownDescription: "Prevent send-extended-community-ebgp from being inherited from parent",
				Computed:            true,
			},
			"soft_reconfiguration_inbound": schema.BoolAttribute{
				MarkdownDescription: "Allow inbound soft reconfiguration for this neighbor",
				Computed:            true,
			},
			"soft_reconfiguration_inbound_always": schema.BoolAttribute{
				MarkdownDescription: "Always use soft reconfig, even if route refresh is supported",
				Computed:            true,
			},
			"update_out_originator_loopcheck": schema.BoolAttribute{
				MarkdownDescription: "Loop check for same originator which sent the route",
				Computed:            true,
			},
			"update_out_originator_loopcheck_disable": schema.BoolAttribute{
				MarkdownDescription: "Disable originator loop check",
				Computed:            true,
			},
			"advertise_vpnv4_unicast": schema.BoolAttribute{
				MarkdownDescription: "Enable advertise vpnv4 unicast",
				Computed:            true,
			},
			"advertise_vpnv4_unicast_re_originated": schema.BoolAttribute{
				MarkdownDescription: "Advertise re-orignated and local routes only",
				Computed:            true,
			},
			"advertise_vpnv4_unicast_re_originated_stitching_rt": schema.BoolAttribute{
				MarkdownDescription: "Advertise re-originated and local routes with stitching Route-Targets",
				Computed:            true,
			},
			"advertise_vpnv6_unicast": schema.BoolAttribute{
				MarkdownDescription: "Enable advertise vpnv6 unicast",
				Computed:            true,
			},
			"advertise_vpnv6_unicast_re_originated": schema.BoolAttribute{
				MarkdownDescription: "Advertise Re-orignated routes only",
				Computed:            true,
			},
			"advertise_vpnv6_unicast_re_originated_stitching_rt": schema.BoolAttribute{
				MarkdownDescription: "Advertise re-originated routes with stitching Route-Targets",
				Computed:            true,
			},
			"advertise_l2vpn_evpn_re_originated": schema.BoolAttribute{
				MarkdownDescription: "Advertise Re-orignated routes only",
				Computed:            true,
			},
			"advertise_l2vpn_evpn_re_originated_stitching_rt": schema.BoolAttribute{
				MarkdownDescription: "Advertise re-originated routes with stitching Route-Targets",
				Computed:            true,
			},
			"segment_routing_srv6_prefix_sid_type4": schema.BoolAttribute{
				MarkdownDescription: "Enable prefix sid version 4 encoding",
				Computed:            true,
			},
			"import_stitching_rt": schema.BoolAttribute{
				MarkdownDescription: "Import routes using stitching RTs",
				Computed:            true,
			},
			"import_stitching_rt_re_originate": schema.BoolAttribute{
				MarkdownDescription: "Re-originate imported routes",
				Computed:            true,
			},
			"import_stitching_rt_re_originate_stitching_rt": schema.BoolAttribute{
				MarkdownDescription: "Reoriginate imported routes by attaching stitching RTs",
				Computed:            true,
			},
			"import_re_originate": schema.BoolAttribute{
				MarkdownDescription: "Reoriginate imported routes by attaching stitching RTs",
				Computed:            true,
			},
			"allowas_in": schema.Int64Attribute{
				MarkdownDescription: "Number of occurrences of AS number",
				Computed:            true,
			},
			"allowconfedas_in": schema.Int64Attribute{
				MarkdownDescription: "Number of occurrences of Confederation AS number",
				Computed:            true,
			},
			"site_of_origin_two_byte_as_number": schema.StringAttribute{
				MarkdownDescription: "2-byte AS number",
				Computed:            true,
			},
			"site_of_origin_two_byte_as_index": schema.Int64Attribute{
				MarkdownDescription: "ASN2:index (hex or decimal format)",
				Computed:            true,
			},
			"site_of_origin_four_byte_as_number": schema.StringAttribute{
				MarkdownDescription: "4-byte AS number in asplain format",
				Computed:            true,
			},
			"site_of_origin_four_byte_as_index": schema.Int64Attribute{
				MarkdownDescription: "ASN4:index (hex or decimal format)",
				Computed:            true,
			},
			"site_of_origin_ipv4_address": schema.StringAttribute{
				MarkdownDescription: "IPv4 address",
				Computed:            true,
			},
			"site_of_origin_ipv4_address_index": schema.Int64Attribute{
				MarkdownDescription: "IPv4Address:index (hex or decimal format)",
				Computed:            true,
			},
			"as_override": schema.BoolAttribute{
				MarkdownDescription: "Override matching AS-number while sending update",
				Computed:            true,
			},
			"as_override_inheritance_disable": schema.BoolAttribute{
				MarkdownDescription: "Prevent as-override from being inherited from the parent",
				Computed:            true,
			},
			"aigp": schema.BoolAttribute{
				MarkdownDescription: "Enable AIGP",
				Computed:            true,
			},
			"aigp_disable": schema.BoolAttribute{
				MarkdownDescription: "Disable AIGP",
				Computed:            true,
			},
			"aigp_send_med": schema.BoolAttribute{
				MarkdownDescription: "Send AIGP value in MED",
				Computed:            true,
			},
			"aigp_send_med_disable": schema.BoolAttribute{
				MarkdownDescription: "Disable aigp send med",
				Computed:            true,
			},
			"aigp_send_cost_community_disable": schema.BoolAttribute{
				MarkdownDescription: "Disable aigp send cost-community",
				Computed:            true,
			},
			"aigp_send_cost_community_id": schema.Int64Attribute{
				MarkdownDescription: "Cost community ID",
				Computed:            true,
			},
			"aigp_send_cost_community_id_poi_igp_cost": schema.BoolAttribute{
				MarkdownDescription: "Cost community is used after IGP distance to next hop",
				Computed:            true,
			},
			"aigp_send_cost_community_id_poi_igp_cost_transitive": schema.BoolAttribute{
				MarkdownDescription: "Enable transitive cost community",
				Computed:            true,
			},
			"aigp_send_cost_community_id_poi_pre_bestpath": schema.BoolAttribute{
				MarkdownDescription: "Cost community is first step in best path calculation",
				Computed:            true,
			},
			"aigp_send_cost_community_id_poi_pre_bestpath_transitive": schema.BoolAttribute{
				MarkdownDescription: "Enable transitive cost community",
				Computed:            true,
			},
			"send_multicast_attributes": schema.BoolAttribute{
				MarkdownDescription: "Send multicast attributes to this neighbor",
				Computed:            true,
			},
			"send_multicast_attributes_disable": schema.BoolAttribute{
				MarkdownDescription: "Disable send multicast attribute",
				Computed:            true,
			},
			"accept_own": schema.BoolAttribute{
				MarkdownDescription: "Handle self-originated routes with Accept-Own community",
				Computed:            true,
			},
			"accept_own_inheritance_disable": schema.BoolAttribute{
				MarkdownDescription: "Prevent item being inherited from a parent group",
				Computed:            true,
			},
			"slow_peer_dynamic": schema.BoolAttribute{
				MarkdownDescription: "Configure this neighbor as dynamic slow-peer",
				Computed:            true,
			},
			"slow_peer_dynamic_threshold": schema.Int64Attribute{
				MarkdownDescription: "Threshold (in seconds) to detect this neighbor as slow-peer",
				Computed:            true,
			},
			"slow_peer_dynamic_disable": schema.BoolAttribute{
				MarkdownDescription: "Disable dynamic slow-peer",
				Computed:            true,
			},
			"slow_peer_static": schema.BoolAttribute{
				MarkdownDescription: "Configure this neighbor as static slow-peer",
				Computed:            true,
			},
			"origin_as_validation_disable": schema.BoolAttribute{
				MarkdownDescription: "Disable RPKI origin-AS validation",
				Computed:            true,
			},
			"bestpath_origin_as_allow_invalid": schema.BoolAttribute{
				MarkdownDescription: "BGP bestpath selection will allow 'invalid' origin-AS",
				Computed:            true,
			},
		},
	}
}

func (d *RouterBGPVRFNeighborAddressFamilyDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, _ *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.data = req.ProviderData.(*IosxrProviderData)
}

// End of section. //template:end model

// Section below is generated&owned by "gen/generator.go". //template:begin read

func (d *RouterBGPVRFNeighborAddressFamilyDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var config RouterBGPVRFNeighborAddressFamilyData

	// Read config
	diags := req.Config.Get(ctx, &config)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	device, ok := d.data.Devices[config.Device.ValueString()]
	if !ok {
		resp.Diagnostics.AddAttributeError(path.Root("device"), "Invalid device", fmt.Sprintf("Device '%s' does not exist in provider configuration.", config.Device.ValueString()))
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("%s: Beginning Read", config.getPath()))

	if device.Managed {
		if device.Protocol == "gnmi" {
			if !d.data.ReuseConnection {
				defer device.GnmiClient.Disconnect()
			}
			getResp, err := device.GnmiClient.Get(ctx, []string{config.getPath()})
			if err != nil {
				resp.Diagnostics.AddError("Unable to apply gNMI Get operation", err.Error())
				return
			}

			// Defensive bounds checking for response structure
			if len(getResp.Notifications) == 0 {
				resp.Diagnostics.AddError("Invalid gNMI response",
					"Response contains no notifications")
				return
			}
			if len(getResp.Notifications[0].Update) == 0 {
				resp.Diagnostics.AddError("Invalid gNMI response",
					"Response notification contains no updates")
				return
			}

			respBody := getResp.Notifications[0].Update[0].Val.GetJsonIetfVal()
			config.fromBody(ctx, gjson.ParseBytes(respBody))
		} else {
			// Serialize NETCONF operations when reuse disabled (concurrent reads allowed when reuse enabled)
			locked := helpers.AcquireNetconfLock(&device.NetconfOpMutex, device.ReuseConnection, false)
			if locked {
				defer device.NetconfOpMutex.Unlock()
			}
			defer helpers.CloseNetconfConnection(ctx, device.NetconfClient, device.ReuseConnection)

			filter := helpers.GetSubtreeFilter(config.getXPath())
			res, err := device.NetconfClient.GetConfig(ctx, "running", filter)
			if err != nil {
				resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Failed to retrieve object (%s), got error: %s", config.getPath(), err))
				return
			}

			config.fromBodyXML(ctx, res.Res)
		}
	}

	tflog.Debug(ctx, fmt.Sprintf("%s: Read finished successfully", config.getPath()))

	diags = resp.State.Set(ctx, &config)
	resp.Diagnostics.Append(diags...)
}

// End of section. //template:end read
