// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports
import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin model

// Ensure the implementation satisfies the expected interfaces.
var (
	_ datasource.DataSource              = &TelemetryModelDrivenDataSource{}
	_ datasource.DataSourceWithConfigure = &TelemetryModelDrivenDataSource{}
)

func NewTelemetryModelDrivenDataSource() datasource.DataSource {
	return &TelemetryModelDrivenDataSource{}
}

type TelemetryModelDrivenDataSource struct {
	data *IosxrProviderData
}

func (d *TelemetryModelDrivenDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_telemetry_model_driven"
}

func (d *TelemetryModelDrivenDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "This data source can read the Telemetry Model Driven configuration.",

		Attributes: map[string]schema.Attribute{
			"device": schema.StringAttribute{
				MarkdownDescription: "A device name from the provider configuration.",
				Optional:            true,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "The path of the retrieved object.",
				Computed:            true,
			},
			"max_containers_per_path": schema.Int64Attribute{
				MarkdownDescription: "Maximum containers allowed per sensor path (default: 16)",
				Computed:            true,
			},
			"max_sensor_paths": schema.Int64Attribute{
				MarkdownDescription: "Maximum allowed sensor paths (default: 1000)",
				Computed:            true,
			},
			"tcp_send_timeout": schema.Int64Attribute{
				MarkdownDescription: "TCP send timeout value in seconds (default: 30)",
				Computed:            true,
			},
			"strict_timer": schema.BoolAttribute{
				MarkdownDescription: "use strict timer for all subscriptions, default is relative timer",
				Computed:            true,
			},
			"gnmi_target_defined_cadence_factor": schema.Int64Attribute{
				MarkdownDescription: "Multiplier factor for cadence of target defined subscriptions",
				Computed:            true,
			},
			"gnmi_target_defined_minimum_cadence": schema.Int64Attribute{
				MarkdownDescription: "Minimum cadence for target defined subscriptions in secs",
				Computed:            true,
			},
			"include_select_leaves_on_events": schema.BoolAttribute{
				MarkdownDescription: "Include only configured leafs on on-change event for the sensor-path",
				Computed:            true,
			},
			"include_empty_values": schema.BoolAttribute{
				MarkdownDescription: "Include fields with empty values in output",
				Computed:            true,
			},
			"gnmi_heartbeat_always": schema.BoolAttribute{
				MarkdownDescription: "Send heartbeat even if events have occurred within interval",
				Computed:            true,
			},
			"gnmi_bundling": schema.BoolAttribute{
				MarkdownDescription: "gNMI bundling of telemetry updates",
				Computed:            true,
			},
			"gnmi_bundling_size": schema.Int64Attribute{
				MarkdownDescription: "gNMI bundling size (default: 32768)",
				Computed:            true,
			},
			"destination_groups": schema.ListNestedAttribute{
				MarkdownDescription: "Destination Group Id",
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							MarkdownDescription: "Destination Group Id string",
							Computed:            true,
						},
						"vrf": schema.StringAttribute{
							MarkdownDescription: "vrf for the dest grp",
							Computed:            true,
						},
						"address_family": schema.ListNestedAttribute{
							MarkdownDescription: "Destination address of the recepient of the telemetry information",
							Computed:            true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"af_name": schema.StringAttribute{
										MarkdownDescription: "af-name",
										Computed:            true,
									},
									"address": schema.StringAttribute{
										MarkdownDescription: "destination-address",
										Computed:            true,
									},
									"port": schema.Int64Attribute{
										MarkdownDescription: "Destination Port configuration",
										Computed:            true,
									},
									"encoding": schema.StringAttribute{
										MarkdownDescription: "Transport protocol encoding",
										Computed:            true,
									},
									"protocol_grpc": schema.BoolAttribute{
										MarkdownDescription: "gRPC",
										Computed:            true,
									},
									"protocol_grpc_no_tls": schema.BoolAttribute{
										MarkdownDescription: "No TLS",
										Computed:            true,
									},
									"protocol_grpc_tls_hostname": schema.StringAttribute{
										MarkdownDescription: "TLS hostname",
										Computed:            true,
									},
									"protocol_grpc_gzip": schema.BoolAttribute{
										MarkdownDescription: "gRPC gzip message compression",
										Computed:            true,
									},
									"protocol_tcp": schema.BoolAttribute{
										MarkdownDescription: "TCP",
										Computed:            true,
									},
									"protocol_udp": schema.BoolAttribute{
										MarkdownDescription: "UDP",
										Computed:            true,
									},
									"protocol_udp_packetsize": schema.Int64Attribute{
										MarkdownDescription: "UDP packet size",
										Computed:            true,
									},
								},
							},
						},
						"destinations": schema.ListNestedAttribute{
							MarkdownDescription: "Destination IP address or fully qualified domain name",
							Computed:            true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"address": schema.StringAttribute{
										MarkdownDescription: "IPv4/IPv6 address or domain name",
										Computed:            true,
									},
									"port": schema.Int64Attribute{
										MarkdownDescription: "Destination port",
										Computed:            true,
									},
									"address_family": schema.StringAttribute{
										MarkdownDescription: "Specify the desired address family for the returned addresses from DNS. Only applicable to FQDN",
										Computed:            true,
									},
									"encoding": schema.StringAttribute{
										MarkdownDescription: "Transport protocol encoding",
										Computed:            true,
									},
									"protocol_grpc": schema.BoolAttribute{
										MarkdownDescription: "gRPC",
										Computed:            true,
									},
									"protocol_grpc_no_tls": schema.BoolAttribute{
										MarkdownDescription: "No TLS",
										Computed:            true,
									},
									"protocol_grpc_tls_hostname": schema.StringAttribute{
										MarkdownDescription: "TLS hostname",
										Computed:            true,
									},
									"protocol_grpc_gzip": schema.BoolAttribute{
										MarkdownDescription: "gRPC gzip message compression",
										Computed:            true,
									},
									"protocol_tcp": schema.BoolAttribute{
										MarkdownDescription: "TCP",
										Computed:            true,
									},
									"protocol_udp": schema.BoolAttribute{
										MarkdownDescription: "UDP",
										Computed:            true,
									},
									"protocol_udp_packetsize": schema.Int64Attribute{
										MarkdownDescription: "UDP packet size",
										Computed:            true,
									},
								},
							},
						},
					},
				},
			},
			"subscriptions": schema.ListNestedAttribute{
				MarkdownDescription: "Subscription Id",
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							MarkdownDescription: "Subscription Id string",
							Computed:            true,
						},
						"source_qos_marking": schema.StringAttribute{
							MarkdownDescription: "Outgoing DSCP value",
							Computed:            true,
						},
						"source_interface": schema.StringAttribute{
							MarkdownDescription: "Source interface to use in the outgoing IP packets",
							Computed:            true,
						},
						"sensor_group_ids": schema.ListNestedAttribute{
							MarkdownDescription: "Association of one or more Sensor Groups with a Subscription Id",
							Computed:            true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Available Sensor Groups",
										Computed:            true,
									},
									"mode": schema.StringAttribute{
										MarkdownDescription: "Subscription mode",
										Computed:            true,
									},
									"heartbeat_always": schema.BoolAttribute{
										MarkdownDescription: "Send heartbeat even if events have occurred within interval",
										Computed:            true,
									},
									"heartbeat_interval": schema.Int64Attribute{
										MarkdownDescription: "Send subscription data per heartbeat interval when no events have occurred within interval",
										Computed:            true,
									},
									"strict_timer": schema.BoolAttribute{
										MarkdownDescription: "use strict timer, default is relative timer",
										Computed:            true,
									},
									"sample_interval": schema.Int64Attribute{
										MarkdownDescription: "Sample interval",
										Computed:            true,
									},
								},
							},
						},
						"destination_ids": schema.ListNestedAttribute{
							MarkdownDescription: "Destination Group Id to associate with the current subscription id",
							Computed:            true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Available Destination Group Ids",
										Computed:            true,
									},
								},
							},
						},
						"send_retry": schema.Int64Attribute{
							MarkdownDescription: "Number of send retries",
							Computed:            true,
						},
						"send_retry_duration": schema.Int64Attribute{
							MarkdownDescription: "Send retry wait duration in microseconds",
							Computed:            true,
						},
					},
				},
			},
			"sensor_groups": schema.ListNestedAttribute{
				MarkdownDescription: "Sensor group configuration",
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							MarkdownDescription: "Sensor Group Id",
							Computed:            true,
						},
						"sensor_paths": schema.ListNestedAttribute{
							MarkdownDescription: "Sensor Path",
							Computed:            true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Sensor Path",
										Computed:            true,
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func (d *TelemetryModelDrivenDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, _ *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.data = req.ProviderData.(*IosxrProviderData)
}

// End of section. //template:end model

// Section below is generated&owned by "gen/generator.go". //template:begin read

func (d *TelemetryModelDrivenDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var config TelemetryModelDrivenData

	// Read config
	diags := req.Config.Get(ctx, &config)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	device, ok := d.data.Devices[config.Device.ValueString()]
	if !ok {
		resp.Diagnostics.AddAttributeError(path.Root("device"), "Invalid device", fmt.Sprintf("Device '%s' does not exist in provider configuration.", config.Device.ValueString()))
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("%s: Beginning Read", config.getPath()))

	if device.Managed {
		if !d.data.ReuseConnection {
			defer device.Client.Disconnect()
		}
		getResp, err := device.Client.Get(ctx, []string{config.getPath()})
		if err != nil {
			resp.Diagnostics.AddError("Unable to apply gNMI Get operation", err.Error())
			return
		}

		// Defensive bounds checking for response structure
		if len(getResp.Notifications) == 0 {
			resp.Diagnostics.AddError("Invalid gNMI response",
				"Response contains no notifications")
			return
		}
		if len(getResp.Notifications[0].Update) == 0 {
			resp.Diagnostics.AddError("Invalid gNMI response",
				"Response notification contains no updates")
			return
		}

		respBody := getResp.Notifications[0].Update[0].Val.GetJsonIetfVal()
		config.fromBody(ctx, respBody)
	}

	config.Id = types.StringValue(config.getPath())

	tflog.Debug(ctx, fmt.Sprintf("%s: Read finished successfully", config.getPath()))

	diags = resp.State.Set(ctx, &config)
	resp.Diagnostics.Append(diags...)
}

// End of section. //template:end read
