// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports
import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/tidwall/gjson"

	"github.com/CiscoDevNet/terraform-provider-iosxr/internal/provider/helpers"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin model

// Ensure the implementation satisfies the expected interfaces.
var (
	_ datasource.DataSource              = &TPADataSource{}
	_ datasource.DataSourceWithConfigure = &TPADataSource{}
)

func NewTPADataSource() datasource.DataSource {
	return &TPADataSource{}
}

type TPADataSource struct {
	data *IosxrProviderData
}

func (d *TPADataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_tpa"
}

func (d *TPADataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "This data source can read the TPA configuration.",

		Attributes: map[string]schema.Attribute{
			"device": schema.StringAttribute{
				MarkdownDescription: "A device name from the provider configuration.",
				Optional:            true,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "The path of the retrieved object.",
				Computed:            true,
			},
			"statistics_update_frequency": schema.Int64Attribute{
				MarkdownDescription: "Delay in seconds for XR stats sync to Linux.",
				Computed:            true,
			},
			"statistics_disable": schema.BoolAttribute{
				MarkdownDescription: "disable statistics syncing from XR to Linux",
				Computed:            true,
			},
			"statistics_max_lpts_events": schema.Int64Attribute{
				MarkdownDescription: "How many events to allow show kim lpts statistics to record",
				Computed:            true,
			},
			"statistics_max_intf_events": schema.Int64Attribute{
				MarkdownDescription: "How many events to allow show kim interface statistics to record",
				Computed:            true,
			},
			"logging_file_max_size_kb": schema.Int64Attribute{
				MarkdownDescription: "perform log rotation when the kim log file hits this size",
				Computed:            true,
			},
			"logging_rotation_max_files": schema.Int64Attribute{
				MarkdownDescription: "how many kim log files to keep in log rotation",
				Computed:            true,
			},
			"vrfs": schema.ListNestedAttribute{
				MarkdownDescription: "Name of VRF",
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"vrf_name": schema.StringAttribute{
							MarkdownDescription: "Name of VRF",
							Computed:            true,
						},
						"ipv4_update_source_dataports_active_management": schema.BoolAttribute{
							MarkdownDescription: "Use the management port on the Active RP",
							Computed:            true,
						},
						"ipv4_update_source_dataports": schema.StringAttribute{
							MarkdownDescription: "Select an interface to use as source for all dataports",
							Computed:            true,
						},
						"ipv4_default_route_mgmt": schema.BoolAttribute{
							MarkdownDescription: "By default all Linux traffic is default routed over the line card ports. Use this option if instead you wish the default to be routed via the RP. This option also makes it possible to default route over the management ports. Note that due to the extra hop via RP performance will be lower for Linux traffic.",
							Computed:            true,
						},
						"ipv6_update_source_dataports_active_management": schema.BoolAttribute{
							MarkdownDescription: "Use the management port on the Active RP",
							Computed:            true,
						},
						"ipv6_update_source_dataports": schema.StringAttribute{
							MarkdownDescription: "Select an interface to use as source for all dataports",
							Computed:            true,
						},
						"ipv6_default_route_mgmt": schema.BoolAttribute{
							MarkdownDescription: "By default all Linux traffic is default routed over the line card ports. Use this option if instead you wish the default to be routed via the RP. This option also makes it possible to default route over the management ports. Note that due to the extra hop via RP performance will be lower for Linux traffic.",
							Computed:            true,
						},
						"ipv4_update_source_destinations": schema.ListNestedAttribute{
							MarkdownDescription: "Set the update source for a destination interfaces",
							Computed:            true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"destination_interface": schema.StringAttribute{
										MarkdownDescription: "Set the update source for a destination interfaces",
										Computed:            true,
									},
									"source_interface": schema.StringAttribute{
										MarkdownDescription: "Set the update source for this interface",
										Computed:            true,
									},
								},
							},
						},
						"ipv6_update_source_destinations": schema.ListNestedAttribute{
							MarkdownDescription: "Set the update source for a destination interfaces",
							Computed:            true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"destination_interface": schema.StringAttribute{
										MarkdownDescription: "Set the update source for a destination interfaces",
										Computed:            true,
									},
									"source_interface": schema.StringAttribute{
										MarkdownDescription: "Set the update source for this interface",
										Computed:            true,
									},
								},
							},
						},
						"east_west_interfaces": schema.ListNestedAttribute{
							MarkdownDescription: "Global interface East-West communication options",
							Computed:            true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"interface_name": schema.StringAttribute{
										MarkdownDescription: "Global interface East-West communication options",
										Computed:            true,
									},
									"referenced_vrf": schema.StringAttribute{
										MarkdownDescription: "VRF name (must be the same as tpa vrf_name)",
										Computed:            true,
									},
									"referenced_interface": schema.StringAttribute{
										MarkdownDescription: "Interface name (must be the same as east_west_interface)",
										Computed:            true,
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func (d *TPADataSource) Configure(_ context.Context, req datasource.ConfigureRequest, _ *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.data = req.ProviderData.(*IosxrProviderData)
}

// End of section. //template:end model

// Section below is generated&owned by "gen/generator.go". //template:begin read

func (d *TPADataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var config TPAData

	// Read config
	diags := req.Config.Get(ctx, &config)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	device, ok := d.data.Devices[config.Device.ValueString()]
	if !ok {
		resp.Diagnostics.AddAttributeError(path.Root("device"), "Invalid device", fmt.Sprintf("Device '%s' does not exist in provider configuration.", config.Device.ValueString()))
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("%s: Beginning Read", config.getPath()))

	if device.Managed {
		if device.Protocol == "gnmi" {
			// Ensure connection is healthy (reconnect if stale)
			if err := helpers.EnsureGnmiConnection(ctx, device.GnmiClient, d.data.ReuseConnection); err != nil {
				resp.Diagnostics.AddError("gNMI Connection Error", fmt.Sprintf("Failed to ensure connection: %s", err))
				return
			}

			defer helpers.CloseGnmiConnection(ctx, device.GnmiClient, d.data.ReuseConnection)
			getResp, err := device.GnmiClient.Get(ctx, []string{config.getPath()})
			if err != nil {
				resp.Diagnostics.AddError("Unable to apply gNMI Get operation", err.Error())
				return
			}

			// Defensive bounds checking for response structure
			if len(getResp.Notifications) == 0 {
				resp.Diagnostics.AddError("Invalid gNMI response",
					"Response contains no notifications")
				return
			}
			if len(getResp.Notifications[0].Update) == 0 {
				resp.Diagnostics.AddError("Invalid gNMI response",
					"Response notification contains no updates")
				return
			}

			update := getResp.Notifications[0].Update[0]
			if update.Val == nil {
				tflog.Debug(ctx, fmt.Sprintf("%s: gNMI Get returned nil Val, path exists but no data returned by device", config.getPath()))
				// When Val is nil, the device confirmed the path exists but didn't return data
				// This is a known behavior for netconf-yang-agent after configuration
				// The presence of the path indicates the service is configured and enabled
				// Return the configured values (these are the values that were set during Create)
				// For other resources, if Val is nil, use fromBody with empty JSON
				config.fromBody(ctx, gjson.Parse("{}"))
			} else {
				respBody := update.Val.GetJsonIetfVal()
				tflog.Debug(ctx, fmt.Sprintf("%s: gNMI Get respBody: %s", config.getPath(), string(respBody)))
				config.fromBody(ctx, gjson.ParseBytes(respBody))
			}
		} else {
			// Serialize NETCONF operations when reuse disabled (concurrent reads allowed when reuse enabled)
			locked := helpers.AcquireNetconfLock(&device.NetconfOpMutex, device.ReuseConnection, false)
			if locked {
				defer device.NetconfOpMutex.Unlock()
			}
			defer helpers.CloseNetconfConnection(ctx, device.NetconfClient, device.ReuseConnection)

			// Ensure connection is healthy (reconnect if stale)
			if err := helpers.EnsureNetconfConnection(ctx, device.NetconfClient, device.ReuseConnection); err != nil {
				resp.Diagnostics.AddError("NETCONF Connection Error", fmt.Sprintf("Failed to ensure connection: %s", err))
				return
			}

			filter := helpers.GetSubtreeFilter(config.getXPath())
			res, err := device.NetconfClient.GetConfig(ctx, "running", filter)
			if err != nil {
				resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Failed to retrieve object (%s), got error: %s", config.getPath(), err))
				return
			}

			config.fromBodyXML(ctx, res.Res)
		}
	}

	config.Id = types.StringValue(config.getPath())

	tflog.Debug(ctx, fmt.Sprintf("%s: Read finished successfully", config.getPath()))

	diags = resp.State.Set(ctx, &config)
	resp.Diagnostics.Append(diags...)
}

// End of section. //template:end read
