// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports
import (
	"context"
	"fmt"
	"reflect"
	"sort"
	"strconv"
	"strings"

	"github.com/CiscoDevNet/terraform-provider-iosxr/internal/provider/helpers"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/netascode/go-netconf"
	"github.com/netascode/xmldot"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin types
type BFD struct {
	Device                                 types.String            `tfsdk:"device"`
	Id                                     types.String            `tfsdk:"id"`
	DeleteMode                             types.String            `tfsdk:"delete_mode"`
	EchoDisable                            types.Bool              `tfsdk:"echo_disable"`
	EchoLatencyDetect                      types.Bool              `tfsdk:"echo_latency_detect"`
	EchoLatencyDetectPercentage            types.Int64             `tfsdk:"echo_latency_detect_percentage"`
	EchoLatencyDetectCount                 types.Int64             `tfsdk:"echo_latency_detect_count"`
	EchoStartupValidateForce               types.Bool              `tfsdk:"echo_startup_validate_force"`
	EchoIpv4Source                         types.String            `tfsdk:"echo_ipv4_source"`
	EchoIpv4BundlePerMemberMinimumInterval types.Int64             `tfsdk:"echo_ipv4_bundle_per_member_minimum_interval"`
	TrapSinglehopPreMapped                 types.Bool              `tfsdk:"trap_singlehop_pre_mapped"`
	MultipathLocations                     []BFDMultipathLocations `tfsdk:"multipath_locations"`
	MultihopTtlDropThreshold               types.Int64             `tfsdk:"multihop_ttl_drop_threshold"`
	DampeningInitialWait                   types.Int64             `tfsdk:"dampening_initial_wait"`
	DampeningSecondaryWait                 types.Int64             `tfsdk:"dampening_secondary_wait"`
	DampeningMaximumWait                   types.Int64             `tfsdk:"dampening_maximum_wait"`
	DampeningThreshold                     types.Int64             `tfsdk:"dampening_threshold"`
	DampeningExtensionsDownMonitoring      types.Bool              `tfsdk:"dampening_extensions_down_monitoring"`
	DampeningDisable                       types.Bool              `tfsdk:"dampening_disable"`
	DampeningBundleMemberL3OnlyMode        types.Bool              `tfsdk:"dampening_bundle_member_l3_only_mode"`
	DampeningBundleMemberInitialWait       types.Int64             `tfsdk:"dampening_bundle_member_initial_wait"`
	DampeningBundleMemberSecondaryWait     types.Int64             `tfsdk:"dampening_bundle_member_secondary_wait"`
	DampeningBundleMemberMaximumWait       types.Int64             `tfsdk:"dampening_bundle_member_maximum_wait"`
	BundleCoexistenceBobBlb                types.String            `tfsdk:"bundle_coexistence_bob_blb"`
	Ipv6ChecksumDisable                    types.Bool              `tfsdk:"ipv6_checksum_disable"`
	Interfaces                             []BFDInterfaces         `tfsdk:"interfaces"`
}

type BFDData struct {
	Device                                 types.String            `tfsdk:"device"`
	Id                                     types.String            `tfsdk:"id"`
	EchoDisable                            types.Bool              `tfsdk:"echo_disable"`
	EchoLatencyDetect                      types.Bool              `tfsdk:"echo_latency_detect"`
	EchoLatencyDetectPercentage            types.Int64             `tfsdk:"echo_latency_detect_percentage"`
	EchoLatencyDetectCount                 types.Int64             `tfsdk:"echo_latency_detect_count"`
	EchoStartupValidateForce               types.Bool              `tfsdk:"echo_startup_validate_force"`
	EchoIpv4Source                         types.String            `tfsdk:"echo_ipv4_source"`
	EchoIpv4BundlePerMemberMinimumInterval types.Int64             `tfsdk:"echo_ipv4_bundle_per_member_minimum_interval"`
	TrapSinglehopPreMapped                 types.Bool              `tfsdk:"trap_singlehop_pre_mapped"`
	MultipathLocations                     []BFDMultipathLocations `tfsdk:"multipath_locations"`
	MultihopTtlDropThreshold               types.Int64             `tfsdk:"multihop_ttl_drop_threshold"`
	DampeningInitialWait                   types.Int64             `tfsdk:"dampening_initial_wait"`
	DampeningSecondaryWait                 types.Int64             `tfsdk:"dampening_secondary_wait"`
	DampeningMaximumWait                   types.Int64             `tfsdk:"dampening_maximum_wait"`
	DampeningThreshold                     types.Int64             `tfsdk:"dampening_threshold"`
	DampeningExtensionsDownMonitoring      types.Bool              `tfsdk:"dampening_extensions_down_monitoring"`
	DampeningDisable                       types.Bool              `tfsdk:"dampening_disable"`
	DampeningBundleMemberL3OnlyMode        types.Bool              `tfsdk:"dampening_bundle_member_l3_only_mode"`
	DampeningBundleMemberInitialWait       types.Int64             `tfsdk:"dampening_bundle_member_initial_wait"`
	DampeningBundleMemberSecondaryWait     types.Int64             `tfsdk:"dampening_bundle_member_secondary_wait"`
	DampeningBundleMemberMaximumWait       types.Int64             `tfsdk:"dampening_bundle_member_maximum_wait"`
	BundleCoexistenceBobBlb                types.String            `tfsdk:"bundle_coexistence_bob_blb"`
	Ipv6ChecksumDisable                    types.Bool              `tfsdk:"ipv6_checksum_disable"`
	Interfaces                             []BFDInterfaces         `tfsdk:"interfaces"`
}
type BFDMultipathLocations struct {
	LocationId types.String `tfsdk:"location_id"`
}
type BFDInterfaces struct {
	InterfaceName       types.String `tfsdk:"interface_name"`
	EchoDisable         types.String `tfsdk:"echo_disable"`
	EchoIpv4Source      types.String `tfsdk:"echo_ipv4_source"`
	Ipv6ChecksumDisable types.Bool   `tfsdk:"ipv6_checksum_disable"`
	Disable             types.Bool   `tfsdk:"disable"`
	LocalAddress        types.String `tfsdk:"local_address"`
	TxInterval          types.Int64  `tfsdk:"tx_interval"`
	RxInterval          types.Int64  `tfsdk:"rx_interval"`
	Multiplier          types.Int64  `tfsdk:"multiplier"`
}

// End of section. //template:end types

// Section below is generated&owned by "gen/generator.go". //template:begin getPath

func (data BFD) getPath() string {
	return "Cisco-IOS-XR-um-bfd-sbfd-cfg:/bfd"
}

func (data BFDData) getPath() string {
	return "Cisco-IOS-XR-um-bfd-sbfd-cfg:/bfd"
}

// getXPath returns the XPath for NETCONF operations
func (data BFD) getXPath() string {
	path := "Cisco-IOS-XR-um-bfd-sbfd-cfg:/bfd"
	return path
}

func (data BFDData) getXPath() string {
	path := "Cisco-IOS-XR-um-bfd-sbfd-cfg:/bfd"
	return path
}

// End of section. //template:end getPath

// Section below is generated&owned by "gen/generator.go". //template:begin toBody

func (data BFD) toBody(ctx context.Context) string {
	body := "{}"
	if !data.EchoDisable.IsNull() && !data.EchoDisable.IsUnknown() {
		if data.EchoDisable.ValueBool() {
			body, _ = sjson.Set(body, "echo.disable", []interface{}{nil})
		}
	}
	if !data.EchoLatencyDetect.IsNull() && !data.EchoLatencyDetect.IsUnknown() {
		if data.EchoLatencyDetect.ValueBool() {
			body, _ = sjson.Set(body, "echo.latency.detect", map[string]string{})
		}
	}
	if !data.EchoLatencyDetectPercentage.IsNull() && !data.EchoLatencyDetectPercentage.IsUnknown() {
		body, _ = sjson.Set(body, "echo.latency.detect.percentage", strconv.FormatInt(data.EchoLatencyDetectPercentage.ValueInt64(), 10))
	}
	if !data.EchoLatencyDetectCount.IsNull() && !data.EchoLatencyDetectCount.IsUnknown() {
		body, _ = sjson.Set(body, "echo.latency.detect.count", strconv.FormatInt(data.EchoLatencyDetectCount.ValueInt64(), 10))
	}
	if !data.EchoStartupValidateForce.IsNull() && !data.EchoStartupValidateForce.IsUnknown() {
		if data.EchoStartupValidateForce.ValueBool() {
			body, _ = sjson.Set(body, "echo.startup.validate.force", []interface{}{nil})
		}
	}
	if !data.EchoIpv4Source.IsNull() && !data.EchoIpv4Source.IsUnknown() {
		body, _ = sjson.Set(body, "echo.ipv4.source.ipv4-address", data.EchoIpv4Source.ValueString())
	}
	if !data.EchoIpv4BundlePerMemberMinimumInterval.IsNull() && !data.EchoIpv4BundlePerMemberMinimumInterval.IsUnknown() {
		body, _ = sjson.Set(body, "echo.ipv4.bundle-per-member.minimum-interval", strconv.FormatInt(data.EchoIpv4BundlePerMemberMinimumInterval.ValueInt64(), 10))
	}
	if !data.TrapSinglehopPreMapped.IsNull() && !data.TrapSinglehopPreMapped.IsUnknown() {
		if data.TrapSinglehopPreMapped.ValueBool() {
			body, _ = sjson.Set(body, "trap.singlehop.pre-mapped", []interface{}{nil})
		}
	}
	if !data.MultihopTtlDropThreshold.IsNull() && !data.MultihopTtlDropThreshold.IsUnknown() {
		body, _ = sjson.Set(body, "multihop.ttl-drop-threshold", strconv.FormatInt(data.MultihopTtlDropThreshold.ValueInt64(), 10))
	}
	if !data.DampeningInitialWait.IsNull() && !data.DampeningInitialWait.IsUnknown() {
		body, _ = sjson.Set(body, "dampening.initial-wait", strconv.FormatInt(data.DampeningInitialWait.ValueInt64(), 10))
	}
	if !data.DampeningSecondaryWait.IsNull() && !data.DampeningSecondaryWait.IsUnknown() {
		body, _ = sjson.Set(body, "dampening.secondary-wait", strconv.FormatInt(data.DampeningSecondaryWait.ValueInt64(), 10))
	}
	if !data.DampeningMaximumWait.IsNull() && !data.DampeningMaximumWait.IsUnknown() {
		body, _ = sjson.Set(body, "dampening.maximum-wait", strconv.FormatInt(data.DampeningMaximumWait.ValueInt64(), 10))
	}
	if !data.DampeningThreshold.IsNull() && !data.DampeningThreshold.IsUnknown() {
		body, _ = sjson.Set(body, "dampening.threshold", strconv.FormatInt(data.DampeningThreshold.ValueInt64(), 10))
	}
	if !data.DampeningExtensionsDownMonitoring.IsNull() && !data.DampeningExtensionsDownMonitoring.IsUnknown() {
		if data.DampeningExtensionsDownMonitoring.ValueBool() {
			body, _ = sjson.Set(body, "dampening.extensions.down-monitoring", []interface{}{nil})
		}
	}
	if !data.DampeningDisable.IsNull() && !data.DampeningDisable.IsUnknown() {
		if data.DampeningDisable.ValueBool() {
			body, _ = sjson.Set(body, "dampening.disable", []interface{}{nil})
		}
	}
	if !data.DampeningBundleMemberL3OnlyMode.IsNull() && !data.DampeningBundleMemberL3OnlyMode.IsUnknown() {
		if data.DampeningBundleMemberL3OnlyMode.ValueBool() {
			body, _ = sjson.Set(body, "dampening.bundle-member.l3-only-mode", []interface{}{nil})
		}
	}
	if !data.DampeningBundleMemberInitialWait.IsNull() && !data.DampeningBundleMemberInitialWait.IsUnknown() {
		body, _ = sjson.Set(body, "dampening.bundle-member.initial-wait", strconv.FormatInt(data.DampeningBundleMemberInitialWait.ValueInt64(), 10))
	}
	if !data.DampeningBundleMemberSecondaryWait.IsNull() && !data.DampeningBundleMemberSecondaryWait.IsUnknown() {
		body, _ = sjson.Set(body, "dampening.bundle-member.secondary-wait", strconv.FormatInt(data.DampeningBundleMemberSecondaryWait.ValueInt64(), 10))
	}
	if !data.DampeningBundleMemberMaximumWait.IsNull() && !data.DampeningBundleMemberMaximumWait.IsUnknown() {
		body, _ = sjson.Set(body, "dampening.bundle-member.maximum-wait", strconv.FormatInt(data.DampeningBundleMemberMaximumWait.ValueInt64(), 10))
	}
	if !data.BundleCoexistenceBobBlb.IsNull() && !data.BundleCoexistenceBobBlb.IsUnknown() {
		body, _ = sjson.Set(body, "bundle.coexistence.bob-blb", data.BundleCoexistenceBobBlb.ValueString())
	}
	if !data.Ipv6ChecksumDisable.IsNull() && !data.Ipv6ChecksumDisable.IsUnknown() {
		if data.Ipv6ChecksumDisable.ValueBool() {
			body, _ = sjson.Set(body, "ipv6.checksum.disable", []interface{}{nil})
		}
	}
	if len(data.MultipathLocations) > 0 {
		body, _ = sjson.Set(body, "multipath.include.locations.location", []interface{}{})
		for index, item := range data.MultipathLocations {
			if !item.LocationId.IsNull() && !item.LocationId.IsUnknown() {
				body, _ = sjson.Set(body, "multipath.include.locations.location"+"."+strconv.Itoa(index)+"."+"location-id", item.LocationId.ValueString())
			}
		}
	}
	if len(data.Interfaces) > 0 {
		body, _ = sjson.Set(body, "interfaces.interface", []interface{}{})
		for index, item := range data.Interfaces {
			if !item.InterfaceName.IsNull() && !item.InterfaceName.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"interface-name", item.InterfaceName.ValueString())
			}
			if !item.EchoDisable.IsNull() && !item.EchoDisable.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"echo.disable", item.EchoDisable.ValueString())
			}
			if !item.EchoIpv4Source.IsNull() && !item.EchoIpv4Source.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"echo.ipv4.source.ipv4-address", item.EchoIpv4Source.ValueString())
			}
			if !item.Ipv6ChecksumDisable.IsNull() && !item.Ipv6ChecksumDisable.IsUnknown() {
				if item.Ipv6ChecksumDisable.ValueBool() {
					body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"ipv6.checksum.disable", []interface{}{nil})
				}
			}
			if !item.Disable.IsNull() && !item.Disable.IsUnknown() {
				if item.Disable.ValueBool() {
					body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"disable", []interface{}{nil})
				}
			}
			if !item.LocalAddress.IsNull() && !item.LocalAddress.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"local-address", item.LocalAddress.ValueString())
			}
			if !item.TxInterval.IsNull() && !item.TxInterval.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"tx-interval", strconv.FormatInt(item.TxInterval.ValueInt64(), 10))
			}
			if !item.RxInterval.IsNull() && !item.RxInterval.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"rx-interval", strconv.FormatInt(item.RxInterval.ValueInt64(), 10))
			}
			if !item.Multiplier.IsNull() && !item.Multiplier.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"multiplier", strconv.FormatInt(item.Multiplier.ValueInt64(), 10))
			}
		}
	}
	return body
}

// End of section. //template:end toBody

// Section below is generated&owned by "gen/generator.go". //template:begin toBodyXML

func (data BFD) toBodyXML(ctx context.Context) string {
	body := netconf.Body{}
	if !data.EchoDisable.IsNull() && !data.EchoDisable.IsUnknown() {
		if data.EchoDisable.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/echo/disable", "")
		}
	}
	if !data.EchoLatencyDetect.IsNull() && !data.EchoLatencyDetect.IsUnknown() {
		if data.EchoLatencyDetect.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/echo/latency/detect", "")
		}
	}
	if !data.EchoLatencyDetectPercentage.IsNull() && !data.EchoLatencyDetectPercentage.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/echo/latency/detect/percentage", strconv.FormatInt(data.EchoLatencyDetectPercentage.ValueInt64(), 10))
	}
	if !data.EchoLatencyDetectCount.IsNull() && !data.EchoLatencyDetectCount.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/echo/latency/detect/count", strconv.FormatInt(data.EchoLatencyDetectCount.ValueInt64(), 10))
	}
	if !data.EchoStartupValidateForce.IsNull() && !data.EchoStartupValidateForce.IsUnknown() {
		if data.EchoStartupValidateForce.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/echo/startup/validate/force", "")
		}
	}
	if !data.EchoIpv4Source.IsNull() && !data.EchoIpv4Source.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/echo/ipv4/source/ipv4-address", data.EchoIpv4Source.ValueString())
	}
	if !data.EchoIpv4BundlePerMemberMinimumInterval.IsNull() && !data.EchoIpv4BundlePerMemberMinimumInterval.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/echo/ipv4/bundle-per-member/minimum-interval", strconv.FormatInt(data.EchoIpv4BundlePerMemberMinimumInterval.ValueInt64(), 10))
	}
	if !data.TrapSinglehopPreMapped.IsNull() && !data.TrapSinglehopPreMapped.IsUnknown() {
		if data.TrapSinglehopPreMapped.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/trap/singlehop/pre-mapped", "")
		}
	}
	if len(data.MultipathLocations) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.MultipathLocations {
			cBody := netconf.Body{}
			if !item.LocationId.IsNull() && !item.LocationId.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "location-id", item.LocationId.ValueString())
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"multipath/include/locations/location", cBody.Res())
		}
	}
	if !data.MultihopTtlDropThreshold.IsNull() && !data.MultihopTtlDropThreshold.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/multihop/ttl-drop-threshold", strconv.FormatInt(data.MultihopTtlDropThreshold.ValueInt64(), 10))
	}
	if !data.DampeningInitialWait.IsNull() && !data.DampeningInitialWait.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/dampening/initial-wait", strconv.FormatInt(data.DampeningInitialWait.ValueInt64(), 10))
	}
	if !data.DampeningSecondaryWait.IsNull() && !data.DampeningSecondaryWait.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/dampening/secondary-wait", strconv.FormatInt(data.DampeningSecondaryWait.ValueInt64(), 10))
	}
	if !data.DampeningMaximumWait.IsNull() && !data.DampeningMaximumWait.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/dampening/maximum-wait", strconv.FormatInt(data.DampeningMaximumWait.ValueInt64(), 10))
	}
	if !data.DampeningThreshold.IsNull() && !data.DampeningThreshold.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/dampening/threshold", strconv.FormatInt(data.DampeningThreshold.ValueInt64(), 10))
	}
	if !data.DampeningExtensionsDownMonitoring.IsNull() && !data.DampeningExtensionsDownMonitoring.IsUnknown() {
		if data.DampeningExtensionsDownMonitoring.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/dampening/extensions/down-monitoring", "")
		}
	}
	if !data.DampeningDisable.IsNull() && !data.DampeningDisable.IsUnknown() {
		if data.DampeningDisable.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/dampening/disable", "")
		}
	}
	if !data.DampeningBundleMemberL3OnlyMode.IsNull() && !data.DampeningBundleMemberL3OnlyMode.IsUnknown() {
		if data.DampeningBundleMemberL3OnlyMode.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/dampening/bundle-member/l3-only-mode", "")
		}
	}
	if !data.DampeningBundleMemberInitialWait.IsNull() && !data.DampeningBundleMemberInitialWait.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/dampening/bundle-member/initial-wait", strconv.FormatInt(data.DampeningBundleMemberInitialWait.ValueInt64(), 10))
	}
	if !data.DampeningBundleMemberSecondaryWait.IsNull() && !data.DampeningBundleMemberSecondaryWait.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/dampening/bundle-member/secondary-wait", strconv.FormatInt(data.DampeningBundleMemberSecondaryWait.ValueInt64(), 10))
	}
	if !data.DampeningBundleMemberMaximumWait.IsNull() && !data.DampeningBundleMemberMaximumWait.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/dampening/bundle-member/maximum-wait", strconv.FormatInt(data.DampeningBundleMemberMaximumWait.ValueInt64(), 10))
	}
	if !data.BundleCoexistenceBobBlb.IsNull() && !data.BundleCoexistenceBobBlb.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/bundle/coexistence/bob-blb", data.BundleCoexistenceBobBlb.ValueString())
	}
	if !data.Ipv6ChecksumDisable.IsNull() && !data.Ipv6ChecksumDisable.IsUnknown() {
		if data.Ipv6ChecksumDisable.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/ipv6/checksum/disable", "")
		}
	}
	if len(data.Interfaces) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.Interfaces {
			cBody := netconf.Body{}
			if !item.InterfaceName.IsNull() && !item.InterfaceName.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "interface-name", item.InterfaceName.ValueString())
			}
			if !item.EchoDisable.IsNull() && !item.EchoDisable.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "echo/disable", item.EchoDisable.ValueString())
			}
			if !item.EchoIpv4Source.IsNull() && !item.EchoIpv4Source.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "echo/ipv4/source/ipv4-address", item.EchoIpv4Source.ValueString())
			}
			if !item.Ipv6ChecksumDisable.IsNull() && !item.Ipv6ChecksumDisable.IsUnknown() {
				if item.Ipv6ChecksumDisable.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "ipv6/checksum/disable", "")
				}
			}
			if !item.Disable.IsNull() && !item.Disable.IsUnknown() {
				if item.Disable.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "disable", "")
				}
			}
			if !item.LocalAddress.IsNull() && !item.LocalAddress.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "local-address", item.LocalAddress.ValueString())
			}
			if !item.TxInterval.IsNull() && !item.TxInterval.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "tx-interval", strconv.FormatInt(item.TxInterval.ValueInt64(), 10))
			}
			if !item.RxInterval.IsNull() && !item.RxInterval.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "rx-interval", strconv.FormatInt(item.RxInterval.ValueInt64(), 10))
			}
			if !item.Multiplier.IsNull() && !item.Multiplier.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "multiplier", strconv.FormatInt(item.Multiplier.ValueInt64(), 10))
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"interfaces/interface", cBody.Res())
		}
	}
	bodyString, err := body.String()
	if err != nil {
		tflog.Error(ctx, fmt.Sprintf("Error converting body to string: %s", err))
	}
	return bodyString
}

// End of section. //template:end toBodyXML

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBody

func (data *BFD) updateFromBody(ctx context.Context, res []byte) {
	if value := gjson.GetBytes(res, "echo.disable"); value.Exists() {
		if !data.EchoDisable.IsNull() {
			data.EchoDisable = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.EchoDisable.IsNull() {
			data.EchoDisable = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "echo.latency.detect"); value.Exists() {
		if !data.EchoLatencyDetect.IsNull() {
			data.EchoLatencyDetect = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.EchoLatencyDetect.IsNull() {
			data.EchoLatencyDetect = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "echo.latency.detect.percentage"); value.Exists() && !data.EchoLatencyDetectPercentage.IsNull() {
		data.EchoLatencyDetectPercentage = types.Int64Value(value.Int())
	} else {
		data.EchoLatencyDetectPercentage = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "echo.latency.detect.count"); value.Exists() && !data.EchoLatencyDetectCount.IsNull() {
		data.EchoLatencyDetectCount = types.Int64Value(value.Int())
	} else {
		data.EchoLatencyDetectCount = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "echo.startup.validate.force"); value.Exists() {
		if !data.EchoStartupValidateForce.IsNull() {
			data.EchoStartupValidateForce = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.EchoStartupValidateForce.IsNull() {
			data.EchoStartupValidateForce = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "echo.ipv4.source.ipv4-address"); value.Exists() && !data.EchoIpv4Source.IsNull() {
		data.EchoIpv4Source = types.StringValue(value.String())
	} else {
		data.EchoIpv4Source = types.StringNull()
	}
	if value := gjson.GetBytes(res, "echo.ipv4.bundle-per-member.minimum-interval"); value.Exists() && !data.EchoIpv4BundlePerMemberMinimumInterval.IsNull() {
		data.EchoIpv4BundlePerMemberMinimumInterval = types.Int64Value(value.Int())
	} else {
		data.EchoIpv4BundlePerMemberMinimumInterval = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "trap.singlehop.pre-mapped"); value.Exists() {
		if !data.TrapSinglehopPreMapped.IsNull() {
			data.TrapSinglehopPreMapped = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.TrapSinglehopPreMapped.IsNull() {
			data.TrapSinglehopPreMapped = types.BoolNull()
		}
	}
	for i := range data.MultipathLocations {
		keys := [...]string{"location-id"}
		keyValues := [...]string{data.MultipathLocations[i].LocationId.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "multipath.include.locations.location").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("location-id"); value.Exists() && !data.MultipathLocations[i].LocationId.IsNull() {
			data.MultipathLocations[i].LocationId = types.StringValue(value.String())
		} else {
			data.MultipathLocations[i].LocationId = types.StringNull()
		}
	}
	if value := gjson.GetBytes(res, "multihop.ttl-drop-threshold"); value.Exists() && !data.MultihopTtlDropThreshold.IsNull() {
		data.MultihopTtlDropThreshold = types.Int64Value(value.Int())
	} else {
		data.MultihopTtlDropThreshold = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "dampening.initial-wait"); value.Exists() && !data.DampeningInitialWait.IsNull() {
		data.DampeningInitialWait = types.Int64Value(value.Int())
	} else {
		data.DampeningInitialWait = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "dampening.secondary-wait"); value.Exists() && !data.DampeningSecondaryWait.IsNull() {
		data.DampeningSecondaryWait = types.Int64Value(value.Int())
	} else {
		data.DampeningSecondaryWait = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "dampening.maximum-wait"); value.Exists() && !data.DampeningMaximumWait.IsNull() {
		data.DampeningMaximumWait = types.Int64Value(value.Int())
	} else {
		data.DampeningMaximumWait = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "dampening.threshold"); value.Exists() && !data.DampeningThreshold.IsNull() {
		data.DampeningThreshold = types.Int64Value(value.Int())
	} else {
		data.DampeningThreshold = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "dampening.extensions.down-monitoring"); value.Exists() {
		if !data.DampeningExtensionsDownMonitoring.IsNull() {
			data.DampeningExtensionsDownMonitoring = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.DampeningExtensionsDownMonitoring.IsNull() {
			data.DampeningExtensionsDownMonitoring = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "dampening.disable"); value.Exists() {
		if !data.DampeningDisable.IsNull() {
			data.DampeningDisable = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.DampeningDisable.IsNull() {
			data.DampeningDisable = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "dampening.bundle-member.l3-only-mode"); value.Exists() {
		if !data.DampeningBundleMemberL3OnlyMode.IsNull() {
			data.DampeningBundleMemberL3OnlyMode = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.DampeningBundleMemberL3OnlyMode.IsNull() {
			data.DampeningBundleMemberL3OnlyMode = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "dampening.bundle-member.initial-wait"); value.Exists() && !data.DampeningBundleMemberInitialWait.IsNull() {
		data.DampeningBundleMemberInitialWait = types.Int64Value(value.Int())
	} else {
		data.DampeningBundleMemberInitialWait = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "dampening.bundle-member.secondary-wait"); value.Exists() && !data.DampeningBundleMemberSecondaryWait.IsNull() {
		data.DampeningBundleMemberSecondaryWait = types.Int64Value(value.Int())
	} else {
		data.DampeningBundleMemberSecondaryWait = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "dampening.bundle-member.maximum-wait"); value.Exists() && !data.DampeningBundleMemberMaximumWait.IsNull() {
		data.DampeningBundleMemberMaximumWait = types.Int64Value(value.Int())
	} else {
		data.DampeningBundleMemberMaximumWait = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "bundle.coexistence.bob-blb"); value.Exists() && !data.BundleCoexistenceBobBlb.IsNull() {
		data.BundleCoexistenceBobBlb = types.StringValue(value.String())
	} else {
		data.BundleCoexistenceBobBlb = types.StringNull()
	}
	if value := gjson.GetBytes(res, "ipv6.checksum.disable"); value.Exists() {
		if !data.Ipv6ChecksumDisable.IsNull() {
			data.Ipv6ChecksumDisable = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.Ipv6ChecksumDisable.IsNull() {
			data.Ipv6ChecksumDisable = types.BoolNull()
		}
	}
	for i := range data.Interfaces {
		keys := [...]string{"interface-name"}
		keyValues := [...]string{data.Interfaces[i].InterfaceName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "interfaces.interface").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("interface-name"); value.Exists() && !data.Interfaces[i].InterfaceName.IsNull() {
			data.Interfaces[i].InterfaceName = types.StringValue(value.String())
		} else {
			data.Interfaces[i].InterfaceName = types.StringNull()
		}
		if value := r.Get("echo.disable"); value.Exists() && !data.Interfaces[i].EchoDisable.IsNull() {
			data.Interfaces[i].EchoDisable = types.StringValue(value.String())
		} else {
			data.Interfaces[i].EchoDisable = types.StringNull()
		}
		if value := r.Get("echo.ipv4.source.ipv4-address"); value.Exists() && !data.Interfaces[i].EchoIpv4Source.IsNull() {
			data.Interfaces[i].EchoIpv4Source = types.StringValue(value.String())
		} else {
			data.Interfaces[i].EchoIpv4Source = types.StringNull()
		}
		if value := r.Get("ipv6.checksum.disable"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Interfaces[i].Ipv6ChecksumDisable.IsNull() && !data.Interfaces[i].Ipv6ChecksumDisable.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Interfaces[i].Ipv6ChecksumDisable = types.BoolValue(false)
			} else if !data.Interfaces[i].Ipv6ChecksumDisable.IsNull() {
				data.Interfaces[i].Ipv6ChecksumDisable = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Interfaces[i].Ipv6ChecksumDisable.IsNull() {
				data.Interfaces[i].Ipv6ChecksumDisable = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Interfaces[i].Ipv6ChecksumDisable = types.BoolValue(false)
			}
		}
		if value := r.Get("disable"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Interfaces[i].Disable.IsNull() && !data.Interfaces[i].Disable.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Interfaces[i].Disable = types.BoolValue(false)
			} else if !data.Interfaces[i].Disable.IsNull() {
				data.Interfaces[i].Disable = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Interfaces[i].Disable.IsNull() {
				data.Interfaces[i].Disable = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Interfaces[i].Disable = types.BoolValue(false)
			}
		}
		if value := r.Get("local-address"); value.Exists() && !data.Interfaces[i].LocalAddress.IsNull() {
			data.Interfaces[i].LocalAddress = types.StringValue(value.String())
		} else {
			data.Interfaces[i].LocalAddress = types.StringNull()
		}
		if value := r.Get("tx-interval"); value.Exists() && !data.Interfaces[i].TxInterval.IsNull() {
			data.Interfaces[i].TxInterval = types.Int64Value(value.Int())
		} else {
			data.Interfaces[i].TxInterval = types.Int64Null()
		}
		if value := r.Get("rx-interval"); value.Exists() && !data.Interfaces[i].RxInterval.IsNull() {
			data.Interfaces[i].RxInterval = types.Int64Value(value.Int())
		} else {
			data.Interfaces[i].RxInterval = types.Int64Null()
		}
		if value := r.Get("multiplier"); value.Exists() && !data.Interfaces[i].Multiplier.IsNull() {
			data.Interfaces[i].Multiplier = types.Int64Value(value.Int())
		} else {
			data.Interfaces[i].Multiplier = types.Int64Null()
		}
	}
}

// End of section. //template:end updateFromBody

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBodyXML

func (data *BFD) updateFromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/echo/disable"); value.Exists() {
		data.EchoDisable = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.EchoDisable.IsNull() {
			data.EchoDisable = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/echo/latency/detect"); value.Exists() {
		data.EchoLatencyDetect = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.EchoLatencyDetect.IsNull() {
			data.EchoLatencyDetect = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/echo/latency/detect/percentage"); value.Exists() {
		data.EchoLatencyDetectPercentage = types.Int64Value(value.Int())
	} else if data.EchoLatencyDetectPercentage.IsNull() {
		data.EchoLatencyDetectPercentage = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/echo/latency/detect/count"); value.Exists() {
		data.EchoLatencyDetectCount = types.Int64Value(value.Int())
	} else if data.EchoLatencyDetectCount.IsNull() {
		data.EchoLatencyDetectCount = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/echo/startup/validate/force"); value.Exists() {
		data.EchoStartupValidateForce = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.EchoStartupValidateForce.IsNull() {
			data.EchoStartupValidateForce = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/echo/ipv4/source/ipv4-address"); value.Exists() {
		data.EchoIpv4Source = types.StringValue(value.String())
	} else if data.EchoIpv4Source.IsNull() {
		data.EchoIpv4Source = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/echo/ipv4/bundle-per-member/minimum-interval"); value.Exists() {
		data.EchoIpv4BundlePerMemberMinimumInterval = types.Int64Value(value.Int())
	} else if data.EchoIpv4BundlePerMemberMinimumInterval.IsNull() {
		data.EchoIpv4BundlePerMemberMinimumInterval = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/trap/singlehop/pre-mapped"); value.Exists() {
		data.TrapSinglehopPreMapped = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.TrapSinglehopPreMapped.IsNull() {
			data.TrapSinglehopPreMapped = types.BoolNull()
		}
	}
	for i := range data.MultipathLocations {
		keys := [...]string{"location-id"}
		keyValues := [...]string{data.MultipathLocations[i].LocationId.ValueString()}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/multipath/include/locations/location").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "location-id"); value.Exists() {
			data.MultipathLocations[i].LocationId = types.StringValue(value.String())
		} else if data.MultipathLocations[i].LocationId.IsNull() {
			data.MultipathLocations[i].LocationId = types.StringNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/multihop/ttl-drop-threshold"); value.Exists() {
		data.MultihopTtlDropThreshold = types.Int64Value(value.Int())
	} else if data.MultihopTtlDropThreshold.IsNull() {
		data.MultihopTtlDropThreshold = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/initial-wait"); value.Exists() {
		data.DampeningInitialWait = types.Int64Value(value.Int())
	} else if data.DampeningInitialWait.IsNull() {
		data.DampeningInitialWait = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/secondary-wait"); value.Exists() {
		data.DampeningSecondaryWait = types.Int64Value(value.Int())
	} else if data.DampeningSecondaryWait.IsNull() {
		data.DampeningSecondaryWait = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/maximum-wait"); value.Exists() {
		data.DampeningMaximumWait = types.Int64Value(value.Int())
	} else if data.DampeningMaximumWait.IsNull() {
		data.DampeningMaximumWait = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/threshold"); value.Exists() {
		data.DampeningThreshold = types.Int64Value(value.Int())
	} else if data.DampeningThreshold.IsNull() {
		data.DampeningThreshold = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/extensions/down-monitoring"); value.Exists() {
		data.DampeningExtensionsDownMonitoring = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.DampeningExtensionsDownMonitoring.IsNull() {
			data.DampeningExtensionsDownMonitoring = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/disable"); value.Exists() {
		data.DampeningDisable = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.DampeningDisable.IsNull() {
			data.DampeningDisable = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/bundle-member/l3-only-mode"); value.Exists() {
		data.DampeningBundleMemberL3OnlyMode = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.DampeningBundleMemberL3OnlyMode.IsNull() {
			data.DampeningBundleMemberL3OnlyMode = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/bundle-member/initial-wait"); value.Exists() {
		data.DampeningBundleMemberInitialWait = types.Int64Value(value.Int())
	} else if data.DampeningBundleMemberInitialWait.IsNull() {
		data.DampeningBundleMemberInitialWait = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/bundle-member/secondary-wait"); value.Exists() {
		data.DampeningBundleMemberSecondaryWait = types.Int64Value(value.Int())
	} else if data.DampeningBundleMemberSecondaryWait.IsNull() {
		data.DampeningBundleMemberSecondaryWait = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/bundle-member/maximum-wait"); value.Exists() {
		data.DampeningBundleMemberMaximumWait = types.Int64Value(value.Int())
	} else if data.DampeningBundleMemberMaximumWait.IsNull() {
		data.DampeningBundleMemberMaximumWait = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/bundle/coexistence/bob-blb"); value.Exists() {
		data.BundleCoexistenceBobBlb = types.StringValue(value.String())
	} else if data.BundleCoexistenceBobBlb.IsNull() {
		data.BundleCoexistenceBobBlb = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/ipv6/checksum/disable"); value.Exists() {
		data.Ipv6ChecksumDisable = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.Ipv6ChecksumDisable.IsNull() {
			data.Ipv6ChecksumDisable = types.BoolNull()
		}
	}
	for i := range data.Interfaces {
		keys := [...]string{"interface-name"}
		keyValues := [...]string{data.Interfaces[i].InterfaceName.ValueString()}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/interfaces/interface").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "interface-name"); value.Exists() {
			data.Interfaces[i].InterfaceName = types.StringValue(value.String())
		} else if data.Interfaces[i].InterfaceName.IsNull() {
			data.Interfaces[i].InterfaceName = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "echo/disable"); value.Exists() {
			data.Interfaces[i].EchoDisable = types.StringValue(value.String())
		} else if data.Interfaces[i].EchoDisable.IsNull() {
			data.Interfaces[i].EchoDisable = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "echo/ipv4/source/ipv4-address"); value.Exists() {
			data.Interfaces[i].EchoIpv4Source = types.StringValue(value.String())
		} else if data.Interfaces[i].EchoIpv4Source.IsNull() {
			data.Interfaces[i].EchoIpv4Source = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "ipv6/checksum/disable"); value.Exists() {
			data.Interfaces[i].Ipv6ChecksumDisable = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Interfaces[i].Ipv6ChecksumDisable.IsNull() {
				data.Interfaces[i].Ipv6ChecksumDisable = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "disable"); value.Exists() {
			data.Interfaces[i].Disable = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Interfaces[i].Disable.IsNull() {
				data.Interfaces[i].Disable = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "local-address"); value.Exists() {
			data.Interfaces[i].LocalAddress = types.StringValue(value.String())
		} else if data.Interfaces[i].LocalAddress.IsNull() {
			data.Interfaces[i].LocalAddress = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "tx-interval"); value.Exists() {
			data.Interfaces[i].TxInterval = types.Int64Value(value.Int())
		} else if data.Interfaces[i].TxInterval.IsNull() {
			data.Interfaces[i].TxInterval = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "rx-interval"); value.Exists() {
			data.Interfaces[i].RxInterval = types.Int64Value(value.Int())
		} else if data.Interfaces[i].RxInterval.IsNull() {
			data.Interfaces[i].RxInterval = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "multiplier"); value.Exists() {
			data.Interfaces[i].Multiplier = types.Int64Value(value.Int())
		} else if data.Interfaces[i].Multiplier.IsNull() {
			data.Interfaces[i].Multiplier = types.Int64Null()
		}
	}
}

// End of section. //template:end updateFromBodyXML

// Section below is generated&owned by "gen/generator.go". //template:begin fromBody

func (data *BFD) fromBody(ctx context.Context, res gjson.Result) {
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	if value := res.Get(prefix + "echo.disable"); value.Exists() {
		data.EchoDisable = types.BoolValue(true)
	} else {
		data.EchoDisable = types.BoolNull()
	}
	if value := res.Get(prefix + "echo.latency.detect"); value.Exists() {
		data.EchoLatencyDetect = types.BoolValue(true)
	} else {
		data.EchoLatencyDetect = types.BoolNull()
	}
	if value := res.Get(prefix + "echo.latency.detect.percentage"); value.Exists() {
		data.EchoLatencyDetectPercentage = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "echo.latency.detect.count"); value.Exists() {
		data.EchoLatencyDetectCount = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "echo.startup.validate.force"); value.Exists() {
		data.EchoStartupValidateForce = types.BoolValue(true)
	} else {
		data.EchoStartupValidateForce = types.BoolNull()
	}
	if value := res.Get(prefix + "echo.ipv4.source.ipv4-address"); value.Exists() {
		data.EchoIpv4Source = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "echo.ipv4.bundle-per-member.minimum-interval"); value.Exists() {
		data.EchoIpv4BundlePerMemberMinimumInterval = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "trap.singlehop.pre-mapped"); value.Exists() {
		data.TrapSinglehopPreMapped = types.BoolValue(true)
	} else {
		data.TrapSinglehopPreMapped = types.BoolNull()
	}
	if value := res.Get(prefix + "multipath.include.locations.location"); value.Exists() {
		data.MultipathLocations = make([]BFDMultipathLocations, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := BFDMultipathLocations{}
			if cValue := v.Get("location-id"); cValue.Exists() {
				item.LocationId = types.StringValue(cValue.String())
			}
			data.MultipathLocations = append(data.MultipathLocations, item)
			return true
		})
	}
	if value := res.Get(prefix + "multihop.ttl-drop-threshold"); value.Exists() {
		data.MultihopTtlDropThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "dampening.initial-wait"); value.Exists() {
		data.DampeningInitialWait = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "dampening.secondary-wait"); value.Exists() {
		data.DampeningSecondaryWait = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "dampening.maximum-wait"); value.Exists() {
		data.DampeningMaximumWait = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "dampening.threshold"); value.Exists() {
		data.DampeningThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "dampening.extensions.down-monitoring"); value.Exists() {
		data.DampeningExtensionsDownMonitoring = types.BoolValue(true)
	} else {
		data.DampeningExtensionsDownMonitoring = types.BoolNull()
	}
	if value := res.Get(prefix + "dampening.disable"); value.Exists() {
		data.DampeningDisable = types.BoolValue(true)
	} else {
		data.DampeningDisable = types.BoolNull()
	}
	if value := res.Get(prefix + "dampening.bundle-member.l3-only-mode"); value.Exists() {
		data.DampeningBundleMemberL3OnlyMode = types.BoolValue(true)
	} else {
		data.DampeningBundleMemberL3OnlyMode = types.BoolNull()
	}
	if value := res.Get(prefix + "dampening.bundle-member.initial-wait"); value.Exists() {
		data.DampeningBundleMemberInitialWait = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "dampening.bundle-member.secondary-wait"); value.Exists() {
		data.DampeningBundleMemberSecondaryWait = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "dampening.bundle-member.maximum-wait"); value.Exists() {
		data.DampeningBundleMemberMaximumWait = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "bundle.coexistence.bob-blb"); value.Exists() {
		data.BundleCoexistenceBobBlb = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "ipv6.checksum.disable"); value.Exists() {
		data.Ipv6ChecksumDisable = types.BoolValue(true)
	} else {
		data.Ipv6ChecksumDisable = types.BoolNull()
	}
	if value := res.Get(prefix + "interfaces.interface"); value.Exists() {
		data.Interfaces = make([]BFDInterfaces, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := BFDInterfaces{}
			if cValue := v.Get("interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("echo.disable"); cValue.Exists() {
				item.EchoDisable = types.StringValue(cValue.String())
			}
			if cValue := v.Get("echo.ipv4.source.ipv4-address"); cValue.Exists() {
				item.EchoIpv4Source = types.StringValue(cValue.String())
			}
			if cValue := v.Get("ipv6.checksum.disable"); cValue.Exists() {
				item.Ipv6ChecksumDisable = types.BoolValue(true)
			} else {
				item.Ipv6ChecksumDisable = types.BoolValue(false)
			}
			if cValue := v.Get("disable"); cValue.Exists() {
				item.Disable = types.BoolValue(true)
			} else {
				item.Disable = types.BoolValue(false)
			}
			if cValue := v.Get("local-address"); cValue.Exists() {
				item.LocalAddress = types.StringValue(cValue.String())
			}
			if cValue := v.Get("tx-interval"); cValue.Exists() {
				item.TxInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("rx-interval"); cValue.Exists() {
				item.RxInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("multiplier"); cValue.Exists() {
				item.Multiplier = types.Int64Value(cValue.Int())
			}
			data.Interfaces = append(data.Interfaces, item)
			return true
		})
	}
}

// End of section. //template:end fromBody

// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyData

func (data *BFDData) fromBody(ctx context.Context, res gjson.Result) {
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	if value := res.Get(prefix + "echo.disable"); value.Exists() {
		data.EchoDisable = types.BoolValue(true)
	} else {
		data.EchoDisable = types.BoolNull()
	}
	if value := res.Get(prefix + "echo.latency.detect"); value.Exists() {
		data.EchoLatencyDetect = types.BoolValue(true)
	} else {
		data.EchoLatencyDetect = types.BoolNull()
	}
	if value := res.Get(prefix + "echo.latency.detect.percentage"); value.Exists() {
		data.EchoLatencyDetectPercentage = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "echo.latency.detect.count"); value.Exists() {
		data.EchoLatencyDetectCount = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "echo.startup.validate.force"); value.Exists() {
		data.EchoStartupValidateForce = types.BoolValue(true)
	} else {
		data.EchoStartupValidateForce = types.BoolNull()
	}
	if value := res.Get(prefix + "echo.ipv4.source.ipv4-address"); value.Exists() {
		data.EchoIpv4Source = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "echo.ipv4.bundle-per-member.minimum-interval"); value.Exists() {
		data.EchoIpv4BundlePerMemberMinimumInterval = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "trap.singlehop.pre-mapped"); value.Exists() {
		data.TrapSinglehopPreMapped = types.BoolValue(true)
	} else {
		data.TrapSinglehopPreMapped = types.BoolNull()
	}
	if value := res.Get(prefix + "multipath.include.locations.location"); value.Exists() {
		data.MultipathLocations = make([]BFDMultipathLocations, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := BFDMultipathLocations{}
			if cValue := v.Get("location-id"); cValue.Exists() {
				item.LocationId = types.StringValue(cValue.String())
			}
			data.MultipathLocations = append(data.MultipathLocations, item)
			return true
		})
	}
	if value := res.Get(prefix + "multihop.ttl-drop-threshold"); value.Exists() {
		data.MultihopTtlDropThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "dampening.initial-wait"); value.Exists() {
		data.DampeningInitialWait = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "dampening.secondary-wait"); value.Exists() {
		data.DampeningSecondaryWait = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "dampening.maximum-wait"); value.Exists() {
		data.DampeningMaximumWait = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "dampening.threshold"); value.Exists() {
		data.DampeningThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "dampening.extensions.down-monitoring"); value.Exists() {
		data.DampeningExtensionsDownMonitoring = types.BoolValue(true)
	} else {
		data.DampeningExtensionsDownMonitoring = types.BoolNull()
	}
	if value := res.Get(prefix + "dampening.disable"); value.Exists() {
		data.DampeningDisable = types.BoolValue(true)
	} else {
		data.DampeningDisable = types.BoolNull()
	}
	if value := res.Get(prefix + "dampening.bundle-member.l3-only-mode"); value.Exists() {
		data.DampeningBundleMemberL3OnlyMode = types.BoolValue(true)
	} else {
		data.DampeningBundleMemberL3OnlyMode = types.BoolNull()
	}
	if value := res.Get(prefix + "dampening.bundle-member.initial-wait"); value.Exists() {
		data.DampeningBundleMemberInitialWait = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "dampening.bundle-member.secondary-wait"); value.Exists() {
		data.DampeningBundleMemberSecondaryWait = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "dampening.bundle-member.maximum-wait"); value.Exists() {
		data.DampeningBundleMemberMaximumWait = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "bundle.coexistence.bob-blb"); value.Exists() {
		data.BundleCoexistenceBobBlb = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "ipv6.checksum.disable"); value.Exists() {
		data.Ipv6ChecksumDisable = types.BoolValue(true)
	} else {
		data.Ipv6ChecksumDisable = types.BoolNull()
	}
	if value := res.Get(prefix + "interfaces.interface"); value.Exists() {
		data.Interfaces = make([]BFDInterfaces, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := BFDInterfaces{}
			if cValue := v.Get("interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("echo.disable"); cValue.Exists() {
				item.EchoDisable = types.StringValue(cValue.String())
			}
			if cValue := v.Get("echo.ipv4.source.ipv4-address"); cValue.Exists() {
				item.EchoIpv4Source = types.StringValue(cValue.String())
			}
			if cValue := v.Get("ipv6.checksum.disable"); cValue.Exists() {
				item.Ipv6ChecksumDisable = types.BoolValue(true)
			} else {
				item.Ipv6ChecksumDisable = types.BoolNull()
			}
			if cValue := v.Get("disable"); cValue.Exists() {
				item.Disable = types.BoolValue(true)
			} else {
				item.Disable = types.BoolNull()
			}
			if cValue := v.Get("local-address"); cValue.Exists() {
				item.LocalAddress = types.StringValue(cValue.String())
			}
			if cValue := v.Get("tx-interval"); cValue.Exists() {
				item.TxInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("rx-interval"); cValue.Exists() {
				item.RxInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("multiplier"); cValue.Exists() {
				item.Multiplier = types.Int64Value(cValue.Int())
			}
			data.Interfaces = append(data.Interfaces, item)
			return true
		})
	}
}

// End of section. //template:end fromBodyData

// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyXML

func (data *BFD) fromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/echo/disable"); value.Exists() {
		data.EchoDisable = types.BoolValue(true)
	} else {
		data.EchoDisable = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/echo/latency/detect"); value.Exists() {
		data.EchoLatencyDetect = types.BoolValue(true)
	} else {
		data.EchoLatencyDetect = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/echo/latency/detect/percentage"); value.Exists() {
		data.EchoLatencyDetectPercentage = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/echo/latency/detect/count"); value.Exists() {
		data.EchoLatencyDetectCount = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/echo/startup/validate/force"); value.Exists() {
		data.EchoStartupValidateForce = types.BoolValue(true)
	} else {
		data.EchoStartupValidateForce = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/echo/ipv4/source/ipv4-address"); value.Exists() {
		data.EchoIpv4Source = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/echo/ipv4/bundle-per-member/minimum-interval"); value.Exists() {
		data.EchoIpv4BundlePerMemberMinimumInterval = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/trap/singlehop/pre-mapped"); value.Exists() {
		data.TrapSinglehopPreMapped = types.BoolValue(true)
	} else {
		data.TrapSinglehopPreMapped = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/multipath/include/locations/location"); value.Exists() {
		data.MultipathLocations = make([]BFDMultipathLocations, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := BFDMultipathLocations{}
			if cValue := helpers.GetFromXPath(v, "location-id"); cValue.Exists() {
				item.LocationId = types.StringValue(cValue.String())
			}
			data.MultipathLocations = append(data.MultipathLocations, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/multihop/ttl-drop-threshold"); value.Exists() {
		data.MultihopTtlDropThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/initial-wait"); value.Exists() {
		data.DampeningInitialWait = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/secondary-wait"); value.Exists() {
		data.DampeningSecondaryWait = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/maximum-wait"); value.Exists() {
		data.DampeningMaximumWait = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/threshold"); value.Exists() {
		data.DampeningThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/extensions/down-monitoring"); value.Exists() {
		data.DampeningExtensionsDownMonitoring = types.BoolValue(true)
	} else {
		data.DampeningExtensionsDownMonitoring = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/disable"); value.Exists() {
		data.DampeningDisable = types.BoolValue(true)
	} else {
		data.DampeningDisable = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/bundle-member/l3-only-mode"); value.Exists() {
		data.DampeningBundleMemberL3OnlyMode = types.BoolValue(true)
	} else {
		data.DampeningBundleMemberL3OnlyMode = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/bundle-member/initial-wait"); value.Exists() {
		data.DampeningBundleMemberInitialWait = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/bundle-member/secondary-wait"); value.Exists() {
		data.DampeningBundleMemberSecondaryWait = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/bundle-member/maximum-wait"); value.Exists() {
		data.DampeningBundleMemberMaximumWait = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/bundle/coexistence/bob-blb"); value.Exists() {
		data.BundleCoexistenceBobBlb = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/ipv6/checksum/disable"); value.Exists() {
		data.Ipv6ChecksumDisable = types.BoolValue(true)
	} else {
		data.Ipv6ChecksumDisable = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/interfaces/interface"); value.Exists() {
		data.Interfaces = make([]BFDInterfaces, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := BFDInterfaces{}
			if cValue := helpers.GetFromXPath(v, "interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "echo/disable"); cValue.Exists() {
				item.EchoDisable = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "echo/ipv4/source/ipv4-address"); cValue.Exists() {
				item.EchoIpv4Source = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "ipv6/checksum/disable"); cValue.Exists() {
				item.Ipv6ChecksumDisable = types.BoolValue(true)
			} else {
				item.Ipv6ChecksumDisable = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "disable"); cValue.Exists() {
				item.Disable = types.BoolValue(true)
			} else {
				item.Disable = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "local-address"); cValue.Exists() {
				item.LocalAddress = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "tx-interval"); cValue.Exists() {
				item.TxInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "rx-interval"); cValue.Exists() {
				item.RxInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "multiplier"); cValue.Exists() {
				item.Multiplier = types.Int64Value(cValue.Int())
			}
			data.Interfaces = append(data.Interfaces, item)
			return true
		})
	}
}

// End of section. //template:end fromBodyXML

// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyDataXML

func (data *BFDData) fromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/echo/disable"); value.Exists() {
		data.EchoDisable = types.BoolValue(true)
	} else {
		data.EchoDisable = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/echo/latency/detect"); value.Exists() {
		data.EchoLatencyDetect = types.BoolValue(true)
	} else {
		data.EchoLatencyDetect = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/echo/latency/detect/percentage"); value.Exists() {
		data.EchoLatencyDetectPercentage = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/echo/latency/detect/count"); value.Exists() {
		data.EchoLatencyDetectCount = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/echo/startup/validate/force"); value.Exists() {
		data.EchoStartupValidateForce = types.BoolValue(true)
	} else {
		data.EchoStartupValidateForce = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/echo/ipv4/source/ipv4-address"); value.Exists() {
		data.EchoIpv4Source = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/echo/ipv4/bundle-per-member/minimum-interval"); value.Exists() {
		data.EchoIpv4BundlePerMemberMinimumInterval = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/trap/singlehop/pre-mapped"); value.Exists() {
		data.TrapSinglehopPreMapped = types.BoolValue(true)
	} else {
		data.TrapSinglehopPreMapped = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/multipath/include/locations/location"); value.Exists() {
		data.MultipathLocations = make([]BFDMultipathLocations, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := BFDMultipathLocations{}
			if cValue := helpers.GetFromXPath(v, "location-id"); cValue.Exists() {
				item.LocationId = types.StringValue(cValue.String())
			}
			data.MultipathLocations = append(data.MultipathLocations, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/multihop/ttl-drop-threshold"); value.Exists() {
		data.MultihopTtlDropThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/initial-wait"); value.Exists() {
		data.DampeningInitialWait = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/secondary-wait"); value.Exists() {
		data.DampeningSecondaryWait = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/maximum-wait"); value.Exists() {
		data.DampeningMaximumWait = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/threshold"); value.Exists() {
		data.DampeningThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/extensions/down-monitoring"); value.Exists() {
		data.DampeningExtensionsDownMonitoring = types.BoolValue(true)
	} else {
		data.DampeningExtensionsDownMonitoring = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/disable"); value.Exists() {
		data.DampeningDisable = types.BoolValue(true)
	} else {
		data.DampeningDisable = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/bundle-member/l3-only-mode"); value.Exists() {
		data.DampeningBundleMemberL3OnlyMode = types.BoolValue(true)
	} else {
		data.DampeningBundleMemberL3OnlyMode = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/bundle-member/initial-wait"); value.Exists() {
		data.DampeningBundleMemberInitialWait = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/bundle-member/secondary-wait"); value.Exists() {
		data.DampeningBundleMemberSecondaryWait = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dampening/bundle-member/maximum-wait"); value.Exists() {
		data.DampeningBundleMemberMaximumWait = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/bundle/coexistence/bob-blb"); value.Exists() {
		data.BundleCoexistenceBobBlb = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/ipv6/checksum/disable"); value.Exists() {
		data.Ipv6ChecksumDisable = types.BoolValue(true)
	} else {
		data.Ipv6ChecksumDisable = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/interfaces/interface"); value.Exists() {
		data.Interfaces = make([]BFDInterfaces, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := BFDInterfaces{}
			if cValue := helpers.GetFromXPath(v, "interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "echo/disable"); cValue.Exists() {
				item.EchoDisable = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "echo/ipv4/source/ipv4-address"); cValue.Exists() {
				item.EchoIpv4Source = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "ipv6/checksum/disable"); cValue.Exists() {
				item.Ipv6ChecksumDisable = types.BoolValue(true)
			} else {
				item.Ipv6ChecksumDisable = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "disable"); cValue.Exists() {
				item.Disable = types.BoolValue(true)
			} else {
				item.Disable = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "local-address"); cValue.Exists() {
				item.LocalAddress = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "tx-interval"); cValue.Exists() {
				item.TxInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "rx-interval"); cValue.Exists() {
				item.RxInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "multiplier"); cValue.Exists() {
				item.Multiplier = types.Int64Value(cValue.Int())
			}
			data.Interfaces = append(data.Interfaces, item)
			return true
		})
	}
}

// End of section. //template:end fromBodyDataXML

// Section below is generated&owned by "gen/generator.go". //template:begin getDeletedItems

func (data *BFD) getDeletedItems(ctx context.Context, state BFD) []string {
	deletedItems := make([]string, 0)
	for i := range state.Interfaces {
		keys := [...]string{"interface-name"}
		stateKeyValues := [...]string{state.Interfaces[i].InterfaceName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.Interfaces[i].InterfaceName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Interfaces {
			found = true
			if state.Interfaces[i].InterfaceName.ValueString() != data.Interfaces[j].InterfaceName.ValueString() {
				found = false
			}
			if found {
				if !state.Interfaces[i].Multiplier.IsNull() && data.Interfaces[j].Multiplier.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/multiplier", state.getPath(), keyString))
				}
				if !state.Interfaces[i].RxInterval.IsNull() && data.Interfaces[j].RxInterval.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/rx-interval", state.getPath(), keyString))
				}
				if !state.Interfaces[i].TxInterval.IsNull() && data.Interfaces[j].TxInterval.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/tx-interval", state.getPath(), keyString))
				}
				if !state.Interfaces[i].LocalAddress.IsNull() && data.Interfaces[j].LocalAddress.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/local-address", state.getPath(), keyString))
				}
				if !state.Interfaces[i].Disable.IsNull() && data.Interfaces[j].Disable.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/disable", state.getPath(), keyString))
				}
				if !state.Interfaces[i].Ipv6ChecksumDisable.IsNull() && data.Interfaces[j].Ipv6ChecksumDisable.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/ipv6/checksum", state.getPath(), keyString))
				}
				if !state.Interfaces[i].EchoIpv4Source.IsNull() && data.Interfaces[j].EchoIpv4Source.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/echo/ipv4/source/ipv4-address", state.getPath(), keyString))
				}
				if !state.Interfaces[i].EchoDisable.IsNull() && data.Interfaces[j].EchoDisable.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/echo/disable", state.getPath(), keyString))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v", state.getPath(), keyString))
		}
	}
	if !state.Ipv6ChecksumDisable.IsNull() && data.Ipv6ChecksumDisable.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/ipv6/checksum/disable", state.getPath()))
	}
	if !state.BundleCoexistenceBobBlb.IsNull() && data.BundleCoexistenceBobBlb.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/bundle/coexistence/bob-blb", state.getPath()))
	}
	if !state.DampeningBundleMemberMaximumWait.IsNull() && data.DampeningBundleMemberMaximumWait.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/dampening/bundle-member/maximum-wait", state.getPath()))
	}
	if !state.DampeningBundleMemberSecondaryWait.IsNull() && data.DampeningBundleMemberSecondaryWait.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/dampening/bundle-member/secondary-wait", state.getPath()))
	}
	if !state.DampeningBundleMemberInitialWait.IsNull() && data.DampeningBundleMemberInitialWait.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/dampening/bundle-member/initial-wait", state.getPath()))
	}
	if !state.DampeningBundleMemberL3OnlyMode.IsNull() && data.DampeningBundleMemberL3OnlyMode.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/dampening/bundle-member/l3-only-mode", state.getPath()))
	}
	if !state.DampeningDisable.IsNull() && data.DampeningDisable.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/dampening/disable", state.getPath()))
	}
	if !state.DampeningExtensionsDownMonitoring.IsNull() && data.DampeningExtensionsDownMonitoring.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/dampening/extensions/down-monitoring", state.getPath()))
	}
	if !state.DampeningThreshold.IsNull() && data.DampeningThreshold.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/dampening/threshold", state.getPath()))
	}
	if !state.DampeningMaximumWait.IsNull() && data.DampeningMaximumWait.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/dampening/maximum-wait", state.getPath()))
	}
	if !state.DampeningSecondaryWait.IsNull() && data.DampeningSecondaryWait.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/dampening/secondary-wait", state.getPath()))
	}
	if !state.DampeningInitialWait.IsNull() && data.DampeningInitialWait.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/dampening/initial-wait", state.getPath()))
	}
	if !state.MultihopTtlDropThreshold.IsNull() && data.MultihopTtlDropThreshold.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/multihop/ttl-drop-threshold", state.getPath()))
	}
	for i := range state.MultipathLocations {
		keys := [...]string{"location-id"}
		stateKeyValues := [...]string{state.MultipathLocations[i].LocationId.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.MultipathLocations[i].LocationId.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.MultipathLocations {
			found = true
			if state.MultipathLocations[i].LocationId.ValueString() != data.MultipathLocations[j].LocationId.ValueString() {
				found = false
			}
			if found {
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/multipath/include/locations/location%v", state.getPath(), keyString))
		}
	}
	if !state.TrapSinglehopPreMapped.IsNull() && data.TrapSinglehopPreMapped.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/trap/singlehop/pre-mapped", state.getPath()))
	}
	if !state.EchoIpv4BundlePerMemberMinimumInterval.IsNull() && data.EchoIpv4BundlePerMemberMinimumInterval.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/echo/ipv4/bundle-per-member/minimum-interval", state.getPath()))
	}
	if !state.EchoIpv4Source.IsNull() && data.EchoIpv4Source.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/echo/ipv4/source/ipv4-address", state.getPath()))
	}
	if !state.EchoStartupValidateForce.IsNull() && data.EchoStartupValidateForce.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/echo/startup/validate", state.getPath()))
	}
	if !state.EchoLatencyDetectCount.IsNull() && data.EchoLatencyDetectCount.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/echo/latency/detect", state.getPath()))
	}
	if !state.EchoLatencyDetectPercentage.IsNull() && data.EchoLatencyDetectPercentage.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/echo/latency/detect", state.getPath()))
	}
	if !state.EchoLatencyDetect.IsNull() && data.EchoLatencyDetect.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/echo/latency/detect", state.getPath()))
	}
	if !state.EchoDisable.IsNull() && data.EchoDisable.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/echo/disable", state.getPath()))
	}
	return deletedItems
}

// End of section. //template:end getDeletedItems

// Section below is generated&owned by "gen/generator.go". //template:begin getEmptyLeafsDelete

func (data *BFD) getEmptyLeafsDelete(ctx context.Context, state *BFD) []string {
	emptyLeafsDelete := make([]string, 0)
	for i := range data.Interfaces {
		keys := [...]string{"interface-name"}
		keyValues := [...]string{data.Interfaces[i].InterfaceName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		// Only delete if state has true and plan has false
		if !data.Interfaces[i].Disable.IsNull() && !data.Interfaces[i].Disable.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Interfaces) && !state.Interfaces[i].Disable.IsNull() && state.Interfaces[i].Disable.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/interfaces/interface%v/disable", data.getXPath(), keyString))
			}
		}
		// Only delete if state has true and plan has false
		if !data.Interfaces[i].Ipv6ChecksumDisable.IsNull() && !data.Interfaces[i].Ipv6ChecksumDisable.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Interfaces) && !state.Interfaces[i].Ipv6ChecksumDisable.IsNull() && state.Interfaces[i].Ipv6ChecksumDisable.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/interfaces/interface%v/ipv6/checksum", data.getXPath(), keyString))
			}
		}
	}
	// Only delete if state has true and plan has false
	if !data.Ipv6ChecksumDisable.IsNull() && !data.Ipv6ChecksumDisable.ValueBool() {
		if state != nil && !state.Ipv6ChecksumDisable.IsNull() && state.Ipv6ChecksumDisable.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/ipv6/checksum/disable", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.DampeningBundleMemberL3OnlyMode.IsNull() && !data.DampeningBundleMemberL3OnlyMode.ValueBool() {
		if state != nil && !state.DampeningBundleMemberL3OnlyMode.IsNull() && state.DampeningBundleMemberL3OnlyMode.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/dampening/bundle-member/l3-only-mode", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.DampeningDisable.IsNull() && !data.DampeningDisable.ValueBool() {
		if state != nil && !state.DampeningDisable.IsNull() && state.DampeningDisable.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/dampening/disable", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.DampeningExtensionsDownMonitoring.IsNull() && !data.DampeningExtensionsDownMonitoring.ValueBool() {
		if state != nil && !state.DampeningExtensionsDownMonitoring.IsNull() && state.DampeningExtensionsDownMonitoring.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/dampening/extensions/down-monitoring", data.getXPath()))
		}
	}
	for i := range data.MultipathLocations {
		keys := [...]string{"location-id"}
		keyValues := [...]string{data.MultipathLocations[i].LocationId.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
	}
	// Only delete if state has true and plan has false
	if !data.TrapSinglehopPreMapped.IsNull() && !data.TrapSinglehopPreMapped.ValueBool() {
		if state != nil && !state.TrapSinglehopPreMapped.IsNull() && state.TrapSinglehopPreMapped.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/trap/singlehop/pre-mapped", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.EchoStartupValidateForce.IsNull() && !data.EchoStartupValidateForce.ValueBool() {
		if state != nil && !state.EchoStartupValidateForce.IsNull() && state.EchoStartupValidateForce.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/echo/startup/validate", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.EchoLatencyDetect.IsNull() && !data.EchoLatencyDetect.ValueBool() {
		if state != nil && !state.EchoLatencyDetect.IsNull() && state.EchoLatencyDetect.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/echo/latency/detect", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.EchoDisable.IsNull() && !data.EchoDisable.ValueBool() {
		if state != nil && !state.EchoDisable.IsNull() && state.EchoDisable.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/echo/disable", data.getXPath()))
		}
	}
	return emptyLeafsDelete
}

// End of section. //template:end getEmptyLeafsDelete

// Section below is generated&owned by "gen/generator.go". //template:begin getDeletePaths

func (data *BFD) getDeletePaths(ctx context.Context) []string {
	var deletePaths []string
	for i := range data.Interfaces {
		keyValues := [...]string{data.Interfaces[i].InterfaceName.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/interfaces/interface=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	if !data.Ipv6ChecksumDisable.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/ipv6/checksum/disable", data.getPath()))
	}
	if !data.BundleCoexistenceBobBlb.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/bundle/coexistence/bob-blb", data.getPath()))
	}
	if !data.DampeningBundleMemberMaximumWait.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/dampening/bundle-member/maximum-wait", data.getPath()))
	}
	if !data.DampeningBundleMemberSecondaryWait.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/dampening/bundle-member/secondary-wait", data.getPath()))
	}
	if !data.DampeningBundleMemberInitialWait.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/dampening/bundle-member/initial-wait", data.getPath()))
	}
	if !data.DampeningBundleMemberL3OnlyMode.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/dampening/bundle-member/l3-only-mode", data.getPath()))
	}
	if !data.DampeningDisable.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/dampening/disable", data.getPath()))
	}
	if !data.DampeningExtensionsDownMonitoring.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/dampening/extensions/down-monitoring", data.getPath()))
	}
	if !data.DampeningThreshold.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/dampening/threshold", data.getPath()))
	}
	if !data.DampeningMaximumWait.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/dampening/maximum-wait", data.getPath()))
	}
	if !data.DampeningSecondaryWait.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/dampening/secondary-wait", data.getPath()))
	}
	if !data.DampeningInitialWait.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/dampening/initial-wait", data.getPath()))
	}
	if !data.MultihopTtlDropThreshold.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/multihop/ttl-drop-threshold", data.getPath()))
	}
	for i := range data.MultipathLocations {
		keyValues := [...]string{data.MultipathLocations[i].LocationId.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/multipath/include/locations/location=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	if !data.TrapSinglehopPreMapped.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/trap/singlehop/pre-mapped", data.getPath()))
	}
	if !data.EchoIpv4BundlePerMemberMinimumInterval.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/echo/ipv4/bundle-per-member/minimum-interval", data.getPath()))
	}
	if !data.EchoIpv4Source.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/echo/ipv4/source/ipv4-address", data.getPath()))
	}
	if !data.EchoStartupValidateForce.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/echo/startup/validate", data.getPath()))
	}
	if !data.EchoLatencyDetectCount.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/echo/latency/detect", data.getPath()))
	}
	if !data.EchoLatencyDetectPercentage.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/echo/latency/detect", data.getPath()))
	}
	if !data.EchoLatencyDetect.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/echo/latency/detect", data.getPath()))
	}
	if !data.EchoDisable.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/echo/disable", data.getPath()))
	}

	return deletePaths
}

// End of section. //template:end getDeletePaths

// Section below is generated&owned by "gen/generator.go". //template:begin addDeletedItemsXML

func (data *BFD) addDeletedItemsXML(ctx context.Context, state BFD, body string) string {
	deleteXml := ""
	deletedPaths := make(map[string]bool)
	_ = deletedPaths // Avoid unused variable error when no delete_parent attributes exist
	for i := range state.Interfaces {
		stateKeys := [...]string{"interface-name"}
		stateKeyValues := [...]string{state.Interfaces[i].InterfaceName.ValueString()}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.Interfaces[i].InterfaceName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Interfaces {
			found = true
			if state.Interfaces[i].InterfaceName.ValueString() != data.Interfaces[j].InterfaceName.ValueString() {
				found = false
			}
			if found {
				if !state.Interfaces[i].Multiplier.IsNull() && data.Interfaces[j].Multiplier.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/multiplier", predicates))
				}
				if !state.Interfaces[i].RxInterval.IsNull() && data.Interfaces[j].RxInterval.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/rx-interval", predicates))
				}
				if !state.Interfaces[i].TxInterval.IsNull() && data.Interfaces[j].TxInterval.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/tx-interval", predicates))
				}
				if !state.Interfaces[i].LocalAddress.IsNull() && data.Interfaces[j].LocalAddress.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/local-address", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Interfaces[i].Disable.IsNull() && state.Interfaces[i].Disable.ValueBool() && data.Interfaces[j].Disable.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/disable", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Interfaces[i].Ipv6ChecksumDisable.IsNull() && state.Interfaces[i].Ipv6ChecksumDisable.ValueBool() && data.Interfaces[j].Ipv6ChecksumDisable.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/ipv6/checksum", predicates))
				}
				if !state.Interfaces[i].EchoIpv4Source.IsNull() && data.Interfaces[j].EchoIpv4Source.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/echo/ipv4/source/ipv4-address", predicates))
				}
				if !state.Interfaces[i].EchoDisable.IsNull() && data.Interfaces[j].EchoDisable.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/echo/disable", predicates))
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v", predicates))
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.Ipv6ChecksumDisable.IsNull() && state.Ipv6ChecksumDisable.ValueBool() && data.Ipv6ChecksumDisable.IsNull() {
		deletePath := state.getXPath() + "/ipv6/checksum/disable"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.BundleCoexistenceBobBlb.IsNull() && data.BundleCoexistenceBobBlb.IsNull() {
		deletePath := state.getXPath() + "/bundle/coexistence/bob-blb"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.DampeningBundleMemberMaximumWait.IsNull() && data.DampeningBundleMemberMaximumWait.IsNull() {
		deletePath := state.getXPath() + "/dampening/bundle-member/maximum-wait"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.DampeningBundleMemberSecondaryWait.IsNull() && data.DampeningBundleMemberSecondaryWait.IsNull() {
		deletePath := state.getXPath() + "/dampening/bundle-member/secondary-wait"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.DampeningBundleMemberInitialWait.IsNull() && data.DampeningBundleMemberInitialWait.IsNull() {
		deletePath := state.getXPath() + "/dampening/bundle-member/initial-wait"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.DampeningBundleMemberL3OnlyMode.IsNull() && state.DampeningBundleMemberL3OnlyMode.ValueBool() && data.DampeningBundleMemberL3OnlyMode.IsNull() {
		deletePath := state.getXPath() + "/dampening/bundle-member/l3-only-mode"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.DampeningDisable.IsNull() && state.DampeningDisable.ValueBool() && data.DampeningDisable.IsNull() {
		deletePath := state.getXPath() + "/dampening/disable"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.DampeningExtensionsDownMonitoring.IsNull() && state.DampeningExtensionsDownMonitoring.ValueBool() && data.DampeningExtensionsDownMonitoring.IsNull() {
		deletePath := state.getXPath() + "/dampening/extensions/down-monitoring"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.DampeningThreshold.IsNull() && data.DampeningThreshold.IsNull() {
		deletePath := state.getXPath() + "/dampening/threshold"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.DampeningMaximumWait.IsNull() && data.DampeningMaximumWait.IsNull() {
		deletePath := state.getXPath() + "/dampening/maximum-wait"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.DampeningSecondaryWait.IsNull() && data.DampeningSecondaryWait.IsNull() {
		deletePath := state.getXPath() + "/dampening/secondary-wait"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.DampeningInitialWait.IsNull() && data.DampeningInitialWait.IsNull() {
		deletePath := state.getXPath() + "/dampening/initial-wait"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MultihopTtlDropThreshold.IsNull() && data.MultihopTtlDropThreshold.IsNull() {
		deletePath := state.getXPath() + "/multihop/ttl-drop-threshold"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	for i := range state.MultipathLocations {
		stateKeys := [...]string{"location-id"}
		stateKeyValues := [...]string{state.MultipathLocations[i].LocationId.ValueString()}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.MultipathLocations[i].LocationId.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.MultipathLocations {
			found = true
			if state.MultipathLocations[i].LocationId.ValueString() != data.MultipathLocations[j].LocationId.ValueString() {
				found = false
			}
			if found {
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/multipath/include/locations/location%v", predicates))
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.TrapSinglehopPreMapped.IsNull() && state.TrapSinglehopPreMapped.ValueBool() && data.TrapSinglehopPreMapped.IsNull() {
		deletePath := state.getXPath() + "/trap/singlehop/pre-mapped"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.EchoIpv4BundlePerMemberMinimumInterval.IsNull() && data.EchoIpv4BundlePerMemberMinimumInterval.IsNull() {
		deletePath := state.getXPath() + "/echo/ipv4/bundle-per-member/minimum-interval"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.EchoIpv4Source.IsNull() && data.EchoIpv4Source.IsNull() {
		deletePath := state.getXPath() + "/echo/ipv4/source/ipv4-address"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.EchoStartupValidateForce.IsNull() && state.EchoStartupValidateForce.ValueBool() && data.EchoStartupValidateForce.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/echo/startup/validate"
		predicates := make(map[string]string)
		predicates["force"] = fmt.Sprintf("%v", state.EchoStartupValidateForce.ValueBool())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.EchoLatencyDetectCount.IsNull() && data.EchoLatencyDetectCount.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/echo/latency/detect"
		predicates := make(map[string]string)
		if !state.EchoLatencyDetectPercentage.IsNull() {
			predicates["percentage"] = fmt.Sprintf("%v", state.EchoLatencyDetectPercentage.ValueInt64())
		}
		predicates["count"] = fmt.Sprintf("%v", state.EchoLatencyDetectCount.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.EchoLatencyDetectPercentage.IsNull() && data.EchoLatencyDetectPercentage.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/echo/latency/detect"
		predicates := make(map[string]string)
		if !state.EchoLatencyDetectCount.IsNull() {
			predicates["count"] = fmt.Sprintf("%v", state.EchoLatencyDetectCount.ValueInt64())
		}
		predicates["percentage"] = fmt.Sprintf("%v", state.EchoLatencyDetectPercentage.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.EchoLatencyDetect.IsNull() && state.EchoLatencyDetect.ValueBool() && data.EchoLatencyDetect.IsNull() {
		deletePath := state.getXPath() + "/echo/latency/detect"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.EchoDisable.IsNull() && state.EchoDisable.ValueBool() && data.EchoDisable.IsNull() {
		deletePath := state.getXPath() + "/echo/disable"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}

	b := netconf.NewBody(deleteXml)
	b = helpers.CleanupRedundantRemoveOperations(b)
	return b.Res()
}

// End of section. //template:end addDeletedItemsXML

// Section below is generated&owned by "gen/generator.go". //template:begin addDeletePathsXML

func (data *BFD) addDeletePathsXML(ctx context.Context, body string) string {
	b := netconf.NewBody(body)
	for i := range data.Interfaces {
		keys := [...]string{"interface-name"}
		keyValues := [...]string{data.Interfaces[i].InterfaceName.ValueString()}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/interfaces/interface%v", predicates))
	}
	if !data.Ipv6ChecksumDisable.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/ipv6/checksum/disable")
	}
	if !data.BundleCoexistenceBobBlb.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/bundle/coexistence/bob-blb")
	}
	if !data.DampeningBundleMemberMaximumWait.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/dampening/bundle-member/maximum-wait")
	}
	if !data.DampeningBundleMemberSecondaryWait.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/dampening/bundle-member/secondary-wait")
	}
	if !data.DampeningBundleMemberInitialWait.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/dampening/bundle-member/initial-wait")
	}
	if !data.DampeningBundleMemberL3OnlyMode.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/dampening/bundle-member/l3-only-mode")
	}
	if !data.DampeningDisable.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/dampening/disable")
	}
	if !data.DampeningExtensionsDownMonitoring.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/dampening/extensions/down-monitoring")
	}
	if !data.DampeningThreshold.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/dampening/threshold")
	}
	if !data.DampeningMaximumWait.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/dampening/maximum-wait")
	}
	if !data.DampeningSecondaryWait.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/dampening/secondary-wait")
	}
	if !data.DampeningInitialWait.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/dampening/initial-wait")
	}
	if !data.MultihopTtlDropThreshold.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/multihop/ttl-drop-threshold")
	}
	for i := range data.MultipathLocations {
		keys := [...]string{"location-id"}
		keyValues := [...]string{data.MultipathLocations[i].LocationId.ValueString()}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/multipath/include/locations/location%v", predicates))
	}
	if !data.TrapSinglehopPreMapped.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/trap/singlehop/pre-mapped")
	}
	if !data.EchoIpv4BundlePerMemberMinimumInterval.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/echo/ipv4/bundle-per-member/minimum-interval")
	}
	if !data.EchoIpv4Source.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/echo/ipv4/source/ipv4-address")
	}
	if !data.EchoStartupValidateForce.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/echo/startup/validate")
	}
	if !data.EchoLatencyDetectCount.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/echo/latency/detect")
	}
	if !data.EchoLatencyDetectPercentage.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/echo/latency/detect")
	}
	if !data.EchoLatencyDetect.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/echo/latency/detect")
	}
	if !data.EchoDisable.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/echo/disable")
	}

	b = helpers.CleanupRedundantRemoveOperations(b)
	return b.Res()
}

// End of section. //template:end addDeletePathsXML
