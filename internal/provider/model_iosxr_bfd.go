// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"reflect"
	"strconv"

	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

type BFD struct {
	Device                                          types.String            `tfsdk:"device"`
	Id                                              types.String            `tfsdk:"id"`
	DeleteMode                                      types.String            `tfsdk:"delete_mode"`
	EchoDisable                                     types.Bool              `tfsdk:"echo_disable"`
	EchoLatencyDetectPercentage                     types.Int64             `tfsdk:"echo_latency_detect_percentage"`
	EchoLatencyDetectCount                          types.Int64             `tfsdk:"echo_latency_detect_count"`
	EchoStartupValidateForce                        types.Bool              `tfsdk:"echo_startup_validate_force"`
	EchoIpv4Source                                  types.String            `tfsdk:"echo_ipv4_source"`
	EchoIpv4BundlePerMemberPreferredMinimumInterval types.Int64             `tfsdk:"echo_ipv4_bundle_per_member_preferred_minimum_interval"`
	TrapSinglehopPreMapped                          types.Bool              `tfsdk:"trap_singlehop_pre_mapped"`
	MultipathLocations                              []BFDMultipathLocations `tfsdk:"multipath_locations"`
	MultihopTtlDropThreshold                        types.Int64             `tfsdk:"multihop_ttl_drop_threshold"`
	DampeningInitialWait                            types.Int64             `tfsdk:"dampening_initial_wait"`
	DampeningSecondaryWait                          types.Int64             `tfsdk:"dampening_secondary_wait"`
	DampeningMaximumWait                            types.Int64             `tfsdk:"dampening_maximum_wait"`
	DampeningThreshold                              types.Int64             `tfsdk:"dampening_threshold"`
	DampeningExtensionsDownMonitoring               types.Bool              `tfsdk:"dampening_extensions_down_monitoring"`
	DampeningDisable                                types.Bool              `tfsdk:"dampening_disable"`
	DampeningBundleMemberL3OnlyMode                 types.Bool              `tfsdk:"dampening_bundle_member_l3_only_mode"`
	DampeningBundleMemberInitialWait                types.Int64             `tfsdk:"dampening_bundle_member_initial_wait"`
	DampeningBundleMemberSecondaryWait              types.Int64             `tfsdk:"dampening_bundle_member_secondary_wait"`
	DampeningBundleMemberMaximumWait                types.Int64             `tfsdk:"dampening_bundle_member_maximum_wait"`
	BundleCoexistenceBobBlbInherit                  types.Bool              `tfsdk:"bundle_coexistence_bob_blb_inherit"`
	BundleCoexistenceBobBlbLogical                  types.Bool              `tfsdk:"bundle_coexistence_bob_blb_logical"`
	Interfaces                                      []BFDInterfaces         `tfsdk:"interfaces"`
	Ipv6ChecksumDisable                             types.Bool              `tfsdk:"ipv6_checksum_disable"`
}

type BFDData struct {
	Device                                          types.String            `tfsdk:"device"`
	Id                                              types.String            `tfsdk:"id"`
	EchoDisable                                     types.Bool              `tfsdk:"echo_disable"`
	EchoLatencyDetectPercentage                     types.Int64             `tfsdk:"echo_latency_detect_percentage"`
	EchoLatencyDetectCount                          types.Int64             `tfsdk:"echo_latency_detect_count"`
	EchoStartupValidateForce                        types.Bool              `tfsdk:"echo_startup_validate_force"`
	EchoIpv4Source                                  types.String            `tfsdk:"echo_ipv4_source"`
	EchoIpv4BundlePerMemberPreferredMinimumInterval types.Int64             `tfsdk:"echo_ipv4_bundle_per_member_preferred_minimum_interval"`
	TrapSinglehopPreMapped                          types.Bool              `tfsdk:"trap_singlehop_pre_mapped"`
	MultipathLocations                              []BFDMultipathLocations `tfsdk:"multipath_locations"`
	MultihopTtlDropThreshold                        types.Int64             `tfsdk:"multihop_ttl_drop_threshold"`
	DampeningInitialWait                            types.Int64             `tfsdk:"dampening_initial_wait"`
	DampeningSecondaryWait                          types.Int64             `tfsdk:"dampening_secondary_wait"`
	DampeningMaximumWait                            types.Int64             `tfsdk:"dampening_maximum_wait"`
	DampeningThreshold                              types.Int64             `tfsdk:"dampening_threshold"`
	DampeningExtensionsDownMonitoring               types.Bool              `tfsdk:"dampening_extensions_down_monitoring"`
	DampeningDisable                                types.Bool              `tfsdk:"dampening_disable"`
	DampeningBundleMemberL3OnlyMode                 types.Bool              `tfsdk:"dampening_bundle_member_l3_only_mode"`
	DampeningBundleMemberInitialWait                types.Int64             `tfsdk:"dampening_bundle_member_initial_wait"`
	DampeningBundleMemberSecondaryWait              types.Int64             `tfsdk:"dampening_bundle_member_secondary_wait"`
	DampeningBundleMemberMaximumWait                types.Int64             `tfsdk:"dampening_bundle_member_maximum_wait"`
	BundleCoexistenceBobBlbInherit                  types.Bool              `tfsdk:"bundle_coexistence_bob_blb_inherit"`
	BundleCoexistenceBobBlbLogical                  types.Bool              `tfsdk:"bundle_coexistence_bob_blb_logical"`
	Interfaces                                      []BFDInterfaces         `tfsdk:"interfaces"`
	Ipv6ChecksumDisable                             types.Bool              `tfsdk:"ipv6_checksum_disable"`
}
type BFDMultipathLocations struct {
	LocationName types.String `tfsdk:"location_name"`
}
type BFDInterfaces struct {
	InterfaceName       types.String `tfsdk:"interface_name"`
	EchoDisable         types.Bool   `tfsdk:"echo_disable"`
	EchoIpv4Source      types.String `tfsdk:"echo_ipv4_source"`
	Ipv6ChecksumDisable types.Bool   `tfsdk:"ipv6_checksum_disable"`
	Disable             types.Bool   `tfsdk:"disable"`
	LocalAddress        types.String `tfsdk:"local_address"`
	TxInterval          types.Int64  `tfsdk:"tx_interval"`
	RxInterval          types.Int64  `tfsdk:"rx_interval"`
	Multiplier          types.Int64  `tfsdk:"multiplier"`
}

func (data BFD) getPath() string {
	return "Cisco-IOS-XR-um-bfd-sbfd-cfg:/bfd"
}

func (data BFDData) getPath() string {
	return "Cisco-IOS-XR-um-bfd-sbfd-cfg:/bfd"
}

func (data BFD) toBody(ctx context.Context) string {
	body := "{}"
	if !data.EchoDisable.IsNull() && !data.EchoDisable.IsUnknown() {
		if data.EchoDisable.ValueBool() {
			body, _ = sjson.Set(body, "echo.disable", map[string]string{})
		}
	}
	if !data.EchoLatencyDetectPercentage.IsNull() && !data.EchoLatencyDetectPercentage.IsUnknown() {
		body, _ = sjson.Set(body, "echo.latency.detect.percentage", strconv.FormatInt(data.EchoLatencyDetectPercentage.ValueInt64(), 10))
	}
	if !data.EchoLatencyDetectCount.IsNull() && !data.EchoLatencyDetectCount.IsUnknown() {
		body, _ = sjson.Set(body, "echo.latency.detect.count", strconv.FormatInt(data.EchoLatencyDetectCount.ValueInt64(), 10))
	}
	if !data.EchoStartupValidateForce.IsNull() && !data.EchoStartupValidateForce.IsUnknown() {
		if data.EchoStartupValidateForce.ValueBool() {
			body, _ = sjson.Set(body, "echo.startup.validate.force", map[string]string{})
		}
	}
	if !data.EchoIpv4Source.IsNull() && !data.EchoIpv4Source.IsUnknown() {
		body, _ = sjson.Set(body, "echo.ipv4.source", data.EchoIpv4Source.ValueString())
	}
	if !data.EchoIpv4BundlePerMemberPreferredMinimumInterval.IsNull() && !data.EchoIpv4BundlePerMemberPreferredMinimumInterval.IsUnknown() {
		body, _ = sjson.Set(body, "echo.ipv4.bundle-per-member.minimum-interval.preferred-minimum-interval", strconv.FormatInt(data.EchoIpv4BundlePerMemberPreferredMinimumInterval.ValueInt64(), 10))
	}
	if !data.TrapSinglehopPreMapped.IsNull() && !data.TrapSinglehopPreMapped.IsUnknown() {
		if data.TrapSinglehopPreMapped.ValueBool() {
			body, _ = sjson.Set(body, "trap.singlehop.pre-mapped", map[string]string{})
		}
	}
	if !data.MultihopTtlDropThreshold.IsNull() && !data.MultihopTtlDropThreshold.IsUnknown() {
		body, _ = sjson.Set(body, "multihop.ttl-drop-threshold", strconv.FormatInt(data.MultihopTtlDropThreshold.ValueInt64(), 10))
	}
	if !data.DampeningInitialWait.IsNull() && !data.DampeningInitialWait.IsUnknown() {
		body, _ = sjson.Set(body, "dampening.initial-wait", strconv.FormatInt(data.DampeningInitialWait.ValueInt64(), 10))
	}
	if !data.DampeningSecondaryWait.IsNull() && !data.DampeningSecondaryWait.IsUnknown() {
		body, _ = sjson.Set(body, "dampening.secondary-wait", strconv.FormatInt(data.DampeningSecondaryWait.ValueInt64(), 10))
	}
	if !data.DampeningMaximumWait.IsNull() && !data.DampeningMaximumWait.IsUnknown() {
		body, _ = sjson.Set(body, "dampening.maximum-wait", strconv.FormatInt(data.DampeningMaximumWait.ValueInt64(), 10))
	}
	if !data.DampeningThreshold.IsNull() && !data.DampeningThreshold.IsUnknown() {
		body, _ = sjson.Set(body, "dampening.threshold", strconv.FormatInt(data.DampeningThreshold.ValueInt64(), 10))
	}
	if !data.DampeningExtensionsDownMonitoring.IsNull() && !data.DampeningExtensionsDownMonitoring.IsUnknown() {
		if data.DampeningExtensionsDownMonitoring.ValueBool() {
			body, _ = sjson.Set(body, "dampening.extensions.down-monitoring", map[string]string{})
		}
	}
	if !data.DampeningDisable.IsNull() && !data.DampeningDisable.IsUnknown() {
		if data.DampeningDisable.ValueBool() {
			body, _ = sjson.Set(body, "dampening.disable", map[string]string{})
		}
	}
	if !data.DampeningBundleMemberL3OnlyMode.IsNull() && !data.DampeningBundleMemberL3OnlyMode.IsUnknown() {
		if data.DampeningBundleMemberL3OnlyMode.ValueBool() {
			body, _ = sjson.Set(body, "dampening.bundle-member.l3-only-mode", map[string]string{})
		}
	}
	if !data.DampeningBundleMemberInitialWait.IsNull() && !data.DampeningBundleMemberInitialWait.IsUnknown() {
		body, _ = sjson.Set(body, "dampening.bundle-member.initial-wait", strconv.FormatInt(data.DampeningBundleMemberInitialWait.ValueInt64(), 10))
	}
	if !data.DampeningBundleMemberSecondaryWait.IsNull() && !data.DampeningBundleMemberSecondaryWait.IsUnknown() {
		body, _ = sjson.Set(body, "dampening.bundle-member.secondary-wait", strconv.FormatInt(data.DampeningBundleMemberSecondaryWait.ValueInt64(), 10))
	}
	if !data.DampeningBundleMemberMaximumWait.IsNull() && !data.DampeningBundleMemberMaximumWait.IsUnknown() {
		body, _ = sjson.Set(body, "dampening.bundle-member.maximum-wait", strconv.FormatInt(data.DampeningBundleMemberMaximumWait.ValueInt64(), 10))
	}
	if !data.BundleCoexistenceBobBlbInherit.IsNull() && !data.BundleCoexistenceBobBlbInherit.IsUnknown() {
		if data.BundleCoexistenceBobBlbInherit.ValueBool() {
			body, _ = sjson.Set(body, "bundle.coexistence.bob-blb.inherit", map[string]string{})
		}
	}
	if !data.BundleCoexistenceBobBlbLogical.IsNull() && !data.BundleCoexistenceBobBlbLogical.IsUnknown() {
		if data.BundleCoexistenceBobBlbLogical.ValueBool() {
			body, _ = sjson.Set(body, "bundle.coexistence.bob-blb.logical", map[string]string{})
		}
	}
	if !data.Ipv6ChecksumDisable.IsNull() && !data.Ipv6ChecksumDisable.IsUnknown() {
		if data.Ipv6ChecksumDisable.ValueBool() {
			body, _ = sjson.Set(body, "ipv6.checksum.disable", map[string]string{})
		}
	}
	if len(data.MultipathLocations) > 0 {
		body, _ = sjson.Set(body, "multipath.include.locations.location", []interface{}{})
		for index, item := range data.MultipathLocations {
			if !item.LocationName.IsNull() && !item.LocationName.IsUnknown() {
				body, _ = sjson.Set(body, "multipath.include.locations.location"+"."+strconv.Itoa(index)+"."+"location-name", item.LocationName.ValueString())
			}
		}
	}
	if len(data.Interfaces) > 0 {
		body, _ = sjson.Set(body, "interfaces.interface", []interface{}{})
		for index, item := range data.Interfaces {
			if !item.InterfaceName.IsNull() && !item.InterfaceName.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"interface-name", item.InterfaceName.ValueString())
			}
			if !item.EchoDisable.IsNull() && !item.EchoDisable.IsUnknown() {
				if item.EchoDisable.ValueBool() {
					body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"echo.disable", map[string]string{})
				}
			}
			if !item.EchoIpv4Source.IsNull() && !item.EchoIpv4Source.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"echo.ipv4.source", item.EchoIpv4Source.ValueString())
			}
			if !item.Ipv6ChecksumDisable.IsNull() && !item.Ipv6ChecksumDisable.IsUnknown() {
				if item.Ipv6ChecksumDisable.ValueBool() {
					body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"ipv6.checksum.disable", map[string]string{})
				}
			}
			if !item.Disable.IsNull() && !item.Disable.IsUnknown() {
				if item.Disable.ValueBool() {
					body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"disable", map[string]string{})
				}
			}
			if !item.LocalAddress.IsNull() && !item.LocalAddress.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"local-address", item.LocalAddress.ValueString())
			}
			if !item.TxInterval.IsNull() && !item.TxInterval.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"tx-interval", strconv.FormatInt(item.TxInterval.ValueInt64(), 10))
			}
			if !item.RxInterval.IsNull() && !item.RxInterval.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"rx-interval", strconv.FormatInt(item.RxInterval.ValueInt64(), 10))
			}
			if !item.Multiplier.IsNull() && !item.Multiplier.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"multiplier", strconv.FormatInt(item.Multiplier.ValueInt64(), 10))
			}
		}
	}
	return body
}

func (data *BFD) updateFromBody(ctx context.Context, res []byte) {
	if value := gjson.GetBytes(res, "echo.disable"); !data.EchoDisable.IsNull() {
		if value.Exists() {
			data.EchoDisable = types.BoolValue(true)
		} else {
			data.EchoDisable = types.BoolValue(false)
		}
	} else {
		data.EchoDisable = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "echo.latency.detect.percentage"); value.Exists() && !data.EchoLatencyDetectPercentage.IsNull() {
		data.EchoLatencyDetectPercentage = types.Int64Value(value.Int())
	} else {
		data.EchoLatencyDetectPercentage = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "echo.latency.detect.count"); value.Exists() && !data.EchoLatencyDetectCount.IsNull() {
		data.EchoLatencyDetectCount = types.Int64Value(value.Int())
	} else {
		data.EchoLatencyDetectCount = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "echo.startup.validate.force"); !data.EchoStartupValidateForce.IsNull() {
		if value.Exists() {
			data.EchoStartupValidateForce = types.BoolValue(true)
		} else {
			data.EchoStartupValidateForce = types.BoolValue(false)
		}
	} else {
		data.EchoStartupValidateForce = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "echo.ipv4.source"); value.Exists() && !data.EchoIpv4Source.IsNull() {
		data.EchoIpv4Source = types.StringValue(value.String())
	} else {
		data.EchoIpv4Source = types.StringNull()
	}
	if value := gjson.GetBytes(res, "echo.ipv4.bundle-per-member.minimum-interval.preferred-minimum-interval"); value.Exists() && !data.EchoIpv4BundlePerMemberPreferredMinimumInterval.IsNull() {
		data.EchoIpv4BundlePerMemberPreferredMinimumInterval = types.Int64Value(value.Int())
	} else {
		data.EchoIpv4BundlePerMemberPreferredMinimumInterval = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "trap.singlehop.pre-mapped"); !data.TrapSinglehopPreMapped.IsNull() {
		if value.Exists() {
			data.TrapSinglehopPreMapped = types.BoolValue(true)
		} else {
			data.TrapSinglehopPreMapped = types.BoolValue(false)
		}
	} else {
		data.TrapSinglehopPreMapped = types.BoolNull()
	}
	for i := range data.MultipathLocations {
		keys := [...]string{"location-name"}
		keyValues := [...]string{data.MultipathLocations[i].LocationName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "multipath.include.locations.location").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("location-name"); value.Exists() && !data.MultipathLocations[i].LocationName.IsNull() {
			data.MultipathLocations[i].LocationName = types.StringValue(value.String())
		} else {
			data.MultipathLocations[i].LocationName = types.StringNull()
		}
	}
	if value := gjson.GetBytes(res, "multihop.ttl-drop-threshold"); value.Exists() && !data.MultihopTtlDropThreshold.IsNull() {
		data.MultihopTtlDropThreshold = types.Int64Value(value.Int())
	} else {
		data.MultihopTtlDropThreshold = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "dampening.initial-wait"); value.Exists() && !data.DampeningInitialWait.IsNull() {
		data.DampeningInitialWait = types.Int64Value(value.Int())
	} else {
		data.DampeningInitialWait = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "dampening.secondary-wait"); value.Exists() && !data.DampeningSecondaryWait.IsNull() {
		data.DampeningSecondaryWait = types.Int64Value(value.Int())
	} else {
		data.DampeningSecondaryWait = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "dampening.maximum-wait"); value.Exists() && !data.DampeningMaximumWait.IsNull() {
		data.DampeningMaximumWait = types.Int64Value(value.Int())
	} else {
		data.DampeningMaximumWait = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "dampening.threshold"); value.Exists() && !data.DampeningThreshold.IsNull() {
		data.DampeningThreshold = types.Int64Value(value.Int())
	} else {
		data.DampeningThreshold = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "dampening.extensions.down-monitoring"); !data.DampeningExtensionsDownMonitoring.IsNull() {
		if value.Exists() {
			data.DampeningExtensionsDownMonitoring = types.BoolValue(true)
		} else {
			data.DampeningExtensionsDownMonitoring = types.BoolValue(false)
		}
	} else {
		data.DampeningExtensionsDownMonitoring = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "dampening.disable"); !data.DampeningDisable.IsNull() {
		if value.Exists() {
			data.DampeningDisable = types.BoolValue(true)
		} else {
			data.DampeningDisable = types.BoolValue(false)
		}
	} else {
		data.DampeningDisable = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "dampening.bundle-member.l3-only-mode"); !data.DampeningBundleMemberL3OnlyMode.IsNull() {
		if value.Exists() {
			data.DampeningBundleMemberL3OnlyMode = types.BoolValue(true)
		} else {
			data.DampeningBundleMemberL3OnlyMode = types.BoolValue(false)
		}
	} else {
		data.DampeningBundleMemberL3OnlyMode = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "dampening.bundle-member.initial-wait"); value.Exists() && !data.DampeningBundleMemberInitialWait.IsNull() {
		data.DampeningBundleMemberInitialWait = types.Int64Value(value.Int())
	} else {
		data.DampeningBundleMemberInitialWait = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "dampening.bundle-member.secondary-wait"); value.Exists() && !data.DampeningBundleMemberSecondaryWait.IsNull() {
		data.DampeningBundleMemberSecondaryWait = types.Int64Value(value.Int())
	} else {
		data.DampeningBundleMemberSecondaryWait = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "dampening.bundle-member.maximum-wait"); value.Exists() && !data.DampeningBundleMemberMaximumWait.IsNull() {
		data.DampeningBundleMemberMaximumWait = types.Int64Value(value.Int())
	} else {
		data.DampeningBundleMemberMaximumWait = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "bundle.coexistence.bob-blb.inherit"); !data.BundleCoexistenceBobBlbInherit.IsNull() {
		if value.Exists() {
			data.BundleCoexistenceBobBlbInherit = types.BoolValue(true)
		} else {
			data.BundleCoexistenceBobBlbInherit = types.BoolValue(false)
		}
	} else {
		data.BundleCoexistenceBobBlbInherit = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "bundle.coexistence.bob-blb.logical"); !data.BundleCoexistenceBobBlbLogical.IsNull() {
		if value.Exists() {
			data.BundleCoexistenceBobBlbLogical = types.BoolValue(true)
		} else {
			data.BundleCoexistenceBobBlbLogical = types.BoolValue(false)
		}
	} else {
		data.BundleCoexistenceBobBlbLogical = types.BoolNull()
	}
	for i := range data.Interfaces {
		keys := [...]string{"interface-name"}
		keyValues := [...]string{data.Interfaces[i].InterfaceName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "interfaces.interface").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("interface-name"); value.Exists() && !data.Interfaces[i].InterfaceName.IsNull() {
			data.Interfaces[i].InterfaceName = types.StringValue(value.String())
		} else {
			data.Interfaces[i].InterfaceName = types.StringNull()
		}
		if value := r.Get("echo.disable"); !data.Interfaces[i].EchoDisable.IsNull() {
			if value.Exists() {
				data.Interfaces[i].EchoDisable = types.BoolValue(true)
			} else {
				data.Interfaces[i].EchoDisable = types.BoolValue(false)
			}
		} else {
			data.Interfaces[i].EchoDisable = types.BoolNull()
		}
		if value := r.Get("echo.ipv4.source"); value.Exists() && !data.Interfaces[i].EchoIpv4Source.IsNull() {
			data.Interfaces[i].EchoIpv4Source = types.StringValue(value.String())
		} else {
			data.Interfaces[i].EchoIpv4Source = types.StringNull()
		}
		if value := r.Get("ipv6.checksum.disable"); !data.Interfaces[i].Ipv6ChecksumDisable.IsNull() {
			if value.Exists() {
				data.Interfaces[i].Ipv6ChecksumDisable = types.BoolValue(true)
			} else {
				data.Interfaces[i].Ipv6ChecksumDisable = types.BoolValue(false)
			}
		} else {
			data.Interfaces[i].Ipv6ChecksumDisable = types.BoolNull()
		}
		if value := r.Get("disable"); !data.Interfaces[i].Disable.IsNull() {
			if value.Exists() {
				data.Interfaces[i].Disable = types.BoolValue(true)
			} else {
				data.Interfaces[i].Disable = types.BoolValue(false)
			}
		} else {
			data.Interfaces[i].Disable = types.BoolNull()
		}
		if value := r.Get("local-address"); value.Exists() && !data.Interfaces[i].LocalAddress.IsNull() {
			data.Interfaces[i].LocalAddress = types.StringValue(value.String())
		} else {
			data.Interfaces[i].LocalAddress = types.StringNull()
		}
		if value := r.Get("tx-interval"); value.Exists() && !data.Interfaces[i].TxInterval.IsNull() {
			data.Interfaces[i].TxInterval = types.Int64Value(value.Int())
		} else {
			data.Interfaces[i].TxInterval = types.Int64Null()
		}
		if value := r.Get("rx-interval"); value.Exists() && !data.Interfaces[i].RxInterval.IsNull() {
			data.Interfaces[i].RxInterval = types.Int64Value(value.Int())
		} else {
			data.Interfaces[i].RxInterval = types.Int64Null()
		}
		if value := r.Get("multiplier"); value.Exists() && !data.Interfaces[i].Multiplier.IsNull() {
			data.Interfaces[i].Multiplier = types.Int64Value(value.Int())
		} else {
			data.Interfaces[i].Multiplier = types.Int64Null()
		}
	}
	if value := gjson.GetBytes(res, "ipv6.checksum.disable"); !data.Ipv6ChecksumDisable.IsNull() {
		if value.Exists() {
			data.Ipv6ChecksumDisable = types.BoolValue(true)
		} else {
			data.Ipv6ChecksumDisable = types.BoolValue(false)
		}
	} else {
		data.Ipv6ChecksumDisable = types.BoolNull()
	}
}

func (data *BFD) fromBody(ctx context.Context, res []byte) {
	if value := gjson.GetBytes(res, "echo.disable"); value.Exists() {
		data.EchoDisable = types.BoolValue(true)
	} else {
		data.EchoDisable = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "echo.latency.detect.percentage"); value.Exists() {
		data.EchoLatencyDetectPercentage = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "echo.latency.detect.count"); value.Exists() {
		data.EchoLatencyDetectCount = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "echo.startup.validate.force"); value.Exists() {
		data.EchoStartupValidateForce = types.BoolValue(true)
	} else {
		data.EchoStartupValidateForce = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "echo.ipv4.source"); value.Exists() {
		data.EchoIpv4Source = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "echo.ipv4.bundle-per-member.minimum-interval.preferred-minimum-interval"); value.Exists() {
		data.EchoIpv4BundlePerMemberPreferredMinimumInterval = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "trap.singlehop.pre-mapped"); value.Exists() {
		data.TrapSinglehopPreMapped = types.BoolValue(true)
	} else {
		data.TrapSinglehopPreMapped = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "multipath.include.locations.location"); value.Exists() {
		data.MultipathLocations = make([]BFDMultipathLocations, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := BFDMultipathLocations{}
			if cValue := v.Get("location-name"); cValue.Exists() {
				item.LocationName = types.StringValue(cValue.String())
			}
			data.MultipathLocations = append(data.MultipathLocations, item)
			return true
		})
	}
	if value := gjson.GetBytes(res, "multihop.ttl-drop-threshold"); value.Exists() {
		data.MultihopTtlDropThreshold = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "dampening.initial-wait"); value.Exists() {
		data.DampeningInitialWait = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "dampening.secondary-wait"); value.Exists() {
		data.DampeningSecondaryWait = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "dampening.maximum-wait"); value.Exists() {
		data.DampeningMaximumWait = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "dampening.threshold"); value.Exists() {
		data.DampeningThreshold = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "dampening.extensions.down-monitoring"); value.Exists() {
		data.DampeningExtensionsDownMonitoring = types.BoolValue(true)
	} else {
		data.DampeningExtensionsDownMonitoring = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "dampening.disable"); value.Exists() {
		data.DampeningDisable = types.BoolValue(true)
	} else {
		data.DampeningDisable = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "dampening.bundle-member.l3-only-mode"); value.Exists() {
		data.DampeningBundleMemberL3OnlyMode = types.BoolValue(true)
	} else {
		data.DampeningBundleMemberL3OnlyMode = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "dampening.bundle-member.initial-wait"); value.Exists() {
		data.DampeningBundleMemberInitialWait = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "dampening.bundle-member.secondary-wait"); value.Exists() {
		data.DampeningBundleMemberSecondaryWait = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "dampening.bundle-member.maximum-wait"); value.Exists() {
		data.DampeningBundleMemberMaximumWait = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "bundle.coexistence.bob-blb.inherit"); value.Exists() {
		data.BundleCoexistenceBobBlbInherit = types.BoolValue(true)
	} else {
		data.BundleCoexistenceBobBlbInherit = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "bundle.coexistence.bob-blb.logical"); value.Exists() {
		data.BundleCoexistenceBobBlbLogical = types.BoolValue(true)
	} else {
		data.BundleCoexistenceBobBlbLogical = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "interfaces.interface"); value.Exists() {
		data.Interfaces = make([]BFDInterfaces, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := BFDInterfaces{}
			if cValue := v.Get("interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("echo.disable"); cValue.Exists() {
				item.EchoDisable = types.BoolValue(true)
			} else {
				item.EchoDisable = types.BoolValue(false)
			}
			if cValue := v.Get("echo.ipv4.source"); cValue.Exists() {
				item.EchoIpv4Source = types.StringValue(cValue.String())
			}
			if cValue := v.Get("ipv6.checksum.disable"); cValue.Exists() {
				item.Ipv6ChecksumDisable = types.BoolValue(true)
			} else {
				item.Ipv6ChecksumDisable = types.BoolValue(false)
			}
			if cValue := v.Get("disable"); cValue.Exists() {
				item.Disable = types.BoolValue(true)
			} else {
				item.Disable = types.BoolValue(false)
			}
			if cValue := v.Get("local-address"); cValue.Exists() {
				item.LocalAddress = types.StringValue(cValue.String())
			}
			if cValue := v.Get("tx-interval"); cValue.Exists() {
				item.TxInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("rx-interval"); cValue.Exists() {
				item.RxInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("multiplier"); cValue.Exists() {
				item.Multiplier = types.Int64Value(cValue.Int())
			}
			data.Interfaces = append(data.Interfaces, item)
			return true
		})
	}
	if value := gjson.GetBytes(res, "ipv6.checksum.disable"); value.Exists() {
		data.Ipv6ChecksumDisable = types.BoolValue(true)
	} else {
		data.Ipv6ChecksumDisable = types.BoolValue(false)
	}
}

func (data *BFDData) fromBody(ctx context.Context, res []byte) {
	if value := gjson.GetBytes(res, "echo.disable"); value.Exists() {
		data.EchoDisable = types.BoolValue(true)
	} else {
		data.EchoDisable = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "echo.latency.detect.percentage"); value.Exists() {
		data.EchoLatencyDetectPercentage = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "echo.latency.detect.count"); value.Exists() {
		data.EchoLatencyDetectCount = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "echo.startup.validate.force"); value.Exists() {
		data.EchoStartupValidateForce = types.BoolValue(true)
	} else {
		data.EchoStartupValidateForce = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "echo.ipv4.source"); value.Exists() {
		data.EchoIpv4Source = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "echo.ipv4.bundle-per-member.minimum-interval.preferred-minimum-interval"); value.Exists() {
		data.EchoIpv4BundlePerMemberPreferredMinimumInterval = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "trap.singlehop.pre-mapped"); value.Exists() {
		data.TrapSinglehopPreMapped = types.BoolValue(true)
	} else {
		data.TrapSinglehopPreMapped = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "multipath.include.locations.location"); value.Exists() {
		data.MultipathLocations = make([]BFDMultipathLocations, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := BFDMultipathLocations{}
			if cValue := v.Get("location-name"); cValue.Exists() {
				item.LocationName = types.StringValue(cValue.String())
			}
			data.MultipathLocations = append(data.MultipathLocations, item)
			return true
		})
	}
	if value := gjson.GetBytes(res, "multihop.ttl-drop-threshold"); value.Exists() {
		data.MultihopTtlDropThreshold = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "dampening.initial-wait"); value.Exists() {
		data.DampeningInitialWait = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "dampening.secondary-wait"); value.Exists() {
		data.DampeningSecondaryWait = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "dampening.maximum-wait"); value.Exists() {
		data.DampeningMaximumWait = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "dampening.threshold"); value.Exists() {
		data.DampeningThreshold = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "dampening.extensions.down-monitoring"); value.Exists() {
		data.DampeningExtensionsDownMonitoring = types.BoolValue(true)
	} else {
		data.DampeningExtensionsDownMonitoring = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "dampening.disable"); value.Exists() {
		data.DampeningDisable = types.BoolValue(true)
	} else {
		data.DampeningDisable = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "dampening.bundle-member.l3-only-mode"); value.Exists() {
		data.DampeningBundleMemberL3OnlyMode = types.BoolValue(true)
	} else {
		data.DampeningBundleMemberL3OnlyMode = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "dampening.bundle-member.initial-wait"); value.Exists() {
		data.DampeningBundleMemberInitialWait = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "dampening.bundle-member.secondary-wait"); value.Exists() {
		data.DampeningBundleMemberSecondaryWait = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "dampening.bundle-member.maximum-wait"); value.Exists() {
		data.DampeningBundleMemberMaximumWait = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "bundle.coexistence.bob-blb.inherit"); value.Exists() {
		data.BundleCoexistenceBobBlbInherit = types.BoolValue(true)
	} else {
		data.BundleCoexistenceBobBlbInherit = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "bundle.coexistence.bob-blb.logical"); value.Exists() {
		data.BundleCoexistenceBobBlbLogical = types.BoolValue(true)
	} else {
		data.BundleCoexistenceBobBlbLogical = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "interfaces.interface"); value.Exists() {
		data.Interfaces = make([]BFDInterfaces, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := BFDInterfaces{}
			if cValue := v.Get("interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("echo.disable"); cValue.Exists() {
				item.EchoDisable = types.BoolValue(true)
			} else {
				item.EchoDisable = types.BoolValue(false)
			}
			if cValue := v.Get("echo.ipv4.source"); cValue.Exists() {
				item.EchoIpv4Source = types.StringValue(cValue.String())
			}
			if cValue := v.Get("ipv6.checksum.disable"); cValue.Exists() {
				item.Ipv6ChecksumDisable = types.BoolValue(true)
			} else {
				item.Ipv6ChecksumDisable = types.BoolValue(false)
			}
			if cValue := v.Get("disable"); cValue.Exists() {
				item.Disable = types.BoolValue(true)
			} else {
				item.Disable = types.BoolValue(false)
			}
			if cValue := v.Get("local-address"); cValue.Exists() {
				item.LocalAddress = types.StringValue(cValue.String())
			}
			if cValue := v.Get("tx-interval"); cValue.Exists() {
				item.TxInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("rx-interval"); cValue.Exists() {
				item.RxInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("multiplier"); cValue.Exists() {
				item.Multiplier = types.Int64Value(cValue.Int())
			}
			data.Interfaces = append(data.Interfaces, item)
			return true
		})
	}
	if value := gjson.GetBytes(res, "ipv6.checksum.disable"); value.Exists() {
		data.Ipv6ChecksumDisable = types.BoolValue(true)
	} else {
		data.Ipv6ChecksumDisable = types.BoolValue(false)
	}
}

func (data *BFD) getDeletedItems(ctx context.Context, state BFD) []string {
	deletedItems := make([]string, 0)
	if !state.EchoDisable.IsNull() && data.EchoDisable.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/echo/disable", state.getPath()))
	}
	if !state.EchoLatencyDetectPercentage.IsNull() && data.EchoLatencyDetectPercentage.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/echo/latency/detect/percentage", state.getPath()))
	}
	if !state.EchoLatencyDetectCount.IsNull() && data.EchoLatencyDetectCount.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/echo/latency/detect/count", state.getPath()))
	}
	if !state.EchoStartupValidateForce.IsNull() && data.EchoStartupValidateForce.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/echo/startup/validate/force", state.getPath()))
	}
	if !state.EchoIpv4Source.IsNull() && data.EchoIpv4Source.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/echo/ipv4/source", state.getPath()))
	}
	if !state.EchoIpv4BundlePerMemberPreferredMinimumInterval.IsNull() && data.EchoIpv4BundlePerMemberPreferredMinimumInterval.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/echo/ipv4/bundle-per-member/minimum-interval/preferred-minimum-interval", state.getPath()))
	}
	if !state.TrapSinglehopPreMapped.IsNull() && data.TrapSinglehopPreMapped.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/trap/singlehop/pre-mapped", state.getPath()))
	}
	for i := range state.MultipathLocations {
		keys := [...]string{"location-name"}
		stateKeyValues := [...]string{state.MultipathLocations[i].LocationName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.MultipathLocations[i].LocationName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.MultipathLocations {
			found = true
			if state.MultipathLocations[i].LocationName.ValueString() != data.MultipathLocations[j].LocationName.ValueString() {
				found = false
			}
			if found {
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/multipath/include/locations/location%v", state.getPath(), keyString))
		}
	}
	if !state.MultihopTtlDropThreshold.IsNull() && data.MultihopTtlDropThreshold.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/multihop/ttl-drop-threshold", state.getPath()))
	}
	if !state.DampeningInitialWait.IsNull() && data.DampeningInitialWait.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/dampening/initial-wait", state.getPath()))
	}
	if !state.DampeningSecondaryWait.IsNull() && data.DampeningSecondaryWait.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/dampening/secondary-wait", state.getPath()))
	}
	if !state.DampeningMaximumWait.IsNull() && data.DampeningMaximumWait.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/dampening/maximum-wait", state.getPath()))
	}
	if !state.DampeningThreshold.IsNull() && data.DampeningThreshold.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/dampening/threshold", state.getPath()))
	}
	if !state.DampeningExtensionsDownMonitoring.IsNull() && data.DampeningExtensionsDownMonitoring.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/dampening/extensions/down-monitoring", state.getPath()))
	}
	if !state.DampeningDisable.IsNull() && data.DampeningDisable.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/dampening/disable", state.getPath()))
	}
	if !state.DampeningBundleMemberL3OnlyMode.IsNull() && data.DampeningBundleMemberL3OnlyMode.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/dampening/bundle-member/l3-only-mode", state.getPath()))
	}
	if !state.DampeningBundleMemberInitialWait.IsNull() && data.DampeningBundleMemberInitialWait.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/dampening/bundle-member/initial-wait", state.getPath()))
	}
	if !state.DampeningBundleMemberSecondaryWait.IsNull() && data.DampeningBundleMemberSecondaryWait.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/dampening/bundle-member/secondary-wait", state.getPath()))
	}
	if !state.DampeningBundleMemberMaximumWait.IsNull() && data.DampeningBundleMemberMaximumWait.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/dampening/bundle-member/maximum-wait", state.getPath()))
	}
	if !state.BundleCoexistenceBobBlbInherit.IsNull() && data.BundleCoexistenceBobBlbInherit.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/bundle/coexistence/bob-blb/inherit", state.getPath()))
	}
	if !state.BundleCoexistenceBobBlbLogical.IsNull() && data.BundleCoexistenceBobBlbLogical.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/bundle/coexistence/bob-blb/logical", state.getPath()))
	}
	for i := range state.Interfaces {
		keys := [...]string{"interface-name"}
		stateKeyValues := [...]string{state.Interfaces[i].InterfaceName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.Interfaces[i].InterfaceName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Interfaces {
			found = true
			if state.Interfaces[i].InterfaceName.ValueString() != data.Interfaces[j].InterfaceName.ValueString() {
				found = false
			}
			if found {
				if !state.Interfaces[i].EchoDisable.IsNull() && data.Interfaces[j].EchoDisable.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/echo/disable", state.getPath(), keyString))
				}
				if !state.Interfaces[i].EchoIpv4Source.IsNull() && data.Interfaces[j].EchoIpv4Source.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/echo/ipv4/source", state.getPath(), keyString))
				}
				if !state.Interfaces[i].Ipv6ChecksumDisable.IsNull() && data.Interfaces[j].Ipv6ChecksumDisable.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/ipv6/checksum/disable", state.getPath(), keyString))
				}
				if !state.Interfaces[i].Disable.IsNull() && data.Interfaces[j].Disable.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/disable", state.getPath(), keyString))
				}
				if !state.Interfaces[i].LocalAddress.IsNull() && data.Interfaces[j].LocalAddress.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/local-address", state.getPath(), keyString))
				}
				if !state.Interfaces[i].TxInterval.IsNull() && data.Interfaces[j].TxInterval.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/tx-interval", state.getPath(), keyString))
				}
				if !state.Interfaces[i].RxInterval.IsNull() && data.Interfaces[j].RxInterval.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/rx-interval", state.getPath(), keyString))
				}
				if !state.Interfaces[i].Multiplier.IsNull() && data.Interfaces[j].Multiplier.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/multiplier", state.getPath(), keyString))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v", state.getPath(), keyString))
		}
	}
	if !state.Ipv6ChecksumDisable.IsNull() && data.Ipv6ChecksumDisable.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/ipv6/checksum/disable", state.getPath()))
	}
	return deletedItems
}

func (data *BFD) getEmptyLeafsDelete(ctx context.Context) []string {
	emptyLeafsDelete := make([]string, 0)
	if !data.EchoDisable.IsNull() && !data.EchoDisable.ValueBool() {
		emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/echo/disable", data.getPath()))
	}
	if !data.EchoStartupValidateForce.IsNull() && !data.EchoStartupValidateForce.ValueBool() {
		emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/echo/startup/validate/force", data.getPath()))
	}
	if !data.TrapSinglehopPreMapped.IsNull() && !data.TrapSinglehopPreMapped.ValueBool() {
		emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/trap/singlehop/pre-mapped", data.getPath()))
	}
	for i := range data.MultipathLocations {
		keys := [...]string{"location-name"}
		keyValues := [...]string{data.MultipathLocations[i].LocationName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
	}
	if !data.DampeningExtensionsDownMonitoring.IsNull() && !data.DampeningExtensionsDownMonitoring.ValueBool() {
		emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/dampening/extensions/down-monitoring", data.getPath()))
	}
	if !data.DampeningDisable.IsNull() && !data.DampeningDisable.ValueBool() {
		emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/dampening/disable", data.getPath()))
	}
	if !data.DampeningBundleMemberL3OnlyMode.IsNull() && !data.DampeningBundleMemberL3OnlyMode.ValueBool() {
		emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/dampening/bundle-member/l3-only-mode", data.getPath()))
	}
	if !data.BundleCoexistenceBobBlbInherit.IsNull() && !data.BundleCoexistenceBobBlbInherit.ValueBool() {
		emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/bundle/coexistence/bob-blb/inherit", data.getPath()))
	}
	if !data.BundleCoexistenceBobBlbLogical.IsNull() && !data.BundleCoexistenceBobBlbLogical.ValueBool() {
		emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/bundle/coexistence/bob-blb/logical", data.getPath()))
	}
	for i := range data.Interfaces {
		keys := [...]string{"interface-name"}
		keyValues := [...]string{data.Interfaces[i].InterfaceName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		if !data.Interfaces[i].EchoDisable.IsNull() && !data.Interfaces[i].EchoDisable.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/interfaces/interface%v/echo/disable", data.getPath(), keyString))
		}
		if !data.Interfaces[i].Ipv6ChecksumDisable.IsNull() && !data.Interfaces[i].Ipv6ChecksumDisable.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/interfaces/interface%v/ipv6/checksum/disable", data.getPath(), keyString))
		}
		if !data.Interfaces[i].Disable.IsNull() && !data.Interfaces[i].Disable.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/interfaces/interface%v/disable", data.getPath(), keyString))
		}
	}
	if !data.Ipv6ChecksumDisable.IsNull() && !data.Ipv6ChecksumDisable.ValueBool() {
		emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/ipv6/checksum/disable", data.getPath()))
	}
	return emptyLeafsDelete
}

func (data *BFD) getDeletePaths(ctx context.Context) []string {
	var deletePaths []string
	if !data.EchoDisable.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/echo/disable", data.getPath()))
	}
	if !data.EchoLatencyDetectPercentage.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/echo/latency/detect/percentage", data.getPath()))
	}
	if !data.EchoLatencyDetectCount.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/echo/latency/detect/count", data.getPath()))
	}
	if !data.EchoStartupValidateForce.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/echo/startup/validate/force", data.getPath()))
	}
	if !data.EchoIpv4Source.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/echo/ipv4/source", data.getPath()))
	}
	if !data.EchoIpv4BundlePerMemberPreferredMinimumInterval.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/echo/ipv4/bundle-per-member/minimum-interval/preferred-minimum-interval", data.getPath()))
	}
	if !data.TrapSinglehopPreMapped.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/trap/singlehop/pre-mapped", data.getPath()))
	}
	for i := range data.MultipathLocations {
		keys := [...]string{"location-name"}
		keyValues := [...]string{data.MultipathLocations[i].LocationName.ValueString()}

		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		deletePaths = append(deletePaths, fmt.Sprintf("%v/multipath/include/locations/location%v", data.getPath(), keyString))
	}
	if !data.MultihopTtlDropThreshold.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/multihop/ttl-drop-threshold", data.getPath()))
	}
	if !data.DampeningInitialWait.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/dampening/initial-wait", data.getPath()))
	}
	if !data.DampeningSecondaryWait.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/dampening/secondary-wait", data.getPath()))
	}
	if !data.DampeningMaximumWait.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/dampening/maximum-wait", data.getPath()))
	}
	if !data.DampeningThreshold.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/dampening/threshold", data.getPath()))
	}
	if !data.DampeningExtensionsDownMonitoring.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/dampening/extensions/down-monitoring", data.getPath()))
	}
	if !data.DampeningDisable.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/dampening/disable", data.getPath()))
	}
	if !data.DampeningBundleMemberL3OnlyMode.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/dampening/bundle-member/l3-only-mode", data.getPath()))
	}
	if !data.DampeningBundleMemberInitialWait.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/dampening/bundle-member/initial-wait", data.getPath()))
	}
	if !data.DampeningBundleMemberSecondaryWait.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/dampening/bundle-member/secondary-wait", data.getPath()))
	}
	if !data.DampeningBundleMemberMaximumWait.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/dampening/bundle-member/maximum-wait", data.getPath()))
	}
	if !data.BundleCoexistenceBobBlbInherit.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/bundle/coexistence/bob-blb/inherit", data.getPath()))
	}
	if !data.BundleCoexistenceBobBlbLogical.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/bundle/coexistence/bob-blb/logical", data.getPath()))
	}
	for i := range data.Interfaces {
		keys := [...]string{"interface-name"}
		keyValues := [...]string{data.Interfaces[i].InterfaceName.ValueString()}

		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		deletePaths = append(deletePaths, fmt.Sprintf("%v/interfaces/interface%v", data.getPath(), keyString))
	}
	if !data.Ipv6ChecksumDisable.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/ipv6/checksum/disable", data.getPath()))
	}
	return deletePaths
}
