// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports
import (
	"context"
	"fmt"
	"reflect"
	"strconv"
	"strings"

	"github.com/CiscoDevNet/terraform-provider-iosxr/internal/provider/helpers"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/netascode/go-netconf"
	"github.com/netascode/xmldot"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin types
type EthernetCFM struct {
	Device                  types.String         `tfsdk:"device"`
	Id                      types.String         `tfsdk:"id"`
	DeleteMode              types.String         `tfsdk:"delete_mode"`
	TracerouteCacheHoldTime types.Int64          `tfsdk:"traceroute_cache_hold_time"`
	TracerouteCacheSize     types.Int64          `tfsdk:"traceroute_cache_size"`
	Domains                 []EthernetCFMDomains `tfsdk:"domains"`
}

type EthernetCFMData struct {
	Device                  types.String         `tfsdk:"device"`
	Id                      types.String         `tfsdk:"id"`
	TracerouteCacheHoldTime types.Int64          `tfsdk:"traceroute_cache_hold_time"`
	TracerouteCacheSize     types.Int64          `tfsdk:"traceroute_cache_size"`
	Domains                 []EthernetCFMDomains `tfsdk:"domains"`
}
type EthernetCFMDomains struct {
	DomainName          types.String                 `tfsdk:"domain_name"`
	Level               types.Int64                  `tfsdk:"level"`
	IdDns               types.String                 `tfsdk:"id_dns"`
	IdMacAddress        types.String                 `tfsdk:"id_mac_address"`
	IdMacAddressInteger types.Int64                  `tfsdk:"id_mac_address_integer"`
	IdNull              types.Bool                   `tfsdk:"id_null"`
	IdString            types.String                 `tfsdk:"id_string"`
	Services            []EthernetCFMDomainsServices `tfsdk:"services"`
}
type EthernetCFMDomainsServices struct {
	ServiceName                          types.String                               `tfsdk:"service_name"`
	BridgeGroup                          types.String                               `tfsdk:"bridge_group"`
	BridgeDomain                         types.String                               `tfsdk:"bridge_domain"`
	DownMeps                             types.Bool                                 `tfsdk:"down_meps"`
	FlexibleXconnectVlanAwareEvi         types.Int64                                `tfsdk:"flexible_xconnect_vlan_aware_evi"`
	FlexibleXconnectVlanUnawareName      types.String                               `tfsdk:"flexible_xconnect_vlan_unaware_name"`
	XconnectMp2mpGroup                   types.String                               `tfsdk:"xconnect_mp2mp_group"`
	XconnectMp2mpName                    types.String                               `tfsdk:"xconnect_mp2mp_name"`
	XconnectMp2mpCeId                    types.Int64                                `tfsdk:"xconnect_mp2mp_ce_id"`
	XconnectMp2mpRemoteCeId              types.Int64                                `tfsdk:"xconnect_mp2mp_remote_ce_id"`
	XconnectP2pGroupName                 types.String                               `tfsdk:"xconnect_p2p_group_name"`
	XconnectP2pXcName                    types.String                               `tfsdk:"xconnect_p2p_xc_name"`
	IdIccBasedIcc                        types.String                               `tfsdk:"id_icc_based_icc"`
	IdIccBasedUmc                        types.String                               `tfsdk:"id_icc_based_umc"`
	IdVlanId                             types.Int64                                `tfsdk:"id_vlan_id"`
	IdNumber                             types.Int64                                `tfsdk:"id_number"`
	IdString                             types.String                               `tfsdk:"id_string"`
	IdVpnIdOui                           types.Int64                                `tfsdk:"id_vpn_id_oui"`
	IdVpnIdIndex                         types.Int64                                `tfsdk:"id_vpn_id_index"`
	Tags                                 types.String                               `tfsdk:"tags"`
	MipAutoCreateAll                     types.Bool                                 `tfsdk:"mip_auto_create_all"`
	MipAutoCreateLowerMepOnly            types.Bool                                 `tfsdk:"mip_auto_create_lower_mep_only"`
	MipAutoCreateCcmLearning             types.Bool                                 `tfsdk:"mip_auto_create_ccm_learning"`
	Efd                                  types.Bool                                 `tfsdk:"efd"`
	EfdProtectionSwitching               types.Bool                                 `tfsdk:"efd_protection_switching"`
	ContinuityCheckInterval              types.String                               `tfsdk:"continuity_check_interval"`
	ContinuityCheckIntervalLossThreshold types.Int64                                `tfsdk:"continuity_check_interval_loss_threshold"`
	ContinuityCheckArchiveHoldTime       types.Int64                                `tfsdk:"continuity_check_archive_hold_time"`
	ContinuityCheckLossAutoTraceroute    types.Bool                                 `tfsdk:"continuity_check_loss_auto_traceroute"`
	MaximumMeps                          types.Int64                                `tfsdk:"maximum_meps"`
	AisTransmissionInterval              types.String                               `tfsdk:"ais_transmission_interval"`
	AisTransmissionCos                   types.Int64                                `tfsdk:"ais_transmission_cos"`
	LogContinuityCheckMepChanges         types.Bool                                 `tfsdk:"log_continuity_check_mep_changes"`
	LogContinuityCheckErrors             types.Bool                                 `tfsdk:"log_continuity_check_errors"`
	LogCrosscheckErrors                  types.Bool                                 `tfsdk:"log_crosscheck_errors"`
	LogAis                               types.Bool                                 `tfsdk:"log_ais"`
	LogCsf                               types.Bool                                 `tfsdk:"log_csf"`
	LogEfd                               types.Bool                                 `tfsdk:"log_efd"`
	MepCrosschecks                       []EthernetCFMDomainsServicesMepCrosschecks `tfsdk:"mep_crosschecks"`
	MepCrosscheckAuto                    types.Bool                                 `tfsdk:"mep_crosscheck_auto"`
	ReportDefectsNone                    types.Bool                                 `tfsdk:"report_defects_none"`
	ReportDefectsAll                     types.Bool                                 `tfsdk:"report_defects_all"`
	ReportDefectsIeeeXcon                types.Bool                                 `tfsdk:"report_defects_ieee_xcon"`
	ReportDefectsIeeeErrorXcon           types.Bool                                 `tfsdk:"report_defects_ieee_error_xcon"`
	ReportDefectsIeeeRemoteErrorXcon     types.Bool                                 `tfsdk:"report_defects_ieee_remote_error_xcon"`
	ReportDefectsIeeeMacRemoteErrorXcon  types.Bool                                 `tfsdk:"report_defects_ieee_mac_remote_error_xcon"`
	ReportDefectsWrongMaid               types.Bool                                 `tfsdk:"report_defects_wrong_maid"`
	ReportDefectsWrongLevel              types.Bool                                 `tfsdk:"report_defects_wrong_level"`
	ReportDefectsOurMac                  types.Bool                                 `tfsdk:"report_defects_our_mac"`
	ReportDefectsOurMepid                types.Bool                                 `tfsdk:"report_defects_our_mepid"`
	ReportDefectsWrongInterval           types.Bool                                 `tfsdk:"report_defects_wrong_interval"`
	ReportDefectsMissing                 types.Bool                                 `tfsdk:"report_defects_missing"`
	ReportDefectsPeerPortDown            types.Bool                                 `tfsdk:"report_defects_peer_port_down"`
	ReportDefectsRdi                     types.Bool                                 `tfsdk:"report_defects_rdi"`
}
type EthernetCFMDomainsServicesMepCrosschecks struct {
	MepId      types.Int64  `tfsdk:"mep_id"`
	MacAddress types.String `tfsdk:"mac_address"`
}

// End of section. //template:end types

// Section below is generated&owned by "gen/generator.go". //template:begin getPath

func (data EthernetCFM) getPath() string {
	return "Cisco-IOS-XR-um-ethernet-cfm-cfg:/cfm"
}

func (data EthernetCFMData) getPath() string {
	return "Cisco-IOS-XR-um-ethernet-cfm-cfg:/cfm"
}

// getXPath returns the XPath for NETCONF operations
func (data EthernetCFM) getXPath() string {
	path := "Cisco-IOS-XR-um-ethernet-cfm-cfg:/cfm"
	return path
}

func (data EthernetCFMData) getXPath() string {
	path := "Cisco-IOS-XR-um-ethernet-cfm-cfg:/cfm"
	return path
}

// End of section. //template:end getPath

// Section below is generated&owned by "gen/generator.go". //template:begin toBody

func (data EthernetCFM) toBody(ctx context.Context) string {
	body := "{}"
	if !data.TracerouteCacheHoldTime.IsNull() && !data.TracerouteCacheHoldTime.IsUnknown() {
		body, _ = sjson.Set(body, "traceroute.cache.hold-time", strconv.FormatInt(data.TracerouteCacheHoldTime.ValueInt64(), 10))
	}
	if !data.TracerouteCacheSize.IsNull() && !data.TracerouteCacheSize.IsUnknown() {
		body, _ = sjson.Set(body, "traceroute.cache.size", strconv.FormatInt(data.TracerouteCacheSize.ValueInt64(), 10))
	}
	if len(data.Domains) > 0 {
		body, _ = sjson.Set(body, "domains.domain", []interface{}{})
		for index, item := range data.Domains {
			if !item.DomainName.IsNull() && !item.DomainName.IsUnknown() {
				body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"domain-name", item.DomainName.ValueString())
			}
			if !item.Level.IsNull() && !item.Level.IsUnknown() {
				body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"level", strconv.FormatInt(item.Level.ValueInt64(), 10))
			}
			if !item.IdDns.IsNull() && !item.IdDns.IsUnknown() {
				body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"id.dns", item.IdDns.ValueString())
			}
			if !item.IdMacAddress.IsNull() && !item.IdMacAddress.IsUnknown() {
				body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"id.mac-address", item.IdMacAddress.ValueString())
			}
			if !item.IdMacAddressInteger.IsNull() && !item.IdMacAddressInteger.IsUnknown() {
				body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"id.mac-address-two-octet-integer", strconv.FormatInt(item.IdMacAddressInteger.ValueInt64(), 10))
			}
			if !item.IdNull.IsNull() && !item.IdNull.IsUnknown() {
				if item.IdNull.ValueBool() {
					body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"id.null", map[string]string{})
				}
			}
			if !item.IdString.IsNull() && !item.IdString.IsUnknown() {
				body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"id.string", item.IdString.ValueString())
			}
			if len(item.Services) > 0 {
				body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service", []interface{}{})
				for cindex, citem := range item.Services {
					if !citem.ServiceName.IsNull() && !citem.ServiceName.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"service-name", citem.ServiceName.ValueString())
					}
					if !citem.BridgeGroup.IsNull() && !citem.BridgeGroup.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"bridge.group", citem.BridgeGroup.ValueString())
					}
					if !citem.BridgeDomain.IsNull() && !citem.BridgeDomain.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"bridge.bridge-domain", citem.BridgeDomain.ValueString())
					}
					if !citem.DownMeps.IsNull() && !citem.DownMeps.IsUnknown() {
						if citem.DownMeps.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"down-meps", map[string]string{})
						}
					}
					if !citem.FlexibleXconnectVlanAwareEvi.IsNull() && !citem.FlexibleXconnectVlanAwareEvi.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"flexible-xconnect.vlan-aware.evi", strconv.FormatInt(citem.FlexibleXconnectVlanAwareEvi.ValueInt64(), 10))
					}
					if !citem.FlexibleXconnectVlanUnawareName.IsNull() && !citem.FlexibleXconnectVlanUnawareName.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"flexible-xconnect.vlan-unaware.cross-connect-name", citem.FlexibleXconnectVlanUnawareName.ValueString())
					}
					if !citem.XconnectMp2mpGroup.IsNull() && !citem.XconnectMp2mpGroup.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"xconnect.mp2mp.group", citem.XconnectMp2mpGroup.ValueString())
					}
					if !citem.XconnectMp2mpName.IsNull() && !citem.XconnectMp2mpName.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"xconnect.mp2mp.cross-connect-name", citem.XconnectMp2mpName.ValueString())
					}
					if !citem.XconnectMp2mpCeId.IsNull() && !citem.XconnectMp2mpCeId.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"xconnect.mp2mp.ce-id", strconv.FormatInt(citem.XconnectMp2mpCeId.ValueInt64(), 10))
					}
					if !citem.XconnectMp2mpRemoteCeId.IsNull() && !citem.XconnectMp2mpRemoteCeId.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"xconnect.mp2mp.remote-ce-id", strconv.FormatInt(citem.XconnectMp2mpRemoteCeId.ValueInt64(), 10))
					}
					if !citem.XconnectP2pGroupName.IsNull() && !citem.XconnectP2pGroupName.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"xconnect.p2p.group", citem.XconnectP2pGroupName.ValueString())
					}
					if !citem.XconnectP2pXcName.IsNull() && !citem.XconnectP2pXcName.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"xconnect.p2p.cross-connect-name", citem.XconnectP2pXcName.ValueString())
					}
					if !citem.IdIccBasedIcc.IsNull() && !citem.IdIccBasedIcc.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"id.icc-based.icc", citem.IdIccBasedIcc.ValueString())
					}
					if !citem.IdIccBasedUmc.IsNull() && !citem.IdIccBasedUmc.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"id.icc-based.umc", citem.IdIccBasedUmc.ValueString())
					}
					if !citem.IdVlanId.IsNull() && !citem.IdVlanId.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"id.vlanid", strconv.FormatInt(citem.IdVlanId.ValueInt64(), 10))
					}
					if !citem.IdNumber.IsNull() && !citem.IdNumber.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"id.number", strconv.FormatInt(citem.IdNumber.ValueInt64(), 10))
					}
					if !citem.IdString.IsNull() && !citem.IdString.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"id.string", citem.IdString.ValueString())
					}
					if !citem.IdVpnIdOui.IsNull() && !citem.IdVpnIdOui.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"id.vpn-id.vpn-oui", strconv.FormatInt(citem.IdVpnIdOui.ValueInt64(), 10))
					}
					if !citem.IdVpnIdIndex.IsNull() && !citem.IdVpnIdIndex.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"id.vpn-id.vpn-index", strconv.FormatInt(citem.IdVpnIdIndex.ValueInt64(), 10))
					}
					if !citem.Tags.IsNull() && !citem.Tags.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"tags", citem.Tags.ValueString())
					}
					if !citem.MipAutoCreateAll.IsNull() && !citem.MipAutoCreateAll.IsUnknown() {
						if citem.MipAutoCreateAll.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"mip.auto-create.all", map[string]string{})
						}
					}
					if !citem.MipAutoCreateLowerMepOnly.IsNull() && !citem.MipAutoCreateLowerMepOnly.IsUnknown() {
						if citem.MipAutoCreateLowerMepOnly.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"mip.auto-create.lower-mep-only", map[string]string{})
						}
					}
					if !citem.MipAutoCreateCcmLearning.IsNull() && !citem.MipAutoCreateCcmLearning.IsUnknown() {
						if citem.MipAutoCreateCcmLearning.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"mip.auto-create.ccm-learning", map[string]string{})
						}
					}
					if !citem.Efd.IsNull() && !citem.Efd.IsUnknown() {
						if citem.Efd.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"efd", map[string]string{})
						}
					}
					if !citem.EfdProtectionSwitching.IsNull() && !citem.EfdProtectionSwitching.IsUnknown() {
						if citem.EfdProtectionSwitching.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"efd.protection-switching", map[string]string{})
						}
					}
					if !citem.ContinuityCheckInterval.IsNull() && !citem.ContinuityCheckInterval.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"continuity-check.interval.interval-time", citem.ContinuityCheckInterval.ValueString())
					}
					if !citem.ContinuityCheckIntervalLossThreshold.IsNull() && !citem.ContinuityCheckIntervalLossThreshold.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"continuity-check.interval.loss-threshold", strconv.FormatInt(citem.ContinuityCheckIntervalLossThreshold.ValueInt64(), 10))
					}
					if !citem.ContinuityCheckArchiveHoldTime.IsNull() && !citem.ContinuityCheckArchiveHoldTime.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"continuity-check.archive.hold-time", strconv.FormatInt(citem.ContinuityCheckArchiveHoldTime.ValueInt64(), 10))
					}
					if !citem.ContinuityCheckLossAutoTraceroute.IsNull() && !citem.ContinuityCheckLossAutoTraceroute.IsUnknown() {
						if citem.ContinuityCheckLossAutoTraceroute.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"continuity-check.loss.auto-traceroute", map[string]string{})
						}
					}
					if !citem.MaximumMeps.IsNull() && !citem.MaximumMeps.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"maximum-meps", strconv.FormatInt(citem.MaximumMeps.ValueInt64(), 10))
					}
					if !citem.AisTransmissionInterval.IsNull() && !citem.AisTransmissionInterval.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"ais.transmission.interval", citem.AisTransmissionInterval.ValueString())
					}
					if !citem.AisTransmissionCos.IsNull() && !citem.AisTransmissionCos.IsUnknown() {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"ais.transmission.cos", strconv.FormatInt(citem.AisTransmissionCos.ValueInt64(), 10))
					}
					if !citem.LogContinuityCheckMepChanges.IsNull() && !citem.LogContinuityCheckMepChanges.IsUnknown() {
						if citem.LogContinuityCheckMepChanges.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"log.continuity-check.mep.changes", map[string]string{})
						}
					}
					if !citem.LogContinuityCheckErrors.IsNull() && !citem.LogContinuityCheckErrors.IsUnknown() {
						if citem.LogContinuityCheckErrors.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"log.continuity-check.errors", map[string]string{})
						}
					}
					if !citem.LogCrosscheckErrors.IsNull() && !citem.LogCrosscheckErrors.IsUnknown() {
						if citem.LogCrosscheckErrors.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"log.crosscheck.errors", map[string]string{})
						}
					}
					if !citem.LogAis.IsNull() && !citem.LogAis.IsUnknown() {
						if citem.LogAis.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"log.ais", map[string]string{})
						}
					}
					if !citem.LogCsf.IsNull() && !citem.LogCsf.IsUnknown() {
						if citem.LogCsf.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"log.csf", map[string]string{})
						}
					}
					if !citem.LogEfd.IsNull() && !citem.LogEfd.IsUnknown() {
						if citem.LogEfd.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"log.efd", map[string]string{})
						}
					}
					if !citem.MepCrosscheckAuto.IsNull() && !citem.MepCrosscheckAuto.IsUnknown() {
						if citem.MepCrosscheckAuto.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"mep.crosscheck.auto", map[string]string{})
						}
					}
					if !citem.ReportDefectsNone.IsNull() && !citem.ReportDefectsNone.IsUnknown() {
						if citem.ReportDefectsNone.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"report.defects.none", map[string]string{})
						}
					}
					if !citem.ReportDefectsAll.IsNull() && !citem.ReportDefectsAll.IsUnknown() {
						if citem.ReportDefectsAll.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"report.defects.all", map[string]string{})
						}
					}
					if !citem.ReportDefectsIeeeXcon.IsNull() && !citem.ReportDefectsIeeeXcon.IsUnknown() {
						if citem.ReportDefectsIeeeXcon.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"report.defects.ieee.xcon", map[string]string{})
						}
					}
					if !citem.ReportDefectsIeeeErrorXcon.IsNull() && !citem.ReportDefectsIeeeErrorXcon.IsUnknown() {
						if citem.ReportDefectsIeeeErrorXcon.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"report.defects.ieee.error-xcon", map[string]string{})
						}
					}
					if !citem.ReportDefectsIeeeRemoteErrorXcon.IsNull() && !citem.ReportDefectsIeeeRemoteErrorXcon.IsUnknown() {
						if citem.ReportDefectsIeeeRemoteErrorXcon.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"report.defects.ieee.remote-error-xcon", map[string]string{})
						}
					}
					if !citem.ReportDefectsIeeeMacRemoteErrorXcon.IsNull() && !citem.ReportDefectsIeeeMacRemoteErrorXcon.IsUnknown() {
						if citem.ReportDefectsIeeeMacRemoteErrorXcon.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"report.defects.ieee.mac-remote-error-xcon", map[string]string{})
						}
					}
					if !citem.ReportDefectsWrongMaid.IsNull() && !citem.ReportDefectsWrongMaid.IsUnknown() {
						if citem.ReportDefectsWrongMaid.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"report.defects.wrong-maid", map[string]string{})
						}
					}
					if !citem.ReportDefectsWrongLevel.IsNull() && !citem.ReportDefectsWrongLevel.IsUnknown() {
						if citem.ReportDefectsWrongLevel.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"report.defects.wrong-level", map[string]string{})
						}
					}
					if !citem.ReportDefectsOurMac.IsNull() && !citem.ReportDefectsOurMac.IsUnknown() {
						if citem.ReportDefectsOurMac.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"report.defects.our-mac", map[string]string{})
						}
					}
					if !citem.ReportDefectsOurMepid.IsNull() && !citem.ReportDefectsOurMepid.IsUnknown() {
						if citem.ReportDefectsOurMepid.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"report.defects.our-mepid", map[string]string{})
						}
					}
					if !citem.ReportDefectsWrongInterval.IsNull() && !citem.ReportDefectsWrongInterval.IsUnknown() {
						if citem.ReportDefectsWrongInterval.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"report.defects.wrong-interval", map[string]string{})
						}
					}
					if !citem.ReportDefectsMissing.IsNull() && !citem.ReportDefectsMissing.IsUnknown() {
						if citem.ReportDefectsMissing.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"report.defects.missing", map[string]string{})
						}
					}
					if !citem.ReportDefectsPeerPortDown.IsNull() && !citem.ReportDefectsPeerPortDown.IsUnknown() {
						if citem.ReportDefectsPeerPortDown.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"report.defects.peer-port-down", map[string]string{})
						}
					}
					if !citem.ReportDefectsRdi.IsNull() && !citem.ReportDefectsRdi.IsUnknown() {
						if citem.ReportDefectsRdi.ValueBool() {
							body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"report.defects.rdi", map[string]string{})
						}
					}
					if len(citem.MepCrosschecks) > 0 {
						body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"mep.crosscheck.mep-ids.mep-id", []interface{}{})
						for ccindex, ccitem := range citem.MepCrosschecks {
							if !ccitem.MepId.IsNull() && !ccitem.MepId.IsUnknown() {
								body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"mep.crosscheck.mep-ids.mep-id"+"."+strconv.Itoa(ccindex)+"."+"mep-id", strconv.FormatInt(ccitem.MepId.ValueInt64(), 10))
							}
							if !ccitem.MacAddress.IsNull() && !ccitem.MacAddress.IsUnknown() {
								body, _ = sjson.Set(body, "domains.domain"+"."+strconv.Itoa(index)+"."+"services.service"+"."+strconv.Itoa(cindex)+"."+"mep.crosscheck.mep-ids.mep-id"+"."+strconv.Itoa(ccindex)+"."+"mac-address", ccitem.MacAddress.ValueString())
							}
						}
					}
				}
			}
		}
	}
	return body
}

// End of section. //template:end toBody

// Section below is generated&owned by "gen/generator.go". //template:begin toBodyXML

func (data EthernetCFM) toBodyXML(ctx context.Context) string {
	body := netconf.Body{}
	if !data.TracerouteCacheHoldTime.IsNull() && !data.TracerouteCacheHoldTime.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/traceroute/cache/hold-time", strconv.FormatInt(data.TracerouteCacheHoldTime.ValueInt64(), 10))
	}
	if !data.TracerouteCacheSize.IsNull() && !data.TracerouteCacheSize.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/traceroute/cache/size", strconv.FormatInt(data.TracerouteCacheSize.ValueInt64(), 10))
	}
	if len(data.Domains) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.Domains {
			cBody := netconf.Body{}
			if !item.DomainName.IsNull() && !item.DomainName.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "domain-name", item.DomainName.ValueString())
			}
			if !item.Level.IsNull() && !item.Level.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "level", strconv.FormatInt(item.Level.ValueInt64(), 10))
			}
			if !item.IdDns.IsNull() && !item.IdDns.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "id/dns", item.IdDns.ValueString())
			}
			if !item.IdMacAddress.IsNull() && !item.IdMacAddress.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "id/mac-address", item.IdMacAddress.ValueString())
			}
			if !item.IdMacAddressInteger.IsNull() && !item.IdMacAddressInteger.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "id/mac-address-two-octet-integer", strconv.FormatInt(item.IdMacAddressInteger.ValueInt64(), 10))
			}
			if !item.IdNull.IsNull() && !item.IdNull.IsUnknown() {
				if item.IdNull.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "id/null", "")
				}
			}
			if !item.IdString.IsNull() && !item.IdString.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "id/string", item.IdString.ValueString())
			}
			if len(item.Services) > 0 {
				for _, citem := range item.Services {
					ccBody := netconf.Body{}
					_ = citem // Suppress unused variable warning when all attributes are IDs
					if !citem.BridgeGroup.IsNull() && !citem.BridgeGroup.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "bridge/group", citem.BridgeGroup.ValueString())
					}
					if !citem.BridgeDomain.IsNull() && !citem.BridgeDomain.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "bridge/bridge-domain", citem.BridgeDomain.ValueString())
					}
					if !citem.DownMeps.IsNull() && !citem.DownMeps.IsUnknown() {
						if citem.DownMeps.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "down-meps", "")
						}
					}
					if !citem.FlexibleXconnectVlanAwareEvi.IsNull() && !citem.FlexibleXconnectVlanAwareEvi.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "flexible-xconnect/vlan-aware/evi", strconv.FormatInt(citem.FlexibleXconnectVlanAwareEvi.ValueInt64(), 10))
					}
					if !citem.FlexibleXconnectVlanUnawareName.IsNull() && !citem.FlexibleXconnectVlanUnawareName.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "flexible-xconnect/vlan-unaware/cross-connect-name", citem.FlexibleXconnectVlanUnawareName.ValueString())
					}
					if !citem.XconnectMp2mpGroup.IsNull() && !citem.XconnectMp2mpGroup.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "xconnect/mp2mp/group", citem.XconnectMp2mpGroup.ValueString())
					}
					if !citem.XconnectMp2mpName.IsNull() && !citem.XconnectMp2mpName.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "xconnect/mp2mp/cross-connect-name", citem.XconnectMp2mpName.ValueString())
					}
					if !citem.XconnectMp2mpCeId.IsNull() && !citem.XconnectMp2mpCeId.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "xconnect/mp2mp/ce-id", strconv.FormatInt(citem.XconnectMp2mpCeId.ValueInt64(), 10))
					}
					if !citem.XconnectMp2mpRemoteCeId.IsNull() && !citem.XconnectMp2mpRemoteCeId.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "xconnect/mp2mp/remote-ce-id", strconv.FormatInt(citem.XconnectMp2mpRemoteCeId.ValueInt64(), 10))
					}
					if !citem.XconnectP2pGroupName.IsNull() && !citem.XconnectP2pGroupName.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "xconnect/p2p/group", citem.XconnectP2pGroupName.ValueString())
					}
					if !citem.XconnectP2pXcName.IsNull() && !citem.XconnectP2pXcName.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "xconnect/p2p/cross-connect-name", citem.XconnectP2pXcName.ValueString())
					}
					if !citem.IdIccBasedIcc.IsNull() && !citem.IdIccBasedIcc.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "id/icc-based/icc", citem.IdIccBasedIcc.ValueString())
					}
					if !citem.IdIccBasedUmc.IsNull() && !citem.IdIccBasedUmc.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "id/icc-based/umc", citem.IdIccBasedUmc.ValueString())
					}
					if !citem.IdVlanId.IsNull() && !citem.IdVlanId.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "id/vlanid", strconv.FormatInt(citem.IdVlanId.ValueInt64(), 10))
					}
					if !citem.IdNumber.IsNull() && !citem.IdNumber.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "id/number", strconv.FormatInt(citem.IdNumber.ValueInt64(), 10))
					}
					if !citem.IdString.IsNull() && !citem.IdString.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "id/string", citem.IdString.ValueString())
					}
					if !citem.IdVpnIdOui.IsNull() && !citem.IdVpnIdOui.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "id/vpn-id/vpn-oui", strconv.FormatInt(citem.IdVpnIdOui.ValueInt64(), 10))
					}
					if !citem.IdVpnIdIndex.IsNull() && !citem.IdVpnIdIndex.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "id/vpn-id/vpn-index", strconv.FormatInt(citem.IdVpnIdIndex.ValueInt64(), 10))
					}
					if !citem.Tags.IsNull() && !citem.Tags.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "tags", citem.Tags.ValueString())
					}
					if !citem.MipAutoCreateAll.IsNull() && !citem.MipAutoCreateAll.IsUnknown() {
						if citem.MipAutoCreateAll.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "mip/auto-create/all", "")
						}
					}
					if !citem.MipAutoCreateLowerMepOnly.IsNull() && !citem.MipAutoCreateLowerMepOnly.IsUnknown() {
						if citem.MipAutoCreateLowerMepOnly.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "mip/auto-create/lower-mep-only", "")
						}
					}
					if !citem.MipAutoCreateCcmLearning.IsNull() && !citem.MipAutoCreateCcmLearning.IsUnknown() {
						if citem.MipAutoCreateCcmLearning.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "mip/auto-create/ccm-learning", "")
						}
					}
					if !citem.Efd.IsNull() && !citem.Efd.IsUnknown() {
						if citem.Efd.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "efd", "")
						}
					}
					if !citem.EfdProtectionSwitching.IsNull() && !citem.EfdProtectionSwitching.IsUnknown() {
						if citem.EfdProtectionSwitching.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "efd/protection-switching", "")
						}
					}
					if !citem.ContinuityCheckInterval.IsNull() && !citem.ContinuityCheckInterval.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "continuity-check/interval/interval-time", citem.ContinuityCheckInterval.ValueString())
					}
					if !citem.ContinuityCheckIntervalLossThreshold.IsNull() && !citem.ContinuityCheckIntervalLossThreshold.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "continuity-check/interval/loss-threshold", strconv.FormatInt(citem.ContinuityCheckIntervalLossThreshold.ValueInt64(), 10))
					}
					if !citem.ContinuityCheckArchiveHoldTime.IsNull() && !citem.ContinuityCheckArchiveHoldTime.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "continuity-check/archive/hold-time", strconv.FormatInt(citem.ContinuityCheckArchiveHoldTime.ValueInt64(), 10))
					}
					if !citem.ContinuityCheckLossAutoTraceroute.IsNull() && !citem.ContinuityCheckLossAutoTraceroute.IsUnknown() {
						if citem.ContinuityCheckLossAutoTraceroute.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "continuity-check/loss/auto-traceroute", "")
						}
					}
					if !citem.MaximumMeps.IsNull() && !citem.MaximumMeps.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "maximum-meps", strconv.FormatInt(citem.MaximumMeps.ValueInt64(), 10))
					}
					if !citem.AisTransmissionInterval.IsNull() && !citem.AisTransmissionInterval.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "ais/transmission/interval", citem.AisTransmissionInterval.ValueString())
					}
					if !citem.AisTransmissionCos.IsNull() && !citem.AisTransmissionCos.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "ais/transmission/cos", strconv.FormatInt(citem.AisTransmissionCos.ValueInt64(), 10))
					}
					if !citem.LogContinuityCheckMepChanges.IsNull() && !citem.LogContinuityCheckMepChanges.IsUnknown() {
						if citem.LogContinuityCheckMepChanges.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "log/continuity-check/mep/changes", "")
						}
					}
					if !citem.LogContinuityCheckErrors.IsNull() && !citem.LogContinuityCheckErrors.IsUnknown() {
						if citem.LogContinuityCheckErrors.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "log/continuity-check/errors", "")
						}
					}
					if !citem.LogCrosscheckErrors.IsNull() && !citem.LogCrosscheckErrors.IsUnknown() {
						if citem.LogCrosscheckErrors.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "log/crosscheck/errors", "")
						}
					}
					if !citem.LogAis.IsNull() && !citem.LogAis.IsUnknown() {
						if citem.LogAis.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "log/ais", "")
						}
					}
					if !citem.LogCsf.IsNull() && !citem.LogCsf.IsUnknown() {
						if citem.LogCsf.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "log/csf", "")
						}
					}
					if !citem.LogEfd.IsNull() && !citem.LogEfd.IsUnknown() {
						if citem.LogEfd.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "log/efd", "")
						}
					}
					if len(citem.MepCrosschecks) > 0 {
						for _, ccitem := range citem.MepCrosschecks {
							cccBody := netconf.Body{}
							_ = ccitem // Suppress unused variable warning
							if !ccitem.MacAddress.IsNull() && !ccitem.MacAddress.IsUnknown() {
								cccBody = helpers.SetFromXPath(cccBody, "mac-address", ccitem.MacAddress.ValueString())
							}
							ccBody = helpers.AppendRawFromXPath(ccBody, "mep/crosscheck/mep-ids/mep-id", cccBody.Res())
						}
					}
					if !citem.MepCrosscheckAuto.IsNull() && !citem.MepCrosscheckAuto.IsUnknown() {
						if citem.MepCrosscheckAuto.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "mep/crosscheck/auto", "")
						}
					}
					if !citem.ReportDefectsNone.IsNull() && !citem.ReportDefectsNone.IsUnknown() {
						if citem.ReportDefectsNone.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "report/defects/none", "")
						}
					}
					if !citem.ReportDefectsAll.IsNull() && !citem.ReportDefectsAll.IsUnknown() {
						if citem.ReportDefectsAll.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "report/defects/all", "")
						}
					}
					if !citem.ReportDefectsIeeeXcon.IsNull() && !citem.ReportDefectsIeeeXcon.IsUnknown() {
						if citem.ReportDefectsIeeeXcon.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "report/defects/ieee/xcon", "")
						}
					}
					if !citem.ReportDefectsIeeeErrorXcon.IsNull() && !citem.ReportDefectsIeeeErrorXcon.IsUnknown() {
						if citem.ReportDefectsIeeeErrorXcon.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "report/defects/ieee/error-xcon", "")
						}
					}
					if !citem.ReportDefectsIeeeRemoteErrorXcon.IsNull() && !citem.ReportDefectsIeeeRemoteErrorXcon.IsUnknown() {
						if citem.ReportDefectsIeeeRemoteErrorXcon.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "report/defects/ieee/remote-error-xcon", "")
						}
					}
					if !citem.ReportDefectsIeeeMacRemoteErrorXcon.IsNull() && !citem.ReportDefectsIeeeMacRemoteErrorXcon.IsUnknown() {
						if citem.ReportDefectsIeeeMacRemoteErrorXcon.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "report/defects/ieee/mac-remote-error-xcon", "")
						}
					}
					if !citem.ReportDefectsWrongMaid.IsNull() && !citem.ReportDefectsWrongMaid.IsUnknown() {
						if citem.ReportDefectsWrongMaid.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "report/defects/wrong-maid", "")
						}
					}
					if !citem.ReportDefectsWrongLevel.IsNull() && !citem.ReportDefectsWrongLevel.IsUnknown() {
						if citem.ReportDefectsWrongLevel.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "report/defects/wrong-level", "")
						}
					}
					if !citem.ReportDefectsOurMac.IsNull() && !citem.ReportDefectsOurMac.IsUnknown() {
						if citem.ReportDefectsOurMac.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "report/defects/our-mac", "")
						}
					}
					if !citem.ReportDefectsOurMepid.IsNull() && !citem.ReportDefectsOurMepid.IsUnknown() {
						if citem.ReportDefectsOurMepid.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "report/defects/our-mepid", "")
						}
					}
					if !citem.ReportDefectsWrongInterval.IsNull() && !citem.ReportDefectsWrongInterval.IsUnknown() {
						if citem.ReportDefectsWrongInterval.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "report/defects/wrong-interval", "")
						}
					}
					if !citem.ReportDefectsMissing.IsNull() && !citem.ReportDefectsMissing.IsUnknown() {
						if citem.ReportDefectsMissing.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "report/defects/missing", "")
						}
					}
					if !citem.ReportDefectsPeerPortDown.IsNull() && !citem.ReportDefectsPeerPortDown.IsUnknown() {
						if citem.ReportDefectsPeerPortDown.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "report/defects/peer-port-down", "")
						}
					}
					if !citem.ReportDefectsRdi.IsNull() && !citem.ReportDefectsRdi.IsUnknown() {
						if citem.ReportDefectsRdi.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "report/defects/rdi", "")
						}
					}
					cBody = helpers.SetRawFromXPath(cBody, "services/service", ccBody.Res())
				}
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"domains/domain", cBody.Res())
		}
	}
	bodyString, err := body.String()
	if err != nil {
		tflog.Error(ctx, fmt.Sprintf("Error converting body to string: %s", err))
	}
	return bodyString
}

// End of section. //template:end toBodyXML

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBody

func (data *EthernetCFM) updateFromBody(ctx context.Context, res []byte) {
	if value := gjson.GetBytes(res, "traceroute.cache.hold-time"); value.Exists() && !data.TracerouteCacheHoldTime.IsNull() {
		data.TracerouteCacheHoldTime = types.Int64Value(value.Int())
	} else {
		data.TracerouteCacheHoldTime = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "traceroute.cache.size"); value.Exists() && !data.TracerouteCacheSize.IsNull() {
		data.TracerouteCacheSize = types.Int64Value(value.Int())
	} else {
		data.TracerouteCacheSize = types.Int64Null()
	}
	for i := range data.Domains {
		keys := [...]string{"domain-name"}
		keyValues := [...]string{data.Domains[i].DomainName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "domains.domain").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("domain-name"); value.Exists() && !data.Domains[i].DomainName.IsNull() {
			data.Domains[i].DomainName = types.StringValue(value.String())
		} else {
			data.Domains[i].DomainName = types.StringNull()
		}
		if value := r.Get("level"); value.Exists() && !data.Domains[i].Level.IsNull() {
			data.Domains[i].Level = types.Int64Value(value.Int())
		} else {
			data.Domains[i].Level = types.Int64Null()
		}
		if value := r.Get("id.dns"); value.Exists() && !data.Domains[i].IdDns.IsNull() {
			data.Domains[i].IdDns = types.StringValue(value.String())
		} else {
			data.Domains[i].IdDns = types.StringNull()
		}
		if value := r.Get("id.mac-address"); value.Exists() && !data.Domains[i].IdMacAddress.IsNull() {
			data.Domains[i].IdMacAddress = types.StringValue(value.String())
		} else {
			data.Domains[i].IdMacAddress = types.StringNull()
		}
		if value := r.Get("id.mac-address-two-octet-integer"); value.Exists() && !data.Domains[i].IdMacAddressInteger.IsNull() {
			data.Domains[i].IdMacAddressInteger = types.Int64Value(value.Int())
		} else {
			data.Domains[i].IdMacAddressInteger = types.Int64Null()
		}
		if value := r.Get("id.null"); value.Exists() {
			if !data.Domains[i].IdNull.IsNull() {
				data.Domains[i].IdNull = types.BoolValue(true)
			}
		} else {
			// For presence-based booleans, only set to null if the attribute is null in state
			if data.Domains[i].IdNull.IsNull() {
				data.Domains[i].IdNull = types.BoolNull()
			}
		}
		if value := r.Get("id.string"); value.Exists() && !data.Domains[i].IdString.IsNull() {
			data.Domains[i].IdString = types.StringValue(value.String())
		} else {
			data.Domains[i].IdString = types.StringNull()
		}
		for ci := range data.Domains[i].Services {
			keys := [...]string{"service-name"}
			keyValues := [...]string{data.Domains[i].Services[ci].ServiceName.ValueString()}

			var cr gjson.Result
			r.Get("services.service").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("service-name"); value.Exists() && !data.Domains[i].Services[ci].ServiceName.IsNull() {
				data.Domains[i].Services[ci].ServiceName = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].ServiceName = types.StringNull()
			}
			if value := cr.Get("bridge.group"); value.Exists() && !data.Domains[i].Services[ci].BridgeGroup.IsNull() {
				data.Domains[i].Services[ci].BridgeGroup = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].BridgeGroup = types.StringNull()
			}
			if value := cr.Get("bridge.bridge-domain"); value.Exists() && !data.Domains[i].Services[ci].BridgeDomain.IsNull() {
				data.Domains[i].Services[ci].BridgeDomain = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].BridgeDomain = types.StringNull()
			}
			if value := cr.Get("down-meps"); value.Exists() {
				if !data.Domains[i].Services[ci].DownMeps.IsNull() {
					data.Domains[i].Services[ci].DownMeps = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].DownMeps.IsNull() {
					data.Domains[i].Services[ci].DownMeps = types.BoolNull()
				}
			}
			if value := cr.Get("flexible-xconnect.vlan-aware.evi"); value.Exists() {
				data.Domains[i].Services[ci].FlexibleXconnectVlanAwareEvi = types.Int64Value(value.Int())
			} else if data.Domains[i].Services[ci].FlexibleXconnectVlanAwareEvi.IsNull() {
				data.Domains[i].Services[ci].FlexibleXconnectVlanAwareEvi = types.Int64Null()
			}
			if value := cr.Get("flexible-xconnect.vlan-unaware.cross-connect-name"); value.Exists() && !data.Domains[i].Services[ci].FlexibleXconnectVlanUnawareName.IsNull() {
				data.Domains[i].Services[ci].FlexibleXconnectVlanUnawareName = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].FlexibleXconnectVlanUnawareName = types.StringNull()
			}
			if value := cr.Get("xconnect.mp2mp.group"); value.Exists() && !data.Domains[i].Services[ci].XconnectMp2mpGroup.IsNull() {
				data.Domains[i].Services[ci].XconnectMp2mpGroup = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].XconnectMp2mpGroup = types.StringNull()
			}
			if value := cr.Get("xconnect.mp2mp.cross-connect-name"); value.Exists() && !data.Domains[i].Services[ci].XconnectMp2mpName.IsNull() {
				data.Domains[i].Services[ci].XconnectMp2mpName = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].XconnectMp2mpName = types.StringNull()
			}
			if value := cr.Get("xconnect.mp2mp.ce-id"); value.Exists() {
				data.Domains[i].Services[ci].XconnectMp2mpCeId = types.Int64Value(value.Int())
			} else if data.Domains[i].Services[ci].XconnectMp2mpCeId.IsNull() {
				data.Domains[i].Services[ci].XconnectMp2mpCeId = types.Int64Null()
			}
			if value := cr.Get("xconnect.mp2mp.remote-ce-id"); value.Exists() {
				data.Domains[i].Services[ci].XconnectMp2mpRemoteCeId = types.Int64Value(value.Int())
			} else if data.Domains[i].Services[ci].XconnectMp2mpRemoteCeId.IsNull() {
				data.Domains[i].Services[ci].XconnectMp2mpRemoteCeId = types.Int64Null()
			}
			if value := cr.Get("xconnect.p2p.group"); value.Exists() && !data.Domains[i].Services[ci].XconnectP2pGroupName.IsNull() {
				data.Domains[i].Services[ci].XconnectP2pGroupName = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].XconnectP2pGroupName = types.StringNull()
			}
			if value := cr.Get("xconnect.p2p.cross-connect-name"); value.Exists() && !data.Domains[i].Services[ci].XconnectP2pXcName.IsNull() {
				data.Domains[i].Services[ci].XconnectP2pXcName = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].XconnectP2pXcName = types.StringNull()
			}
			if value := cr.Get("id.icc-based.icc"); value.Exists() && !data.Domains[i].Services[ci].IdIccBasedIcc.IsNull() {
				data.Domains[i].Services[ci].IdIccBasedIcc = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].IdIccBasedIcc = types.StringNull()
			}
			if value := cr.Get("id.icc-based.umc"); value.Exists() && !data.Domains[i].Services[ci].IdIccBasedUmc.IsNull() {
				data.Domains[i].Services[ci].IdIccBasedUmc = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].IdIccBasedUmc = types.StringNull()
			}
			if value := cr.Get("id.vlanid"); value.Exists() {
				data.Domains[i].Services[ci].IdVlanId = types.Int64Value(value.Int())
			} else if data.Domains[i].Services[ci].IdVlanId.IsNull() {
				data.Domains[i].Services[ci].IdVlanId = types.Int64Null()
			}
			if value := cr.Get("id.number"); value.Exists() {
				data.Domains[i].Services[ci].IdNumber = types.Int64Value(value.Int())
			} else if data.Domains[i].Services[ci].IdNumber.IsNull() {
				data.Domains[i].Services[ci].IdNumber = types.Int64Null()
			}
			if value := cr.Get("id.string"); value.Exists() && !data.Domains[i].Services[ci].IdString.IsNull() {
				data.Domains[i].Services[ci].IdString = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].IdString = types.StringNull()
			}
			if value := cr.Get("id.vpn-id.vpn-oui"); value.Exists() {
				data.Domains[i].Services[ci].IdVpnIdOui = types.Int64Value(value.Int())
			} else if data.Domains[i].Services[ci].IdVpnIdOui.IsNull() {
				data.Domains[i].Services[ci].IdVpnIdOui = types.Int64Null()
			}
			if value := cr.Get("id.vpn-id.vpn-index"); value.Exists() {
				data.Domains[i].Services[ci].IdVpnIdIndex = types.Int64Value(value.Int())
			} else if data.Domains[i].Services[ci].IdVpnIdIndex.IsNull() {
				data.Domains[i].Services[ci].IdVpnIdIndex = types.Int64Null()
			}
			if value := cr.Get("tags"); value.Exists() && !data.Domains[i].Services[ci].Tags.IsNull() {
				data.Domains[i].Services[ci].Tags = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].Tags = types.StringNull()
			}
			if value := cr.Get("mip.auto-create.all"); value.Exists() {
				if !data.Domains[i].Services[ci].MipAutoCreateAll.IsNull() {
					data.Domains[i].Services[ci].MipAutoCreateAll = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].MipAutoCreateAll.IsNull() {
					data.Domains[i].Services[ci].MipAutoCreateAll = types.BoolNull()
				}
			}
			if value := cr.Get("mip.auto-create.lower-mep-only"); value.Exists() {
				if !data.Domains[i].Services[ci].MipAutoCreateLowerMepOnly.IsNull() {
					data.Domains[i].Services[ci].MipAutoCreateLowerMepOnly = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].MipAutoCreateLowerMepOnly.IsNull() {
					data.Domains[i].Services[ci].MipAutoCreateLowerMepOnly = types.BoolNull()
				}
			}
			if value := cr.Get("mip.auto-create.ccm-learning"); value.Exists() {
				if !data.Domains[i].Services[ci].MipAutoCreateCcmLearning.IsNull() {
					data.Domains[i].Services[ci].MipAutoCreateCcmLearning = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].MipAutoCreateCcmLearning.IsNull() {
					data.Domains[i].Services[ci].MipAutoCreateCcmLearning = types.BoolNull()
				}
			}
			if value := cr.Get("efd"); value.Exists() {
				if !data.Domains[i].Services[ci].Efd.IsNull() {
					data.Domains[i].Services[ci].Efd = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].Efd.IsNull() {
					data.Domains[i].Services[ci].Efd = types.BoolNull()
				}
			}
			if value := cr.Get("efd.protection-switching"); value.Exists() {
				if !data.Domains[i].Services[ci].EfdProtectionSwitching.IsNull() {
					data.Domains[i].Services[ci].EfdProtectionSwitching = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].EfdProtectionSwitching.IsNull() {
					data.Domains[i].Services[ci].EfdProtectionSwitching = types.BoolNull()
				}
			}
			if value := cr.Get("continuity-check.interval.interval-time"); value.Exists() && !data.Domains[i].Services[ci].ContinuityCheckInterval.IsNull() {
				data.Domains[i].Services[ci].ContinuityCheckInterval = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].ContinuityCheckInterval = types.StringNull()
			}
			if value := cr.Get("continuity-check.interval.loss-threshold"); value.Exists() {
				data.Domains[i].Services[ci].ContinuityCheckIntervalLossThreshold = types.Int64Value(value.Int())
			} else if data.Domains[i].Services[ci].ContinuityCheckIntervalLossThreshold.IsNull() {
				data.Domains[i].Services[ci].ContinuityCheckIntervalLossThreshold = types.Int64Null()
			}
			if value := cr.Get("continuity-check.archive.hold-time"); value.Exists() {
				data.Domains[i].Services[ci].ContinuityCheckArchiveHoldTime = types.Int64Value(value.Int())
			} else if data.Domains[i].Services[ci].ContinuityCheckArchiveHoldTime.IsNull() {
				data.Domains[i].Services[ci].ContinuityCheckArchiveHoldTime = types.Int64Null()
			}
			if value := cr.Get("continuity-check.loss.auto-traceroute"); value.Exists() {
				if !data.Domains[i].Services[ci].ContinuityCheckLossAutoTraceroute.IsNull() {
					data.Domains[i].Services[ci].ContinuityCheckLossAutoTraceroute = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].ContinuityCheckLossAutoTraceroute.IsNull() {
					data.Domains[i].Services[ci].ContinuityCheckLossAutoTraceroute = types.BoolNull()
				}
			}
			if value := cr.Get("maximum-meps"); value.Exists() {
				data.Domains[i].Services[ci].MaximumMeps = types.Int64Value(value.Int())
			} else if data.Domains[i].Services[ci].MaximumMeps.IsNull() {
				data.Domains[i].Services[ci].MaximumMeps = types.Int64Null()
			}
			if value := cr.Get("ais.transmission.interval"); value.Exists() && !data.Domains[i].Services[ci].AisTransmissionInterval.IsNull() {
				data.Domains[i].Services[ci].AisTransmissionInterval = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].AisTransmissionInterval = types.StringNull()
			}
			if value := cr.Get("ais.transmission.cos"); value.Exists() {
				data.Domains[i].Services[ci].AisTransmissionCos = types.Int64Value(value.Int())
			} else if data.Domains[i].Services[ci].AisTransmissionCos.IsNull() {
				data.Domains[i].Services[ci].AisTransmissionCos = types.Int64Null()
			}
			if value := cr.Get("log.continuity-check.mep.changes"); value.Exists() {
				if !data.Domains[i].Services[ci].LogContinuityCheckMepChanges.IsNull() {
					data.Domains[i].Services[ci].LogContinuityCheckMepChanges = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].LogContinuityCheckMepChanges.IsNull() {
					data.Domains[i].Services[ci].LogContinuityCheckMepChanges = types.BoolNull()
				}
			}
			if value := cr.Get("log.continuity-check.errors"); value.Exists() {
				if !data.Domains[i].Services[ci].LogContinuityCheckErrors.IsNull() {
					data.Domains[i].Services[ci].LogContinuityCheckErrors = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].LogContinuityCheckErrors.IsNull() {
					data.Domains[i].Services[ci].LogContinuityCheckErrors = types.BoolNull()
				}
			}
			if value := cr.Get("log.crosscheck.errors"); value.Exists() {
				if !data.Domains[i].Services[ci].LogCrosscheckErrors.IsNull() {
					data.Domains[i].Services[ci].LogCrosscheckErrors = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].LogCrosscheckErrors.IsNull() {
					data.Domains[i].Services[ci].LogCrosscheckErrors = types.BoolNull()
				}
			}
			if value := cr.Get("log.ais"); value.Exists() {
				if !data.Domains[i].Services[ci].LogAis.IsNull() {
					data.Domains[i].Services[ci].LogAis = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].LogAis.IsNull() {
					data.Domains[i].Services[ci].LogAis = types.BoolNull()
				}
			}
			if value := cr.Get("log.csf"); value.Exists() {
				if !data.Domains[i].Services[ci].LogCsf.IsNull() {
					data.Domains[i].Services[ci].LogCsf = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].LogCsf.IsNull() {
					data.Domains[i].Services[ci].LogCsf = types.BoolNull()
				}
			}
			if value := cr.Get("log.efd"); value.Exists() {
				if !data.Domains[i].Services[ci].LogEfd.IsNull() {
					data.Domains[i].Services[ci].LogEfd = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].LogEfd.IsNull() {
					data.Domains[i].Services[ci].LogEfd = types.BoolNull()
				}
			}
			for cci := range data.Domains[i].Services[ci].MepCrosschecks {
				keys := [...]string{"mep-id"}
				keyValues := [...]string{strconv.FormatInt(data.Domains[i].Services[ci].MepCrosschecks[cci].MepId.ValueInt64(), 10)}

				var ccr gjson.Result
				cr.Get("mep.crosscheck.mep-ids.mep-id").ForEach(
					func(_, v gjson.Result) bool {
						found := false
						for ik := range keys {
							if v.Get(keys[ik]).String() == keyValues[ik] {
								found = true
								continue
							}
							found = false
							break
						}
						if found {
							ccr = v
							return false
						}
						return true
					},
				)
				if value := ccr.Get("mep-id"); value.Exists() && !data.Domains[i].Services[ci].MepCrosschecks[cci].MepId.IsNull() {
					data.Domains[i].Services[ci].MepCrosschecks[cci].MepId = types.Int64Value(value.Int())
				} else {
					data.Domains[i].Services[ci].MepCrosschecks[cci].MepId = types.Int64Null()
				}
				if value := ccr.Get("mac-address"); value.Exists() && !data.Domains[i].Services[ci].MepCrosschecks[cci].MacAddress.IsNull() {
					data.Domains[i].Services[ci].MepCrosschecks[cci].MacAddress = types.StringValue(value.String())
				} else {
					data.Domains[i].Services[ci].MepCrosschecks[cci].MacAddress = types.StringNull()
				}
			}
			if value := cr.Get("mep.crosscheck.auto"); value.Exists() {
				if !data.Domains[i].Services[ci].MepCrosscheckAuto.IsNull() {
					data.Domains[i].Services[ci].MepCrosscheckAuto = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].MepCrosscheckAuto.IsNull() {
					data.Domains[i].Services[ci].MepCrosscheckAuto = types.BoolNull()
				}
			}
			if value := cr.Get("report.defects.none"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsNone.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsNone = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsNone.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsNone = types.BoolNull()
				}
			}
			if value := cr.Get("report.defects.all"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsAll.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsAll = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsAll.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsAll = types.BoolNull()
				}
			}
			if value := cr.Get("report.defects.ieee.xcon"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsIeeeXcon.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsIeeeXcon = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsIeeeXcon.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsIeeeXcon = types.BoolNull()
				}
			}
			if value := cr.Get("report.defects.ieee.error-xcon"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsIeeeErrorXcon.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsIeeeErrorXcon = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsIeeeErrorXcon.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsIeeeErrorXcon = types.BoolNull()
				}
			}
			if value := cr.Get("report.defects.ieee.remote-error-xcon"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsIeeeRemoteErrorXcon.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsIeeeRemoteErrorXcon = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsIeeeRemoteErrorXcon.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsIeeeRemoteErrorXcon = types.BoolNull()
				}
			}
			if value := cr.Get("report.defects.ieee.mac-remote-error-xcon"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsIeeeMacRemoteErrorXcon.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsIeeeMacRemoteErrorXcon = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsIeeeMacRemoteErrorXcon.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsIeeeMacRemoteErrorXcon = types.BoolNull()
				}
			}
			if value := cr.Get("report.defects.wrong-maid"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsWrongMaid.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsWrongMaid = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsWrongMaid.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsWrongMaid = types.BoolNull()
				}
			}
			if value := cr.Get("report.defects.wrong-level"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsWrongLevel.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsWrongLevel = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsWrongLevel.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsWrongLevel = types.BoolNull()
				}
			}
			if value := cr.Get("report.defects.our-mac"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsOurMac.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsOurMac = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsOurMac.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsOurMac = types.BoolNull()
				}
			}
			if value := cr.Get("report.defects.our-mepid"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsOurMepid.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsOurMepid = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsOurMepid.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsOurMepid = types.BoolNull()
				}
			}
			if value := cr.Get("report.defects.wrong-interval"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsWrongInterval.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsWrongInterval = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsWrongInterval.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsWrongInterval = types.BoolNull()
				}
			}
			if value := cr.Get("report.defects.missing"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsMissing.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsMissing = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsMissing.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsMissing = types.BoolNull()
				}
			}
			if value := cr.Get("report.defects.peer-port-down"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsPeerPortDown.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsPeerPortDown = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsPeerPortDown.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsPeerPortDown = types.BoolNull()
				}
			}
			if value := cr.Get("report.defects.rdi"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsRdi.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsRdi = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to null if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsRdi.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsRdi = types.BoolNull()
				}
			}
		}
	}
}

// End of section. //template:end updateFromBody

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBodyXML

func (data *EthernetCFM) updateFromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/traceroute/cache/hold-time"); value.Exists() {
		data.TracerouteCacheHoldTime = types.Int64Value(value.Int())
	} else if data.TracerouteCacheHoldTime.IsNull() {
		data.TracerouteCacheHoldTime = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/traceroute/cache/size"); value.Exists() {
		data.TracerouteCacheSize = types.Int64Value(value.Int())
	} else if data.TracerouteCacheSize.IsNull() {
		data.TracerouteCacheSize = types.Int64Null()
	}
	for i := range data.Domains {
		keys := [...]string{"domain-name"}
		keyValues := [...]string{data.Domains[i].DomainName.ValueString()}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/domains/domain").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "domain-name"); value.Exists() {
			data.Domains[i].DomainName = types.StringValue(value.String())
		} else if data.Domains[i].DomainName.IsNull() {
			data.Domains[i].DomainName = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "level"); value.Exists() {
			data.Domains[i].Level = types.Int64Value(value.Int())
		} else if data.Domains[i].Level.IsNull() {
			data.Domains[i].Level = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "id/dns"); value.Exists() {
			data.Domains[i].IdDns = types.StringValue(value.String())
		} else if data.Domains[i].IdDns.IsNull() {
			data.Domains[i].IdDns = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "id/mac-address"); value.Exists() {
			data.Domains[i].IdMacAddress = types.StringValue(value.String())
		} else if data.Domains[i].IdMacAddress.IsNull() {
			data.Domains[i].IdMacAddress = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "id/mac-address-two-octet-integer"); value.Exists() {
			data.Domains[i].IdMacAddressInteger = types.Int64Value(value.Int())
		} else if data.Domains[i].IdMacAddressInteger.IsNull() {
			data.Domains[i].IdMacAddressInteger = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "id/null"); value.Exists() {
			data.Domains[i].IdNull = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Domains[i].IdNull.IsNull() {
				data.Domains[i].IdNull = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "id/string"); value.Exists() {
			data.Domains[i].IdString = types.StringValue(value.String())
		} else if data.Domains[i].IdString.IsNull() {
			data.Domains[i].IdString = types.StringNull()
		}
		for ci := range data.Domains[i].Services {
			keys := [...]string{"service-name"}
			keyValues := [...]string{data.Domains[i].Services[ci].ServiceName.ValueString()}

			var cr xmldot.Result
			helpers.GetFromXPath(r, "services/service").ForEach(
				func(_ int, v xmldot.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := helpers.GetFromXPath(cr, "service-name"); value.Exists() {
				data.Domains[i].Services[ci].ServiceName = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].ServiceName = types.StringNull()
			}
			if value := helpers.GetFromXPath(cr, "bridge/group"); value.Exists() {
				data.Domains[i].Services[ci].BridgeGroup = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].BridgeGroup = types.StringNull()
			}
			if value := helpers.GetFromXPath(cr, "bridge/bridge-domain"); value.Exists() {
				data.Domains[i].Services[ci].BridgeDomain = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].BridgeDomain = types.StringNull()
			}
			if value := helpers.GetFromXPath(cr, "down-meps"); value.Exists() {
				if !data.Domains[i].Services[ci].DownMeps.IsNull() {
					data.Domains[i].Services[ci].DownMeps = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].DownMeps.IsNull() {
					data.Domains[i].Services[ci].DownMeps = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "flexible-xconnect/vlan-aware/evi"); value.Exists() {
				data.Domains[i].Services[ci].FlexibleXconnectVlanAwareEvi = types.Int64Value(value.Int())
			} else {
				data.Domains[i].Services[ci].FlexibleXconnectVlanAwareEvi = types.Int64Null()
			}
			if value := helpers.GetFromXPath(cr, "flexible-xconnect/vlan-unaware/cross-connect-name"); value.Exists() {
				data.Domains[i].Services[ci].FlexibleXconnectVlanUnawareName = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].FlexibleXconnectVlanUnawareName = types.StringNull()
			}
			if value := helpers.GetFromXPath(cr, "xconnect/mp2mp/group"); value.Exists() {
				data.Domains[i].Services[ci].XconnectMp2mpGroup = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].XconnectMp2mpGroup = types.StringNull()
			}
			if value := helpers.GetFromXPath(cr, "xconnect/mp2mp/cross-connect-name"); value.Exists() {
				data.Domains[i].Services[ci].XconnectMp2mpName = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].XconnectMp2mpName = types.StringNull()
			}
			if value := helpers.GetFromXPath(cr, "xconnect/mp2mp/ce-id"); value.Exists() {
				data.Domains[i].Services[ci].XconnectMp2mpCeId = types.Int64Value(value.Int())
			} else {
				data.Domains[i].Services[ci].XconnectMp2mpCeId = types.Int64Null()
			}
			if value := helpers.GetFromXPath(cr, "xconnect/mp2mp/remote-ce-id"); value.Exists() {
				data.Domains[i].Services[ci].XconnectMp2mpRemoteCeId = types.Int64Value(value.Int())
			} else {
				data.Domains[i].Services[ci].XconnectMp2mpRemoteCeId = types.Int64Null()
			}
			if value := helpers.GetFromXPath(cr, "xconnect/p2p/group"); value.Exists() {
				data.Domains[i].Services[ci].XconnectP2pGroupName = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].XconnectP2pGroupName = types.StringNull()
			}
			if value := helpers.GetFromXPath(cr, "xconnect/p2p/cross-connect-name"); value.Exists() {
				data.Domains[i].Services[ci].XconnectP2pXcName = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].XconnectP2pXcName = types.StringNull()
			}
			if value := helpers.GetFromXPath(cr, "id/icc-based/icc"); value.Exists() {
				data.Domains[i].Services[ci].IdIccBasedIcc = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].IdIccBasedIcc = types.StringNull()
			}
			if value := helpers.GetFromXPath(cr, "id/icc-based/umc"); value.Exists() {
				data.Domains[i].Services[ci].IdIccBasedUmc = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].IdIccBasedUmc = types.StringNull()
			}
			if value := helpers.GetFromXPath(cr, "id/vlanid"); value.Exists() {
				data.Domains[i].Services[ci].IdVlanId = types.Int64Value(value.Int())
			} else {
				data.Domains[i].Services[ci].IdVlanId = types.Int64Null()
			}
			if value := helpers.GetFromXPath(cr, "id/number"); value.Exists() {
				data.Domains[i].Services[ci].IdNumber = types.Int64Value(value.Int())
			} else {
				data.Domains[i].Services[ci].IdNumber = types.Int64Null()
			}
			if value := helpers.GetFromXPath(cr, "id/string"); value.Exists() {
				data.Domains[i].Services[ci].IdString = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].IdString = types.StringNull()
			}
			if value := helpers.GetFromXPath(cr, "id/vpn-id/vpn-oui"); value.Exists() {
				data.Domains[i].Services[ci].IdVpnIdOui = types.Int64Value(value.Int())
			} else {
				data.Domains[i].Services[ci].IdVpnIdOui = types.Int64Null()
			}
			if value := helpers.GetFromXPath(cr, "id/vpn-id/vpn-index"); value.Exists() {
				data.Domains[i].Services[ci].IdVpnIdIndex = types.Int64Value(value.Int())
			} else {
				data.Domains[i].Services[ci].IdVpnIdIndex = types.Int64Null()
			}
			if value := helpers.GetFromXPath(cr, "tags"); value.Exists() {
				data.Domains[i].Services[ci].Tags = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].Tags = types.StringNull()
			}
			if value := helpers.GetFromXPath(cr, "mip/auto-create/all"); value.Exists() {
				if !data.Domains[i].Services[ci].MipAutoCreateAll.IsNull() {
					data.Domains[i].Services[ci].MipAutoCreateAll = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].MipAutoCreateAll.IsNull() {
					data.Domains[i].Services[ci].MipAutoCreateAll = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "mip/auto-create/lower-mep-only"); value.Exists() {
				if !data.Domains[i].Services[ci].MipAutoCreateLowerMepOnly.IsNull() {
					data.Domains[i].Services[ci].MipAutoCreateLowerMepOnly = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].MipAutoCreateLowerMepOnly.IsNull() {
					data.Domains[i].Services[ci].MipAutoCreateLowerMepOnly = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "mip/auto-create/ccm-learning"); value.Exists() {
				if !data.Domains[i].Services[ci].MipAutoCreateCcmLearning.IsNull() {
					data.Domains[i].Services[ci].MipAutoCreateCcmLearning = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].MipAutoCreateCcmLearning.IsNull() {
					data.Domains[i].Services[ci].MipAutoCreateCcmLearning = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "efd"); value.Exists() {
				if !data.Domains[i].Services[ci].Efd.IsNull() {
					data.Domains[i].Services[ci].Efd = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].Efd.IsNull() {
					data.Domains[i].Services[ci].Efd = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "efd/protection-switching"); value.Exists() {
				if !data.Domains[i].Services[ci].EfdProtectionSwitching.IsNull() {
					data.Domains[i].Services[ci].EfdProtectionSwitching = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].EfdProtectionSwitching.IsNull() {
					data.Domains[i].Services[ci].EfdProtectionSwitching = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "continuity-check/interval/interval-time"); value.Exists() {
				data.Domains[i].Services[ci].ContinuityCheckInterval = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].ContinuityCheckInterval = types.StringNull()
			}
			if value := helpers.GetFromXPath(cr, "continuity-check/interval/loss-threshold"); value.Exists() {
				data.Domains[i].Services[ci].ContinuityCheckIntervalLossThreshold = types.Int64Value(value.Int())
			} else {
				data.Domains[i].Services[ci].ContinuityCheckIntervalLossThreshold = types.Int64Null()
			}
			if value := helpers.GetFromXPath(cr, "continuity-check/archive/hold-time"); value.Exists() {
				data.Domains[i].Services[ci].ContinuityCheckArchiveHoldTime = types.Int64Value(value.Int())
			} else {
				data.Domains[i].Services[ci].ContinuityCheckArchiveHoldTime = types.Int64Null()
			}
			if value := helpers.GetFromXPath(cr, "continuity-check/loss/auto-traceroute"); value.Exists() {
				if !data.Domains[i].Services[ci].ContinuityCheckLossAutoTraceroute.IsNull() {
					data.Domains[i].Services[ci].ContinuityCheckLossAutoTraceroute = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].ContinuityCheckLossAutoTraceroute.IsNull() {
					data.Domains[i].Services[ci].ContinuityCheckLossAutoTraceroute = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "maximum-meps"); value.Exists() {
				data.Domains[i].Services[ci].MaximumMeps = types.Int64Value(value.Int())
			} else {
				data.Domains[i].Services[ci].MaximumMeps = types.Int64Null()
			}
			if value := helpers.GetFromXPath(cr, "ais/transmission/interval"); value.Exists() {
				data.Domains[i].Services[ci].AisTransmissionInterval = types.StringValue(value.String())
			} else {
				data.Domains[i].Services[ci].AisTransmissionInterval = types.StringNull()
			}
			if value := helpers.GetFromXPath(cr, "ais/transmission/cos"); value.Exists() {
				data.Domains[i].Services[ci].AisTransmissionCos = types.Int64Value(value.Int())
			} else {
				data.Domains[i].Services[ci].AisTransmissionCos = types.Int64Null()
			}
			if value := helpers.GetFromXPath(cr, "log/continuity-check/mep/changes"); value.Exists() {
				if !data.Domains[i].Services[ci].LogContinuityCheckMepChanges.IsNull() {
					data.Domains[i].Services[ci].LogContinuityCheckMepChanges = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].LogContinuityCheckMepChanges.IsNull() {
					data.Domains[i].Services[ci].LogContinuityCheckMepChanges = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "log/continuity-check/errors"); value.Exists() {
				if !data.Domains[i].Services[ci].LogContinuityCheckErrors.IsNull() {
					data.Domains[i].Services[ci].LogContinuityCheckErrors = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].LogContinuityCheckErrors.IsNull() {
					data.Domains[i].Services[ci].LogContinuityCheckErrors = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "log/crosscheck/errors"); value.Exists() {
				if !data.Domains[i].Services[ci].LogCrosscheckErrors.IsNull() {
					data.Domains[i].Services[ci].LogCrosscheckErrors = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].LogCrosscheckErrors.IsNull() {
					data.Domains[i].Services[ci].LogCrosscheckErrors = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "log/ais"); value.Exists() {
				if !data.Domains[i].Services[ci].LogAis.IsNull() {
					data.Domains[i].Services[ci].LogAis = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].LogAis.IsNull() {
					data.Domains[i].Services[ci].LogAis = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "log/csf"); value.Exists() {
				if !data.Domains[i].Services[ci].LogCsf.IsNull() {
					data.Domains[i].Services[ci].LogCsf = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].LogCsf.IsNull() {
					data.Domains[i].Services[ci].LogCsf = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "log/efd"); value.Exists() {
				if !data.Domains[i].Services[ci].LogEfd.IsNull() {
					data.Domains[i].Services[ci].LogEfd = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].LogEfd.IsNull() {
					data.Domains[i].Services[ci].LogEfd = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "mep/crosscheck/auto"); value.Exists() {
				if !data.Domains[i].Services[ci].MepCrosscheckAuto.IsNull() {
					data.Domains[i].Services[ci].MepCrosscheckAuto = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].MepCrosscheckAuto.IsNull() {
					data.Domains[i].Services[ci].MepCrosscheckAuto = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "report/defects/none"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsNone.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsNone = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsNone.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsNone = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "report/defects/all"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsAll.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsAll = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsAll.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsAll = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "report/defects/ieee/xcon"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsIeeeXcon.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsIeeeXcon = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsIeeeXcon.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsIeeeXcon = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "report/defects/ieee/error-xcon"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsIeeeErrorXcon.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsIeeeErrorXcon = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsIeeeErrorXcon.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsIeeeErrorXcon = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "report/defects/ieee/remote-error-xcon"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsIeeeRemoteErrorXcon.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsIeeeRemoteErrorXcon = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsIeeeRemoteErrorXcon.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsIeeeRemoteErrorXcon = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "report/defects/ieee/mac-remote-error-xcon"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsIeeeMacRemoteErrorXcon.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsIeeeMacRemoteErrorXcon = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsIeeeMacRemoteErrorXcon.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsIeeeMacRemoteErrorXcon = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "report/defects/wrong-maid"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsWrongMaid.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsWrongMaid = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsWrongMaid.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsWrongMaid = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "report/defects/wrong-level"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsWrongLevel.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsWrongLevel = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsWrongLevel.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsWrongLevel = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "report/defects/our-mac"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsOurMac.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsOurMac = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsOurMac.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsOurMac = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "report/defects/our-mepid"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsOurMepid.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsOurMepid = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsOurMepid.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsOurMepid = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "report/defects/wrong-interval"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsWrongInterval.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsWrongInterval = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsWrongInterval.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsWrongInterval = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "report/defects/missing"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsMissing.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsMissing = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsMissing.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsMissing = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "report/defects/peer-port-down"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsPeerPortDown.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsPeerPortDown = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsPeerPortDown.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsPeerPortDown = types.BoolNull()
				}
			}
			if value := helpers.GetFromXPath(cr, "report/defects/rdi"); value.Exists() {
				if !data.Domains[i].Services[ci].ReportDefectsRdi.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsRdi = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.Domains[i].Services[ci].ReportDefectsRdi.IsNull() {
					data.Domains[i].Services[ci].ReportDefectsRdi = types.BoolNull()
				}
			}
		}
	}
}

// End of section. //template:end updateFromBodyXML

// Section below is generated&owned by "gen/generator.go". //template:begin fromBody

func (data *EthernetCFM) fromBody(ctx context.Context, res gjson.Result) {
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	if value := res.Get(prefix + "traceroute.cache.hold-time"); value.Exists() {
		data.TracerouteCacheHoldTime = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "traceroute.cache.size"); value.Exists() {
		data.TracerouteCacheSize = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "domains.domain"); value.Exists() {
		data.Domains = make([]EthernetCFMDomains, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := EthernetCFMDomains{}
			if cValue := v.Get("domain-name"); cValue.Exists() {
				item.DomainName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("level"); cValue.Exists() {
				item.Level = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("id.dns"); cValue.Exists() {
				item.IdDns = types.StringValue(cValue.String())
			}
			if cValue := v.Get("id.mac-address"); cValue.Exists() {
				item.IdMacAddress = types.StringValue(cValue.String())
			}
			if cValue := v.Get("id.mac-address-two-octet-integer"); cValue.Exists() {
				item.IdMacAddressInteger = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("id.null"); cValue.Exists() {
				item.IdNull = types.BoolValue(true)
			} else {
				item.IdNull = types.BoolNull()
			}
			if cValue := v.Get("id.string"); cValue.Exists() {
				item.IdString = types.StringValue(cValue.String())
			}
			if cValue := v.Get("services.service"); cValue.Exists() {
				item.Services = make([]EthernetCFMDomainsServices, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := EthernetCFMDomainsServices{}
					if ccValue := cv.Get("service-name"); ccValue.Exists() {
						cItem.ServiceName = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("bridge.group"); ccValue.Exists() {
						cItem.BridgeGroup = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("bridge.bridge-domain"); ccValue.Exists() {
						cItem.BridgeDomain = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("down-meps"); ccValue.Exists() {
						cItem.DownMeps = types.BoolValue(true)
					} else {
						cItem.DownMeps = types.BoolNull()
					}
					if ccValue := cv.Get("flexible-xconnect.vlan-aware.evi"); ccValue.Exists() {
						cItem.FlexibleXconnectVlanAwareEvi = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("flexible-xconnect.vlan-unaware.cross-connect-name"); ccValue.Exists() {
						cItem.FlexibleXconnectVlanUnawareName = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("xconnect.mp2mp.group"); ccValue.Exists() {
						cItem.XconnectMp2mpGroup = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("xconnect.mp2mp.cross-connect-name"); ccValue.Exists() {
						cItem.XconnectMp2mpName = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("xconnect.mp2mp.ce-id"); ccValue.Exists() {
						cItem.XconnectMp2mpCeId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("xconnect.mp2mp.remote-ce-id"); ccValue.Exists() {
						cItem.XconnectMp2mpRemoteCeId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("xconnect.p2p.group"); ccValue.Exists() {
						cItem.XconnectP2pGroupName = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("xconnect.p2p.cross-connect-name"); ccValue.Exists() {
						cItem.XconnectP2pXcName = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("id.icc-based.icc"); ccValue.Exists() {
						cItem.IdIccBasedIcc = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("id.icc-based.umc"); ccValue.Exists() {
						cItem.IdIccBasedUmc = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("id.vlanid"); ccValue.Exists() {
						cItem.IdVlanId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("id.number"); ccValue.Exists() {
						cItem.IdNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("id.string"); ccValue.Exists() {
						cItem.IdString = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("id.vpn-id.vpn-oui"); ccValue.Exists() {
						cItem.IdVpnIdOui = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("id.vpn-id.vpn-index"); ccValue.Exists() {
						cItem.IdVpnIdIndex = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("tags"); ccValue.Exists() {
						cItem.Tags = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("mip.auto-create.all"); ccValue.Exists() {
						cItem.MipAutoCreateAll = types.BoolValue(true)
					} else {
						cItem.MipAutoCreateAll = types.BoolNull()
					}
					if ccValue := cv.Get("mip.auto-create.lower-mep-only"); ccValue.Exists() {
						cItem.MipAutoCreateLowerMepOnly = types.BoolValue(true)
					} else {
						cItem.MipAutoCreateLowerMepOnly = types.BoolNull()
					}
					if ccValue := cv.Get("mip.auto-create.ccm-learning"); ccValue.Exists() {
						cItem.MipAutoCreateCcmLearning = types.BoolValue(true)
					} else {
						cItem.MipAutoCreateCcmLearning = types.BoolNull()
					}
					if ccValue := cv.Get("efd"); ccValue.Exists() {
						cItem.Efd = types.BoolValue(true)
					} else {
						cItem.Efd = types.BoolNull()
					}
					if ccValue := cv.Get("efd.protection-switching"); ccValue.Exists() {
						cItem.EfdProtectionSwitching = types.BoolValue(true)
					} else {
						cItem.EfdProtectionSwitching = types.BoolNull()
					}
					if ccValue := cv.Get("continuity-check.interval.interval-time"); ccValue.Exists() {
						cItem.ContinuityCheckInterval = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("continuity-check.interval.loss-threshold"); ccValue.Exists() {
						cItem.ContinuityCheckIntervalLossThreshold = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("continuity-check.archive.hold-time"); ccValue.Exists() {
						cItem.ContinuityCheckArchiveHoldTime = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("continuity-check.loss.auto-traceroute"); ccValue.Exists() {
						cItem.ContinuityCheckLossAutoTraceroute = types.BoolValue(true)
					} else {
						cItem.ContinuityCheckLossAutoTraceroute = types.BoolNull()
					}
					if ccValue := cv.Get("maximum-meps"); ccValue.Exists() {
						cItem.MaximumMeps = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("ais.transmission.interval"); ccValue.Exists() {
						cItem.AisTransmissionInterval = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("ais.transmission.cos"); ccValue.Exists() {
						cItem.AisTransmissionCos = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("log.continuity-check.mep.changes"); ccValue.Exists() {
						cItem.LogContinuityCheckMepChanges = types.BoolValue(true)
					} else {
						cItem.LogContinuityCheckMepChanges = types.BoolNull()
					}
					if ccValue := cv.Get("log.continuity-check.errors"); ccValue.Exists() {
						cItem.LogContinuityCheckErrors = types.BoolValue(true)
					} else {
						cItem.LogContinuityCheckErrors = types.BoolNull()
					}
					if ccValue := cv.Get("log.crosscheck.errors"); ccValue.Exists() {
						cItem.LogCrosscheckErrors = types.BoolValue(true)
					} else {
						cItem.LogCrosscheckErrors = types.BoolNull()
					}
					if ccValue := cv.Get("log.ais"); ccValue.Exists() {
						cItem.LogAis = types.BoolValue(true)
					} else {
						cItem.LogAis = types.BoolNull()
					}
					if ccValue := cv.Get("log.csf"); ccValue.Exists() {
						cItem.LogCsf = types.BoolValue(true)
					} else {
						cItem.LogCsf = types.BoolNull()
					}
					if ccValue := cv.Get("log.efd"); ccValue.Exists() {
						cItem.LogEfd = types.BoolValue(true)
					} else {
						cItem.LogEfd = types.BoolNull()
					}
					if ccValue := cv.Get("mep.crosscheck.mep-ids.mep-id"); ccValue.Exists() {
						cItem.MepCrosschecks = make([]EthernetCFMDomainsServicesMepCrosschecks, 0)
						ccValue.ForEach(func(cck, ccv gjson.Result) bool {
							ccItem := EthernetCFMDomainsServicesMepCrosschecks{}
							if cccValue := ccv.Get("mep-id"); cccValue.Exists() {
								ccItem.MepId = types.Int64Value(cccValue.Int())
							}
							if cccValue := ccv.Get("mac-address"); cccValue.Exists() {
								ccItem.MacAddress = types.StringValue(cccValue.String())
							}
							cItem.MepCrosschecks = append(cItem.MepCrosschecks, ccItem)
							return true
						})
					}
					if ccValue := cv.Get("mep.crosscheck.auto"); ccValue.Exists() {
						cItem.MepCrosscheckAuto = types.BoolValue(true)
					} else {
						cItem.MepCrosscheckAuto = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.none"); ccValue.Exists() {
						cItem.ReportDefectsNone = types.BoolValue(true)
					} else {
						cItem.ReportDefectsNone = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.all"); ccValue.Exists() {
						cItem.ReportDefectsAll = types.BoolValue(true)
					} else {
						cItem.ReportDefectsAll = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.ieee.xcon"); ccValue.Exists() {
						cItem.ReportDefectsIeeeXcon = types.BoolValue(true)
					} else {
						cItem.ReportDefectsIeeeXcon = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.ieee.error-xcon"); ccValue.Exists() {
						cItem.ReportDefectsIeeeErrorXcon = types.BoolValue(true)
					} else {
						cItem.ReportDefectsIeeeErrorXcon = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.ieee.remote-error-xcon"); ccValue.Exists() {
						cItem.ReportDefectsIeeeRemoteErrorXcon = types.BoolValue(true)
					} else {
						cItem.ReportDefectsIeeeRemoteErrorXcon = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.ieee.mac-remote-error-xcon"); ccValue.Exists() {
						cItem.ReportDefectsIeeeMacRemoteErrorXcon = types.BoolValue(true)
					} else {
						cItem.ReportDefectsIeeeMacRemoteErrorXcon = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.wrong-maid"); ccValue.Exists() {
						cItem.ReportDefectsWrongMaid = types.BoolValue(true)
					} else {
						cItem.ReportDefectsWrongMaid = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.wrong-level"); ccValue.Exists() {
						cItem.ReportDefectsWrongLevel = types.BoolValue(true)
					} else {
						cItem.ReportDefectsWrongLevel = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.our-mac"); ccValue.Exists() {
						cItem.ReportDefectsOurMac = types.BoolValue(true)
					} else {
						cItem.ReportDefectsOurMac = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.our-mepid"); ccValue.Exists() {
						cItem.ReportDefectsOurMepid = types.BoolValue(true)
					} else {
						cItem.ReportDefectsOurMepid = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.wrong-interval"); ccValue.Exists() {
						cItem.ReportDefectsWrongInterval = types.BoolValue(true)
					} else {
						cItem.ReportDefectsWrongInterval = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.missing"); ccValue.Exists() {
						cItem.ReportDefectsMissing = types.BoolValue(true)
					} else {
						cItem.ReportDefectsMissing = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.peer-port-down"); ccValue.Exists() {
						cItem.ReportDefectsPeerPortDown = types.BoolValue(true)
					} else {
						cItem.ReportDefectsPeerPortDown = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.rdi"); ccValue.Exists() {
						cItem.ReportDefectsRdi = types.BoolValue(true)
					} else {
						cItem.ReportDefectsRdi = types.BoolNull()
					}
					item.Services = append(item.Services, cItem)
					return true
				})
			}
			data.Domains = append(data.Domains, item)
			return true
		})
	}
}

// End of section. //template:end fromBody

// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyData

func (data *EthernetCFMData) fromBody(ctx context.Context, res gjson.Result) {
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	if value := res.Get(prefix + "traceroute.cache.hold-time"); value.Exists() {
		data.TracerouteCacheHoldTime = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "traceroute.cache.size"); value.Exists() {
		data.TracerouteCacheSize = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "domains.domain"); value.Exists() {
		data.Domains = make([]EthernetCFMDomains, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := EthernetCFMDomains{}
			if cValue := v.Get("domain-name"); cValue.Exists() {
				item.DomainName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("level"); cValue.Exists() {
				item.Level = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("id.dns"); cValue.Exists() {
				item.IdDns = types.StringValue(cValue.String())
			}
			if cValue := v.Get("id.mac-address"); cValue.Exists() {
				item.IdMacAddress = types.StringValue(cValue.String())
			}
			if cValue := v.Get("id.mac-address-two-octet-integer"); cValue.Exists() {
				item.IdMacAddressInteger = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("id.null"); cValue.Exists() {
				item.IdNull = types.BoolValue(true)
			} else {
				item.IdNull = types.BoolNull()
			}
			if cValue := v.Get("id.string"); cValue.Exists() {
				item.IdString = types.StringValue(cValue.String())
			}
			if cValue := v.Get("services.service"); cValue.Exists() {
				item.Services = make([]EthernetCFMDomainsServices, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := EthernetCFMDomainsServices{}
					if ccValue := cv.Get("service-name"); ccValue.Exists() {
						cItem.ServiceName = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("bridge.group"); ccValue.Exists() {
						cItem.BridgeGroup = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("bridge.bridge-domain"); ccValue.Exists() {
						cItem.BridgeDomain = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("down-meps"); ccValue.Exists() {
						cItem.DownMeps = types.BoolValue(true)
					} else {
						cItem.DownMeps = types.BoolNull()
					}
					if ccValue := cv.Get("flexible-xconnect.vlan-aware.evi"); ccValue.Exists() {
						cItem.FlexibleXconnectVlanAwareEvi = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("flexible-xconnect.vlan-unaware.cross-connect-name"); ccValue.Exists() {
						cItem.FlexibleXconnectVlanUnawareName = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("xconnect.mp2mp.group"); ccValue.Exists() {
						cItem.XconnectMp2mpGroup = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("xconnect.mp2mp.cross-connect-name"); ccValue.Exists() {
						cItem.XconnectMp2mpName = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("xconnect.mp2mp.ce-id"); ccValue.Exists() {
						cItem.XconnectMp2mpCeId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("xconnect.mp2mp.remote-ce-id"); ccValue.Exists() {
						cItem.XconnectMp2mpRemoteCeId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("xconnect.p2p.group"); ccValue.Exists() {
						cItem.XconnectP2pGroupName = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("xconnect.p2p.cross-connect-name"); ccValue.Exists() {
						cItem.XconnectP2pXcName = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("id.icc-based.icc"); ccValue.Exists() {
						cItem.IdIccBasedIcc = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("id.icc-based.umc"); ccValue.Exists() {
						cItem.IdIccBasedUmc = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("id.vlanid"); ccValue.Exists() {
						cItem.IdVlanId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("id.number"); ccValue.Exists() {
						cItem.IdNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("id.string"); ccValue.Exists() {
						cItem.IdString = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("id.vpn-id.vpn-oui"); ccValue.Exists() {
						cItem.IdVpnIdOui = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("id.vpn-id.vpn-index"); ccValue.Exists() {
						cItem.IdVpnIdIndex = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("tags"); ccValue.Exists() {
						cItem.Tags = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("mip.auto-create.all"); ccValue.Exists() {
						cItem.MipAutoCreateAll = types.BoolValue(true)
					} else {
						cItem.MipAutoCreateAll = types.BoolNull()
					}
					if ccValue := cv.Get("mip.auto-create.lower-mep-only"); ccValue.Exists() {
						cItem.MipAutoCreateLowerMepOnly = types.BoolValue(true)
					} else {
						cItem.MipAutoCreateLowerMepOnly = types.BoolNull()
					}
					if ccValue := cv.Get("mip.auto-create.ccm-learning"); ccValue.Exists() {
						cItem.MipAutoCreateCcmLearning = types.BoolValue(true)
					} else {
						cItem.MipAutoCreateCcmLearning = types.BoolNull()
					}
					if ccValue := cv.Get("efd"); ccValue.Exists() {
						cItem.Efd = types.BoolValue(true)
					} else {
						cItem.Efd = types.BoolNull()
					}
					if ccValue := cv.Get("efd.protection-switching"); ccValue.Exists() {
						cItem.EfdProtectionSwitching = types.BoolValue(true)
					} else {
						cItem.EfdProtectionSwitching = types.BoolNull()
					}
					if ccValue := cv.Get("continuity-check.interval.interval-time"); ccValue.Exists() {
						cItem.ContinuityCheckInterval = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("continuity-check.interval.loss-threshold"); ccValue.Exists() {
						cItem.ContinuityCheckIntervalLossThreshold = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("continuity-check.archive.hold-time"); ccValue.Exists() {
						cItem.ContinuityCheckArchiveHoldTime = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("continuity-check.loss.auto-traceroute"); ccValue.Exists() {
						cItem.ContinuityCheckLossAutoTraceroute = types.BoolValue(true)
					} else {
						cItem.ContinuityCheckLossAutoTraceroute = types.BoolNull()
					}
					if ccValue := cv.Get("maximum-meps"); ccValue.Exists() {
						cItem.MaximumMeps = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("ais.transmission.interval"); ccValue.Exists() {
						cItem.AisTransmissionInterval = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("ais.transmission.cos"); ccValue.Exists() {
						cItem.AisTransmissionCos = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("log.continuity-check.mep.changes"); ccValue.Exists() {
						cItem.LogContinuityCheckMepChanges = types.BoolValue(true)
					} else {
						cItem.LogContinuityCheckMepChanges = types.BoolNull()
					}
					if ccValue := cv.Get("log.continuity-check.errors"); ccValue.Exists() {
						cItem.LogContinuityCheckErrors = types.BoolValue(true)
					} else {
						cItem.LogContinuityCheckErrors = types.BoolNull()
					}
					if ccValue := cv.Get("log.crosscheck.errors"); ccValue.Exists() {
						cItem.LogCrosscheckErrors = types.BoolValue(true)
					} else {
						cItem.LogCrosscheckErrors = types.BoolNull()
					}
					if ccValue := cv.Get("log.ais"); ccValue.Exists() {
						cItem.LogAis = types.BoolValue(true)
					} else {
						cItem.LogAis = types.BoolNull()
					}
					if ccValue := cv.Get("log.csf"); ccValue.Exists() {
						cItem.LogCsf = types.BoolValue(true)
					} else {
						cItem.LogCsf = types.BoolNull()
					}
					if ccValue := cv.Get("log.efd"); ccValue.Exists() {
						cItem.LogEfd = types.BoolValue(true)
					} else {
						cItem.LogEfd = types.BoolNull()
					}
					if ccValue := cv.Get("mep.crosscheck.mep-ids.mep-id"); ccValue.Exists() {
						cItem.MepCrosschecks = make([]EthernetCFMDomainsServicesMepCrosschecks, 0)
						ccValue.ForEach(func(cck, ccv gjson.Result) bool {
							ccItem := EthernetCFMDomainsServicesMepCrosschecks{}
							if cccValue := ccv.Get("mep-id"); cccValue.Exists() {
								ccItem.MepId = types.Int64Value(cccValue.Int())
							}
							if cccValue := ccv.Get("mac-address"); cccValue.Exists() {
								ccItem.MacAddress = types.StringValue(cccValue.String())
							}
							cItem.MepCrosschecks = append(cItem.MepCrosschecks, ccItem)
							return true
						})
					}
					if ccValue := cv.Get("mep.crosscheck.auto"); ccValue.Exists() {
						cItem.MepCrosscheckAuto = types.BoolValue(true)
					} else {
						cItem.MepCrosscheckAuto = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.none"); ccValue.Exists() {
						cItem.ReportDefectsNone = types.BoolValue(true)
					} else {
						cItem.ReportDefectsNone = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.all"); ccValue.Exists() {
						cItem.ReportDefectsAll = types.BoolValue(true)
					} else {
						cItem.ReportDefectsAll = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.ieee.xcon"); ccValue.Exists() {
						cItem.ReportDefectsIeeeXcon = types.BoolValue(true)
					} else {
						cItem.ReportDefectsIeeeXcon = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.ieee.error-xcon"); ccValue.Exists() {
						cItem.ReportDefectsIeeeErrorXcon = types.BoolValue(true)
					} else {
						cItem.ReportDefectsIeeeErrorXcon = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.ieee.remote-error-xcon"); ccValue.Exists() {
						cItem.ReportDefectsIeeeRemoteErrorXcon = types.BoolValue(true)
					} else {
						cItem.ReportDefectsIeeeRemoteErrorXcon = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.ieee.mac-remote-error-xcon"); ccValue.Exists() {
						cItem.ReportDefectsIeeeMacRemoteErrorXcon = types.BoolValue(true)
					} else {
						cItem.ReportDefectsIeeeMacRemoteErrorXcon = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.wrong-maid"); ccValue.Exists() {
						cItem.ReportDefectsWrongMaid = types.BoolValue(true)
					} else {
						cItem.ReportDefectsWrongMaid = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.wrong-level"); ccValue.Exists() {
						cItem.ReportDefectsWrongLevel = types.BoolValue(true)
					} else {
						cItem.ReportDefectsWrongLevel = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.our-mac"); ccValue.Exists() {
						cItem.ReportDefectsOurMac = types.BoolValue(true)
					} else {
						cItem.ReportDefectsOurMac = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.our-mepid"); ccValue.Exists() {
						cItem.ReportDefectsOurMepid = types.BoolValue(true)
					} else {
						cItem.ReportDefectsOurMepid = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.wrong-interval"); ccValue.Exists() {
						cItem.ReportDefectsWrongInterval = types.BoolValue(true)
					} else {
						cItem.ReportDefectsWrongInterval = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.missing"); ccValue.Exists() {
						cItem.ReportDefectsMissing = types.BoolValue(true)
					} else {
						cItem.ReportDefectsMissing = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.peer-port-down"); ccValue.Exists() {
						cItem.ReportDefectsPeerPortDown = types.BoolValue(true)
					} else {
						cItem.ReportDefectsPeerPortDown = types.BoolNull()
					}
					if ccValue := cv.Get("report.defects.rdi"); ccValue.Exists() {
						cItem.ReportDefectsRdi = types.BoolValue(true)
					} else {
						cItem.ReportDefectsRdi = types.BoolNull()
					}
					item.Services = append(item.Services, cItem)
					return true
				})
			}
			data.Domains = append(data.Domains, item)
			return true
		})
	}
}

// End of section. //template:end fromBodyData

// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyXML

func (data *EthernetCFM) fromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/traceroute/cache/hold-time"); value.Exists() {
		data.TracerouteCacheHoldTime = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/traceroute/cache/size"); value.Exists() {
		data.TracerouteCacheSize = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/domains/domain"); value.Exists() {
		data.Domains = make([]EthernetCFMDomains, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := EthernetCFMDomains{}
			if cValue := helpers.GetFromXPath(v, "domain-name"); cValue.Exists() {
				item.DomainName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "level"); cValue.Exists() {
				item.Level = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "id/dns"); cValue.Exists() {
				item.IdDns = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "id/mac-address"); cValue.Exists() {
				item.IdMacAddress = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "id/mac-address-two-octet-integer"); cValue.Exists() {
				item.IdMacAddressInteger = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "id/null"); cValue.Exists() {
				item.IdNull = types.BoolValue(true)
			} else {
				item.IdNull = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "id/string"); cValue.Exists() {
				item.IdString = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "services/service"); cValue.Exists() {
				item.Services = make([]EthernetCFMDomainsServices, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := EthernetCFMDomainsServices{}
					if ccValue := helpers.GetFromXPath(cv, "service-name"); ccValue.Exists() {
						cItem.ServiceName = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "bridge/group"); ccValue.Exists() {
						cItem.BridgeGroup = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "bridge/bridge-domain"); ccValue.Exists() {
						cItem.BridgeDomain = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "down-meps"); ccValue.Exists() {
						cItem.DownMeps = types.BoolValue(true)
					} else {
						cItem.DownMeps = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "flexible-xconnect/vlan-aware/evi"); ccValue.Exists() {
						cItem.FlexibleXconnectVlanAwareEvi = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "flexible-xconnect/vlan-unaware/cross-connect-name"); ccValue.Exists() {
						cItem.FlexibleXconnectVlanUnawareName = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "xconnect/mp2mp/group"); ccValue.Exists() {
						cItem.XconnectMp2mpGroup = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "xconnect/mp2mp/cross-connect-name"); ccValue.Exists() {
						cItem.XconnectMp2mpName = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "xconnect/mp2mp/ce-id"); ccValue.Exists() {
						cItem.XconnectMp2mpCeId = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "xconnect/mp2mp/remote-ce-id"); ccValue.Exists() {
						cItem.XconnectMp2mpRemoteCeId = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "xconnect/p2p/group"); ccValue.Exists() {
						cItem.XconnectP2pGroupName = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "xconnect/p2p/cross-connect-name"); ccValue.Exists() {
						cItem.XconnectP2pXcName = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "id/icc-based/icc"); ccValue.Exists() {
						cItem.IdIccBasedIcc = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "id/icc-based/umc"); ccValue.Exists() {
						cItem.IdIccBasedUmc = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "id/vlanid"); ccValue.Exists() {
						cItem.IdVlanId = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "id/number"); ccValue.Exists() {
						cItem.IdNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "id/string"); ccValue.Exists() {
						cItem.IdString = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "id/vpn-id/vpn-oui"); ccValue.Exists() {
						cItem.IdVpnIdOui = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "id/vpn-id/vpn-index"); ccValue.Exists() {
						cItem.IdVpnIdIndex = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "tags"); ccValue.Exists() {
						cItem.Tags = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "mip/auto-create/all"); ccValue.Exists() {
						cItem.MipAutoCreateAll = types.BoolValue(true)
					} else {
						cItem.MipAutoCreateAll = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "mip/auto-create/lower-mep-only"); ccValue.Exists() {
						cItem.MipAutoCreateLowerMepOnly = types.BoolValue(true)
					} else {
						cItem.MipAutoCreateLowerMepOnly = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "mip/auto-create/ccm-learning"); ccValue.Exists() {
						cItem.MipAutoCreateCcmLearning = types.BoolValue(true)
					} else {
						cItem.MipAutoCreateCcmLearning = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "efd"); ccValue.Exists() {
						cItem.Efd = types.BoolValue(true)
					} else {
						cItem.Efd = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "efd/protection-switching"); ccValue.Exists() {
						cItem.EfdProtectionSwitching = types.BoolValue(true)
					} else {
						cItem.EfdProtectionSwitching = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "continuity-check/interval/interval-time"); ccValue.Exists() {
						cItem.ContinuityCheckInterval = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "continuity-check/interval/loss-threshold"); ccValue.Exists() {
						cItem.ContinuityCheckIntervalLossThreshold = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "continuity-check/archive/hold-time"); ccValue.Exists() {
						cItem.ContinuityCheckArchiveHoldTime = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "continuity-check/loss/auto-traceroute"); ccValue.Exists() {
						cItem.ContinuityCheckLossAutoTraceroute = types.BoolValue(true)
					} else {
						cItem.ContinuityCheckLossAutoTraceroute = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "maximum-meps"); ccValue.Exists() {
						cItem.MaximumMeps = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "ais/transmission/interval"); ccValue.Exists() {
						cItem.AisTransmissionInterval = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "ais/transmission/cos"); ccValue.Exists() {
						cItem.AisTransmissionCos = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "log/continuity-check/mep/changes"); ccValue.Exists() {
						cItem.LogContinuityCheckMepChanges = types.BoolValue(true)
					} else {
						cItem.LogContinuityCheckMepChanges = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "log/continuity-check/errors"); ccValue.Exists() {
						cItem.LogContinuityCheckErrors = types.BoolValue(true)
					} else {
						cItem.LogContinuityCheckErrors = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "log/crosscheck/errors"); ccValue.Exists() {
						cItem.LogCrosscheckErrors = types.BoolValue(true)
					} else {
						cItem.LogCrosscheckErrors = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "log/ais"); ccValue.Exists() {
						cItem.LogAis = types.BoolValue(true)
					} else {
						cItem.LogAis = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "log/csf"); ccValue.Exists() {
						cItem.LogCsf = types.BoolValue(true)
					} else {
						cItem.LogCsf = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "log/efd"); ccValue.Exists() {
						cItem.LogEfd = types.BoolValue(true)
					} else {
						cItem.LogEfd = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "mep/crosscheck/mep-ids/mep-id"); ccValue.Exists() {
						cItem.MepCrosschecks = make([]EthernetCFMDomainsServicesMepCrosschecks, 0)
						ccValue.ForEach(func(_ int, ccv xmldot.Result) bool {
							ccItem := EthernetCFMDomainsServicesMepCrosschecks{}
							if cccValue := helpers.GetFromXPath(ccv, "mep-id"); cccValue.Exists() {
								ccItem.MepId = types.Int64Value(cccValue.Int())
							}
							if cccValue := helpers.GetFromXPath(ccv, "mac-address"); cccValue.Exists() {
								ccItem.MacAddress = types.StringValue(cccValue.String())
							}
							cItem.MepCrosschecks = append(cItem.MepCrosschecks, ccItem)
							return true
						})
					}
					if ccValue := helpers.GetFromXPath(cv, "mep/crosscheck/auto"); ccValue.Exists() {
						cItem.MepCrosscheckAuto = types.BoolValue(true)
					} else {
						cItem.MepCrosscheckAuto = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/none"); ccValue.Exists() {
						cItem.ReportDefectsNone = types.BoolValue(true)
					} else {
						cItem.ReportDefectsNone = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/all"); ccValue.Exists() {
						cItem.ReportDefectsAll = types.BoolValue(true)
					} else {
						cItem.ReportDefectsAll = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/ieee/xcon"); ccValue.Exists() {
						cItem.ReportDefectsIeeeXcon = types.BoolValue(true)
					} else {
						cItem.ReportDefectsIeeeXcon = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/ieee/error-xcon"); ccValue.Exists() {
						cItem.ReportDefectsIeeeErrorXcon = types.BoolValue(true)
					} else {
						cItem.ReportDefectsIeeeErrorXcon = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/ieee/remote-error-xcon"); ccValue.Exists() {
						cItem.ReportDefectsIeeeRemoteErrorXcon = types.BoolValue(true)
					} else {
						cItem.ReportDefectsIeeeRemoteErrorXcon = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/ieee/mac-remote-error-xcon"); ccValue.Exists() {
						cItem.ReportDefectsIeeeMacRemoteErrorXcon = types.BoolValue(true)
					} else {
						cItem.ReportDefectsIeeeMacRemoteErrorXcon = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/wrong-maid"); ccValue.Exists() {
						cItem.ReportDefectsWrongMaid = types.BoolValue(true)
					} else {
						cItem.ReportDefectsWrongMaid = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/wrong-level"); ccValue.Exists() {
						cItem.ReportDefectsWrongLevel = types.BoolValue(true)
					} else {
						cItem.ReportDefectsWrongLevel = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/our-mac"); ccValue.Exists() {
						cItem.ReportDefectsOurMac = types.BoolValue(true)
					} else {
						cItem.ReportDefectsOurMac = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/our-mepid"); ccValue.Exists() {
						cItem.ReportDefectsOurMepid = types.BoolValue(true)
					} else {
						cItem.ReportDefectsOurMepid = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/wrong-interval"); ccValue.Exists() {
						cItem.ReportDefectsWrongInterval = types.BoolValue(true)
					} else {
						cItem.ReportDefectsWrongInterval = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/missing"); ccValue.Exists() {
						cItem.ReportDefectsMissing = types.BoolValue(true)
					} else {
						cItem.ReportDefectsMissing = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/peer-port-down"); ccValue.Exists() {
						cItem.ReportDefectsPeerPortDown = types.BoolValue(true)
					} else {
						cItem.ReportDefectsPeerPortDown = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/rdi"); ccValue.Exists() {
						cItem.ReportDefectsRdi = types.BoolValue(true)
					} else {
						cItem.ReportDefectsRdi = types.BoolNull()
					}
					item.Services = append(item.Services, cItem)
					return true
				})
			}
			data.Domains = append(data.Domains, item)
			return true
		})
	}
}

// End of section. //template:end fromBodyXML

// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyDataXML

func (data *EthernetCFMData) fromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/traceroute/cache/hold-time"); value.Exists() {
		data.TracerouteCacheHoldTime = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/traceroute/cache/size"); value.Exists() {
		data.TracerouteCacheSize = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/domains/domain"); value.Exists() {
		data.Domains = make([]EthernetCFMDomains, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := EthernetCFMDomains{}
			if cValue := helpers.GetFromXPath(v, "domain-name"); cValue.Exists() {
				item.DomainName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "level"); cValue.Exists() {
				item.Level = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "id/dns"); cValue.Exists() {
				item.IdDns = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "id/mac-address"); cValue.Exists() {
				item.IdMacAddress = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "id/mac-address-two-octet-integer"); cValue.Exists() {
				item.IdMacAddressInteger = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "id/null"); cValue.Exists() {
				item.IdNull = types.BoolValue(true)
			} else {
				item.IdNull = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "id/string"); cValue.Exists() {
				item.IdString = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "services/service"); cValue.Exists() {
				item.Services = make([]EthernetCFMDomainsServices, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := EthernetCFMDomainsServices{}
					if ccValue := helpers.GetFromXPath(cv, "service-name"); ccValue.Exists() {
						cItem.ServiceName = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "bridge/group"); ccValue.Exists() {
						cItem.BridgeGroup = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "bridge/bridge-domain"); ccValue.Exists() {
						cItem.BridgeDomain = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "down-meps"); ccValue.Exists() {
						cItem.DownMeps = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "flexible-xconnect/vlan-aware/evi"); ccValue.Exists() {
						cItem.FlexibleXconnectVlanAwareEvi = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "flexible-xconnect/vlan-unaware/cross-connect-name"); ccValue.Exists() {
						cItem.FlexibleXconnectVlanUnawareName = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "xconnect/mp2mp/group"); ccValue.Exists() {
						cItem.XconnectMp2mpGroup = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "xconnect/mp2mp/cross-connect-name"); ccValue.Exists() {
						cItem.XconnectMp2mpName = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "xconnect/mp2mp/ce-id"); ccValue.Exists() {
						cItem.XconnectMp2mpCeId = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "xconnect/mp2mp/remote-ce-id"); ccValue.Exists() {
						cItem.XconnectMp2mpRemoteCeId = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "xconnect/p2p/group"); ccValue.Exists() {
						cItem.XconnectP2pGroupName = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "xconnect/p2p/cross-connect-name"); ccValue.Exists() {
						cItem.XconnectP2pXcName = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "id/icc-based/icc"); ccValue.Exists() {
						cItem.IdIccBasedIcc = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "id/icc-based/umc"); ccValue.Exists() {
						cItem.IdIccBasedUmc = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "id/vlanid"); ccValue.Exists() {
						cItem.IdVlanId = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "id/number"); ccValue.Exists() {
						cItem.IdNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "id/string"); ccValue.Exists() {
						cItem.IdString = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "id/vpn-id/vpn-oui"); ccValue.Exists() {
						cItem.IdVpnIdOui = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "id/vpn-id/vpn-index"); ccValue.Exists() {
						cItem.IdVpnIdIndex = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "tags"); ccValue.Exists() {
						cItem.Tags = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "mip/auto-create/all"); ccValue.Exists() {
						cItem.MipAutoCreateAll = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "mip/auto-create/lower-mep-only"); ccValue.Exists() {
						cItem.MipAutoCreateLowerMepOnly = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "mip/auto-create/ccm-learning"); ccValue.Exists() {
						cItem.MipAutoCreateCcmLearning = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "efd"); ccValue.Exists() {
						cItem.Efd = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "efd/protection-switching"); ccValue.Exists() {
						cItem.EfdProtectionSwitching = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "continuity-check/interval/interval-time"); ccValue.Exists() {
						cItem.ContinuityCheckInterval = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "continuity-check/interval/loss-threshold"); ccValue.Exists() {
						cItem.ContinuityCheckIntervalLossThreshold = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "continuity-check/archive/hold-time"); ccValue.Exists() {
						cItem.ContinuityCheckArchiveHoldTime = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "continuity-check/loss/auto-traceroute"); ccValue.Exists() {
						cItem.ContinuityCheckLossAutoTraceroute = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "maximum-meps"); ccValue.Exists() {
						cItem.MaximumMeps = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "ais/transmission/interval"); ccValue.Exists() {
						cItem.AisTransmissionInterval = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "ais/transmission/cos"); ccValue.Exists() {
						cItem.AisTransmissionCos = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "log/continuity-check/mep/changes"); ccValue.Exists() {
						cItem.LogContinuityCheckMepChanges = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "log/continuity-check/errors"); ccValue.Exists() {
						cItem.LogContinuityCheckErrors = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "log/crosscheck/errors"); ccValue.Exists() {
						cItem.LogCrosscheckErrors = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "log/ais"); ccValue.Exists() {
						cItem.LogAis = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "log/csf"); ccValue.Exists() {
						cItem.LogCsf = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "log/efd"); ccValue.Exists() {
						cItem.LogEfd = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "mep/crosscheck/auto"); ccValue.Exists() {
						cItem.MepCrosscheckAuto = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/none"); ccValue.Exists() {
						cItem.ReportDefectsNone = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/all"); ccValue.Exists() {
						cItem.ReportDefectsAll = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/ieee/xcon"); ccValue.Exists() {
						cItem.ReportDefectsIeeeXcon = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/ieee/error-xcon"); ccValue.Exists() {
						cItem.ReportDefectsIeeeErrorXcon = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/ieee/remote-error-xcon"); ccValue.Exists() {
						cItem.ReportDefectsIeeeRemoteErrorXcon = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/ieee/mac-remote-error-xcon"); ccValue.Exists() {
						cItem.ReportDefectsIeeeMacRemoteErrorXcon = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/wrong-maid"); ccValue.Exists() {
						cItem.ReportDefectsWrongMaid = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/wrong-level"); ccValue.Exists() {
						cItem.ReportDefectsWrongLevel = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/our-mac"); ccValue.Exists() {
						cItem.ReportDefectsOurMac = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/our-mepid"); ccValue.Exists() {
						cItem.ReportDefectsOurMepid = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/wrong-interval"); ccValue.Exists() {
						cItem.ReportDefectsWrongInterval = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/missing"); ccValue.Exists() {
						cItem.ReportDefectsMissing = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/peer-port-down"); ccValue.Exists() {
						cItem.ReportDefectsPeerPortDown = types.BoolValue(true)
					} else {
					}
					if ccValue := helpers.GetFromXPath(cv, "report/defects/rdi"); ccValue.Exists() {
						cItem.ReportDefectsRdi = types.BoolValue(true)
					} else {
					}
					item.Services = append(item.Services, cItem)
					return true
				})
			}
			data.Domains = append(data.Domains, item)
			return true
		})
	}
}

// End of section. //template:end fromBodyDataXML

// Section below is generated&owned by "gen/generator.go". //template:begin getDeletedItems

func (data *EthernetCFM) getDeletedItems(ctx context.Context, state EthernetCFM) []string {
	deletedItems := make([]string, 0)
	for i := range state.Domains {
		keys := [...]string{"domain-name"}
		stateKeyValues := [...]string{state.Domains[i].DomainName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.Domains[i].DomainName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Domains {
			found = true
			if state.Domains[i].DomainName.ValueString() != data.Domains[j].DomainName.ValueString() {
				found = false
			}
			if found {
				for ci := range state.Domains[i].Services {
					ckeys := [...]string{"service-name"}
					cstateKeyValues := [...]string{state.Domains[i].Services[ci].ServiceName.ValueString()}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.Domains[i].Services[ci].ServiceName.ValueString()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.Domains[j].Services {
						found = true
						if state.Domains[i].Services[ci].ServiceName.ValueString() != data.Domains[j].Services[cj].ServiceName.ValueString() {
							found = false
						}
						if found {
							if !state.Domains[i].Services[ci].ReportDefectsRdi.IsNull() && data.Domains[j].Services[cj].ReportDefectsRdi.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/rdi", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].ReportDefectsPeerPortDown.IsNull() && data.Domains[j].Services[cj].ReportDefectsPeerPortDown.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/peer-port-down", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].ReportDefectsMissing.IsNull() && data.Domains[j].Services[cj].ReportDefectsMissing.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/missing", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].ReportDefectsWrongInterval.IsNull() && data.Domains[j].Services[cj].ReportDefectsWrongInterval.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/wrong-interval", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].ReportDefectsOurMepid.IsNull() && data.Domains[j].Services[cj].ReportDefectsOurMepid.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/our-mepid", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].ReportDefectsOurMac.IsNull() && data.Domains[j].Services[cj].ReportDefectsOurMac.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/our-mac", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].ReportDefectsWrongLevel.IsNull() && data.Domains[j].Services[cj].ReportDefectsWrongLevel.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/wrong-level", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].ReportDefectsWrongMaid.IsNull() && data.Domains[j].Services[cj].ReportDefectsWrongMaid.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/wrong-maid", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].ReportDefectsIeeeMacRemoteErrorXcon.IsNull() && data.Domains[j].Services[cj].ReportDefectsIeeeMacRemoteErrorXcon.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/ieee/mac-remote-error-xcon", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].ReportDefectsIeeeRemoteErrorXcon.IsNull() && data.Domains[j].Services[cj].ReportDefectsIeeeRemoteErrorXcon.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/ieee/remote-error-xcon", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].ReportDefectsIeeeErrorXcon.IsNull() && data.Domains[j].Services[cj].ReportDefectsIeeeErrorXcon.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/ieee/error-xcon", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].ReportDefectsIeeeXcon.IsNull() && data.Domains[j].Services[cj].ReportDefectsIeeeXcon.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/ieee/xcon", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].ReportDefectsAll.IsNull() && data.Domains[j].Services[cj].ReportDefectsAll.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/all", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].ReportDefectsNone.IsNull() && data.Domains[j].Services[cj].ReportDefectsNone.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/none", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].MepCrosscheckAuto.IsNull() && data.Domains[j].Services[cj].MepCrosscheckAuto.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/mep/crosscheck/auto", state.getPath(), keyString, ckeyString))
							}
							for cci := range state.Domains[i].Services[ci].MepCrosschecks {
								cckeys := [...]string{"mep-id"}
								ccstateKeyValues := [...]string{strconv.FormatInt(state.Domains[i].Services[ci].MepCrosschecks[cci].MepId.ValueInt64(), 10)}
								cckeyString := ""
								for ccki := range cckeys {
									cckeyString += "[" + cckeys[ccki] + "=" + ccstateKeyValues[ccki] + "]"
								}

								ccemptyKeys := true
								if !reflect.ValueOf(state.Domains[i].Services[ci].MepCrosschecks[cci].MepId.ValueInt64()).IsZero() {
									ccemptyKeys = false
								}
								if ccemptyKeys {
									continue
								}

								found := false
								for ccj := range data.Domains[j].Services[cj].MepCrosschecks {
									found = true
									if state.Domains[i].Services[ci].MepCrosschecks[cci].MepId.ValueInt64() != data.Domains[j].Services[cj].MepCrosschecks[ccj].MepId.ValueInt64() {
										found = false
									}
									if found {
										if !state.Domains[i].Services[ci].MepCrosschecks[cci].MacAddress.IsNull() && data.Domains[j].Services[cj].MepCrosschecks[ccj].MacAddress.IsNull() {
											deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/mep/crosscheck/mep-ids/mep-id%v/mac-address", state.getPath(), keyString, ckeyString, cckeyString))
										}
										break
									}
								}
								if !found {
									deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/mep/crosscheck/mep-ids/mep-id%v", state.getPath(), keyString, ckeyString, cckeyString))
								}
							}
							if !state.Domains[i].Services[ci].LogEfd.IsNull() && data.Domains[j].Services[cj].LogEfd.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/log/efd", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].LogCsf.IsNull() && data.Domains[j].Services[cj].LogCsf.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/log/csf", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].LogAis.IsNull() && data.Domains[j].Services[cj].LogAis.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/log/ais", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].LogCrosscheckErrors.IsNull() && data.Domains[j].Services[cj].LogCrosscheckErrors.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/log/crosscheck/errors", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].LogContinuityCheckErrors.IsNull() && data.Domains[j].Services[cj].LogContinuityCheckErrors.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/log/continuity-check/errors", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].LogContinuityCheckMepChanges.IsNull() && data.Domains[j].Services[cj].LogContinuityCheckMepChanges.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/log/continuity-check/mep/changes", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].AisTransmissionCos.IsNull() && data.Domains[j].Services[cj].AisTransmissionCos.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/ais/transmission/cos", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].AisTransmissionInterval.IsNull() && data.Domains[j].Services[cj].AisTransmissionInterval.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/ais/transmission/interval", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].MaximumMeps.IsNull() && data.Domains[j].Services[cj].MaximumMeps.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/maximum-meps", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].ContinuityCheckLossAutoTraceroute.IsNull() && data.Domains[j].Services[cj].ContinuityCheckLossAutoTraceroute.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/continuity-check/loss/auto-traceroute", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].ContinuityCheckArchiveHoldTime.IsNull() && data.Domains[j].Services[cj].ContinuityCheckArchiveHoldTime.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/continuity-check/archive/hold-time", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].ContinuityCheckIntervalLossThreshold.IsNull() && data.Domains[j].Services[cj].ContinuityCheckIntervalLossThreshold.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/continuity-check/interval/loss-threshold", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].ContinuityCheckInterval.IsNull() && data.Domains[j].Services[cj].ContinuityCheckInterval.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/continuity-check/interval/interval-time", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].EfdProtectionSwitching.IsNull() && data.Domains[j].Services[cj].EfdProtectionSwitching.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/efd/protection-switching", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].Efd.IsNull() && data.Domains[j].Services[cj].Efd.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/efd", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].MipAutoCreateCcmLearning.IsNull() && data.Domains[j].Services[cj].MipAutoCreateCcmLearning.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/mip/auto-create/ccm-learning", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].MipAutoCreateLowerMepOnly.IsNull() && data.Domains[j].Services[cj].MipAutoCreateLowerMepOnly.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/mip/auto-create/lower-mep-only", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].MipAutoCreateAll.IsNull() && data.Domains[j].Services[cj].MipAutoCreateAll.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/mip/auto-create/all", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].Tags.IsNull() && data.Domains[j].Services[cj].Tags.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/tags", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].IdVpnIdIndex.IsNull() && data.Domains[j].Services[cj].IdVpnIdIndex.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/id/vpn-id/vpn-index", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].IdVpnIdOui.IsNull() && data.Domains[j].Services[cj].IdVpnIdOui.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/id/vpn-id/vpn-oui", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].IdString.IsNull() && data.Domains[j].Services[cj].IdString.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/id/string", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].IdNumber.IsNull() && data.Domains[j].Services[cj].IdNumber.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/id/number", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].IdVlanId.IsNull() && data.Domains[j].Services[cj].IdVlanId.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/id/vlanid", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].IdIccBasedUmc.IsNull() && data.Domains[j].Services[cj].IdIccBasedUmc.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/id/icc-based/umc", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].IdIccBasedIcc.IsNull() && data.Domains[j].Services[cj].IdIccBasedIcc.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/id/icc-based/icc", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].XconnectP2pXcName.IsNull() && data.Domains[j].Services[cj].XconnectP2pXcName.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/xconnect/p2p/cross-connect-name", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].XconnectP2pGroupName.IsNull() && data.Domains[j].Services[cj].XconnectP2pGroupName.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/xconnect/p2p/group", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].XconnectMp2mpRemoteCeId.IsNull() && data.Domains[j].Services[cj].XconnectMp2mpRemoteCeId.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/xconnect/mp2mp/remote-ce-id", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].XconnectMp2mpCeId.IsNull() && data.Domains[j].Services[cj].XconnectMp2mpCeId.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/xconnect/mp2mp/ce-id", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].XconnectMp2mpName.IsNull() && data.Domains[j].Services[cj].XconnectMp2mpName.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/xconnect/mp2mp/cross-connect-name", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].XconnectMp2mpGroup.IsNull() && data.Domains[j].Services[cj].XconnectMp2mpGroup.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/xconnect/mp2mp/group", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].FlexibleXconnectVlanUnawareName.IsNull() && data.Domains[j].Services[cj].FlexibleXconnectVlanUnawareName.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/flexible-xconnect/vlan-unaware/cross-connect-name", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].FlexibleXconnectVlanAwareEvi.IsNull() && data.Domains[j].Services[cj].FlexibleXconnectVlanAwareEvi.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/flexible-xconnect/vlan-aware/evi", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].DownMeps.IsNull() && data.Domains[j].Services[cj].DownMeps.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/down-meps", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].BridgeDomain.IsNull() && data.Domains[j].Services[cj].BridgeDomain.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/bridge/bridge-domain", state.getPath(), keyString, ckeyString))
							}
							if !state.Domains[i].Services[ci].BridgeGroup.IsNull() && data.Domains[j].Services[cj].BridgeGroup.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v/bridge/group", state.getPath(), keyString, ckeyString))
							}
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/services/service%v", state.getPath(), keyString, ckeyString))
					}
				}
				if !state.Domains[i].IdString.IsNull() && data.Domains[j].IdString.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/id/string", state.getPath(), keyString))
				}
				if !state.Domains[i].IdNull.IsNull() && data.Domains[j].IdNull.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/id/null", state.getPath(), keyString))
				}
				if !state.Domains[i].IdMacAddressInteger.IsNull() && data.Domains[j].IdMacAddressInteger.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/id/mac-address-two-octet-integer", state.getPath(), keyString))
				}
				if !state.Domains[i].IdMacAddress.IsNull() && data.Domains[j].IdMacAddress.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/id/mac-address", state.getPath(), keyString))
				}
				if !state.Domains[i].IdDns.IsNull() && data.Domains[j].IdDns.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/id/dns", state.getPath(), keyString))
				}
				if !state.Domains[i].Level.IsNull() && data.Domains[j].Level.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v/level", state.getPath(), keyString))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/domains/domain%v", state.getPath(), keyString))
		}
	}
	if !state.TracerouteCacheSize.IsNull() && data.TracerouteCacheSize.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/traceroute/cache/size", state.getPath()))
	}
	if !state.TracerouteCacheHoldTime.IsNull() && data.TracerouteCacheHoldTime.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/traceroute/cache/hold-time", state.getPath()))
	}
	return deletedItems
}

// End of section. //template:end getDeletedItems

// Section below is generated&owned by "gen/generator.go". //template:begin getEmptyLeafsDelete

func (data *EthernetCFM) getEmptyLeafsDelete(ctx context.Context, state *EthernetCFM) []string {
	emptyLeafsDelete := make([]string, 0)
	for i := range data.Domains {
		keys := [...]string{"domain-name"}
		keyValues := [...]string{data.Domains[i].DomainName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		for ci := range data.Domains[i].Services {
			ckeys := [...]string{"service-name"}
			ckeyValues := [...]string{data.Domains[i].Services[ci].ServiceName.ValueString()}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].ReportDefectsRdi.IsNull() && !data.Domains[i].Services[ci].ReportDefectsRdi.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].ReportDefectsRdi.IsNull() && state.Domains[i].Services[ci].ReportDefectsRdi.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/rdi", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].ReportDefectsPeerPortDown.IsNull() && !data.Domains[i].Services[ci].ReportDefectsPeerPortDown.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].ReportDefectsPeerPortDown.IsNull() && state.Domains[i].Services[ci].ReportDefectsPeerPortDown.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/peer-port-down", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].ReportDefectsMissing.IsNull() && !data.Domains[i].Services[ci].ReportDefectsMissing.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].ReportDefectsMissing.IsNull() && state.Domains[i].Services[ci].ReportDefectsMissing.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/missing", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].ReportDefectsWrongInterval.IsNull() && !data.Domains[i].Services[ci].ReportDefectsWrongInterval.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].ReportDefectsWrongInterval.IsNull() && state.Domains[i].Services[ci].ReportDefectsWrongInterval.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/wrong-interval", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].ReportDefectsOurMepid.IsNull() && !data.Domains[i].Services[ci].ReportDefectsOurMepid.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].ReportDefectsOurMepid.IsNull() && state.Domains[i].Services[ci].ReportDefectsOurMepid.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/our-mepid", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].ReportDefectsOurMac.IsNull() && !data.Domains[i].Services[ci].ReportDefectsOurMac.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].ReportDefectsOurMac.IsNull() && state.Domains[i].Services[ci].ReportDefectsOurMac.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/our-mac", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].ReportDefectsWrongLevel.IsNull() && !data.Domains[i].Services[ci].ReportDefectsWrongLevel.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].ReportDefectsWrongLevel.IsNull() && state.Domains[i].Services[ci].ReportDefectsWrongLevel.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/wrong-level", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].ReportDefectsWrongMaid.IsNull() && !data.Domains[i].Services[ci].ReportDefectsWrongMaid.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].ReportDefectsWrongMaid.IsNull() && state.Domains[i].Services[ci].ReportDefectsWrongMaid.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/wrong-maid", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].ReportDefectsIeeeMacRemoteErrorXcon.IsNull() && !data.Domains[i].Services[ci].ReportDefectsIeeeMacRemoteErrorXcon.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].ReportDefectsIeeeMacRemoteErrorXcon.IsNull() && state.Domains[i].Services[ci].ReportDefectsIeeeMacRemoteErrorXcon.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/ieee/mac-remote-error-xcon", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].ReportDefectsIeeeRemoteErrorXcon.IsNull() && !data.Domains[i].Services[ci].ReportDefectsIeeeRemoteErrorXcon.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].ReportDefectsIeeeRemoteErrorXcon.IsNull() && state.Domains[i].Services[ci].ReportDefectsIeeeRemoteErrorXcon.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/ieee/remote-error-xcon", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].ReportDefectsIeeeErrorXcon.IsNull() && !data.Domains[i].Services[ci].ReportDefectsIeeeErrorXcon.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].ReportDefectsIeeeErrorXcon.IsNull() && state.Domains[i].Services[ci].ReportDefectsIeeeErrorXcon.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/ieee/error-xcon", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].ReportDefectsIeeeXcon.IsNull() && !data.Domains[i].Services[ci].ReportDefectsIeeeXcon.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].ReportDefectsIeeeXcon.IsNull() && state.Domains[i].Services[ci].ReportDefectsIeeeXcon.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/ieee/xcon", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].ReportDefectsAll.IsNull() && !data.Domains[i].Services[ci].ReportDefectsAll.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].ReportDefectsAll.IsNull() && state.Domains[i].Services[ci].ReportDefectsAll.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/all", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].ReportDefectsNone.IsNull() && !data.Domains[i].Services[ci].ReportDefectsNone.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].ReportDefectsNone.IsNull() && state.Domains[i].Services[ci].ReportDefectsNone.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/report/defects/none", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].MepCrosscheckAuto.IsNull() && !data.Domains[i].Services[ci].MepCrosscheckAuto.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].MepCrosscheckAuto.IsNull() && state.Domains[i].Services[ci].MepCrosscheckAuto.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/mep/crosscheck/auto", data.getXPath(), keyString, ckeyString))
				}
			}
			for cci := range data.Domains[i].Services[ci].MepCrosschecks {
				cckeys := [...]string{"mep-id"}
				cckeyValues := [...]string{strconv.FormatInt(data.Domains[i].Services[ci].MepCrosschecks[cci].MepId.ValueInt64(), 10)}
				cckeyString := ""
				for ccki := range cckeys {
					cckeyString += "[" + cckeys[ccki] + "=" + cckeyValues[ccki] + "]"
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].LogEfd.IsNull() && !data.Domains[i].Services[ci].LogEfd.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].LogEfd.IsNull() && state.Domains[i].Services[ci].LogEfd.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/log/efd", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].LogCsf.IsNull() && !data.Domains[i].Services[ci].LogCsf.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].LogCsf.IsNull() && state.Domains[i].Services[ci].LogCsf.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/log/csf", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].LogAis.IsNull() && !data.Domains[i].Services[ci].LogAis.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].LogAis.IsNull() && state.Domains[i].Services[ci].LogAis.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/log/ais", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].LogCrosscheckErrors.IsNull() && !data.Domains[i].Services[ci].LogCrosscheckErrors.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].LogCrosscheckErrors.IsNull() && state.Domains[i].Services[ci].LogCrosscheckErrors.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/log/crosscheck/errors", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].LogContinuityCheckErrors.IsNull() && !data.Domains[i].Services[ci].LogContinuityCheckErrors.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].LogContinuityCheckErrors.IsNull() && state.Domains[i].Services[ci].LogContinuityCheckErrors.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/log/continuity-check/errors", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].LogContinuityCheckMepChanges.IsNull() && !data.Domains[i].Services[ci].LogContinuityCheckMepChanges.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].LogContinuityCheckMepChanges.IsNull() && state.Domains[i].Services[ci].LogContinuityCheckMepChanges.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/log/continuity-check/mep/changes", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].ContinuityCheckLossAutoTraceroute.IsNull() && !data.Domains[i].Services[ci].ContinuityCheckLossAutoTraceroute.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].ContinuityCheckLossAutoTraceroute.IsNull() && state.Domains[i].Services[ci].ContinuityCheckLossAutoTraceroute.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/continuity-check/loss/auto-traceroute", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].EfdProtectionSwitching.IsNull() && !data.Domains[i].Services[ci].EfdProtectionSwitching.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].EfdProtectionSwitching.IsNull() && state.Domains[i].Services[ci].EfdProtectionSwitching.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/efd/protection-switching", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].Efd.IsNull() && !data.Domains[i].Services[ci].Efd.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].Efd.IsNull() && state.Domains[i].Services[ci].Efd.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/efd", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].MipAutoCreateCcmLearning.IsNull() && !data.Domains[i].Services[ci].MipAutoCreateCcmLearning.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].MipAutoCreateCcmLearning.IsNull() && state.Domains[i].Services[ci].MipAutoCreateCcmLearning.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/mip/auto-create/ccm-learning", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].MipAutoCreateLowerMepOnly.IsNull() && !data.Domains[i].Services[ci].MipAutoCreateLowerMepOnly.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].MipAutoCreateLowerMepOnly.IsNull() && state.Domains[i].Services[ci].MipAutoCreateLowerMepOnly.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/mip/auto-create/lower-mep-only", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].MipAutoCreateAll.IsNull() && !data.Domains[i].Services[ci].MipAutoCreateAll.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].MipAutoCreateAll.IsNull() && state.Domains[i].Services[ci].MipAutoCreateAll.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/mip/auto-create/all", data.getXPath(), keyString, ckeyString))
				}
			}
			// Only delete if state has true and plan has false
			if !data.Domains[i].Services[ci].DownMeps.IsNull() && !data.Domains[i].Services[ci].DownMeps.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.Domains) && ci < len(state.Domains[i].Services) && !state.Domains[i].Services[ci].DownMeps.IsNull() && state.Domains[i].Services[ci].DownMeps.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/services/service%v/down-meps", data.getXPath(), keyString, ckeyString))
				}
			}
		}
		// Only delete if state has true and plan has false
		if !data.Domains[i].IdNull.IsNull() && !data.Domains[i].IdNull.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Domains) && !state.Domains[i].IdNull.IsNull() && state.Domains[i].IdNull.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/domains/domain%v/id/null", data.getXPath(), keyString))
			}
		}
	}
	return emptyLeafsDelete
}

// End of section. //template:end getEmptyLeafsDelete

// Section below is generated&owned by "gen/generator.go". //template:begin getDeletePaths

func (data *EthernetCFM) getDeletePaths(ctx context.Context) []string {
	var deletePaths []string
	for i := range data.Domains {
		keyValues := [...]string{data.Domains[i].DomainName.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/domains/domain=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	if !data.TracerouteCacheSize.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/traceroute/cache/size", data.getPath()))
	}
	if !data.TracerouteCacheHoldTime.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/traceroute/cache/hold-time", data.getPath()))
	}

	return deletePaths
}

// End of section. //template:end getDeletePaths

// Section below is generated&owned by "gen/generator.go". //template:begin addDeletedItemsXML

func (data *EthernetCFM) addDeletedItemsXML(ctx context.Context, state EthernetCFM, body string) string {
	deleteXml := ""
	deletedPaths := make(map[string]bool)
	_ = deletedPaths // Avoid unused variable error when no delete_parent attributes exist
	for i := range state.Domains {
		stateKeys := [...]string{"domain-name"}
		stateKeyValues := [...]string{state.Domains[i].DomainName.ValueString()}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.Domains[i].DomainName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Domains {
			found = true
			if state.Domains[i].DomainName.ValueString() != data.Domains[j].DomainName.ValueString() {
				found = false
			}
			if found {
				for ci := range state.Domains[i].Services {
					cstateKeys := [...]string{"service-name"}
					cstateKeyValues := [...]string{state.Domains[i].Services[ci].ServiceName.ValueString()}
					cpredicates := ""
					for i := range cstateKeys {
						cpredicates += fmt.Sprintf("[%s='%s']", cstateKeys[i], cstateKeyValues[i])
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.Domains[i].Services[ci].ServiceName.ValueString()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.Domains[j].Services {
						found = true
						if state.Domains[i].Services[ci].ServiceName.ValueString() != data.Domains[j].Services[cj].ServiceName.ValueString() {
							found = false
						}
						if found {
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].ReportDefectsRdi.IsNull() && state.Domains[i].Services[ci].ReportDefectsRdi.ValueBool() && data.Domains[j].Services[cj].ReportDefectsRdi.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/report/defects/rdi", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].ReportDefectsPeerPortDown.IsNull() && state.Domains[i].Services[ci].ReportDefectsPeerPortDown.ValueBool() && data.Domains[j].Services[cj].ReportDefectsPeerPortDown.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/report/defects/peer-port-down", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].ReportDefectsMissing.IsNull() && state.Domains[i].Services[ci].ReportDefectsMissing.ValueBool() && data.Domains[j].Services[cj].ReportDefectsMissing.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/report/defects/missing", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].ReportDefectsWrongInterval.IsNull() && state.Domains[i].Services[ci].ReportDefectsWrongInterval.ValueBool() && data.Domains[j].Services[cj].ReportDefectsWrongInterval.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/report/defects/wrong-interval", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].ReportDefectsOurMepid.IsNull() && state.Domains[i].Services[ci].ReportDefectsOurMepid.ValueBool() && data.Domains[j].Services[cj].ReportDefectsOurMepid.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/report/defects/our-mepid", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].ReportDefectsOurMac.IsNull() && state.Domains[i].Services[ci].ReportDefectsOurMac.ValueBool() && data.Domains[j].Services[cj].ReportDefectsOurMac.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/report/defects/our-mac", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].ReportDefectsWrongLevel.IsNull() && state.Domains[i].Services[ci].ReportDefectsWrongLevel.ValueBool() && data.Domains[j].Services[cj].ReportDefectsWrongLevel.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/report/defects/wrong-level", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].ReportDefectsWrongMaid.IsNull() && state.Domains[i].Services[ci].ReportDefectsWrongMaid.ValueBool() && data.Domains[j].Services[cj].ReportDefectsWrongMaid.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/report/defects/wrong-maid", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].ReportDefectsIeeeMacRemoteErrorXcon.IsNull() && state.Domains[i].Services[ci].ReportDefectsIeeeMacRemoteErrorXcon.ValueBool() && data.Domains[j].Services[cj].ReportDefectsIeeeMacRemoteErrorXcon.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/report/defects/ieee/mac-remote-error-xcon", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].ReportDefectsIeeeRemoteErrorXcon.IsNull() && state.Domains[i].Services[ci].ReportDefectsIeeeRemoteErrorXcon.ValueBool() && data.Domains[j].Services[cj].ReportDefectsIeeeRemoteErrorXcon.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/report/defects/ieee/remote-error-xcon", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].ReportDefectsIeeeErrorXcon.IsNull() && state.Domains[i].Services[ci].ReportDefectsIeeeErrorXcon.ValueBool() && data.Domains[j].Services[cj].ReportDefectsIeeeErrorXcon.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/report/defects/ieee/error-xcon", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].ReportDefectsIeeeXcon.IsNull() && state.Domains[i].Services[ci].ReportDefectsIeeeXcon.ValueBool() && data.Domains[j].Services[cj].ReportDefectsIeeeXcon.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/report/defects/ieee/xcon", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].ReportDefectsAll.IsNull() && state.Domains[i].Services[ci].ReportDefectsAll.ValueBool() && data.Domains[j].Services[cj].ReportDefectsAll.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/report/defects/all", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].ReportDefectsNone.IsNull() && state.Domains[i].Services[ci].ReportDefectsNone.ValueBool() && data.Domains[j].Services[cj].ReportDefectsNone.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/report/defects/none", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].MepCrosscheckAuto.IsNull() && state.Domains[i].Services[ci].MepCrosscheckAuto.ValueBool() && data.Domains[j].Services[cj].MepCrosscheckAuto.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/mep/crosscheck/auto", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].LogEfd.IsNull() && state.Domains[i].Services[ci].LogEfd.ValueBool() && data.Domains[j].Services[cj].LogEfd.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/log/efd", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].LogCsf.IsNull() && state.Domains[i].Services[ci].LogCsf.ValueBool() && data.Domains[j].Services[cj].LogCsf.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/log/csf", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].LogAis.IsNull() && state.Domains[i].Services[ci].LogAis.ValueBool() && data.Domains[j].Services[cj].LogAis.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/log/ais", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].LogCrosscheckErrors.IsNull() && state.Domains[i].Services[ci].LogCrosscheckErrors.ValueBool() && data.Domains[j].Services[cj].LogCrosscheckErrors.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/log/crosscheck/errors", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].LogContinuityCheckErrors.IsNull() && state.Domains[i].Services[ci].LogContinuityCheckErrors.ValueBool() && data.Domains[j].Services[cj].LogContinuityCheckErrors.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/log/continuity-check/errors", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].LogContinuityCheckMepChanges.IsNull() && state.Domains[i].Services[ci].LogContinuityCheckMepChanges.ValueBool() && data.Domains[j].Services[cj].LogContinuityCheckMepChanges.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/log/continuity-check/mep/changes", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].AisTransmissionCos.IsNull() && data.Domains[j].Services[cj].AisTransmissionCos.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/ais/transmission/cos", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].AisTransmissionInterval.IsNull() && data.Domains[j].Services[cj].AisTransmissionInterval.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/ais/transmission/interval", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].MaximumMeps.IsNull() && data.Domains[j].Services[cj].MaximumMeps.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/maximum-meps", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].ContinuityCheckLossAutoTraceroute.IsNull() && state.Domains[i].Services[ci].ContinuityCheckLossAutoTraceroute.ValueBool() && data.Domains[j].Services[cj].ContinuityCheckLossAutoTraceroute.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/continuity-check/loss/auto-traceroute", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].ContinuityCheckArchiveHoldTime.IsNull() && data.Domains[j].Services[cj].ContinuityCheckArchiveHoldTime.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/continuity-check/archive/hold-time", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].ContinuityCheckIntervalLossThreshold.IsNull() && data.Domains[j].Services[cj].ContinuityCheckIntervalLossThreshold.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/continuity-check/interval/loss-threshold", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].ContinuityCheckInterval.IsNull() && data.Domains[j].Services[cj].ContinuityCheckInterval.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/continuity-check/interval/interval-time", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].EfdProtectionSwitching.IsNull() && state.Domains[i].Services[ci].EfdProtectionSwitching.ValueBool() && data.Domains[j].Services[cj].EfdProtectionSwitching.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/efd/protection-switching", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].Efd.IsNull() && state.Domains[i].Services[ci].Efd.ValueBool() && data.Domains[j].Services[cj].Efd.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/efd", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].MipAutoCreateCcmLearning.IsNull() && state.Domains[i].Services[ci].MipAutoCreateCcmLearning.ValueBool() && data.Domains[j].Services[cj].MipAutoCreateCcmLearning.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/mip/auto-create/ccm-learning", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].MipAutoCreateLowerMepOnly.IsNull() && state.Domains[i].Services[ci].MipAutoCreateLowerMepOnly.ValueBool() && data.Domains[j].Services[cj].MipAutoCreateLowerMepOnly.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/mip/auto-create/lower-mep-only", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].MipAutoCreateAll.IsNull() && state.Domains[i].Services[ci].MipAutoCreateAll.ValueBool() && data.Domains[j].Services[cj].MipAutoCreateAll.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/mip/auto-create/all", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].Tags.IsNull() && data.Domains[j].Services[cj].Tags.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/tags", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].IdVpnIdIndex.IsNull() && data.Domains[j].Services[cj].IdVpnIdIndex.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/id/vpn-id/vpn-index", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].IdVpnIdOui.IsNull() && data.Domains[j].Services[cj].IdVpnIdOui.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/id/vpn-id/vpn-oui", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].IdString.IsNull() && data.Domains[j].Services[cj].IdString.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/id/string", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].IdNumber.IsNull() && data.Domains[j].Services[cj].IdNumber.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/id/number", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].IdVlanId.IsNull() && data.Domains[j].Services[cj].IdVlanId.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/id/vlanid", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].IdIccBasedUmc.IsNull() && data.Domains[j].Services[cj].IdIccBasedUmc.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/id/icc-based/umc", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].IdIccBasedIcc.IsNull() && data.Domains[j].Services[cj].IdIccBasedIcc.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/id/icc-based/icc", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].XconnectP2pXcName.IsNull() && data.Domains[j].Services[cj].XconnectP2pXcName.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/xconnect/p2p/cross-connect-name", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].XconnectP2pGroupName.IsNull() && data.Domains[j].Services[cj].XconnectP2pGroupName.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/xconnect/p2p/group", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].XconnectMp2mpRemoteCeId.IsNull() && data.Domains[j].Services[cj].XconnectMp2mpRemoteCeId.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/xconnect/mp2mp/remote-ce-id", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].XconnectMp2mpCeId.IsNull() && data.Domains[j].Services[cj].XconnectMp2mpCeId.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/xconnect/mp2mp/ce-id", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].XconnectMp2mpName.IsNull() && data.Domains[j].Services[cj].XconnectMp2mpName.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/xconnect/mp2mp/cross-connect-name", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].XconnectMp2mpGroup.IsNull() && data.Domains[j].Services[cj].XconnectMp2mpGroup.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/xconnect/mp2mp/group", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].FlexibleXconnectVlanUnawareName.IsNull() && data.Domains[j].Services[cj].FlexibleXconnectVlanUnawareName.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/flexible-xconnect/vlan-unaware/cross-connect-name", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].FlexibleXconnectVlanAwareEvi.IsNull() && data.Domains[j].Services[cj].FlexibleXconnectVlanAwareEvi.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/flexible-xconnect/vlan-aware/evi", predicates, cpredicates))
							}
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.Domains[i].Services[ci].DownMeps.IsNull() && state.Domains[i].Services[ci].DownMeps.ValueBool() && data.Domains[j].Services[cj].DownMeps.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/down-meps", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].BridgeDomain.IsNull() && data.Domains[j].Services[cj].BridgeDomain.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/bridge/bridge-domain", predicates, cpredicates))
							}
							if !state.Domains[i].Services[ci].BridgeGroup.IsNull() && data.Domains[j].Services[cj].BridgeGroup.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v/bridge/group", predicates, cpredicates))
							}
							break
						}
					}
					if !found {
						deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/services/service%v", predicates, cpredicates))
					}
				}
				if !state.Domains[i].IdString.IsNull() && data.Domains[j].IdString.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/id/string", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Domains[i].IdNull.IsNull() && state.Domains[i].IdNull.ValueBool() && data.Domains[j].IdNull.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/id/null", predicates))
				}
				if !state.Domains[i].IdMacAddressInteger.IsNull() && data.Domains[j].IdMacAddressInteger.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/id/mac-address-two-octet-integer", predicates))
				}
				if !state.Domains[i].IdMacAddress.IsNull() && data.Domains[j].IdMacAddress.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/id/mac-address", predicates))
				}
				if !state.Domains[i].IdDns.IsNull() && data.Domains[j].IdDns.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/id/dns", predicates))
				}
				if !state.Domains[i].Level.IsNull() && data.Domains[j].Level.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v/level", predicates))
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/domains/domain%v", predicates))
		}
	}
	if !state.TracerouteCacheSize.IsNull() && data.TracerouteCacheSize.IsNull() {
		deletePath := state.getXPath() + "/traceroute/cache/size"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.TracerouteCacheHoldTime.IsNull() && data.TracerouteCacheHoldTime.IsNull() {
		deletePath := state.getXPath() + "/traceroute/cache/hold-time"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}

	b := netconf.NewBody(deleteXml)
	b = helpers.CleanupRedundantRemoveOperations(b)
	return b.Res()
}

// End of section. //template:end addDeletedItemsXML

// Section below is generated&owned by "gen/generator.go". //template:begin addDeletePathsXML

func (data *EthernetCFM) addDeletePathsXML(ctx context.Context, body string) string {
	b := netconf.NewBody(body)
	for i := range data.Domains {
		keys := [...]string{"domain-name"}
		keyValues := [...]string{data.Domains[i].DomainName.ValueString()}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/domains/domain%v", predicates))
	}
	if !data.TracerouteCacheSize.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/traceroute/cache/size")
	}
	if !data.TracerouteCacheHoldTime.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/traceroute/cache/hold-time")
	}

	b = helpers.CleanupRedundantRemoveOperations(b)
	return b.Res()
}

// End of section. //template:end addDeletePathsXML
