// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports
import (
	"context"
	"fmt"
	"reflect"
	"strconv"
	"strings"

	"github.com/CiscoDevNet/terraform-provider-iosxr/internal/provider/helpers"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/netascode/go-netconf"
	"github.com/netascode/xmldot"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin types
type FlowMonitorMap struct {
	Device                                types.String              `tfsdk:"device"`
	Id                                    types.String              `tfsdk:"id"`
	Name                                  types.String              `tfsdk:"name"`
	Exporters                             []FlowMonitorMapExporters `tfsdk:"exporters"`
	OptionOutphysint                      types.Bool                `tfsdk:"option_outphysint"`
	OptionFiltered                        types.Bool                `tfsdk:"option_filtered"`
	OptionBgpattr                         types.Bool                `tfsdk:"option_bgpattr"`
	OptionOutbundlemember                 types.Bool                `tfsdk:"option_outbundlemember"`
	RecordIpv4                            types.Bool                `tfsdk:"record_ipv4"`
	RecordIpv4Destination                 types.Bool                `tfsdk:"record_ipv4_destination"`
	RecordIpv4DestinationTos              types.Bool                `tfsdk:"record_ipv4_destination_tos"`
	RecordIpv4As                          types.Bool                `tfsdk:"record_ipv4_as"`
	RecordIpv4ProtocolPort                types.Bool                `tfsdk:"record_ipv4_protocol_port"`
	RecordIpv4Prefix                      types.Bool                `tfsdk:"record_ipv4_prefix"`
	RecordIpv4SourcePrefix                types.Bool                `tfsdk:"record_ipv4_source_prefix"`
	RecordIpv4DestinationPrefix           types.Bool                `tfsdk:"record_ipv4_destination_prefix"`
	RecordIpv4AsTos                       types.Bool                `tfsdk:"record_ipv4_as_tos"`
	RecordIpv4ProtocolPortTos             types.Bool                `tfsdk:"record_ipv4_protocol_port_tos"`
	RecordIpv4PrefixTos                   types.Bool                `tfsdk:"record_ipv4_prefix_tos"`
	RecordIpv4SourcePrefixTos             types.Bool                `tfsdk:"record_ipv4_source_prefix_tos"`
	RecordIpv4DestinationPrefixTos        types.Bool                `tfsdk:"record_ipv4_destination_prefix_tos"`
	RecordIpv4PrefixPort                  types.Bool                `tfsdk:"record_ipv4_prefix_port"`
	RecordIpv4BgpNexthopTos               types.Bool                `tfsdk:"record_ipv4_bgp_nexthop_tos"`
	RecordIpv4PeerAs                      types.Bool                `tfsdk:"record_ipv4_peer_as"`
	RecordIpv4Gtp                         types.Bool                `tfsdk:"record_ipv4_gtp"`
	RecordIpv4L2L3                        types.Bool                `tfsdk:"record_ipv4_l2_l3"`
	RecordIpv4Extended                    types.Bool                `tfsdk:"record_ipv4_extended"`
	RecordIpv6                            types.Bool                `tfsdk:"record_ipv6"`
	RecordIpv6Destination                 types.Bool                `tfsdk:"record_ipv6_destination"`
	RecordIpv6PeerAs                      types.Bool                `tfsdk:"record_ipv6_peer_as"`
	RecordIpv6Gtp                         types.Bool                `tfsdk:"record_ipv6_gtp"`
	RecordIpv6Srv6                        types.Bool                `tfsdk:"record_ipv6_srv6"`
	RecordIpv6L2L3                        types.Bool                `tfsdk:"record_ipv6_l2_l3"`
	RecordIpv6Extended                    types.Bool                `tfsdk:"record_ipv6_extended"`
	RecordMpls                            types.Bool                `tfsdk:"record_mpls"`
	RecordMplsIpv4Fields                  types.Bool                `tfsdk:"record_mpls_ipv4_fields"`
	RecordMplsIpv6Fields                  types.Bool                `tfsdk:"record_mpls_ipv6_fields"`
	RecordMplsIpv4Ipv6Fields              types.Bool                `tfsdk:"record_mpls_ipv4_ipv6_fields"`
	RecordMplsLabels                      types.Int64               `tfsdk:"record_mpls_labels"`
	RecordMapT                            types.Bool                `tfsdk:"record_map_t"`
	RecordSflow                           types.Bool                `tfsdk:"record_sflow"`
	RecordDatalinkRecord                  types.Bool                `tfsdk:"record_datalink_record"`
	RecordDefaultRtp                      types.Bool                `tfsdk:"record_default_rtp"`
	RecordDefaultMdi                      types.Bool                `tfsdk:"record_default_mdi"`
	CacheEntries                          types.Int64               `tfsdk:"cache_entries"`
	CacheTimeoutActive                    types.Int64               `tfsdk:"cache_timeout_active"`
	CacheTimeoutInactive                  types.Int64               `tfsdk:"cache_timeout_inactive"`
	CacheTimeoutUpdate                    types.Int64               `tfsdk:"cache_timeout_update"`
	CacheTimeoutRateLimit                 types.Int64               `tfsdk:"cache_timeout_rate_limit"`
	CachePermanent                        types.Bool                `tfsdk:"cache_permanent"`
	CacheImmediate                        types.Bool                `tfsdk:"cache_immediate"`
	HwCacheTimeoutInactive                types.Int64               `tfsdk:"hw_cache_timeout_inactive"`
	SflowOptions                          types.Bool                `tfsdk:"sflow_options"`
	SflowOptionsExtendedRouter            types.Bool                `tfsdk:"sflow_options_extended_router"`
	SflowOptionsExtendedGateway           types.Bool                `tfsdk:"sflow_options_extended_gateway"`
	SflowOptionsExtendedIpv4TunnelEgress  types.Bool                `tfsdk:"sflow_options_extended_ipv4_tunnel_egress"`
	SflowOptionsExtendedIpv6TunnelEgress  types.Bool                `tfsdk:"sflow_options_extended_ipv6_tunnel_egress"`
	SflowOptionsIfCountersPollingInterval types.Int64               `tfsdk:"sflow_options_if_counters_polling_interval"`
	SflowOptionsSampleHeaderSize          types.Int64               `tfsdk:"sflow_options_sample_header_size"`
	SflowOptionsInputIfindex              types.String              `tfsdk:"sflow_options_input_ifindex"`
	SflowOptionsOutputIfindex             types.String              `tfsdk:"sflow_options_output_ifindex"`
}

type FlowMonitorMapData struct {
	Device                                types.String              `tfsdk:"device"`
	Id                                    types.String              `tfsdk:"id"`
	Name                                  types.String              `tfsdk:"name"`
	Exporters                             []FlowMonitorMapExporters `tfsdk:"exporters"`
	OptionOutphysint                      types.Bool                `tfsdk:"option_outphysint"`
	OptionFiltered                        types.Bool                `tfsdk:"option_filtered"`
	OptionBgpattr                         types.Bool                `tfsdk:"option_bgpattr"`
	OptionOutbundlemember                 types.Bool                `tfsdk:"option_outbundlemember"`
	RecordIpv4                            types.Bool                `tfsdk:"record_ipv4"`
	RecordIpv4Destination                 types.Bool                `tfsdk:"record_ipv4_destination"`
	RecordIpv4DestinationTos              types.Bool                `tfsdk:"record_ipv4_destination_tos"`
	RecordIpv4As                          types.Bool                `tfsdk:"record_ipv4_as"`
	RecordIpv4ProtocolPort                types.Bool                `tfsdk:"record_ipv4_protocol_port"`
	RecordIpv4Prefix                      types.Bool                `tfsdk:"record_ipv4_prefix"`
	RecordIpv4SourcePrefix                types.Bool                `tfsdk:"record_ipv4_source_prefix"`
	RecordIpv4DestinationPrefix           types.Bool                `tfsdk:"record_ipv4_destination_prefix"`
	RecordIpv4AsTos                       types.Bool                `tfsdk:"record_ipv4_as_tos"`
	RecordIpv4ProtocolPortTos             types.Bool                `tfsdk:"record_ipv4_protocol_port_tos"`
	RecordIpv4PrefixTos                   types.Bool                `tfsdk:"record_ipv4_prefix_tos"`
	RecordIpv4SourcePrefixTos             types.Bool                `tfsdk:"record_ipv4_source_prefix_tos"`
	RecordIpv4DestinationPrefixTos        types.Bool                `tfsdk:"record_ipv4_destination_prefix_tos"`
	RecordIpv4PrefixPort                  types.Bool                `tfsdk:"record_ipv4_prefix_port"`
	RecordIpv4BgpNexthopTos               types.Bool                `tfsdk:"record_ipv4_bgp_nexthop_tos"`
	RecordIpv4PeerAs                      types.Bool                `tfsdk:"record_ipv4_peer_as"`
	RecordIpv4Gtp                         types.Bool                `tfsdk:"record_ipv4_gtp"`
	RecordIpv4L2L3                        types.Bool                `tfsdk:"record_ipv4_l2_l3"`
	RecordIpv4Extended                    types.Bool                `tfsdk:"record_ipv4_extended"`
	RecordIpv6                            types.Bool                `tfsdk:"record_ipv6"`
	RecordIpv6Destination                 types.Bool                `tfsdk:"record_ipv6_destination"`
	RecordIpv6PeerAs                      types.Bool                `tfsdk:"record_ipv6_peer_as"`
	RecordIpv6Gtp                         types.Bool                `tfsdk:"record_ipv6_gtp"`
	RecordIpv6Srv6                        types.Bool                `tfsdk:"record_ipv6_srv6"`
	RecordIpv6L2L3                        types.Bool                `tfsdk:"record_ipv6_l2_l3"`
	RecordIpv6Extended                    types.Bool                `tfsdk:"record_ipv6_extended"`
	RecordMpls                            types.Bool                `tfsdk:"record_mpls"`
	RecordMplsIpv4Fields                  types.Bool                `tfsdk:"record_mpls_ipv4_fields"`
	RecordMplsIpv6Fields                  types.Bool                `tfsdk:"record_mpls_ipv6_fields"`
	RecordMplsIpv4Ipv6Fields              types.Bool                `tfsdk:"record_mpls_ipv4_ipv6_fields"`
	RecordMplsLabels                      types.Int64               `tfsdk:"record_mpls_labels"`
	RecordMapT                            types.Bool                `tfsdk:"record_map_t"`
	RecordSflow                           types.Bool                `tfsdk:"record_sflow"`
	RecordDatalinkRecord                  types.Bool                `tfsdk:"record_datalink_record"`
	RecordDefaultRtp                      types.Bool                `tfsdk:"record_default_rtp"`
	RecordDefaultMdi                      types.Bool                `tfsdk:"record_default_mdi"`
	CacheEntries                          types.Int64               `tfsdk:"cache_entries"`
	CacheTimeoutActive                    types.Int64               `tfsdk:"cache_timeout_active"`
	CacheTimeoutInactive                  types.Int64               `tfsdk:"cache_timeout_inactive"`
	CacheTimeoutUpdate                    types.Int64               `tfsdk:"cache_timeout_update"`
	CacheTimeoutRateLimit                 types.Int64               `tfsdk:"cache_timeout_rate_limit"`
	CachePermanent                        types.Bool                `tfsdk:"cache_permanent"`
	CacheImmediate                        types.Bool                `tfsdk:"cache_immediate"`
	HwCacheTimeoutInactive                types.Int64               `tfsdk:"hw_cache_timeout_inactive"`
	SflowOptions                          types.Bool                `tfsdk:"sflow_options"`
	SflowOptionsExtendedRouter            types.Bool                `tfsdk:"sflow_options_extended_router"`
	SflowOptionsExtendedGateway           types.Bool                `tfsdk:"sflow_options_extended_gateway"`
	SflowOptionsExtendedIpv4TunnelEgress  types.Bool                `tfsdk:"sflow_options_extended_ipv4_tunnel_egress"`
	SflowOptionsExtendedIpv6TunnelEgress  types.Bool                `tfsdk:"sflow_options_extended_ipv6_tunnel_egress"`
	SflowOptionsIfCountersPollingInterval types.Int64               `tfsdk:"sflow_options_if_counters_polling_interval"`
	SflowOptionsSampleHeaderSize          types.Int64               `tfsdk:"sflow_options_sample_header_size"`
	SflowOptionsInputIfindex              types.String              `tfsdk:"sflow_options_input_ifindex"`
	SflowOptionsOutputIfindex             types.String              `tfsdk:"sflow_options_output_ifindex"`
}
type FlowMonitorMapExporters struct {
	Name types.String `tfsdk:"name"`
}

// End of section. //template:end types

// Section below is generated&owned by "gen/generator.go". //template:begin getPath

func (data FlowMonitorMap) getPath() string {
	return fmt.Sprintf("Cisco-IOS-XR-um-flow-cfg:/flow/monitor-map/monitor-maps/monitor-map[monitor-map-name=%s]", data.Name.ValueString())
}

func (data FlowMonitorMapData) getPath() string {
	return fmt.Sprintf("Cisco-IOS-XR-um-flow-cfg:/flow/monitor-map/monitor-maps/monitor-map[monitor-map-name=%s]", data.Name.ValueString())
}

// getXPath returns the XPath for NETCONF operations
func (data FlowMonitorMap) getXPath() string {
	path := "Cisco-IOS-XR-um-flow-cfg:/flow/monitor-map/monitor-maps/monitor-map[monitor-map-name=%s]"
	path = fmt.Sprintf(path, fmt.Sprintf("%v", data.Name.ValueString()))
	return path
}

func (data FlowMonitorMapData) getXPath() string {
	path := "Cisco-IOS-XR-um-flow-cfg:/flow/monitor-map/monitor-maps/monitor-map[monitor-map-name=%s]"
	path = fmt.Sprintf(path, fmt.Sprintf("%v", data.Name.ValueString()))
	return path
}

// End of section. //template:end getPath

// Section below is generated&owned by "gen/generator.go". //template:begin toBody

func (data FlowMonitorMap) toBody(ctx context.Context) string {
	body := "{}"
	if !data.Name.IsNull() && !data.Name.IsUnknown() {
		body, _ = sjson.Set(body, "monitor-map-name", data.Name.ValueString())
	}
	if !data.OptionOutphysint.IsNull() && !data.OptionOutphysint.IsUnknown() {
		if data.OptionOutphysint.ValueBool() {
			body, _ = sjson.Set(body, "option.outphysint", map[string]string{})
		}
	}
	if !data.OptionFiltered.IsNull() && !data.OptionFiltered.IsUnknown() {
		if data.OptionFiltered.ValueBool() {
			body, _ = sjson.Set(body, "option.filtered", map[string]string{})
		}
	}
	if !data.OptionBgpattr.IsNull() && !data.OptionBgpattr.IsUnknown() {
		if data.OptionBgpattr.ValueBool() {
			body, _ = sjson.Set(body, "option.bgpattr", map[string]string{})
		}
	}
	if !data.OptionOutbundlemember.IsNull() && !data.OptionOutbundlemember.IsUnknown() {
		if data.OptionOutbundlemember.ValueBool() {
			body, _ = sjson.Set(body, "option.outbundlemember", map[string]string{})
		}
	}
	if !data.RecordIpv4.IsNull() && !data.RecordIpv4.IsUnknown() {
		if data.RecordIpv4.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv4", map[string]string{})
		}
	}
	if !data.RecordIpv4Destination.IsNull() && !data.RecordIpv4Destination.IsUnknown() {
		if data.RecordIpv4Destination.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv4.destination", map[string]string{})
		}
	}
	if !data.RecordIpv4DestinationTos.IsNull() && !data.RecordIpv4DestinationTos.IsUnknown() {
		if data.RecordIpv4DestinationTos.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv4.destination-tos", map[string]string{})
		}
	}
	if !data.RecordIpv4As.IsNull() && !data.RecordIpv4As.IsUnknown() {
		if data.RecordIpv4As.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv4.as", map[string]string{})
		}
	}
	if !data.RecordIpv4ProtocolPort.IsNull() && !data.RecordIpv4ProtocolPort.IsUnknown() {
		if data.RecordIpv4ProtocolPort.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv4.protocol-port", map[string]string{})
		}
	}
	if !data.RecordIpv4Prefix.IsNull() && !data.RecordIpv4Prefix.IsUnknown() {
		if data.RecordIpv4Prefix.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv4.prefix", map[string]string{})
		}
	}
	if !data.RecordIpv4SourcePrefix.IsNull() && !data.RecordIpv4SourcePrefix.IsUnknown() {
		if data.RecordIpv4SourcePrefix.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv4.source-prefix", map[string]string{})
		}
	}
	if !data.RecordIpv4DestinationPrefix.IsNull() && !data.RecordIpv4DestinationPrefix.IsUnknown() {
		if data.RecordIpv4DestinationPrefix.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv4.destination-prefix", map[string]string{})
		}
	}
	if !data.RecordIpv4AsTos.IsNull() && !data.RecordIpv4AsTos.IsUnknown() {
		if data.RecordIpv4AsTos.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv4.as-tos", map[string]string{})
		}
	}
	if !data.RecordIpv4ProtocolPortTos.IsNull() && !data.RecordIpv4ProtocolPortTos.IsUnknown() {
		if data.RecordIpv4ProtocolPortTos.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv4.protocol-port-tos", map[string]string{})
		}
	}
	if !data.RecordIpv4PrefixTos.IsNull() && !data.RecordIpv4PrefixTos.IsUnknown() {
		if data.RecordIpv4PrefixTos.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv4.prefix-tos", map[string]string{})
		}
	}
	if !data.RecordIpv4SourcePrefixTos.IsNull() && !data.RecordIpv4SourcePrefixTos.IsUnknown() {
		if data.RecordIpv4SourcePrefixTos.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv4.source-prefix-tos", map[string]string{})
		}
	}
	if !data.RecordIpv4DestinationPrefixTos.IsNull() && !data.RecordIpv4DestinationPrefixTos.IsUnknown() {
		if data.RecordIpv4DestinationPrefixTos.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv4.destination-prefix-tos", map[string]string{})
		}
	}
	if !data.RecordIpv4PrefixPort.IsNull() && !data.RecordIpv4PrefixPort.IsUnknown() {
		if data.RecordIpv4PrefixPort.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv4.prefix-port", map[string]string{})
		}
	}
	if !data.RecordIpv4BgpNexthopTos.IsNull() && !data.RecordIpv4BgpNexthopTos.IsUnknown() {
		if data.RecordIpv4BgpNexthopTos.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv4.bgp-nexthop-tos", map[string]string{})
		}
	}
	if !data.RecordIpv4PeerAs.IsNull() && !data.RecordIpv4PeerAs.IsUnknown() {
		if data.RecordIpv4PeerAs.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv4.peer-as", map[string]string{})
		}
	}
	if !data.RecordIpv4Gtp.IsNull() && !data.RecordIpv4Gtp.IsUnknown() {
		if data.RecordIpv4Gtp.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv4.gtp", map[string]string{})
		}
	}
	if !data.RecordIpv4L2L3.IsNull() && !data.RecordIpv4L2L3.IsUnknown() {
		if data.RecordIpv4L2L3.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv4.l2-l3", map[string]string{})
		}
	}
	if !data.RecordIpv4Extended.IsNull() && !data.RecordIpv4Extended.IsUnknown() {
		if data.RecordIpv4Extended.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv4.extended", map[string]string{})
		}
	}
	if !data.RecordIpv6.IsNull() && !data.RecordIpv6.IsUnknown() {
		if data.RecordIpv6.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv6", map[string]string{})
		}
	}
	if !data.RecordIpv6Destination.IsNull() && !data.RecordIpv6Destination.IsUnknown() {
		if data.RecordIpv6Destination.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv6.destination", map[string]string{})
		}
	}
	if !data.RecordIpv6PeerAs.IsNull() && !data.RecordIpv6PeerAs.IsUnknown() {
		if data.RecordIpv6PeerAs.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv6.peer-as", map[string]string{})
		}
	}
	if !data.RecordIpv6Gtp.IsNull() && !data.RecordIpv6Gtp.IsUnknown() {
		if data.RecordIpv6Gtp.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv6.gtp", map[string]string{})
		}
	}
	if !data.RecordIpv6Srv6.IsNull() && !data.RecordIpv6Srv6.IsUnknown() {
		if data.RecordIpv6Srv6.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv6.srv6", map[string]string{})
		}
	}
	if !data.RecordIpv6L2L3.IsNull() && !data.RecordIpv6L2L3.IsUnknown() {
		if data.RecordIpv6L2L3.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv6.l2-l3", map[string]string{})
		}
	}
	if !data.RecordIpv6Extended.IsNull() && !data.RecordIpv6Extended.IsUnknown() {
		if data.RecordIpv6Extended.ValueBool() {
			body, _ = sjson.Set(body, "record.ipv6.extended", map[string]string{})
		}
	}
	if !data.RecordMpls.IsNull() && !data.RecordMpls.IsUnknown() {
		if data.RecordMpls.ValueBool() {
			body, _ = sjson.Set(body, "record.mpls", map[string]string{})
		}
	}
	if !data.RecordMplsIpv4Fields.IsNull() && !data.RecordMplsIpv4Fields.IsUnknown() {
		if data.RecordMplsIpv4Fields.ValueBool() {
			body, _ = sjson.Set(body, "record.mpls.ipv4-fields", map[string]string{})
		}
	}
	if !data.RecordMplsIpv6Fields.IsNull() && !data.RecordMplsIpv6Fields.IsUnknown() {
		if data.RecordMplsIpv6Fields.ValueBool() {
			body, _ = sjson.Set(body, "record.mpls.ipv6-fields", map[string]string{})
		}
	}
	if !data.RecordMplsIpv4Ipv6Fields.IsNull() && !data.RecordMplsIpv4Ipv6Fields.IsUnknown() {
		if data.RecordMplsIpv4Ipv6Fields.ValueBool() {
			body, _ = sjson.Set(body, "record.mpls.ipv4-ipv6-fields", map[string]string{})
		}
	}
	if !data.RecordMplsLabels.IsNull() && !data.RecordMplsLabels.IsUnknown() {
		body, _ = sjson.Set(body, "record.mpls.labels", strconv.FormatInt(data.RecordMplsLabels.ValueInt64(), 10))
	}
	if !data.RecordMapT.IsNull() && !data.RecordMapT.IsUnknown() {
		if data.RecordMapT.ValueBool() {
			body, _ = sjson.Set(body, "record.map-t", map[string]string{})
		}
	}
	if !data.RecordSflow.IsNull() && !data.RecordSflow.IsUnknown() {
		if data.RecordSflow.ValueBool() {
			body, _ = sjson.Set(body, "record.sflow", map[string]string{})
		}
	}
	if !data.RecordDatalinkRecord.IsNull() && !data.RecordDatalinkRecord.IsUnknown() {
		if data.RecordDatalinkRecord.ValueBool() {
			body, _ = sjson.Set(body, "record.datalink-record", map[string]string{})
		}
	}
	if !data.RecordDefaultRtp.IsNull() && !data.RecordDefaultRtp.IsUnknown() {
		if data.RecordDefaultRtp.ValueBool() {
			body, _ = sjson.Set(body, "record.default-rtp", map[string]string{})
		}
	}
	if !data.RecordDefaultMdi.IsNull() && !data.RecordDefaultMdi.IsUnknown() {
		if data.RecordDefaultMdi.ValueBool() {
			body, _ = sjson.Set(body, "record.default-mdi", map[string]string{})
		}
	}
	if !data.CacheEntries.IsNull() && !data.CacheEntries.IsUnknown() {
		body, _ = sjson.Set(body, "cache.entries", strconv.FormatInt(data.CacheEntries.ValueInt64(), 10))
	}
	if !data.CacheTimeoutActive.IsNull() && !data.CacheTimeoutActive.IsUnknown() {
		body, _ = sjson.Set(body, "cache.timeout.active", strconv.FormatInt(data.CacheTimeoutActive.ValueInt64(), 10))
	}
	if !data.CacheTimeoutInactive.IsNull() && !data.CacheTimeoutInactive.IsUnknown() {
		body, _ = sjson.Set(body, "cache.timeout.inactive", strconv.FormatInt(data.CacheTimeoutInactive.ValueInt64(), 10))
	}
	if !data.CacheTimeoutUpdate.IsNull() && !data.CacheTimeoutUpdate.IsUnknown() {
		body, _ = sjson.Set(body, "cache.timeout.update", strconv.FormatInt(data.CacheTimeoutUpdate.ValueInt64(), 10))
	}
	if !data.CacheTimeoutRateLimit.IsNull() && !data.CacheTimeoutRateLimit.IsUnknown() {
		body, _ = sjson.Set(body, "cache.timeout.rate-limit", strconv.FormatInt(data.CacheTimeoutRateLimit.ValueInt64(), 10))
	}
	if !data.CachePermanent.IsNull() && !data.CachePermanent.IsUnknown() {
		if data.CachePermanent.ValueBool() {
			body, _ = sjson.Set(body, "cache.permanent", map[string]string{})
		}
	}
	if !data.CacheImmediate.IsNull() && !data.CacheImmediate.IsUnknown() {
		if data.CacheImmediate.ValueBool() {
			body, _ = sjson.Set(body, "cache.immediate", map[string]string{})
		}
	}
	if !data.HwCacheTimeoutInactive.IsNull() && !data.HwCacheTimeoutInactive.IsUnknown() {
		body, _ = sjson.Set(body, "hw-cache.timeout.inactive", strconv.FormatInt(data.HwCacheTimeoutInactive.ValueInt64(), 10))
	}
	if !data.SflowOptions.IsNull() && !data.SflowOptions.IsUnknown() {
		if data.SflowOptions.ValueBool() {
			body, _ = sjson.Set(body, "sflow.options", map[string]string{})
		}
	}
	if !data.SflowOptionsExtendedRouter.IsNull() && !data.SflowOptionsExtendedRouter.IsUnknown() {
		if data.SflowOptionsExtendedRouter.ValueBool() {
			body, _ = sjson.Set(body, "sflow.options.extended-router", map[string]string{})
		}
	}
	if !data.SflowOptionsExtendedGateway.IsNull() && !data.SflowOptionsExtendedGateway.IsUnknown() {
		if data.SflowOptionsExtendedGateway.ValueBool() {
			body, _ = sjson.Set(body, "sflow.options.extended-gateway", map[string]string{})
		}
	}
	if !data.SflowOptionsExtendedIpv4TunnelEgress.IsNull() && !data.SflowOptionsExtendedIpv4TunnelEgress.IsUnknown() {
		if data.SflowOptionsExtendedIpv4TunnelEgress.ValueBool() {
			body, _ = sjson.Set(body, "sflow.options.extended-ipv4-tunnel-egress", map[string]string{})
		}
	}
	if !data.SflowOptionsExtendedIpv6TunnelEgress.IsNull() && !data.SflowOptionsExtendedIpv6TunnelEgress.IsUnknown() {
		if data.SflowOptionsExtendedIpv6TunnelEgress.ValueBool() {
			body, _ = sjson.Set(body, "sflow.options.extended-ipv6-tunnel-egress", map[string]string{})
		}
	}
	if !data.SflowOptionsIfCountersPollingInterval.IsNull() && !data.SflowOptionsIfCountersPollingInterval.IsUnknown() {
		body, _ = sjson.Set(body, "sflow.options.if-counters.polling-interval", strconv.FormatInt(data.SflowOptionsIfCountersPollingInterval.ValueInt64(), 10))
	}
	if !data.SflowOptionsSampleHeaderSize.IsNull() && !data.SflowOptionsSampleHeaderSize.IsUnknown() {
		body, _ = sjson.Set(body, "sflow.options.sample-header.size", strconv.FormatInt(data.SflowOptionsSampleHeaderSize.ValueInt64(), 10))
	}
	if !data.SflowOptionsInputIfindex.IsNull() && !data.SflowOptionsInputIfindex.IsUnknown() {
		body, _ = sjson.Set(body, "sflow.options.input.ifindex", data.SflowOptionsInputIfindex.ValueString())
	}
	if !data.SflowOptionsOutputIfindex.IsNull() && !data.SflowOptionsOutputIfindex.IsUnknown() {
		body, _ = sjson.Set(body, "sflow.options.output.ifindex", data.SflowOptionsOutputIfindex.ValueString())
	}
	if len(data.Exporters) > 0 {
		body, _ = sjson.Set(body, "exporters.exporter", []interface{}{})
		for index, item := range data.Exporters {
			if !item.Name.IsNull() && !item.Name.IsUnknown() {
				body, _ = sjson.Set(body, "exporters.exporter"+"."+strconv.Itoa(index)+"."+"exporter-name", item.Name.ValueString())
			}
		}
	}
	return body
}

// End of section. //template:end toBody

// Section below is generated&owned by "gen/generator.go". //template:begin toBodyXML

func (data FlowMonitorMap) toBodyXML(ctx context.Context) string {
	body := netconf.Body{}
	if !data.Name.IsNull() && !data.Name.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/monitor-map-name", data.Name.ValueString())
	}
	if len(data.Exporters) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.Exporters {
			cBody := netconf.Body{}
			if !item.Name.IsNull() && !item.Name.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "exporter-name", item.Name.ValueString())
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"exporters/exporter", cBody.Res())
		}
	}
	if !data.OptionOutphysint.IsNull() && !data.OptionOutphysint.IsUnknown() {
		if data.OptionOutphysint.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/option/outphysint", "")
		}
	}
	if !data.OptionFiltered.IsNull() && !data.OptionFiltered.IsUnknown() {
		if data.OptionFiltered.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/option/filtered", "")
		}
	}
	if !data.OptionBgpattr.IsNull() && !data.OptionBgpattr.IsUnknown() {
		if data.OptionBgpattr.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/option/bgpattr", "")
		}
	}
	if !data.OptionOutbundlemember.IsNull() && !data.OptionOutbundlemember.IsUnknown() {
		if data.OptionOutbundlemember.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/option/outbundlemember", "")
		}
	}
	if !data.RecordIpv4.IsNull() && !data.RecordIpv4.IsUnknown() {
		if data.RecordIpv4.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv4", "")
		}
	}
	if !data.RecordIpv4Destination.IsNull() && !data.RecordIpv4Destination.IsUnknown() {
		if data.RecordIpv4Destination.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv4/destination", "")
		}
	}
	if !data.RecordIpv4DestinationTos.IsNull() && !data.RecordIpv4DestinationTos.IsUnknown() {
		if data.RecordIpv4DestinationTos.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv4/destination-tos", "")
		}
	}
	if !data.RecordIpv4As.IsNull() && !data.RecordIpv4As.IsUnknown() {
		if data.RecordIpv4As.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv4/as", "")
		}
	}
	if !data.RecordIpv4ProtocolPort.IsNull() && !data.RecordIpv4ProtocolPort.IsUnknown() {
		if data.RecordIpv4ProtocolPort.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv4/protocol-port", "")
		}
	}
	if !data.RecordIpv4Prefix.IsNull() && !data.RecordIpv4Prefix.IsUnknown() {
		if data.RecordIpv4Prefix.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv4/prefix", "")
		}
	}
	if !data.RecordIpv4SourcePrefix.IsNull() && !data.RecordIpv4SourcePrefix.IsUnknown() {
		if data.RecordIpv4SourcePrefix.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv4/source-prefix", "")
		}
	}
	if !data.RecordIpv4DestinationPrefix.IsNull() && !data.RecordIpv4DestinationPrefix.IsUnknown() {
		if data.RecordIpv4DestinationPrefix.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv4/destination-prefix", "")
		}
	}
	if !data.RecordIpv4AsTos.IsNull() && !data.RecordIpv4AsTos.IsUnknown() {
		if data.RecordIpv4AsTos.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv4/as-tos", "")
		}
	}
	if !data.RecordIpv4ProtocolPortTos.IsNull() && !data.RecordIpv4ProtocolPortTos.IsUnknown() {
		if data.RecordIpv4ProtocolPortTos.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv4/protocol-port-tos", "")
		}
	}
	if !data.RecordIpv4PrefixTos.IsNull() && !data.RecordIpv4PrefixTos.IsUnknown() {
		if data.RecordIpv4PrefixTos.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv4/prefix-tos", "")
		}
	}
	if !data.RecordIpv4SourcePrefixTos.IsNull() && !data.RecordIpv4SourcePrefixTos.IsUnknown() {
		if data.RecordIpv4SourcePrefixTos.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv4/source-prefix-tos", "")
		}
	}
	if !data.RecordIpv4DestinationPrefixTos.IsNull() && !data.RecordIpv4DestinationPrefixTos.IsUnknown() {
		if data.RecordIpv4DestinationPrefixTos.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv4/destination-prefix-tos", "")
		}
	}
	if !data.RecordIpv4PrefixPort.IsNull() && !data.RecordIpv4PrefixPort.IsUnknown() {
		if data.RecordIpv4PrefixPort.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv4/prefix-port", "")
		}
	}
	if !data.RecordIpv4BgpNexthopTos.IsNull() && !data.RecordIpv4BgpNexthopTos.IsUnknown() {
		if data.RecordIpv4BgpNexthopTos.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv4/bgp-nexthop-tos", "")
		}
	}
	if !data.RecordIpv4PeerAs.IsNull() && !data.RecordIpv4PeerAs.IsUnknown() {
		if data.RecordIpv4PeerAs.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv4/peer-as", "")
		}
	}
	if !data.RecordIpv4Gtp.IsNull() && !data.RecordIpv4Gtp.IsUnknown() {
		if data.RecordIpv4Gtp.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv4/gtp", "")
		}
	}
	if !data.RecordIpv4L2L3.IsNull() && !data.RecordIpv4L2L3.IsUnknown() {
		if data.RecordIpv4L2L3.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv4/l2-l3", "")
		}
	}
	if !data.RecordIpv4Extended.IsNull() && !data.RecordIpv4Extended.IsUnknown() {
		if data.RecordIpv4Extended.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv4/extended", "")
		}
	}
	if !data.RecordIpv6.IsNull() && !data.RecordIpv6.IsUnknown() {
		if data.RecordIpv6.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv6", "")
		}
	}
	if !data.RecordIpv6Destination.IsNull() && !data.RecordIpv6Destination.IsUnknown() {
		if data.RecordIpv6Destination.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv6/destination", "")
		}
	}
	if !data.RecordIpv6PeerAs.IsNull() && !data.RecordIpv6PeerAs.IsUnknown() {
		if data.RecordIpv6PeerAs.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv6/peer-as", "")
		}
	}
	if !data.RecordIpv6Gtp.IsNull() && !data.RecordIpv6Gtp.IsUnknown() {
		if data.RecordIpv6Gtp.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv6/gtp", "")
		}
	}
	if !data.RecordIpv6Srv6.IsNull() && !data.RecordIpv6Srv6.IsUnknown() {
		if data.RecordIpv6Srv6.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv6/srv6", "")
		}
	}
	if !data.RecordIpv6L2L3.IsNull() && !data.RecordIpv6L2L3.IsUnknown() {
		if data.RecordIpv6L2L3.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv6/l2-l3", "")
		}
	}
	if !data.RecordIpv6Extended.IsNull() && !data.RecordIpv6Extended.IsUnknown() {
		if data.RecordIpv6Extended.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/ipv6/extended", "")
		}
	}
	if !data.RecordMpls.IsNull() && !data.RecordMpls.IsUnknown() {
		if data.RecordMpls.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/mpls", "")
		}
	}
	if !data.RecordMplsIpv4Fields.IsNull() && !data.RecordMplsIpv4Fields.IsUnknown() {
		if data.RecordMplsIpv4Fields.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/mpls/ipv4-fields", "")
		}
	}
	if !data.RecordMplsIpv6Fields.IsNull() && !data.RecordMplsIpv6Fields.IsUnknown() {
		if data.RecordMplsIpv6Fields.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/mpls/ipv6-fields", "")
		}
	}
	if !data.RecordMplsIpv4Ipv6Fields.IsNull() && !data.RecordMplsIpv4Ipv6Fields.IsUnknown() {
		if data.RecordMplsIpv4Ipv6Fields.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/mpls/ipv4-ipv6-fields", "")
		}
	}
	if !data.RecordMplsLabels.IsNull() && !data.RecordMplsLabels.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/record/mpls/labels", strconv.FormatInt(data.RecordMplsLabels.ValueInt64(), 10))
	}
	if !data.RecordMapT.IsNull() && !data.RecordMapT.IsUnknown() {
		if data.RecordMapT.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/map-t", "")
		}
	}
	if !data.RecordSflow.IsNull() && !data.RecordSflow.IsUnknown() {
		if data.RecordSflow.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/sflow", "")
		}
	}
	if !data.RecordDatalinkRecord.IsNull() && !data.RecordDatalinkRecord.IsUnknown() {
		if data.RecordDatalinkRecord.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/datalink-record", "")
		}
	}
	if !data.RecordDefaultRtp.IsNull() && !data.RecordDefaultRtp.IsUnknown() {
		if data.RecordDefaultRtp.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/default-rtp", "")
		}
	}
	if !data.RecordDefaultMdi.IsNull() && !data.RecordDefaultMdi.IsUnknown() {
		if data.RecordDefaultMdi.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/record/default-mdi", "")
		}
	}
	if !data.CacheEntries.IsNull() && !data.CacheEntries.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/cache/entries", strconv.FormatInt(data.CacheEntries.ValueInt64(), 10))
	}
	if !data.CacheTimeoutActive.IsNull() && !data.CacheTimeoutActive.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/cache/timeout/active", strconv.FormatInt(data.CacheTimeoutActive.ValueInt64(), 10))
	}
	if !data.CacheTimeoutInactive.IsNull() && !data.CacheTimeoutInactive.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/cache/timeout/inactive", strconv.FormatInt(data.CacheTimeoutInactive.ValueInt64(), 10))
	}
	if !data.CacheTimeoutUpdate.IsNull() && !data.CacheTimeoutUpdate.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/cache/timeout/update", strconv.FormatInt(data.CacheTimeoutUpdate.ValueInt64(), 10))
	}
	if !data.CacheTimeoutRateLimit.IsNull() && !data.CacheTimeoutRateLimit.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/cache/timeout/rate-limit", strconv.FormatInt(data.CacheTimeoutRateLimit.ValueInt64(), 10))
	}
	if !data.CachePermanent.IsNull() && !data.CachePermanent.IsUnknown() {
		if data.CachePermanent.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/cache/permanent", "")
		}
	}
	if !data.CacheImmediate.IsNull() && !data.CacheImmediate.IsUnknown() {
		if data.CacheImmediate.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/cache/immediate", "")
		}
	}
	if !data.HwCacheTimeoutInactive.IsNull() && !data.HwCacheTimeoutInactive.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/hw-cache/timeout/inactive", strconv.FormatInt(data.HwCacheTimeoutInactive.ValueInt64(), 10))
	}
	if !data.SflowOptions.IsNull() && !data.SflowOptions.IsUnknown() {
		if data.SflowOptions.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/sflow/options", "")
		}
	}
	if !data.SflowOptionsExtendedRouter.IsNull() && !data.SflowOptionsExtendedRouter.IsUnknown() {
		if data.SflowOptionsExtendedRouter.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/sflow/options/extended-router", "")
		}
	}
	if !data.SflowOptionsExtendedGateway.IsNull() && !data.SflowOptionsExtendedGateway.IsUnknown() {
		if data.SflowOptionsExtendedGateway.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/sflow/options/extended-gateway", "")
		}
	}
	if !data.SflowOptionsExtendedIpv4TunnelEgress.IsNull() && !data.SflowOptionsExtendedIpv4TunnelEgress.IsUnknown() {
		if data.SflowOptionsExtendedIpv4TunnelEgress.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/sflow/options/extended-ipv4-tunnel-egress", "")
		}
	}
	if !data.SflowOptionsExtendedIpv6TunnelEgress.IsNull() && !data.SflowOptionsExtendedIpv6TunnelEgress.IsUnknown() {
		if data.SflowOptionsExtendedIpv6TunnelEgress.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/sflow/options/extended-ipv6-tunnel-egress", "")
		}
	}
	if !data.SflowOptionsIfCountersPollingInterval.IsNull() && !data.SflowOptionsIfCountersPollingInterval.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/sflow/options/if-counters/polling-interval", strconv.FormatInt(data.SflowOptionsIfCountersPollingInterval.ValueInt64(), 10))
	}
	if !data.SflowOptionsSampleHeaderSize.IsNull() && !data.SflowOptionsSampleHeaderSize.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/sflow/options/sample-header/size", strconv.FormatInt(data.SflowOptionsSampleHeaderSize.ValueInt64(), 10))
	}
	if !data.SflowOptionsInputIfindex.IsNull() && !data.SflowOptionsInputIfindex.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/sflow/options/input/ifindex", data.SflowOptionsInputIfindex.ValueString())
	}
	if !data.SflowOptionsOutputIfindex.IsNull() && !data.SflowOptionsOutputIfindex.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/sflow/options/output/ifindex", data.SflowOptionsOutputIfindex.ValueString())
	}
	bodyString, err := body.String()
	if err != nil {
		tflog.Error(ctx, fmt.Sprintf("Error converting body to string: %s", err))
	}
	return bodyString
}

// End of section. //template:end toBodyXML

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBody

func (data *FlowMonitorMap) updateFromBody(ctx context.Context, res []byte) {
	for i := range data.Exporters {
		keys := [...]string{"exporter-name"}
		keyValues := [...]string{data.Exporters[i].Name.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "exporters.exporter").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("exporter-name"); value.Exists() && !data.Exporters[i].Name.IsNull() {
			data.Exporters[i].Name = types.StringValue(value.String())
		} else {
			data.Exporters[i].Name = types.StringNull()
		}
	}
	if value := gjson.GetBytes(res, "option.outphysint"); value.Exists() {
		if !data.OptionOutphysint.IsNull() {
			data.OptionOutphysint = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.OptionOutphysint.IsNull() {
			data.OptionOutphysint = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "option.filtered"); value.Exists() {
		if !data.OptionFiltered.IsNull() {
			data.OptionFiltered = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.OptionFiltered.IsNull() {
			data.OptionFiltered = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "option.bgpattr"); value.Exists() {
		if !data.OptionBgpattr.IsNull() {
			data.OptionBgpattr = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.OptionBgpattr.IsNull() {
			data.OptionBgpattr = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "option.outbundlemember"); value.Exists() {
		if !data.OptionOutbundlemember.IsNull() {
			data.OptionOutbundlemember = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.OptionOutbundlemember.IsNull() {
			data.OptionOutbundlemember = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv4"); value.Exists() {
		if !data.RecordIpv4.IsNull() {
			data.RecordIpv4 = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv4.IsNull() {
			data.RecordIpv4 = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv4.destination"); value.Exists() {
		if !data.RecordIpv4Destination.IsNull() {
			data.RecordIpv4Destination = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv4Destination.IsNull() {
			data.RecordIpv4Destination = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv4.destination-tos"); value.Exists() {
		if !data.RecordIpv4DestinationTos.IsNull() {
			data.RecordIpv4DestinationTos = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv4DestinationTos.IsNull() {
			data.RecordIpv4DestinationTos = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv4.as"); value.Exists() {
		if !data.RecordIpv4As.IsNull() {
			data.RecordIpv4As = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv4As.IsNull() {
			data.RecordIpv4As = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv4.protocol-port"); value.Exists() {
		if !data.RecordIpv4ProtocolPort.IsNull() {
			data.RecordIpv4ProtocolPort = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv4ProtocolPort.IsNull() {
			data.RecordIpv4ProtocolPort = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv4.prefix"); value.Exists() {
		if !data.RecordIpv4Prefix.IsNull() {
			data.RecordIpv4Prefix = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv4Prefix.IsNull() {
			data.RecordIpv4Prefix = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv4.source-prefix"); value.Exists() {
		if !data.RecordIpv4SourcePrefix.IsNull() {
			data.RecordIpv4SourcePrefix = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv4SourcePrefix.IsNull() {
			data.RecordIpv4SourcePrefix = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv4.destination-prefix"); value.Exists() {
		if !data.RecordIpv4DestinationPrefix.IsNull() {
			data.RecordIpv4DestinationPrefix = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv4DestinationPrefix.IsNull() {
			data.RecordIpv4DestinationPrefix = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv4.as-tos"); value.Exists() {
		if !data.RecordIpv4AsTos.IsNull() {
			data.RecordIpv4AsTos = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv4AsTos.IsNull() {
			data.RecordIpv4AsTos = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv4.protocol-port-tos"); value.Exists() {
		if !data.RecordIpv4ProtocolPortTos.IsNull() {
			data.RecordIpv4ProtocolPortTos = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv4ProtocolPortTos.IsNull() {
			data.RecordIpv4ProtocolPortTos = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv4.prefix-tos"); value.Exists() {
		if !data.RecordIpv4PrefixTos.IsNull() {
			data.RecordIpv4PrefixTos = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv4PrefixTos.IsNull() {
			data.RecordIpv4PrefixTos = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv4.source-prefix-tos"); value.Exists() {
		if !data.RecordIpv4SourcePrefixTos.IsNull() {
			data.RecordIpv4SourcePrefixTos = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv4SourcePrefixTos.IsNull() {
			data.RecordIpv4SourcePrefixTos = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv4.destination-prefix-tos"); value.Exists() {
		if !data.RecordIpv4DestinationPrefixTos.IsNull() {
			data.RecordIpv4DestinationPrefixTos = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv4DestinationPrefixTos.IsNull() {
			data.RecordIpv4DestinationPrefixTos = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv4.prefix-port"); value.Exists() {
		if !data.RecordIpv4PrefixPort.IsNull() {
			data.RecordIpv4PrefixPort = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv4PrefixPort.IsNull() {
			data.RecordIpv4PrefixPort = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv4.bgp-nexthop-tos"); value.Exists() {
		if !data.RecordIpv4BgpNexthopTos.IsNull() {
			data.RecordIpv4BgpNexthopTos = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv4BgpNexthopTos.IsNull() {
			data.RecordIpv4BgpNexthopTos = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv4.peer-as"); value.Exists() {
		if !data.RecordIpv4PeerAs.IsNull() {
			data.RecordIpv4PeerAs = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv4PeerAs.IsNull() {
			data.RecordIpv4PeerAs = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv4.gtp"); value.Exists() {
		if !data.RecordIpv4Gtp.IsNull() {
			data.RecordIpv4Gtp = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv4Gtp.IsNull() {
			data.RecordIpv4Gtp = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv4.l2-l3"); value.Exists() {
		if !data.RecordIpv4L2L3.IsNull() {
			data.RecordIpv4L2L3 = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv4L2L3.IsNull() {
			data.RecordIpv4L2L3 = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv4.extended"); value.Exists() {
		if !data.RecordIpv4Extended.IsNull() {
			data.RecordIpv4Extended = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv4Extended.IsNull() {
			data.RecordIpv4Extended = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv6"); value.Exists() {
		if !data.RecordIpv6.IsNull() {
			data.RecordIpv6 = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv6.IsNull() {
			data.RecordIpv6 = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv6.destination"); value.Exists() {
		if !data.RecordIpv6Destination.IsNull() {
			data.RecordIpv6Destination = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv6Destination.IsNull() {
			data.RecordIpv6Destination = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv6.peer-as"); value.Exists() {
		if !data.RecordIpv6PeerAs.IsNull() {
			data.RecordIpv6PeerAs = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv6PeerAs.IsNull() {
			data.RecordIpv6PeerAs = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv6.gtp"); value.Exists() {
		if !data.RecordIpv6Gtp.IsNull() {
			data.RecordIpv6Gtp = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv6Gtp.IsNull() {
			data.RecordIpv6Gtp = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv6.srv6"); value.Exists() {
		if !data.RecordIpv6Srv6.IsNull() {
			data.RecordIpv6Srv6 = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv6Srv6.IsNull() {
			data.RecordIpv6Srv6 = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv6.l2-l3"); value.Exists() {
		if !data.RecordIpv6L2L3.IsNull() {
			data.RecordIpv6L2L3 = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv6L2L3.IsNull() {
			data.RecordIpv6L2L3 = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.ipv6.extended"); value.Exists() {
		if !data.RecordIpv6Extended.IsNull() {
			data.RecordIpv6Extended = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordIpv6Extended.IsNull() {
			data.RecordIpv6Extended = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.mpls"); value.Exists() {
		if !data.RecordMpls.IsNull() {
			data.RecordMpls = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordMpls.IsNull() {
			data.RecordMpls = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.mpls.ipv4-fields"); value.Exists() {
		if !data.RecordMplsIpv4Fields.IsNull() {
			data.RecordMplsIpv4Fields = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordMplsIpv4Fields.IsNull() {
			data.RecordMplsIpv4Fields = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.mpls.ipv6-fields"); value.Exists() {
		if !data.RecordMplsIpv6Fields.IsNull() {
			data.RecordMplsIpv6Fields = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordMplsIpv6Fields.IsNull() {
			data.RecordMplsIpv6Fields = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.mpls.ipv4-ipv6-fields"); value.Exists() {
		if !data.RecordMplsIpv4Ipv6Fields.IsNull() {
			data.RecordMplsIpv4Ipv6Fields = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordMplsIpv4Ipv6Fields.IsNull() {
			data.RecordMplsIpv4Ipv6Fields = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.mpls.labels"); value.Exists() && !data.RecordMplsLabels.IsNull() {
		data.RecordMplsLabels = types.Int64Value(value.Int())
	} else {
		data.RecordMplsLabels = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "record.map-t"); value.Exists() {
		if !data.RecordMapT.IsNull() {
			data.RecordMapT = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordMapT.IsNull() {
			data.RecordMapT = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.sflow"); value.Exists() {
		if !data.RecordSflow.IsNull() {
			data.RecordSflow = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordSflow.IsNull() {
			data.RecordSflow = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.datalink-record"); value.Exists() {
		if !data.RecordDatalinkRecord.IsNull() {
			data.RecordDatalinkRecord = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordDatalinkRecord.IsNull() {
			data.RecordDatalinkRecord = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.default-rtp"); value.Exists() {
		if !data.RecordDefaultRtp.IsNull() {
			data.RecordDefaultRtp = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordDefaultRtp.IsNull() {
			data.RecordDefaultRtp = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "record.default-mdi"); value.Exists() {
		if !data.RecordDefaultMdi.IsNull() {
			data.RecordDefaultMdi = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RecordDefaultMdi.IsNull() {
			data.RecordDefaultMdi = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "cache.entries"); value.Exists() && !data.CacheEntries.IsNull() {
		data.CacheEntries = types.Int64Value(value.Int())
	} else {
		data.CacheEntries = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "cache.timeout.active"); value.Exists() && !data.CacheTimeoutActive.IsNull() {
		data.CacheTimeoutActive = types.Int64Value(value.Int())
	} else {
		data.CacheTimeoutActive = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "cache.timeout.inactive"); value.Exists() && !data.CacheTimeoutInactive.IsNull() {
		data.CacheTimeoutInactive = types.Int64Value(value.Int())
	} else {
		data.CacheTimeoutInactive = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "cache.timeout.update"); value.Exists() && !data.CacheTimeoutUpdate.IsNull() {
		data.CacheTimeoutUpdate = types.Int64Value(value.Int())
	} else {
		data.CacheTimeoutUpdate = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "cache.timeout.rate-limit"); value.Exists() && !data.CacheTimeoutRateLimit.IsNull() {
		data.CacheTimeoutRateLimit = types.Int64Value(value.Int())
	} else {
		data.CacheTimeoutRateLimit = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "cache.permanent"); value.Exists() {
		if !data.CachePermanent.IsNull() {
			data.CachePermanent = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.CachePermanent.IsNull() {
			data.CachePermanent = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "cache.immediate"); value.Exists() {
		if !data.CacheImmediate.IsNull() {
			data.CacheImmediate = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.CacheImmediate.IsNull() {
			data.CacheImmediate = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "hw-cache.timeout.inactive"); value.Exists() && !data.HwCacheTimeoutInactive.IsNull() {
		data.HwCacheTimeoutInactive = types.Int64Value(value.Int())
	} else {
		data.HwCacheTimeoutInactive = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "sflow.options"); value.Exists() {
		if !data.SflowOptions.IsNull() {
			data.SflowOptions = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.SflowOptions.IsNull() {
			data.SflowOptions = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "sflow.options.extended-router"); value.Exists() {
		if !data.SflowOptionsExtendedRouter.IsNull() {
			data.SflowOptionsExtendedRouter = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.SflowOptionsExtendedRouter.IsNull() {
			data.SflowOptionsExtendedRouter = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "sflow.options.extended-gateway"); value.Exists() {
		if !data.SflowOptionsExtendedGateway.IsNull() {
			data.SflowOptionsExtendedGateway = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.SflowOptionsExtendedGateway.IsNull() {
			data.SflowOptionsExtendedGateway = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "sflow.options.extended-ipv4-tunnel-egress"); value.Exists() {
		if !data.SflowOptionsExtendedIpv4TunnelEgress.IsNull() {
			data.SflowOptionsExtendedIpv4TunnelEgress = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.SflowOptionsExtendedIpv4TunnelEgress.IsNull() {
			data.SflowOptionsExtendedIpv4TunnelEgress = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "sflow.options.extended-ipv6-tunnel-egress"); value.Exists() {
		if !data.SflowOptionsExtendedIpv6TunnelEgress.IsNull() {
			data.SflowOptionsExtendedIpv6TunnelEgress = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.SflowOptionsExtendedIpv6TunnelEgress.IsNull() {
			data.SflowOptionsExtendedIpv6TunnelEgress = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "sflow.options.if-counters.polling-interval"); value.Exists() && !data.SflowOptionsIfCountersPollingInterval.IsNull() {
		data.SflowOptionsIfCountersPollingInterval = types.Int64Value(value.Int())
	} else {
		data.SflowOptionsIfCountersPollingInterval = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "sflow.options.sample-header.size"); value.Exists() && !data.SflowOptionsSampleHeaderSize.IsNull() {
		data.SflowOptionsSampleHeaderSize = types.Int64Value(value.Int())
	} else {
		data.SflowOptionsSampleHeaderSize = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "sflow.options.input.ifindex"); value.Exists() && !data.SflowOptionsInputIfindex.IsNull() {
		data.SflowOptionsInputIfindex = types.StringValue(value.String())
	} else {
		data.SflowOptionsInputIfindex = types.StringNull()
	}
	if value := gjson.GetBytes(res, "sflow.options.output.ifindex"); value.Exists() && !data.SflowOptionsOutputIfindex.IsNull() {
		data.SflowOptionsOutputIfindex = types.StringValue(value.String())
	} else {
		data.SflowOptionsOutputIfindex = types.StringNull()
	}
}

// End of section. //template:end updateFromBody

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBodyXML

func (data *FlowMonitorMap) updateFromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/monitor-map-name"); value.Exists() {
		data.Name = types.StringValue(value.String())
	} else if data.Name.IsNull() {
		data.Name = types.StringNull()
	}
	for i := range data.Exporters {
		keys := [...]string{"exporter-name"}
		keyValues := [...]string{data.Exporters[i].Name.ValueString()}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/exporters/exporter").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "exporter-name"); value.Exists() {
			data.Exporters[i].Name = types.StringValue(value.String())
		} else if data.Exporters[i].Name.IsNull() {
			data.Exporters[i].Name = types.StringNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/option/outphysint"); value.Exists() {
		data.OptionOutphysint = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.OptionOutphysint.IsNull() {
			data.OptionOutphysint = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/option/filtered"); value.Exists() {
		data.OptionFiltered = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.OptionFiltered.IsNull() {
			data.OptionFiltered = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/option/bgpattr"); value.Exists() {
		data.OptionBgpattr = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.OptionBgpattr.IsNull() {
			data.OptionBgpattr = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/option/outbundlemember"); value.Exists() {
		data.OptionOutbundlemember = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.OptionOutbundlemember.IsNull() {
			data.OptionOutbundlemember = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4"); value.Exists() {
		data.RecordIpv4 = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv4.IsNull() {
			data.RecordIpv4 = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/destination"); value.Exists() {
		data.RecordIpv4Destination = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv4Destination.IsNull() {
			data.RecordIpv4Destination = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/destination-tos"); value.Exists() {
		data.RecordIpv4DestinationTos = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv4DestinationTos.IsNull() {
			data.RecordIpv4DestinationTos = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/as"); value.Exists() {
		data.RecordIpv4As = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv4As.IsNull() {
			data.RecordIpv4As = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/protocol-port"); value.Exists() {
		data.RecordIpv4ProtocolPort = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv4ProtocolPort.IsNull() {
			data.RecordIpv4ProtocolPort = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/prefix"); value.Exists() {
		data.RecordIpv4Prefix = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv4Prefix.IsNull() {
			data.RecordIpv4Prefix = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/source-prefix"); value.Exists() {
		data.RecordIpv4SourcePrefix = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv4SourcePrefix.IsNull() {
			data.RecordIpv4SourcePrefix = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/destination-prefix"); value.Exists() {
		data.RecordIpv4DestinationPrefix = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv4DestinationPrefix.IsNull() {
			data.RecordIpv4DestinationPrefix = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/as-tos"); value.Exists() {
		data.RecordIpv4AsTos = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv4AsTos.IsNull() {
			data.RecordIpv4AsTos = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/protocol-port-tos"); value.Exists() {
		data.RecordIpv4ProtocolPortTos = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv4ProtocolPortTos.IsNull() {
			data.RecordIpv4ProtocolPortTos = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/prefix-tos"); value.Exists() {
		data.RecordIpv4PrefixTos = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv4PrefixTos.IsNull() {
			data.RecordIpv4PrefixTos = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/source-prefix-tos"); value.Exists() {
		data.RecordIpv4SourcePrefixTos = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv4SourcePrefixTos.IsNull() {
			data.RecordIpv4SourcePrefixTos = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/destination-prefix-tos"); value.Exists() {
		data.RecordIpv4DestinationPrefixTos = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv4DestinationPrefixTos.IsNull() {
			data.RecordIpv4DestinationPrefixTos = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/prefix-port"); value.Exists() {
		data.RecordIpv4PrefixPort = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv4PrefixPort.IsNull() {
			data.RecordIpv4PrefixPort = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/bgp-nexthop-tos"); value.Exists() {
		data.RecordIpv4BgpNexthopTos = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv4BgpNexthopTos.IsNull() {
			data.RecordIpv4BgpNexthopTos = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/peer-as"); value.Exists() {
		data.RecordIpv4PeerAs = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv4PeerAs.IsNull() {
			data.RecordIpv4PeerAs = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/gtp"); value.Exists() {
		data.RecordIpv4Gtp = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv4Gtp.IsNull() {
			data.RecordIpv4Gtp = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/l2-l3"); value.Exists() {
		data.RecordIpv4L2L3 = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv4L2L3.IsNull() {
			data.RecordIpv4L2L3 = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/extended"); value.Exists() {
		data.RecordIpv4Extended = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv4Extended.IsNull() {
			data.RecordIpv4Extended = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv6"); value.Exists() {
		data.RecordIpv6 = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv6.IsNull() {
			data.RecordIpv6 = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv6/destination"); value.Exists() {
		data.RecordIpv6Destination = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv6Destination.IsNull() {
			data.RecordIpv6Destination = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv6/peer-as"); value.Exists() {
		data.RecordIpv6PeerAs = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv6PeerAs.IsNull() {
			data.RecordIpv6PeerAs = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv6/gtp"); value.Exists() {
		data.RecordIpv6Gtp = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv6Gtp.IsNull() {
			data.RecordIpv6Gtp = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv6/srv6"); value.Exists() {
		data.RecordIpv6Srv6 = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv6Srv6.IsNull() {
			data.RecordIpv6Srv6 = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv6/l2-l3"); value.Exists() {
		data.RecordIpv6L2L3 = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv6L2L3.IsNull() {
			data.RecordIpv6L2L3 = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv6/extended"); value.Exists() {
		data.RecordIpv6Extended = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordIpv6Extended.IsNull() {
			data.RecordIpv6Extended = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/mpls"); value.Exists() {
		data.RecordMpls = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordMpls.IsNull() {
			data.RecordMpls = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/mpls/ipv4-fields"); value.Exists() {
		data.RecordMplsIpv4Fields = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordMplsIpv4Fields.IsNull() {
			data.RecordMplsIpv4Fields = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/mpls/ipv6-fields"); value.Exists() {
		data.RecordMplsIpv6Fields = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordMplsIpv6Fields.IsNull() {
			data.RecordMplsIpv6Fields = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/mpls/ipv4-ipv6-fields"); value.Exists() {
		data.RecordMplsIpv4Ipv6Fields = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordMplsIpv4Ipv6Fields.IsNull() {
			data.RecordMplsIpv4Ipv6Fields = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/mpls/labels"); value.Exists() {
		data.RecordMplsLabels = types.Int64Value(value.Int())
	} else if data.RecordMplsLabels.IsNull() {
		data.RecordMplsLabels = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/map-t"); value.Exists() {
		data.RecordMapT = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordMapT.IsNull() {
			data.RecordMapT = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/sflow"); value.Exists() {
		data.RecordSflow = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordSflow.IsNull() {
			data.RecordSflow = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/datalink-record"); value.Exists() {
		data.RecordDatalinkRecord = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordDatalinkRecord.IsNull() {
			data.RecordDatalinkRecord = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/default-rtp"); value.Exists() {
		data.RecordDefaultRtp = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordDefaultRtp.IsNull() {
			data.RecordDefaultRtp = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/default-mdi"); value.Exists() {
		data.RecordDefaultMdi = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RecordDefaultMdi.IsNull() {
			data.RecordDefaultMdi = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/cache/entries"); value.Exists() {
		data.CacheEntries = types.Int64Value(value.Int())
	} else if data.CacheEntries.IsNull() {
		data.CacheEntries = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/cache/timeout/active"); value.Exists() {
		data.CacheTimeoutActive = types.Int64Value(value.Int())
	} else if data.CacheTimeoutActive.IsNull() {
		data.CacheTimeoutActive = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/cache/timeout/inactive"); value.Exists() {
		data.CacheTimeoutInactive = types.Int64Value(value.Int())
	} else if data.CacheTimeoutInactive.IsNull() {
		data.CacheTimeoutInactive = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/cache/timeout/update"); value.Exists() {
		data.CacheTimeoutUpdate = types.Int64Value(value.Int())
	} else if data.CacheTimeoutUpdate.IsNull() {
		data.CacheTimeoutUpdate = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/cache/timeout/rate-limit"); value.Exists() {
		data.CacheTimeoutRateLimit = types.Int64Value(value.Int())
	} else if data.CacheTimeoutRateLimit.IsNull() {
		data.CacheTimeoutRateLimit = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/cache/permanent"); value.Exists() {
		data.CachePermanent = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.CachePermanent.IsNull() {
			data.CachePermanent = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/cache/immediate"); value.Exists() {
		data.CacheImmediate = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.CacheImmediate.IsNull() {
			data.CacheImmediate = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/hw-cache/timeout/inactive"); value.Exists() {
		data.HwCacheTimeoutInactive = types.Int64Value(value.Int())
	} else if data.HwCacheTimeoutInactive.IsNull() {
		data.HwCacheTimeoutInactive = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options"); value.Exists() {
		data.SflowOptions = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.SflowOptions.IsNull() {
			data.SflowOptions = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/extended-router"); value.Exists() {
		data.SflowOptionsExtendedRouter = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.SflowOptionsExtendedRouter.IsNull() {
			data.SflowOptionsExtendedRouter = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/extended-gateway"); value.Exists() {
		data.SflowOptionsExtendedGateway = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.SflowOptionsExtendedGateway.IsNull() {
			data.SflowOptionsExtendedGateway = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/extended-ipv4-tunnel-egress"); value.Exists() {
		data.SflowOptionsExtendedIpv4TunnelEgress = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.SflowOptionsExtendedIpv4TunnelEgress.IsNull() {
			data.SflowOptionsExtendedIpv4TunnelEgress = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/extended-ipv6-tunnel-egress"); value.Exists() {
		data.SflowOptionsExtendedIpv6TunnelEgress = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.SflowOptionsExtendedIpv6TunnelEgress.IsNull() {
			data.SflowOptionsExtendedIpv6TunnelEgress = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/if-counters/polling-interval"); value.Exists() {
		data.SflowOptionsIfCountersPollingInterval = types.Int64Value(value.Int())
	} else if data.SflowOptionsIfCountersPollingInterval.IsNull() {
		data.SflowOptionsIfCountersPollingInterval = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/sample-header/size"); value.Exists() {
		data.SflowOptionsSampleHeaderSize = types.Int64Value(value.Int())
	} else if data.SflowOptionsSampleHeaderSize.IsNull() {
		data.SflowOptionsSampleHeaderSize = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/input/ifindex"); value.Exists() {
		data.SflowOptionsInputIfindex = types.StringValue(value.String())
	} else if data.SflowOptionsInputIfindex.IsNull() {
		data.SflowOptionsInputIfindex = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/output/ifindex"); value.Exists() {
		data.SflowOptionsOutputIfindex = types.StringValue(value.String())
	} else if data.SflowOptionsOutputIfindex.IsNull() {
		data.SflowOptionsOutputIfindex = types.StringNull()
	}
}

// End of section. //template:end updateFromBodyXML

// Section below is generated&owned by "gen/generator.go". //template:begin fromBody

func (data *FlowMonitorMap) fromBody(ctx context.Context, res gjson.Result) {
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	if value := res.Get(prefix + "exporters.exporter"); value.Exists() {
		data.Exporters = make([]FlowMonitorMapExporters, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := FlowMonitorMapExporters{}
			if cValue := v.Get("exporter-name"); cValue.Exists() {
				item.Name = types.StringValue(cValue.String())
			}
			data.Exporters = append(data.Exporters, item)
			return true
		})
	}
	if value := res.Get(prefix + "option.outphysint"); value.Exists() {
		data.OptionOutphysint = types.BoolValue(true)
	} else {
		data.OptionOutphysint = types.BoolNull()
	}
	if value := res.Get(prefix + "option.filtered"); value.Exists() {
		data.OptionFiltered = types.BoolValue(true)
	} else {
		data.OptionFiltered = types.BoolNull()
	}
	if value := res.Get(prefix + "option.bgpattr"); value.Exists() {
		data.OptionBgpattr = types.BoolValue(true)
	} else {
		data.OptionBgpattr = types.BoolNull()
	}
	if value := res.Get(prefix + "option.outbundlemember"); value.Exists() {
		data.OptionOutbundlemember = types.BoolValue(true)
	} else {
		data.OptionOutbundlemember = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4"); value.Exists() {
		data.RecordIpv4 = types.BoolValue(true)
	} else {
		data.RecordIpv4 = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.destination"); value.Exists() {
		data.RecordIpv4Destination = types.BoolValue(true)
	} else {
		data.RecordIpv4Destination = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.destination-tos"); value.Exists() {
		data.RecordIpv4DestinationTos = types.BoolValue(true)
	} else {
		data.RecordIpv4DestinationTos = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.as"); value.Exists() {
		data.RecordIpv4As = types.BoolValue(true)
	} else {
		data.RecordIpv4As = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.protocol-port"); value.Exists() {
		data.RecordIpv4ProtocolPort = types.BoolValue(true)
	} else {
		data.RecordIpv4ProtocolPort = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.prefix"); value.Exists() {
		data.RecordIpv4Prefix = types.BoolValue(true)
	} else {
		data.RecordIpv4Prefix = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.source-prefix"); value.Exists() {
		data.RecordIpv4SourcePrefix = types.BoolValue(true)
	} else {
		data.RecordIpv4SourcePrefix = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.destination-prefix"); value.Exists() {
		data.RecordIpv4DestinationPrefix = types.BoolValue(true)
	} else {
		data.RecordIpv4DestinationPrefix = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.as-tos"); value.Exists() {
		data.RecordIpv4AsTos = types.BoolValue(true)
	} else {
		data.RecordIpv4AsTos = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.protocol-port-tos"); value.Exists() {
		data.RecordIpv4ProtocolPortTos = types.BoolValue(true)
	} else {
		data.RecordIpv4ProtocolPortTos = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.prefix-tos"); value.Exists() {
		data.RecordIpv4PrefixTos = types.BoolValue(true)
	} else {
		data.RecordIpv4PrefixTos = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.source-prefix-tos"); value.Exists() {
		data.RecordIpv4SourcePrefixTos = types.BoolValue(true)
	} else {
		data.RecordIpv4SourcePrefixTos = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.destination-prefix-tos"); value.Exists() {
		data.RecordIpv4DestinationPrefixTos = types.BoolValue(true)
	} else {
		data.RecordIpv4DestinationPrefixTos = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.prefix-port"); value.Exists() {
		data.RecordIpv4PrefixPort = types.BoolValue(true)
	} else {
		data.RecordIpv4PrefixPort = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.bgp-nexthop-tos"); value.Exists() {
		data.RecordIpv4BgpNexthopTos = types.BoolValue(true)
	} else {
		data.RecordIpv4BgpNexthopTos = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.peer-as"); value.Exists() {
		data.RecordIpv4PeerAs = types.BoolValue(true)
	} else {
		data.RecordIpv4PeerAs = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.gtp"); value.Exists() {
		data.RecordIpv4Gtp = types.BoolValue(true)
	} else {
		data.RecordIpv4Gtp = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.l2-l3"); value.Exists() {
		data.RecordIpv4L2L3 = types.BoolValue(true)
	} else {
		data.RecordIpv4L2L3 = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.extended"); value.Exists() {
		data.RecordIpv4Extended = types.BoolValue(true)
	} else {
		data.RecordIpv4Extended = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv6"); value.Exists() {
		data.RecordIpv6 = types.BoolValue(true)
	} else {
		data.RecordIpv6 = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv6.destination"); value.Exists() {
		data.RecordIpv6Destination = types.BoolValue(true)
	} else {
		data.RecordIpv6Destination = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv6.peer-as"); value.Exists() {
		data.RecordIpv6PeerAs = types.BoolValue(true)
	} else {
		data.RecordIpv6PeerAs = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv6.gtp"); value.Exists() {
		data.RecordIpv6Gtp = types.BoolValue(true)
	} else {
		data.RecordIpv6Gtp = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv6.srv6"); value.Exists() {
		data.RecordIpv6Srv6 = types.BoolValue(true)
	} else {
		data.RecordIpv6Srv6 = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv6.l2-l3"); value.Exists() {
		data.RecordIpv6L2L3 = types.BoolValue(true)
	} else {
		data.RecordIpv6L2L3 = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv6.extended"); value.Exists() {
		data.RecordIpv6Extended = types.BoolValue(true)
	} else {
		data.RecordIpv6Extended = types.BoolNull()
	}
	if value := res.Get(prefix + "record.mpls"); value.Exists() {
		data.RecordMpls = types.BoolValue(true)
	} else {
		data.RecordMpls = types.BoolNull()
	}
	if value := res.Get(prefix + "record.mpls.ipv4-fields"); value.Exists() {
		data.RecordMplsIpv4Fields = types.BoolValue(true)
	} else {
		data.RecordMplsIpv4Fields = types.BoolNull()
	}
	if value := res.Get(prefix + "record.mpls.ipv6-fields"); value.Exists() {
		data.RecordMplsIpv6Fields = types.BoolValue(true)
	} else {
		data.RecordMplsIpv6Fields = types.BoolNull()
	}
	if value := res.Get(prefix + "record.mpls.ipv4-ipv6-fields"); value.Exists() {
		data.RecordMplsIpv4Ipv6Fields = types.BoolValue(true)
	} else {
		data.RecordMplsIpv4Ipv6Fields = types.BoolNull()
	}
	if value := res.Get(prefix + "record.mpls.labels"); value.Exists() {
		data.RecordMplsLabels = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "record.map-t"); value.Exists() {
		data.RecordMapT = types.BoolValue(true)
	} else {
		data.RecordMapT = types.BoolNull()
	}
	if value := res.Get(prefix + "record.sflow"); value.Exists() {
		data.RecordSflow = types.BoolValue(true)
	} else {
		data.RecordSflow = types.BoolNull()
	}
	if value := res.Get(prefix + "record.datalink-record"); value.Exists() {
		data.RecordDatalinkRecord = types.BoolValue(true)
	} else {
		data.RecordDatalinkRecord = types.BoolNull()
	}
	if value := res.Get(prefix + "record.default-rtp"); value.Exists() {
		data.RecordDefaultRtp = types.BoolValue(true)
	} else {
		data.RecordDefaultRtp = types.BoolNull()
	}
	if value := res.Get(prefix + "record.default-mdi"); value.Exists() {
		data.RecordDefaultMdi = types.BoolValue(true)
	} else {
		data.RecordDefaultMdi = types.BoolNull()
	}
	if value := res.Get(prefix + "cache.entries"); value.Exists() {
		data.CacheEntries = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "cache.timeout.active"); value.Exists() {
		data.CacheTimeoutActive = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "cache.timeout.inactive"); value.Exists() {
		data.CacheTimeoutInactive = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "cache.timeout.update"); value.Exists() {
		data.CacheTimeoutUpdate = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "cache.timeout.rate-limit"); value.Exists() {
		data.CacheTimeoutRateLimit = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "cache.permanent"); value.Exists() {
		data.CachePermanent = types.BoolValue(true)
	} else {
		data.CachePermanent = types.BoolNull()
	}
	if value := res.Get(prefix + "cache.immediate"); value.Exists() {
		data.CacheImmediate = types.BoolValue(true)
	} else {
		data.CacheImmediate = types.BoolNull()
	}
	if value := res.Get(prefix + "hw-cache.timeout.inactive"); value.Exists() {
		data.HwCacheTimeoutInactive = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "sflow.options"); value.Exists() {
		data.SflowOptions = types.BoolValue(true)
	} else {
		data.SflowOptions = types.BoolNull()
	}
	if value := res.Get(prefix + "sflow.options.extended-router"); value.Exists() {
		data.SflowOptionsExtendedRouter = types.BoolValue(true)
	} else {
		data.SflowOptionsExtendedRouter = types.BoolNull()
	}
	if value := res.Get(prefix + "sflow.options.extended-gateway"); value.Exists() {
		data.SflowOptionsExtendedGateway = types.BoolValue(true)
	} else {
		data.SflowOptionsExtendedGateway = types.BoolNull()
	}
	if value := res.Get(prefix + "sflow.options.extended-ipv4-tunnel-egress"); value.Exists() {
		data.SflowOptionsExtendedIpv4TunnelEgress = types.BoolValue(true)
	} else {
		data.SflowOptionsExtendedIpv4TunnelEgress = types.BoolNull()
	}
	if value := res.Get(prefix + "sflow.options.extended-ipv6-tunnel-egress"); value.Exists() {
		data.SflowOptionsExtendedIpv6TunnelEgress = types.BoolValue(true)
	} else {
		data.SflowOptionsExtendedIpv6TunnelEgress = types.BoolNull()
	}
	if value := res.Get(prefix + "sflow.options.if-counters.polling-interval"); value.Exists() {
		data.SflowOptionsIfCountersPollingInterval = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "sflow.options.sample-header.size"); value.Exists() {
		data.SflowOptionsSampleHeaderSize = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "sflow.options.input.ifindex"); value.Exists() {
		data.SflowOptionsInputIfindex = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "sflow.options.output.ifindex"); value.Exists() {
		data.SflowOptionsOutputIfindex = types.StringValue(value.String())
	}
}

// End of section. //template:end fromBody

// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyData

func (data *FlowMonitorMapData) fromBody(ctx context.Context, res gjson.Result) {
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	if value := res.Get(prefix + "exporters.exporter"); value.Exists() {
		data.Exporters = make([]FlowMonitorMapExporters, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := FlowMonitorMapExporters{}
			if cValue := v.Get("exporter-name"); cValue.Exists() {
				item.Name = types.StringValue(cValue.String())
			}
			data.Exporters = append(data.Exporters, item)
			return true
		})
	}
	if value := res.Get(prefix + "option.outphysint"); value.Exists() {
		data.OptionOutphysint = types.BoolValue(true)
	} else {
		data.OptionOutphysint = types.BoolNull()
	}
	if value := res.Get(prefix + "option.filtered"); value.Exists() {
		data.OptionFiltered = types.BoolValue(true)
	} else {
		data.OptionFiltered = types.BoolNull()
	}
	if value := res.Get(prefix + "option.bgpattr"); value.Exists() {
		data.OptionBgpattr = types.BoolValue(true)
	} else {
		data.OptionBgpattr = types.BoolNull()
	}
	if value := res.Get(prefix + "option.outbundlemember"); value.Exists() {
		data.OptionOutbundlemember = types.BoolValue(true)
	} else {
		data.OptionOutbundlemember = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4"); value.Exists() {
		data.RecordIpv4 = types.BoolValue(true)
	} else {
		data.RecordIpv4 = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.destination"); value.Exists() {
		data.RecordIpv4Destination = types.BoolValue(true)
	} else {
		data.RecordIpv4Destination = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.destination-tos"); value.Exists() {
		data.RecordIpv4DestinationTos = types.BoolValue(true)
	} else {
		data.RecordIpv4DestinationTos = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.as"); value.Exists() {
		data.RecordIpv4As = types.BoolValue(true)
	} else {
		data.RecordIpv4As = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.protocol-port"); value.Exists() {
		data.RecordIpv4ProtocolPort = types.BoolValue(true)
	} else {
		data.RecordIpv4ProtocolPort = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.prefix"); value.Exists() {
		data.RecordIpv4Prefix = types.BoolValue(true)
	} else {
		data.RecordIpv4Prefix = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.source-prefix"); value.Exists() {
		data.RecordIpv4SourcePrefix = types.BoolValue(true)
	} else {
		data.RecordIpv4SourcePrefix = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.destination-prefix"); value.Exists() {
		data.RecordIpv4DestinationPrefix = types.BoolValue(true)
	} else {
		data.RecordIpv4DestinationPrefix = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.as-tos"); value.Exists() {
		data.RecordIpv4AsTos = types.BoolValue(true)
	} else {
		data.RecordIpv4AsTos = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.protocol-port-tos"); value.Exists() {
		data.RecordIpv4ProtocolPortTos = types.BoolValue(true)
	} else {
		data.RecordIpv4ProtocolPortTos = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.prefix-tos"); value.Exists() {
		data.RecordIpv4PrefixTos = types.BoolValue(true)
	} else {
		data.RecordIpv4PrefixTos = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.source-prefix-tos"); value.Exists() {
		data.RecordIpv4SourcePrefixTos = types.BoolValue(true)
	} else {
		data.RecordIpv4SourcePrefixTos = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.destination-prefix-tos"); value.Exists() {
		data.RecordIpv4DestinationPrefixTos = types.BoolValue(true)
	} else {
		data.RecordIpv4DestinationPrefixTos = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.prefix-port"); value.Exists() {
		data.RecordIpv4PrefixPort = types.BoolValue(true)
	} else {
		data.RecordIpv4PrefixPort = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.bgp-nexthop-tos"); value.Exists() {
		data.RecordIpv4BgpNexthopTos = types.BoolValue(true)
	} else {
		data.RecordIpv4BgpNexthopTos = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.peer-as"); value.Exists() {
		data.RecordIpv4PeerAs = types.BoolValue(true)
	} else {
		data.RecordIpv4PeerAs = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.gtp"); value.Exists() {
		data.RecordIpv4Gtp = types.BoolValue(true)
	} else {
		data.RecordIpv4Gtp = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.l2-l3"); value.Exists() {
		data.RecordIpv4L2L3 = types.BoolValue(true)
	} else {
		data.RecordIpv4L2L3 = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv4.extended"); value.Exists() {
		data.RecordIpv4Extended = types.BoolValue(true)
	} else {
		data.RecordIpv4Extended = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv6"); value.Exists() {
		data.RecordIpv6 = types.BoolValue(true)
	} else {
		data.RecordIpv6 = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv6.destination"); value.Exists() {
		data.RecordIpv6Destination = types.BoolValue(true)
	} else {
		data.RecordIpv6Destination = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv6.peer-as"); value.Exists() {
		data.RecordIpv6PeerAs = types.BoolValue(true)
	} else {
		data.RecordIpv6PeerAs = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv6.gtp"); value.Exists() {
		data.RecordIpv6Gtp = types.BoolValue(true)
	} else {
		data.RecordIpv6Gtp = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv6.srv6"); value.Exists() {
		data.RecordIpv6Srv6 = types.BoolValue(true)
	} else {
		data.RecordIpv6Srv6 = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv6.l2-l3"); value.Exists() {
		data.RecordIpv6L2L3 = types.BoolValue(true)
	} else {
		data.RecordIpv6L2L3 = types.BoolNull()
	}
	if value := res.Get(prefix + "record.ipv6.extended"); value.Exists() {
		data.RecordIpv6Extended = types.BoolValue(true)
	} else {
		data.RecordIpv6Extended = types.BoolNull()
	}
	if value := res.Get(prefix + "record.mpls"); value.Exists() {
		data.RecordMpls = types.BoolValue(true)
	} else {
		data.RecordMpls = types.BoolNull()
	}
	if value := res.Get(prefix + "record.mpls.ipv4-fields"); value.Exists() {
		data.RecordMplsIpv4Fields = types.BoolValue(true)
	} else {
		data.RecordMplsIpv4Fields = types.BoolNull()
	}
	if value := res.Get(prefix + "record.mpls.ipv6-fields"); value.Exists() {
		data.RecordMplsIpv6Fields = types.BoolValue(true)
	} else {
		data.RecordMplsIpv6Fields = types.BoolNull()
	}
	if value := res.Get(prefix + "record.mpls.ipv4-ipv6-fields"); value.Exists() {
		data.RecordMplsIpv4Ipv6Fields = types.BoolValue(true)
	} else {
		data.RecordMplsIpv4Ipv6Fields = types.BoolNull()
	}
	if value := res.Get(prefix + "record.mpls.labels"); value.Exists() {
		data.RecordMplsLabels = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "record.map-t"); value.Exists() {
		data.RecordMapT = types.BoolValue(true)
	} else {
		data.RecordMapT = types.BoolNull()
	}
	if value := res.Get(prefix + "record.sflow"); value.Exists() {
		data.RecordSflow = types.BoolValue(true)
	} else {
		data.RecordSflow = types.BoolNull()
	}
	if value := res.Get(prefix + "record.datalink-record"); value.Exists() {
		data.RecordDatalinkRecord = types.BoolValue(true)
	} else {
		data.RecordDatalinkRecord = types.BoolNull()
	}
	if value := res.Get(prefix + "record.default-rtp"); value.Exists() {
		data.RecordDefaultRtp = types.BoolValue(true)
	} else {
		data.RecordDefaultRtp = types.BoolNull()
	}
	if value := res.Get(prefix + "record.default-mdi"); value.Exists() {
		data.RecordDefaultMdi = types.BoolValue(true)
	} else {
		data.RecordDefaultMdi = types.BoolNull()
	}
	if value := res.Get(prefix + "cache.entries"); value.Exists() {
		data.CacheEntries = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "cache.timeout.active"); value.Exists() {
		data.CacheTimeoutActive = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "cache.timeout.inactive"); value.Exists() {
		data.CacheTimeoutInactive = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "cache.timeout.update"); value.Exists() {
		data.CacheTimeoutUpdate = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "cache.timeout.rate-limit"); value.Exists() {
		data.CacheTimeoutRateLimit = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "cache.permanent"); value.Exists() {
		data.CachePermanent = types.BoolValue(true)
	} else {
		data.CachePermanent = types.BoolNull()
	}
	if value := res.Get(prefix + "cache.immediate"); value.Exists() {
		data.CacheImmediate = types.BoolValue(true)
	} else {
		data.CacheImmediate = types.BoolNull()
	}
	if value := res.Get(prefix + "hw-cache.timeout.inactive"); value.Exists() {
		data.HwCacheTimeoutInactive = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "sflow.options"); value.Exists() {
		data.SflowOptions = types.BoolValue(true)
	} else {
		data.SflowOptions = types.BoolNull()
	}
	if value := res.Get(prefix + "sflow.options.extended-router"); value.Exists() {
		data.SflowOptionsExtendedRouter = types.BoolValue(true)
	} else {
		data.SflowOptionsExtendedRouter = types.BoolNull()
	}
	if value := res.Get(prefix + "sflow.options.extended-gateway"); value.Exists() {
		data.SflowOptionsExtendedGateway = types.BoolValue(true)
	} else {
		data.SflowOptionsExtendedGateway = types.BoolNull()
	}
	if value := res.Get(prefix + "sflow.options.extended-ipv4-tunnel-egress"); value.Exists() {
		data.SflowOptionsExtendedIpv4TunnelEgress = types.BoolValue(true)
	} else {
		data.SflowOptionsExtendedIpv4TunnelEgress = types.BoolNull()
	}
	if value := res.Get(prefix + "sflow.options.extended-ipv6-tunnel-egress"); value.Exists() {
		data.SflowOptionsExtendedIpv6TunnelEgress = types.BoolValue(true)
	} else {
		data.SflowOptionsExtendedIpv6TunnelEgress = types.BoolNull()
	}
	if value := res.Get(prefix + "sflow.options.if-counters.polling-interval"); value.Exists() {
		data.SflowOptionsIfCountersPollingInterval = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "sflow.options.sample-header.size"); value.Exists() {
		data.SflowOptionsSampleHeaderSize = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "sflow.options.input.ifindex"); value.Exists() {
		data.SflowOptionsInputIfindex = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "sflow.options.output.ifindex"); value.Exists() {
		data.SflowOptionsOutputIfindex = types.StringValue(value.String())
	}
}

// End of section. //template:end fromBodyData

// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyXML

func (data *FlowMonitorMap) fromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/exporters/exporter"); value.Exists() {
		data.Exporters = make([]FlowMonitorMapExporters, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := FlowMonitorMapExporters{}
			if cValue := helpers.GetFromXPath(v, "exporter-name"); cValue.Exists() {
				item.Name = types.StringValue(cValue.String())
			}
			data.Exporters = append(data.Exporters, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/option/outphysint"); value.Exists() {
		data.OptionOutphysint = types.BoolValue(true)
	} else {
		data.OptionOutphysint = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/option/filtered"); value.Exists() {
		data.OptionFiltered = types.BoolValue(true)
	} else {
		data.OptionFiltered = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/option/bgpattr"); value.Exists() {
		data.OptionBgpattr = types.BoolValue(true)
	} else {
		data.OptionBgpattr = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/option/outbundlemember"); value.Exists() {
		data.OptionOutbundlemember = types.BoolValue(true)
	} else {
		data.OptionOutbundlemember = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4"); value.Exists() {
		data.RecordIpv4 = types.BoolValue(true)
	} else {
		data.RecordIpv4 = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/destination"); value.Exists() {
		data.RecordIpv4Destination = types.BoolValue(true)
	} else {
		data.RecordIpv4Destination = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/destination-tos"); value.Exists() {
		data.RecordIpv4DestinationTos = types.BoolValue(true)
	} else {
		data.RecordIpv4DestinationTos = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/as"); value.Exists() {
		data.RecordIpv4As = types.BoolValue(true)
	} else {
		data.RecordIpv4As = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/protocol-port"); value.Exists() {
		data.RecordIpv4ProtocolPort = types.BoolValue(true)
	} else {
		data.RecordIpv4ProtocolPort = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/prefix"); value.Exists() {
		data.RecordIpv4Prefix = types.BoolValue(true)
	} else {
		data.RecordIpv4Prefix = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/source-prefix"); value.Exists() {
		data.RecordIpv4SourcePrefix = types.BoolValue(true)
	} else {
		data.RecordIpv4SourcePrefix = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/destination-prefix"); value.Exists() {
		data.RecordIpv4DestinationPrefix = types.BoolValue(true)
	} else {
		data.RecordIpv4DestinationPrefix = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/as-tos"); value.Exists() {
		data.RecordIpv4AsTos = types.BoolValue(true)
	} else {
		data.RecordIpv4AsTos = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/protocol-port-tos"); value.Exists() {
		data.RecordIpv4ProtocolPortTos = types.BoolValue(true)
	} else {
		data.RecordIpv4ProtocolPortTos = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/prefix-tos"); value.Exists() {
		data.RecordIpv4PrefixTos = types.BoolValue(true)
	} else {
		data.RecordIpv4PrefixTos = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/source-prefix-tos"); value.Exists() {
		data.RecordIpv4SourcePrefixTos = types.BoolValue(true)
	} else {
		data.RecordIpv4SourcePrefixTos = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/destination-prefix-tos"); value.Exists() {
		data.RecordIpv4DestinationPrefixTos = types.BoolValue(true)
	} else {
		data.RecordIpv4DestinationPrefixTos = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/prefix-port"); value.Exists() {
		data.RecordIpv4PrefixPort = types.BoolValue(true)
	} else {
		data.RecordIpv4PrefixPort = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/bgp-nexthop-tos"); value.Exists() {
		data.RecordIpv4BgpNexthopTos = types.BoolValue(true)
	} else {
		data.RecordIpv4BgpNexthopTos = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/peer-as"); value.Exists() {
		data.RecordIpv4PeerAs = types.BoolValue(true)
	} else {
		data.RecordIpv4PeerAs = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/gtp"); value.Exists() {
		data.RecordIpv4Gtp = types.BoolValue(true)
	} else {
		data.RecordIpv4Gtp = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/l2-l3"); value.Exists() {
		data.RecordIpv4L2L3 = types.BoolValue(true)
	} else {
		data.RecordIpv4L2L3 = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/extended"); value.Exists() {
		data.RecordIpv4Extended = types.BoolValue(true)
	} else {
		data.RecordIpv4Extended = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv6"); value.Exists() {
		data.RecordIpv6 = types.BoolValue(true)
	} else {
		data.RecordIpv6 = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv6/destination"); value.Exists() {
		data.RecordIpv6Destination = types.BoolValue(true)
	} else {
		data.RecordIpv6Destination = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv6/peer-as"); value.Exists() {
		data.RecordIpv6PeerAs = types.BoolValue(true)
	} else {
		data.RecordIpv6PeerAs = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv6/gtp"); value.Exists() {
		data.RecordIpv6Gtp = types.BoolValue(true)
	} else {
		data.RecordIpv6Gtp = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv6/srv6"); value.Exists() {
		data.RecordIpv6Srv6 = types.BoolValue(true)
	} else {
		data.RecordIpv6Srv6 = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv6/l2-l3"); value.Exists() {
		data.RecordIpv6L2L3 = types.BoolValue(true)
	} else {
		data.RecordIpv6L2L3 = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv6/extended"); value.Exists() {
		data.RecordIpv6Extended = types.BoolValue(true)
	} else {
		data.RecordIpv6Extended = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/mpls"); value.Exists() {
		data.RecordMpls = types.BoolValue(true)
	} else {
		data.RecordMpls = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/mpls/ipv4-fields"); value.Exists() {
		data.RecordMplsIpv4Fields = types.BoolValue(true)
	} else {
		data.RecordMplsIpv4Fields = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/mpls/ipv6-fields"); value.Exists() {
		data.RecordMplsIpv6Fields = types.BoolValue(true)
	} else {
		data.RecordMplsIpv6Fields = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/mpls/ipv4-ipv6-fields"); value.Exists() {
		data.RecordMplsIpv4Ipv6Fields = types.BoolValue(true)
	} else {
		data.RecordMplsIpv4Ipv6Fields = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/mpls/labels"); value.Exists() {
		data.RecordMplsLabels = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/map-t"); value.Exists() {
		data.RecordMapT = types.BoolValue(true)
	} else {
		data.RecordMapT = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/sflow"); value.Exists() {
		data.RecordSflow = types.BoolValue(true)
	} else {
		data.RecordSflow = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/datalink-record"); value.Exists() {
		data.RecordDatalinkRecord = types.BoolValue(true)
	} else {
		data.RecordDatalinkRecord = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/default-rtp"); value.Exists() {
		data.RecordDefaultRtp = types.BoolValue(true)
	} else {
		data.RecordDefaultRtp = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/default-mdi"); value.Exists() {
		data.RecordDefaultMdi = types.BoolValue(true)
	} else {
		data.RecordDefaultMdi = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/cache/entries"); value.Exists() {
		data.CacheEntries = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/cache/timeout/active"); value.Exists() {
		data.CacheTimeoutActive = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/cache/timeout/inactive"); value.Exists() {
		data.CacheTimeoutInactive = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/cache/timeout/update"); value.Exists() {
		data.CacheTimeoutUpdate = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/cache/timeout/rate-limit"); value.Exists() {
		data.CacheTimeoutRateLimit = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/cache/permanent"); value.Exists() {
		data.CachePermanent = types.BoolValue(true)
	} else {
		data.CachePermanent = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/cache/immediate"); value.Exists() {
		data.CacheImmediate = types.BoolValue(true)
	} else {
		data.CacheImmediate = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/hw-cache/timeout/inactive"); value.Exists() {
		data.HwCacheTimeoutInactive = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options"); value.Exists() {
		data.SflowOptions = types.BoolValue(true)
	} else {
		data.SflowOptions = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/extended-router"); value.Exists() {
		data.SflowOptionsExtendedRouter = types.BoolValue(true)
	} else {
		data.SflowOptionsExtendedRouter = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/extended-gateway"); value.Exists() {
		data.SflowOptionsExtendedGateway = types.BoolValue(true)
	} else {
		data.SflowOptionsExtendedGateway = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/extended-ipv4-tunnel-egress"); value.Exists() {
		data.SflowOptionsExtendedIpv4TunnelEgress = types.BoolValue(true)
	} else {
		data.SflowOptionsExtendedIpv4TunnelEgress = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/extended-ipv6-tunnel-egress"); value.Exists() {
		data.SflowOptionsExtendedIpv6TunnelEgress = types.BoolValue(true)
	} else {
		data.SflowOptionsExtendedIpv6TunnelEgress = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/if-counters/polling-interval"); value.Exists() {
		data.SflowOptionsIfCountersPollingInterval = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/sample-header/size"); value.Exists() {
		data.SflowOptionsSampleHeaderSize = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/input/ifindex"); value.Exists() {
		data.SflowOptionsInputIfindex = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/output/ifindex"); value.Exists() {
		data.SflowOptionsOutputIfindex = types.StringValue(value.String())
	}
}

// End of section. //template:end fromBodyXML

// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyDataXML

func (data *FlowMonitorMapData) fromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/exporters/exporter"); value.Exists() {
		data.Exporters = make([]FlowMonitorMapExporters, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := FlowMonitorMapExporters{}
			if cValue := helpers.GetFromXPath(v, "exporter-name"); cValue.Exists() {
				item.Name = types.StringValue(cValue.String())
			}
			data.Exporters = append(data.Exporters, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/option/outphysint"); value.Exists() {
		data.OptionOutphysint = types.BoolValue(true)
	} else {
		data.OptionOutphysint = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/option/filtered"); value.Exists() {
		data.OptionFiltered = types.BoolValue(true)
	} else {
		data.OptionFiltered = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/option/bgpattr"); value.Exists() {
		data.OptionBgpattr = types.BoolValue(true)
	} else {
		data.OptionBgpattr = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/option/outbundlemember"); value.Exists() {
		data.OptionOutbundlemember = types.BoolValue(true)
	} else {
		data.OptionOutbundlemember = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4"); value.Exists() {
		data.RecordIpv4 = types.BoolValue(true)
	} else {
		data.RecordIpv4 = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/destination"); value.Exists() {
		data.RecordIpv4Destination = types.BoolValue(true)
	} else {
		data.RecordIpv4Destination = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/destination-tos"); value.Exists() {
		data.RecordIpv4DestinationTos = types.BoolValue(true)
	} else {
		data.RecordIpv4DestinationTos = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/as"); value.Exists() {
		data.RecordIpv4As = types.BoolValue(true)
	} else {
		data.RecordIpv4As = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/protocol-port"); value.Exists() {
		data.RecordIpv4ProtocolPort = types.BoolValue(true)
	} else {
		data.RecordIpv4ProtocolPort = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/prefix"); value.Exists() {
		data.RecordIpv4Prefix = types.BoolValue(true)
	} else {
		data.RecordIpv4Prefix = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/source-prefix"); value.Exists() {
		data.RecordIpv4SourcePrefix = types.BoolValue(true)
	} else {
		data.RecordIpv4SourcePrefix = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/destination-prefix"); value.Exists() {
		data.RecordIpv4DestinationPrefix = types.BoolValue(true)
	} else {
		data.RecordIpv4DestinationPrefix = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/as-tos"); value.Exists() {
		data.RecordIpv4AsTos = types.BoolValue(true)
	} else {
		data.RecordIpv4AsTos = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/protocol-port-tos"); value.Exists() {
		data.RecordIpv4ProtocolPortTos = types.BoolValue(true)
	} else {
		data.RecordIpv4ProtocolPortTos = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/prefix-tos"); value.Exists() {
		data.RecordIpv4PrefixTos = types.BoolValue(true)
	} else {
		data.RecordIpv4PrefixTos = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/source-prefix-tos"); value.Exists() {
		data.RecordIpv4SourcePrefixTos = types.BoolValue(true)
	} else {
		data.RecordIpv4SourcePrefixTos = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/destination-prefix-tos"); value.Exists() {
		data.RecordIpv4DestinationPrefixTos = types.BoolValue(true)
	} else {
		data.RecordIpv4DestinationPrefixTos = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/prefix-port"); value.Exists() {
		data.RecordIpv4PrefixPort = types.BoolValue(true)
	} else {
		data.RecordIpv4PrefixPort = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/bgp-nexthop-tos"); value.Exists() {
		data.RecordIpv4BgpNexthopTos = types.BoolValue(true)
	} else {
		data.RecordIpv4BgpNexthopTos = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/peer-as"); value.Exists() {
		data.RecordIpv4PeerAs = types.BoolValue(true)
	} else {
		data.RecordIpv4PeerAs = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/gtp"); value.Exists() {
		data.RecordIpv4Gtp = types.BoolValue(true)
	} else {
		data.RecordIpv4Gtp = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/l2-l3"); value.Exists() {
		data.RecordIpv4L2L3 = types.BoolValue(true)
	} else {
		data.RecordIpv4L2L3 = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv4/extended"); value.Exists() {
		data.RecordIpv4Extended = types.BoolValue(true)
	} else {
		data.RecordIpv4Extended = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv6"); value.Exists() {
		data.RecordIpv6 = types.BoolValue(true)
	} else {
		data.RecordIpv6 = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv6/destination"); value.Exists() {
		data.RecordIpv6Destination = types.BoolValue(true)
	} else {
		data.RecordIpv6Destination = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv6/peer-as"); value.Exists() {
		data.RecordIpv6PeerAs = types.BoolValue(true)
	} else {
		data.RecordIpv6PeerAs = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv6/gtp"); value.Exists() {
		data.RecordIpv6Gtp = types.BoolValue(true)
	} else {
		data.RecordIpv6Gtp = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv6/srv6"); value.Exists() {
		data.RecordIpv6Srv6 = types.BoolValue(true)
	} else {
		data.RecordIpv6Srv6 = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv6/l2-l3"); value.Exists() {
		data.RecordIpv6L2L3 = types.BoolValue(true)
	} else {
		data.RecordIpv6L2L3 = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/ipv6/extended"); value.Exists() {
		data.RecordIpv6Extended = types.BoolValue(true)
	} else {
		data.RecordIpv6Extended = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/mpls"); value.Exists() {
		data.RecordMpls = types.BoolValue(true)
	} else {
		data.RecordMpls = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/mpls/ipv4-fields"); value.Exists() {
		data.RecordMplsIpv4Fields = types.BoolValue(true)
	} else {
		data.RecordMplsIpv4Fields = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/mpls/ipv6-fields"); value.Exists() {
		data.RecordMplsIpv6Fields = types.BoolValue(true)
	} else {
		data.RecordMplsIpv6Fields = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/mpls/ipv4-ipv6-fields"); value.Exists() {
		data.RecordMplsIpv4Ipv6Fields = types.BoolValue(true)
	} else {
		data.RecordMplsIpv4Ipv6Fields = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/mpls/labels"); value.Exists() {
		data.RecordMplsLabels = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/map-t"); value.Exists() {
		data.RecordMapT = types.BoolValue(true)
	} else {
		data.RecordMapT = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/sflow"); value.Exists() {
		data.RecordSflow = types.BoolValue(true)
	} else {
		data.RecordSflow = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/datalink-record"); value.Exists() {
		data.RecordDatalinkRecord = types.BoolValue(true)
	} else {
		data.RecordDatalinkRecord = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/default-rtp"); value.Exists() {
		data.RecordDefaultRtp = types.BoolValue(true)
	} else {
		data.RecordDefaultRtp = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/record/default-mdi"); value.Exists() {
		data.RecordDefaultMdi = types.BoolValue(true)
	} else {
		data.RecordDefaultMdi = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/cache/entries"); value.Exists() {
		data.CacheEntries = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/cache/timeout/active"); value.Exists() {
		data.CacheTimeoutActive = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/cache/timeout/inactive"); value.Exists() {
		data.CacheTimeoutInactive = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/cache/timeout/update"); value.Exists() {
		data.CacheTimeoutUpdate = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/cache/timeout/rate-limit"); value.Exists() {
		data.CacheTimeoutRateLimit = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/cache/permanent"); value.Exists() {
		data.CachePermanent = types.BoolValue(true)
	} else {
		data.CachePermanent = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/cache/immediate"); value.Exists() {
		data.CacheImmediate = types.BoolValue(true)
	} else {
		data.CacheImmediate = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/hw-cache/timeout/inactive"); value.Exists() {
		data.HwCacheTimeoutInactive = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options"); value.Exists() {
		data.SflowOptions = types.BoolValue(true)
	} else {
		data.SflowOptions = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/extended-router"); value.Exists() {
		data.SflowOptionsExtendedRouter = types.BoolValue(true)
	} else {
		data.SflowOptionsExtendedRouter = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/extended-gateway"); value.Exists() {
		data.SflowOptionsExtendedGateway = types.BoolValue(true)
	} else {
		data.SflowOptionsExtendedGateway = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/extended-ipv4-tunnel-egress"); value.Exists() {
		data.SflowOptionsExtendedIpv4TunnelEgress = types.BoolValue(true)
	} else {
		data.SflowOptionsExtendedIpv4TunnelEgress = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/extended-ipv6-tunnel-egress"); value.Exists() {
		data.SflowOptionsExtendedIpv6TunnelEgress = types.BoolValue(true)
	} else {
		data.SflowOptionsExtendedIpv6TunnelEgress = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/if-counters/polling-interval"); value.Exists() {
		data.SflowOptionsIfCountersPollingInterval = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/sample-header/size"); value.Exists() {
		data.SflowOptionsSampleHeaderSize = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/input/ifindex"); value.Exists() {
		data.SflowOptionsInputIfindex = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sflow/options/output/ifindex"); value.Exists() {
		data.SflowOptionsOutputIfindex = types.StringValue(value.String())
	}
}

// End of section. //template:end fromBodyDataXML

// Section below is generated&owned by "gen/generator.go". //template:begin getDeletedItems

func (data *FlowMonitorMap) getDeletedItems(ctx context.Context, state FlowMonitorMap) []string {
	deletedItems := make([]string, 0)
	if !state.SflowOptionsOutputIfindex.IsNull() && data.SflowOptionsOutputIfindex.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/sflow/options/output/ifindex", state.getPath()))
	}
	if !state.SflowOptionsInputIfindex.IsNull() && data.SflowOptionsInputIfindex.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/sflow/options/input/ifindex", state.getPath()))
	}
	if !state.SflowOptionsSampleHeaderSize.IsNull() && data.SflowOptionsSampleHeaderSize.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/sflow/options/sample-header/size", state.getPath()))
	}
	if !state.SflowOptionsIfCountersPollingInterval.IsNull() && data.SflowOptionsIfCountersPollingInterval.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/sflow/options/if-counters/polling-interval", state.getPath()))
	}
	if !state.SflowOptionsExtendedIpv6TunnelEgress.IsNull() && data.SflowOptionsExtendedIpv6TunnelEgress.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/sflow/options/extended-ipv6-tunnel-egress", state.getPath()))
	}
	if !state.SflowOptionsExtendedIpv4TunnelEgress.IsNull() && data.SflowOptionsExtendedIpv4TunnelEgress.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/sflow/options/extended-ipv4-tunnel-egress", state.getPath()))
	}
	if !state.SflowOptionsExtendedGateway.IsNull() && data.SflowOptionsExtendedGateway.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/sflow/options/extended-gateway", state.getPath()))
	}
	if !state.SflowOptionsExtendedRouter.IsNull() && data.SflowOptionsExtendedRouter.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/sflow/options/extended-router", state.getPath()))
	}
	if !state.SflowOptions.IsNull() && data.SflowOptions.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/sflow/options", state.getPath()))
	}
	if !state.HwCacheTimeoutInactive.IsNull() && data.HwCacheTimeoutInactive.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/hw-cache/timeout/inactive", state.getPath()))
	}
	if !state.CacheImmediate.IsNull() && data.CacheImmediate.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/cache/immediate", state.getPath()))
	}
	if !state.CachePermanent.IsNull() && data.CachePermanent.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/cache/permanent", state.getPath()))
	}
	if !state.CacheTimeoutRateLimit.IsNull() && data.CacheTimeoutRateLimit.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/cache/timeout/rate-limit", state.getPath()))
	}
	if !state.CacheTimeoutUpdate.IsNull() && data.CacheTimeoutUpdate.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/cache/timeout/update", state.getPath()))
	}
	if !state.CacheTimeoutInactive.IsNull() && data.CacheTimeoutInactive.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/cache/timeout/inactive", state.getPath()))
	}
	if !state.CacheTimeoutActive.IsNull() && data.CacheTimeoutActive.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/cache/timeout/active", state.getPath()))
	}
	if !state.CacheEntries.IsNull() && data.CacheEntries.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/cache/entries", state.getPath()))
	}
	if !state.RecordDefaultMdi.IsNull() && data.RecordDefaultMdi.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/default-mdi", state.getPath()))
	}
	if !state.RecordDefaultRtp.IsNull() && data.RecordDefaultRtp.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/default-rtp", state.getPath()))
	}
	if !state.RecordDatalinkRecord.IsNull() && data.RecordDatalinkRecord.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/datalink-record", state.getPath()))
	}
	if !state.RecordSflow.IsNull() && data.RecordSflow.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/sflow", state.getPath()))
	}
	if !state.RecordMapT.IsNull() && data.RecordMapT.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/map-t", state.getPath()))
	}
	if !state.RecordMplsLabels.IsNull() && data.RecordMplsLabels.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/mpls/labels", state.getPath()))
	}
	if !state.RecordMplsIpv4Ipv6Fields.IsNull() && data.RecordMplsIpv4Ipv6Fields.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/mpls/ipv4-ipv6-fields", state.getPath()))
	}
	if !state.RecordMplsIpv6Fields.IsNull() && data.RecordMplsIpv6Fields.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/mpls/ipv6-fields", state.getPath()))
	}
	if !state.RecordMplsIpv4Fields.IsNull() && data.RecordMplsIpv4Fields.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/mpls/ipv4-fields", state.getPath()))
	}
	if !state.RecordMpls.IsNull() && data.RecordMpls.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/mpls", state.getPath()))
	}
	if !state.RecordIpv6Extended.IsNull() && data.RecordIpv6Extended.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv6/extended", state.getPath()))
	}
	if !state.RecordIpv6L2L3.IsNull() && data.RecordIpv6L2L3.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv6/l2-l3", state.getPath()))
	}
	if !state.RecordIpv6Srv6.IsNull() && data.RecordIpv6Srv6.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv6/srv6", state.getPath()))
	}
	if !state.RecordIpv6Gtp.IsNull() && data.RecordIpv6Gtp.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv6/gtp", state.getPath()))
	}
	if !state.RecordIpv6PeerAs.IsNull() && data.RecordIpv6PeerAs.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv6/peer-as", state.getPath()))
	}
	if !state.RecordIpv6Destination.IsNull() && data.RecordIpv6Destination.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv6/destination", state.getPath()))
	}
	if !state.RecordIpv6.IsNull() && data.RecordIpv6.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv6", state.getPath()))
	}
	if !state.RecordIpv4Extended.IsNull() && data.RecordIpv4Extended.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv4/extended", state.getPath()))
	}
	if !state.RecordIpv4L2L3.IsNull() && data.RecordIpv4L2L3.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv4/l2-l3", state.getPath()))
	}
	if !state.RecordIpv4Gtp.IsNull() && data.RecordIpv4Gtp.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv4/gtp", state.getPath()))
	}
	if !state.RecordIpv4PeerAs.IsNull() && data.RecordIpv4PeerAs.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv4/peer-as", state.getPath()))
	}
	if !state.RecordIpv4BgpNexthopTos.IsNull() && data.RecordIpv4BgpNexthopTos.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv4/bgp-nexthop-tos", state.getPath()))
	}
	if !state.RecordIpv4PrefixPort.IsNull() && data.RecordIpv4PrefixPort.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv4/prefix-port", state.getPath()))
	}
	if !state.RecordIpv4DestinationPrefixTos.IsNull() && data.RecordIpv4DestinationPrefixTos.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv4/destination-prefix-tos", state.getPath()))
	}
	if !state.RecordIpv4SourcePrefixTos.IsNull() && data.RecordIpv4SourcePrefixTos.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv4/source-prefix-tos", state.getPath()))
	}
	if !state.RecordIpv4PrefixTos.IsNull() && data.RecordIpv4PrefixTos.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv4/prefix-tos", state.getPath()))
	}
	if !state.RecordIpv4ProtocolPortTos.IsNull() && data.RecordIpv4ProtocolPortTos.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv4/protocol-port-tos", state.getPath()))
	}
	if !state.RecordIpv4AsTos.IsNull() && data.RecordIpv4AsTos.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv4/as-tos", state.getPath()))
	}
	if !state.RecordIpv4DestinationPrefix.IsNull() && data.RecordIpv4DestinationPrefix.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv4/destination-prefix", state.getPath()))
	}
	if !state.RecordIpv4SourcePrefix.IsNull() && data.RecordIpv4SourcePrefix.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv4/source-prefix", state.getPath()))
	}
	if !state.RecordIpv4Prefix.IsNull() && data.RecordIpv4Prefix.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv4/prefix", state.getPath()))
	}
	if !state.RecordIpv4ProtocolPort.IsNull() && data.RecordIpv4ProtocolPort.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv4/protocol-port", state.getPath()))
	}
	if !state.RecordIpv4As.IsNull() && data.RecordIpv4As.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv4/as", state.getPath()))
	}
	if !state.RecordIpv4DestinationTos.IsNull() && data.RecordIpv4DestinationTos.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv4/destination-tos", state.getPath()))
	}
	if !state.RecordIpv4Destination.IsNull() && data.RecordIpv4Destination.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv4/destination", state.getPath()))
	}
	if !state.RecordIpv4.IsNull() && data.RecordIpv4.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/record/ipv4", state.getPath()))
	}
	if !state.OptionOutbundlemember.IsNull() && data.OptionOutbundlemember.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/option/outbundlemember", state.getPath()))
	}
	if !state.OptionBgpattr.IsNull() && data.OptionBgpattr.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/option/bgpattr", state.getPath()))
	}
	if !state.OptionFiltered.IsNull() && data.OptionFiltered.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/option/filtered", state.getPath()))
	}
	if !state.OptionOutphysint.IsNull() && data.OptionOutphysint.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/option/outphysint", state.getPath()))
	}
	for i := range state.Exporters {
		keys := [...]string{"exporter-name"}
		stateKeyValues := [...]string{state.Exporters[i].Name.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.Exporters[i].Name.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Exporters {
			found = true
			if state.Exporters[i].Name.ValueString() != data.Exporters[j].Name.ValueString() {
				found = false
			}
			if found {
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/exporters/exporter%v", state.getPath(), keyString))
		}
	}
	return deletedItems
}

// End of section. //template:end getDeletedItems

// Section below is generated&owned by "gen/generator.go". //template:begin getEmptyLeafsDelete

func (data *FlowMonitorMap) getEmptyLeafsDelete(ctx context.Context, state *FlowMonitorMap) []string {
	emptyLeafsDelete := make([]string, 0)
	// Only delete if state has true and plan has false
	if !data.SflowOptionsExtendedIpv6TunnelEgress.IsNull() && !data.SflowOptionsExtendedIpv6TunnelEgress.ValueBool() {
		if state != nil && !state.SflowOptionsExtendedIpv6TunnelEgress.IsNull() && state.SflowOptionsExtendedIpv6TunnelEgress.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/sflow/options/extended-ipv6-tunnel-egress", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.SflowOptionsExtendedIpv4TunnelEgress.IsNull() && !data.SflowOptionsExtendedIpv4TunnelEgress.ValueBool() {
		if state != nil && !state.SflowOptionsExtendedIpv4TunnelEgress.IsNull() && state.SflowOptionsExtendedIpv4TunnelEgress.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/sflow/options/extended-ipv4-tunnel-egress", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.SflowOptionsExtendedGateway.IsNull() && !data.SflowOptionsExtendedGateway.ValueBool() {
		if state != nil && !state.SflowOptionsExtendedGateway.IsNull() && state.SflowOptionsExtendedGateway.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/sflow/options/extended-gateway", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.SflowOptionsExtendedRouter.IsNull() && !data.SflowOptionsExtendedRouter.ValueBool() {
		if state != nil && !state.SflowOptionsExtendedRouter.IsNull() && state.SflowOptionsExtendedRouter.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/sflow/options/extended-router", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.SflowOptions.IsNull() && !data.SflowOptions.ValueBool() {
		if state != nil && !state.SflowOptions.IsNull() && state.SflowOptions.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/sflow/options", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.CacheImmediate.IsNull() && !data.CacheImmediate.ValueBool() {
		if state != nil && !state.CacheImmediate.IsNull() && state.CacheImmediate.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/cache/immediate", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.CachePermanent.IsNull() && !data.CachePermanent.ValueBool() {
		if state != nil && !state.CachePermanent.IsNull() && state.CachePermanent.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/cache/permanent", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordDefaultMdi.IsNull() && !data.RecordDefaultMdi.ValueBool() {
		if state != nil && !state.RecordDefaultMdi.IsNull() && state.RecordDefaultMdi.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/default-mdi", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordDefaultRtp.IsNull() && !data.RecordDefaultRtp.ValueBool() {
		if state != nil && !state.RecordDefaultRtp.IsNull() && state.RecordDefaultRtp.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/default-rtp", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordDatalinkRecord.IsNull() && !data.RecordDatalinkRecord.ValueBool() {
		if state != nil && !state.RecordDatalinkRecord.IsNull() && state.RecordDatalinkRecord.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/datalink-record", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordSflow.IsNull() && !data.RecordSflow.ValueBool() {
		if state != nil && !state.RecordSflow.IsNull() && state.RecordSflow.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/sflow", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordMapT.IsNull() && !data.RecordMapT.ValueBool() {
		if state != nil && !state.RecordMapT.IsNull() && state.RecordMapT.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/map-t", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordMplsIpv4Ipv6Fields.IsNull() && !data.RecordMplsIpv4Ipv6Fields.ValueBool() {
		if state != nil && !state.RecordMplsIpv4Ipv6Fields.IsNull() && state.RecordMplsIpv4Ipv6Fields.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/mpls/ipv4-ipv6-fields", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordMplsIpv6Fields.IsNull() && !data.RecordMplsIpv6Fields.ValueBool() {
		if state != nil && !state.RecordMplsIpv6Fields.IsNull() && state.RecordMplsIpv6Fields.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/mpls/ipv6-fields", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordMplsIpv4Fields.IsNull() && !data.RecordMplsIpv4Fields.ValueBool() {
		if state != nil && !state.RecordMplsIpv4Fields.IsNull() && state.RecordMplsIpv4Fields.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/mpls/ipv4-fields", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordMpls.IsNull() && !data.RecordMpls.ValueBool() {
		if state != nil && !state.RecordMpls.IsNull() && state.RecordMpls.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/mpls", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv6Extended.IsNull() && !data.RecordIpv6Extended.ValueBool() {
		if state != nil && !state.RecordIpv6Extended.IsNull() && state.RecordIpv6Extended.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv6/extended", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv6L2L3.IsNull() && !data.RecordIpv6L2L3.ValueBool() {
		if state != nil && !state.RecordIpv6L2L3.IsNull() && state.RecordIpv6L2L3.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv6/l2-l3", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv6Srv6.IsNull() && !data.RecordIpv6Srv6.ValueBool() {
		if state != nil && !state.RecordIpv6Srv6.IsNull() && state.RecordIpv6Srv6.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv6/srv6", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv6Gtp.IsNull() && !data.RecordIpv6Gtp.ValueBool() {
		if state != nil && !state.RecordIpv6Gtp.IsNull() && state.RecordIpv6Gtp.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv6/gtp", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv6PeerAs.IsNull() && !data.RecordIpv6PeerAs.ValueBool() {
		if state != nil && !state.RecordIpv6PeerAs.IsNull() && state.RecordIpv6PeerAs.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv6/peer-as", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv6Destination.IsNull() && !data.RecordIpv6Destination.ValueBool() {
		if state != nil && !state.RecordIpv6Destination.IsNull() && state.RecordIpv6Destination.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv6/destination", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv6.IsNull() && !data.RecordIpv6.ValueBool() {
		if state != nil && !state.RecordIpv6.IsNull() && state.RecordIpv6.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv6", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv4Extended.IsNull() && !data.RecordIpv4Extended.ValueBool() {
		if state != nil && !state.RecordIpv4Extended.IsNull() && state.RecordIpv4Extended.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv4/extended", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv4L2L3.IsNull() && !data.RecordIpv4L2L3.ValueBool() {
		if state != nil && !state.RecordIpv4L2L3.IsNull() && state.RecordIpv4L2L3.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv4/l2-l3", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv4Gtp.IsNull() && !data.RecordIpv4Gtp.ValueBool() {
		if state != nil && !state.RecordIpv4Gtp.IsNull() && state.RecordIpv4Gtp.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv4/gtp", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv4PeerAs.IsNull() && !data.RecordIpv4PeerAs.ValueBool() {
		if state != nil && !state.RecordIpv4PeerAs.IsNull() && state.RecordIpv4PeerAs.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv4/peer-as", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv4BgpNexthopTos.IsNull() && !data.RecordIpv4BgpNexthopTos.ValueBool() {
		if state != nil && !state.RecordIpv4BgpNexthopTos.IsNull() && state.RecordIpv4BgpNexthopTos.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv4/bgp-nexthop-tos", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv4PrefixPort.IsNull() && !data.RecordIpv4PrefixPort.ValueBool() {
		if state != nil && !state.RecordIpv4PrefixPort.IsNull() && state.RecordIpv4PrefixPort.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv4/prefix-port", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv4DestinationPrefixTos.IsNull() && !data.RecordIpv4DestinationPrefixTos.ValueBool() {
		if state != nil && !state.RecordIpv4DestinationPrefixTos.IsNull() && state.RecordIpv4DestinationPrefixTos.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv4/destination-prefix-tos", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv4SourcePrefixTos.IsNull() && !data.RecordIpv4SourcePrefixTos.ValueBool() {
		if state != nil && !state.RecordIpv4SourcePrefixTos.IsNull() && state.RecordIpv4SourcePrefixTos.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv4/source-prefix-tos", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv4PrefixTos.IsNull() && !data.RecordIpv4PrefixTos.ValueBool() {
		if state != nil && !state.RecordIpv4PrefixTos.IsNull() && state.RecordIpv4PrefixTos.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv4/prefix-tos", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv4ProtocolPortTos.IsNull() && !data.RecordIpv4ProtocolPortTos.ValueBool() {
		if state != nil && !state.RecordIpv4ProtocolPortTos.IsNull() && state.RecordIpv4ProtocolPortTos.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv4/protocol-port-tos", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv4AsTos.IsNull() && !data.RecordIpv4AsTos.ValueBool() {
		if state != nil && !state.RecordIpv4AsTos.IsNull() && state.RecordIpv4AsTos.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv4/as-tos", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv4DestinationPrefix.IsNull() && !data.RecordIpv4DestinationPrefix.ValueBool() {
		if state != nil && !state.RecordIpv4DestinationPrefix.IsNull() && state.RecordIpv4DestinationPrefix.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv4/destination-prefix", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv4SourcePrefix.IsNull() && !data.RecordIpv4SourcePrefix.ValueBool() {
		if state != nil && !state.RecordIpv4SourcePrefix.IsNull() && state.RecordIpv4SourcePrefix.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv4/source-prefix", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv4Prefix.IsNull() && !data.RecordIpv4Prefix.ValueBool() {
		if state != nil && !state.RecordIpv4Prefix.IsNull() && state.RecordIpv4Prefix.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv4/prefix", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv4ProtocolPort.IsNull() && !data.RecordIpv4ProtocolPort.ValueBool() {
		if state != nil && !state.RecordIpv4ProtocolPort.IsNull() && state.RecordIpv4ProtocolPort.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv4/protocol-port", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv4As.IsNull() && !data.RecordIpv4As.ValueBool() {
		if state != nil && !state.RecordIpv4As.IsNull() && state.RecordIpv4As.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv4/as", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv4DestinationTos.IsNull() && !data.RecordIpv4DestinationTos.ValueBool() {
		if state != nil && !state.RecordIpv4DestinationTos.IsNull() && state.RecordIpv4DestinationTos.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv4/destination-tos", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv4Destination.IsNull() && !data.RecordIpv4Destination.ValueBool() {
		if state != nil && !state.RecordIpv4Destination.IsNull() && state.RecordIpv4Destination.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv4/destination", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RecordIpv4.IsNull() && !data.RecordIpv4.ValueBool() {
		if state != nil && !state.RecordIpv4.IsNull() && state.RecordIpv4.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record/ipv4", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.OptionOutbundlemember.IsNull() && !data.OptionOutbundlemember.ValueBool() {
		if state != nil && !state.OptionOutbundlemember.IsNull() && state.OptionOutbundlemember.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/option/outbundlemember", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.OptionBgpattr.IsNull() && !data.OptionBgpattr.ValueBool() {
		if state != nil && !state.OptionBgpattr.IsNull() && state.OptionBgpattr.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/option/bgpattr", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.OptionFiltered.IsNull() && !data.OptionFiltered.ValueBool() {
		if state != nil && !state.OptionFiltered.IsNull() && state.OptionFiltered.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/option/filtered", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.OptionOutphysint.IsNull() && !data.OptionOutphysint.ValueBool() {
		if state != nil && !state.OptionOutphysint.IsNull() && state.OptionOutphysint.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/option/outphysint", data.getXPath()))
		}
	}
	for i := range data.Exporters {
		keys := [...]string{"exporter-name"}
		keyValues := [...]string{data.Exporters[i].Name.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
	}
	return emptyLeafsDelete
}

// End of section. //template:end getEmptyLeafsDelete

// Section below is generated&owned by "gen/generator.go". //template:begin getDeletePaths

func (data *FlowMonitorMap) getDeletePaths(ctx context.Context) []string {
	var deletePaths []string
	if !data.SflowOptionsOutputIfindex.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/sflow/options/output/ifindex", data.getPath()))
	}
	if !data.SflowOptionsInputIfindex.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/sflow/options/input/ifindex", data.getPath()))
	}
	if !data.SflowOptionsSampleHeaderSize.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/sflow/options/sample-header/size", data.getPath()))
	}
	if !data.SflowOptionsIfCountersPollingInterval.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/sflow/options/if-counters/polling-interval", data.getPath()))
	}
	if !data.SflowOptionsExtendedIpv6TunnelEgress.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/sflow/options/extended-ipv6-tunnel-egress", data.getPath()))
	}
	if !data.SflowOptionsExtendedIpv4TunnelEgress.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/sflow/options/extended-ipv4-tunnel-egress", data.getPath()))
	}
	if !data.SflowOptionsExtendedGateway.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/sflow/options/extended-gateway", data.getPath()))
	}
	if !data.SflowOptionsExtendedRouter.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/sflow/options/extended-router", data.getPath()))
	}
	if !data.SflowOptions.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/sflow/options", data.getPath()))
	}
	if !data.HwCacheTimeoutInactive.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/hw-cache/timeout/inactive", data.getPath()))
	}
	if !data.CacheImmediate.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/cache/immediate", data.getPath()))
	}
	if !data.CachePermanent.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/cache/permanent", data.getPath()))
	}
	if !data.CacheTimeoutRateLimit.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/cache/timeout/rate-limit", data.getPath()))
	}
	if !data.CacheTimeoutUpdate.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/cache/timeout/update", data.getPath()))
	}
	if !data.CacheTimeoutInactive.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/cache/timeout/inactive", data.getPath()))
	}
	if !data.CacheTimeoutActive.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/cache/timeout/active", data.getPath()))
	}
	if !data.CacheEntries.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/cache/entries", data.getPath()))
	}
	if !data.RecordDefaultMdi.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/default-mdi", data.getPath()))
	}
	if !data.RecordDefaultRtp.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/default-rtp", data.getPath()))
	}
	if !data.RecordDatalinkRecord.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/datalink-record", data.getPath()))
	}
	if !data.RecordSflow.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/sflow", data.getPath()))
	}
	if !data.RecordMapT.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/map-t", data.getPath()))
	}
	if !data.RecordMplsLabels.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/mpls/labels", data.getPath()))
	}
	if !data.RecordMplsIpv4Ipv6Fields.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/mpls/ipv4-ipv6-fields", data.getPath()))
	}
	if !data.RecordMplsIpv6Fields.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/mpls/ipv6-fields", data.getPath()))
	}
	if !data.RecordMplsIpv4Fields.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/mpls/ipv4-fields", data.getPath()))
	}
	if !data.RecordMpls.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/mpls", data.getPath()))
	}
	if !data.RecordIpv6Extended.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv6/extended", data.getPath()))
	}
	if !data.RecordIpv6L2L3.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv6/l2-l3", data.getPath()))
	}
	if !data.RecordIpv6Srv6.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv6/srv6", data.getPath()))
	}
	if !data.RecordIpv6Gtp.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv6/gtp", data.getPath()))
	}
	if !data.RecordIpv6PeerAs.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv6/peer-as", data.getPath()))
	}
	if !data.RecordIpv6Destination.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv6/destination", data.getPath()))
	}
	if !data.RecordIpv6.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv6", data.getPath()))
	}
	if !data.RecordIpv4Extended.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv4/extended", data.getPath()))
	}
	if !data.RecordIpv4L2L3.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv4/l2-l3", data.getPath()))
	}
	if !data.RecordIpv4Gtp.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv4/gtp", data.getPath()))
	}
	if !data.RecordIpv4PeerAs.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv4/peer-as", data.getPath()))
	}
	if !data.RecordIpv4BgpNexthopTos.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv4/bgp-nexthop-tos", data.getPath()))
	}
	if !data.RecordIpv4PrefixPort.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv4/prefix-port", data.getPath()))
	}
	if !data.RecordIpv4DestinationPrefixTos.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv4/destination-prefix-tos", data.getPath()))
	}
	if !data.RecordIpv4SourcePrefixTos.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv4/source-prefix-tos", data.getPath()))
	}
	if !data.RecordIpv4PrefixTos.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv4/prefix-tos", data.getPath()))
	}
	if !data.RecordIpv4ProtocolPortTos.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv4/protocol-port-tos", data.getPath()))
	}
	if !data.RecordIpv4AsTos.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv4/as-tos", data.getPath()))
	}
	if !data.RecordIpv4DestinationPrefix.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv4/destination-prefix", data.getPath()))
	}
	if !data.RecordIpv4SourcePrefix.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv4/source-prefix", data.getPath()))
	}
	if !data.RecordIpv4Prefix.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv4/prefix", data.getPath()))
	}
	if !data.RecordIpv4ProtocolPort.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv4/protocol-port", data.getPath()))
	}
	if !data.RecordIpv4As.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv4/as", data.getPath()))
	}
	if !data.RecordIpv4DestinationTos.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv4/destination-tos", data.getPath()))
	}
	if !data.RecordIpv4Destination.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv4/destination", data.getPath()))
	}
	if !data.RecordIpv4.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/record/ipv4", data.getPath()))
	}
	if !data.OptionOutbundlemember.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/option/outbundlemember", data.getPath()))
	}
	if !data.OptionBgpattr.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/option/bgpattr", data.getPath()))
	}
	if !data.OptionFiltered.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/option/filtered", data.getPath()))
	}
	if !data.OptionOutphysint.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/option/outphysint", data.getPath()))
	}
	for i := range data.Exporters {
		keyValues := [...]string{data.Exporters[i].Name.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/exporters/exporter=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}

	return deletePaths
}

// End of section. //template:end getDeletePaths

// Section below is generated&owned by "gen/generator.go". //template:begin addDeletedItemsXML

func (data *FlowMonitorMap) addDeletedItemsXML(ctx context.Context, state FlowMonitorMap, body string) string {
	deleteXml := ""
	deletedPaths := make(map[string]bool)
	_ = deletedPaths // Avoid unused variable error when no delete_parent attributes exist
	if !state.SflowOptionsOutputIfindex.IsNull() && data.SflowOptionsOutputIfindex.IsNull() {
		deletePath := state.getXPath() + "/sflow/options/output/ifindex"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.SflowOptionsInputIfindex.IsNull() && data.SflowOptionsInputIfindex.IsNull() {
		deletePath := state.getXPath() + "/sflow/options/input/ifindex"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.SflowOptionsSampleHeaderSize.IsNull() && data.SflowOptionsSampleHeaderSize.IsNull() {
		deletePath := state.getXPath() + "/sflow/options/sample-header/size"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.SflowOptionsIfCountersPollingInterval.IsNull() && data.SflowOptionsIfCountersPollingInterval.IsNull() {
		deletePath := state.getXPath() + "/sflow/options/if-counters/polling-interval"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.SflowOptionsExtendedIpv6TunnelEgress.IsNull() && state.SflowOptionsExtendedIpv6TunnelEgress.ValueBool() && data.SflowOptionsExtendedIpv6TunnelEgress.IsNull() {
		deletePath := state.getXPath() + "/sflow/options/extended-ipv6-tunnel-egress"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.SflowOptionsExtendedIpv4TunnelEgress.IsNull() && state.SflowOptionsExtendedIpv4TunnelEgress.ValueBool() && data.SflowOptionsExtendedIpv4TunnelEgress.IsNull() {
		deletePath := state.getXPath() + "/sflow/options/extended-ipv4-tunnel-egress"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.SflowOptionsExtendedGateway.IsNull() && state.SflowOptionsExtendedGateway.ValueBool() && data.SflowOptionsExtendedGateway.IsNull() {
		deletePath := state.getXPath() + "/sflow/options/extended-gateway"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.SflowOptionsExtendedRouter.IsNull() && state.SflowOptionsExtendedRouter.ValueBool() && data.SflowOptionsExtendedRouter.IsNull() {
		deletePath := state.getXPath() + "/sflow/options/extended-router"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.SflowOptions.IsNull() && state.SflowOptions.ValueBool() && data.SflowOptions.IsNull() {
		deletePath := state.getXPath() + "/sflow/options"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.HwCacheTimeoutInactive.IsNull() && data.HwCacheTimeoutInactive.IsNull() {
		deletePath := state.getXPath() + "/hw-cache/timeout/inactive"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.CacheImmediate.IsNull() && state.CacheImmediate.ValueBool() && data.CacheImmediate.IsNull() {
		deletePath := state.getXPath() + "/cache/immediate"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.CachePermanent.IsNull() && state.CachePermanent.ValueBool() && data.CachePermanent.IsNull() {
		deletePath := state.getXPath() + "/cache/permanent"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.CacheTimeoutRateLimit.IsNull() && data.CacheTimeoutRateLimit.IsNull() {
		deletePath := state.getXPath() + "/cache/timeout/rate-limit"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.CacheTimeoutUpdate.IsNull() && data.CacheTimeoutUpdate.IsNull() {
		deletePath := state.getXPath() + "/cache/timeout/update"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.CacheTimeoutInactive.IsNull() && data.CacheTimeoutInactive.IsNull() {
		deletePath := state.getXPath() + "/cache/timeout/inactive"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.CacheTimeoutActive.IsNull() && data.CacheTimeoutActive.IsNull() {
		deletePath := state.getXPath() + "/cache/timeout/active"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.CacheEntries.IsNull() && data.CacheEntries.IsNull() {
		deletePath := state.getXPath() + "/cache/entries"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordDefaultMdi.IsNull() && state.RecordDefaultMdi.ValueBool() && data.RecordDefaultMdi.IsNull() {
		deletePath := state.getXPath() + "/record/default-mdi"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordDefaultRtp.IsNull() && state.RecordDefaultRtp.ValueBool() && data.RecordDefaultRtp.IsNull() {
		deletePath := state.getXPath() + "/record/default-rtp"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordDatalinkRecord.IsNull() && state.RecordDatalinkRecord.ValueBool() && data.RecordDatalinkRecord.IsNull() {
		deletePath := state.getXPath() + "/record/datalink-record"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordSflow.IsNull() && state.RecordSflow.ValueBool() && data.RecordSflow.IsNull() {
		deletePath := state.getXPath() + "/record/sflow"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordMapT.IsNull() && state.RecordMapT.ValueBool() && data.RecordMapT.IsNull() {
		deletePath := state.getXPath() + "/record/map-t"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.RecordMplsLabels.IsNull() && data.RecordMplsLabels.IsNull() {
		deletePath := state.getXPath() + "/record/mpls/labels"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordMplsIpv4Ipv6Fields.IsNull() && state.RecordMplsIpv4Ipv6Fields.ValueBool() && data.RecordMplsIpv4Ipv6Fields.IsNull() {
		deletePath := state.getXPath() + "/record/mpls/ipv4-ipv6-fields"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordMplsIpv6Fields.IsNull() && state.RecordMplsIpv6Fields.ValueBool() && data.RecordMplsIpv6Fields.IsNull() {
		deletePath := state.getXPath() + "/record/mpls/ipv6-fields"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordMplsIpv4Fields.IsNull() && state.RecordMplsIpv4Fields.ValueBool() && data.RecordMplsIpv4Fields.IsNull() {
		deletePath := state.getXPath() + "/record/mpls/ipv4-fields"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordMpls.IsNull() && state.RecordMpls.ValueBool() && data.RecordMpls.IsNull() {
		deletePath := state.getXPath() + "/record/mpls"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv6Extended.IsNull() && state.RecordIpv6Extended.ValueBool() && data.RecordIpv6Extended.IsNull() {
		deletePath := state.getXPath() + "/record/ipv6/extended"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv6L2L3.IsNull() && state.RecordIpv6L2L3.ValueBool() && data.RecordIpv6L2L3.IsNull() {
		deletePath := state.getXPath() + "/record/ipv6/l2-l3"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv6Srv6.IsNull() && state.RecordIpv6Srv6.ValueBool() && data.RecordIpv6Srv6.IsNull() {
		deletePath := state.getXPath() + "/record/ipv6/srv6"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv6Gtp.IsNull() && state.RecordIpv6Gtp.ValueBool() && data.RecordIpv6Gtp.IsNull() {
		deletePath := state.getXPath() + "/record/ipv6/gtp"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv6PeerAs.IsNull() && state.RecordIpv6PeerAs.ValueBool() && data.RecordIpv6PeerAs.IsNull() {
		deletePath := state.getXPath() + "/record/ipv6/peer-as"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv6Destination.IsNull() && state.RecordIpv6Destination.ValueBool() && data.RecordIpv6Destination.IsNull() {
		deletePath := state.getXPath() + "/record/ipv6/destination"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv6.IsNull() && state.RecordIpv6.ValueBool() && data.RecordIpv6.IsNull() {
		deletePath := state.getXPath() + "/record/ipv6"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv4Extended.IsNull() && state.RecordIpv4Extended.ValueBool() && data.RecordIpv4Extended.IsNull() {
		deletePath := state.getXPath() + "/record/ipv4/extended"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv4L2L3.IsNull() && state.RecordIpv4L2L3.ValueBool() && data.RecordIpv4L2L3.IsNull() {
		deletePath := state.getXPath() + "/record/ipv4/l2-l3"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv4Gtp.IsNull() && state.RecordIpv4Gtp.ValueBool() && data.RecordIpv4Gtp.IsNull() {
		deletePath := state.getXPath() + "/record/ipv4/gtp"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv4PeerAs.IsNull() && state.RecordIpv4PeerAs.ValueBool() && data.RecordIpv4PeerAs.IsNull() {
		deletePath := state.getXPath() + "/record/ipv4/peer-as"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv4BgpNexthopTos.IsNull() && state.RecordIpv4BgpNexthopTos.ValueBool() && data.RecordIpv4BgpNexthopTos.IsNull() {
		deletePath := state.getXPath() + "/record/ipv4/bgp-nexthop-tos"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv4PrefixPort.IsNull() && state.RecordIpv4PrefixPort.ValueBool() && data.RecordIpv4PrefixPort.IsNull() {
		deletePath := state.getXPath() + "/record/ipv4/prefix-port"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv4DestinationPrefixTos.IsNull() && state.RecordIpv4DestinationPrefixTos.ValueBool() && data.RecordIpv4DestinationPrefixTos.IsNull() {
		deletePath := state.getXPath() + "/record/ipv4/destination-prefix-tos"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv4SourcePrefixTos.IsNull() && state.RecordIpv4SourcePrefixTos.ValueBool() && data.RecordIpv4SourcePrefixTos.IsNull() {
		deletePath := state.getXPath() + "/record/ipv4/source-prefix-tos"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv4PrefixTos.IsNull() && state.RecordIpv4PrefixTos.ValueBool() && data.RecordIpv4PrefixTos.IsNull() {
		deletePath := state.getXPath() + "/record/ipv4/prefix-tos"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv4ProtocolPortTos.IsNull() && state.RecordIpv4ProtocolPortTos.ValueBool() && data.RecordIpv4ProtocolPortTos.IsNull() {
		deletePath := state.getXPath() + "/record/ipv4/protocol-port-tos"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv4AsTos.IsNull() && state.RecordIpv4AsTos.ValueBool() && data.RecordIpv4AsTos.IsNull() {
		deletePath := state.getXPath() + "/record/ipv4/as-tos"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv4DestinationPrefix.IsNull() && state.RecordIpv4DestinationPrefix.ValueBool() && data.RecordIpv4DestinationPrefix.IsNull() {
		deletePath := state.getXPath() + "/record/ipv4/destination-prefix"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv4SourcePrefix.IsNull() && state.RecordIpv4SourcePrefix.ValueBool() && data.RecordIpv4SourcePrefix.IsNull() {
		deletePath := state.getXPath() + "/record/ipv4/source-prefix"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv4Prefix.IsNull() && state.RecordIpv4Prefix.ValueBool() && data.RecordIpv4Prefix.IsNull() {
		deletePath := state.getXPath() + "/record/ipv4/prefix"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv4ProtocolPort.IsNull() && state.RecordIpv4ProtocolPort.ValueBool() && data.RecordIpv4ProtocolPort.IsNull() {
		deletePath := state.getXPath() + "/record/ipv4/protocol-port"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv4As.IsNull() && state.RecordIpv4As.ValueBool() && data.RecordIpv4As.IsNull() {
		deletePath := state.getXPath() + "/record/ipv4/as"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv4DestinationTos.IsNull() && state.RecordIpv4DestinationTos.ValueBool() && data.RecordIpv4DestinationTos.IsNull() {
		deletePath := state.getXPath() + "/record/ipv4/destination-tos"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv4Destination.IsNull() && state.RecordIpv4Destination.ValueBool() && data.RecordIpv4Destination.IsNull() {
		deletePath := state.getXPath() + "/record/ipv4/destination"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RecordIpv4.IsNull() && state.RecordIpv4.ValueBool() && data.RecordIpv4.IsNull() {
		deletePath := state.getXPath() + "/record/ipv4"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.OptionOutbundlemember.IsNull() && state.OptionOutbundlemember.ValueBool() && data.OptionOutbundlemember.IsNull() {
		deletePath := state.getXPath() + "/option/outbundlemember"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.OptionBgpattr.IsNull() && state.OptionBgpattr.ValueBool() && data.OptionBgpattr.IsNull() {
		deletePath := state.getXPath() + "/option/bgpattr"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.OptionFiltered.IsNull() && state.OptionFiltered.ValueBool() && data.OptionFiltered.IsNull() {
		deletePath := state.getXPath() + "/option/filtered"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.OptionOutphysint.IsNull() && state.OptionOutphysint.ValueBool() && data.OptionOutphysint.IsNull() {
		deletePath := state.getXPath() + "/option/outphysint"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	for i := range state.Exporters {
		stateKeys := [...]string{"exporter-name"}
		stateKeyValues := [...]string{state.Exporters[i].Name.ValueString()}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.Exporters[i].Name.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Exporters {
			found = true
			if state.Exporters[i].Name.ValueString() != data.Exporters[j].Name.ValueString() {
				found = false
			}
			if found {
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/exporters/exporter%v", predicates))
		}
	}

	b := netconf.NewBody(deleteXml)
	b = helpers.CleanupRedundantRemoveOperations(b)
	return b.Res()
}

// End of section. //template:end addDeletedItemsXML

// Section below is generated&owned by "gen/generator.go". //template:begin addDeletePathsXML

func (data *FlowMonitorMap) addDeletePathsXML(ctx context.Context, body string) string {
	b := netconf.NewBody(body)
	if !data.SflowOptionsOutputIfindex.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/sflow/options/output/ifindex")
	}
	if !data.SflowOptionsInputIfindex.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/sflow/options/input/ifindex")
	}
	if !data.SflowOptionsSampleHeaderSize.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/sflow/options/sample-header/size")
	}
	if !data.SflowOptionsIfCountersPollingInterval.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/sflow/options/if-counters/polling-interval")
	}
	if !data.SflowOptionsExtendedIpv6TunnelEgress.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/sflow/options/extended-ipv6-tunnel-egress")
	}
	if !data.SflowOptionsExtendedIpv4TunnelEgress.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/sflow/options/extended-ipv4-tunnel-egress")
	}
	if !data.SflowOptionsExtendedGateway.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/sflow/options/extended-gateway")
	}
	if !data.SflowOptionsExtendedRouter.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/sflow/options/extended-router")
	}
	if !data.SflowOptions.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/sflow/options")
	}
	if !data.HwCacheTimeoutInactive.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/hw-cache/timeout/inactive")
	}
	if !data.CacheImmediate.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/cache/immediate")
	}
	if !data.CachePermanent.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/cache/permanent")
	}
	if !data.CacheTimeoutRateLimit.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/cache/timeout/rate-limit")
	}
	if !data.CacheTimeoutUpdate.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/cache/timeout/update")
	}
	if !data.CacheTimeoutInactive.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/cache/timeout/inactive")
	}
	if !data.CacheTimeoutActive.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/cache/timeout/active")
	}
	if !data.CacheEntries.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/cache/entries")
	}
	if !data.RecordDefaultMdi.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/default-mdi")
	}
	if !data.RecordDefaultRtp.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/default-rtp")
	}
	if !data.RecordDatalinkRecord.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/datalink-record")
	}
	if !data.RecordSflow.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/sflow")
	}
	if !data.RecordMapT.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/map-t")
	}
	if !data.RecordMplsLabels.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/mpls/labels")
	}
	if !data.RecordMplsIpv4Ipv6Fields.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/mpls/ipv4-ipv6-fields")
	}
	if !data.RecordMplsIpv6Fields.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/mpls/ipv6-fields")
	}
	if !data.RecordMplsIpv4Fields.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/mpls/ipv4-fields")
	}
	if !data.RecordMpls.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/mpls")
	}
	if !data.RecordIpv6Extended.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv6/extended")
	}
	if !data.RecordIpv6L2L3.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv6/l2-l3")
	}
	if !data.RecordIpv6Srv6.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv6/srv6")
	}
	if !data.RecordIpv6Gtp.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv6/gtp")
	}
	if !data.RecordIpv6PeerAs.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv6/peer-as")
	}
	if !data.RecordIpv6Destination.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv6/destination")
	}
	if !data.RecordIpv6.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv6")
	}
	if !data.RecordIpv4Extended.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv4/extended")
	}
	if !data.RecordIpv4L2L3.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv4/l2-l3")
	}
	if !data.RecordIpv4Gtp.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv4/gtp")
	}
	if !data.RecordIpv4PeerAs.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv4/peer-as")
	}
	if !data.RecordIpv4BgpNexthopTos.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv4/bgp-nexthop-tos")
	}
	if !data.RecordIpv4PrefixPort.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv4/prefix-port")
	}
	if !data.RecordIpv4DestinationPrefixTos.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv4/destination-prefix-tos")
	}
	if !data.RecordIpv4SourcePrefixTos.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv4/source-prefix-tos")
	}
	if !data.RecordIpv4PrefixTos.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv4/prefix-tos")
	}
	if !data.RecordIpv4ProtocolPortTos.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv4/protocol-port-tos")
	}
	if !data.RecordIpv4AsTos.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv4/as-tos")
	}
	if !data.RecordIpv4DestinationPrefix.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv4/destination-prefix")
	}
	if !data.RecordIpv4SourcePrefix.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv4/source-prefix")
	}
	if !data.RecordIpv4Prefix.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv4/prefix")
	}
	if !data.RecordIpv4ProtocolPort.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv4/protocol-port")
	}
	if !data.RecordIpv4As.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv4/as")
	}
	if !data.RecordIpv4DestinationTos.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv4/destination-tos")
	}
	if !data.RecordIpv4Destination.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv4/destination")
	}
	if !data.RecordIpv4.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/record/ipv4")
	}
	if !data.OptionOutbundlemember.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/option/outbundlemember")
	}
	if !data.OptionBgpattr.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/option/bgpattr")
	}
	if !data.OptionFiltered.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/option/filtered")
	}
	if !data.OptionOutphysint.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/option/outphysint")
	}
	for i := range data.Exporters {
		keys := [...]string{"exporter-name"}
		keyValues := [...]string{data.Exporters[i].Name.ValueString()}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/exporters/exporter%v", predicates))
	}

	b = helpers.CleanupRedundantRemoveOperations(b)
	return b.Res()
}

// End of section. //template:end addDeletePathsXML
