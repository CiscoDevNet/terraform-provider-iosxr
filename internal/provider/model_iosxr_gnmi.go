// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

import (
	"context"
	"encoding/json"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

type Gnmi struct {
	Id         types.String `tfsdk:"id"`
	Device     types.String `tfsdk:"device"`
	Path       types.String `tfsdk:"path"`
	Delete     types.Bool   `tfsdk:"delete"`
	Attributes types.Map    `tfsdk:"attributes"`
	Lists      []GnmiList   `tfsdk:"lists"`
}

type GnmiList struct {
	Name   types.String   `tfsdk:"name"`
	Key    types.String   `tfsdk:"key"`
	Values []types.String `tfsdk:"values"`
	Items  []types.Map    `tfsdk:"items"`
}

type GnmiData struct {
	Id         types.String `tfsdk:"id"`
	Device     types.String `tfsdk:"device"`
	Path       types.String `tfsdk:"path"`
	Attributes types.Map    `tfsdk:"attributes"`
	Lists      []GnmiList   `tfsdk:"lists"`
}

func (data Gnmi) getPath() string {
	return data.Path.ValueString()
}

func (data Gnmi) toBody(ctx context.Context) string {
	body := ""

	if !data.Attributes.IsNull() {
		attrs := make(map[string]string)
		data.Attributes.ElementsAs(ctx, &attrs, false)
		for key, value := range attrs {
			if value == "<EMPTY>" {
				body, _ = sjson.Set(body, key, map[string]interface{}{})
			} else if value != "<NULL>" {
				body, _ = sjson.Set(body, key, value)
			}
		}
	}

	for _, list := range data.Lists {
		if len(list.Values) > 0 {
			var values []string
			for _, v := range list.Values {
				values = append(values, v.ValueString())
			}
			body, _ = sjson.Set(body, list.Name.ValueString(), values)
		} else if len(list.Items) > 0 {
			body, _ = sjson.Set(body, list.Name.ValueString(), []interface{}{})
			for _, item := range list.Items {
				attrs := make(map[string]string)
				item.ElementsAs(ctx, &attrs, false)
				itemBody := ""
				for key, value := range attrs {
					if value == "<EMPTY>" {
						itemBody, _ = sjson.Set(itemBody, key, map[string]interface{}{})
					} else if value != "<NULL>" {
						itemBody, _ = sjson.Set(itemBody, key, value)
					}
				}
				var itemMap map[string]interface{}
				json.Unmarshal([]byte(itemBody), &itemMap)
				body, _ = sjson.Set(body, list.Name.ValueString()+".-1", itemMap)
			}
		}
	}

	return body
}

func (data *Gnmi) fromBody(ctx context.Context, res []byte) diag.Diagnostics {
	if !data.Attributes.IsNull() {
		attrs := make(map[string]string)
		data.Attributes.ElementsAs(ctx, &attrs, false)
		for key := range attrs {
			value := gjson.GetBytes(res, key)
			if value.Exists() {
				attrs[key] = value.String()
			}
		}
		var diags diag.Diagnostics
		data.Attributes, diags = types.MapValueFrom(ctx, types.StringType, attrs)
		if diags.HasError() {
			return diags
		}
	}

	for i := range data.Lists {
		if len(data.Lists[i].Values) > 0 {
			values := gjson.GetBytes(res, data.Lists[i].Name.ValueString())
			if values.Exists() {
				data.Lists[i].Values = []types.String{}
				values.ForEach(func(k, v gjson.Result) bool {
					data.Lists[i].Values = append(data.Lists[i].Values, types.StringValue(v.String()))
					return true
				})
			}
		} else if len(data.Lists[i].Items) > 0 {
			items := gjson.GetBytes(res, data.Lists[i].Name.ValueString())
			if items.Exists() {
				data.Lists[i].Items = []types.Map{}
				items.ForEach(func(k, v gjson.Result) bool {
					attrs := make(map[string]string)
					for key := range data.Lists[i].Items[0].Elements() {
						value := gjson.Get(v.String(), key)
						if value.Exists() {
							attrs[key] = value.String()
						}
					}
					var diags diag.Diagnostics
					m, diags := types.MapValueFrom(ctx, types.StringType, attrs)
					if !diags.HasError() {
						data.Lists[i].Items = append(data.Lists[i].Items, m)
					}
					return true
				})
			}
		}
	}

	return nil
}

func (data GnmiData) getPath() string {
	return data.Path.ValueString()
}

func (data *GnmiData) fromBody(ctx context.Context, res []byte) diag.Diagnostics {
	if !data.Attributes.IsNull() {
		attrs := make(map[string]string)
		data.Attributes.ElementsAs(ctx, &attrs, false)
		for key := range attrs {
			value := gjson.GetBytes(res, key)
			if value.Exists() {
				attrs[key] = value.String()
			}
		}
		var diags diag.Diagnostics
		data.Attributes, diags = types.MapValueFrom(ctx, types.StringType, attrs)
		if diags.HasError() {
			return diags
		}
	}

	for i := range data.Lists {
		if len(data.Lists[i].Values) > 0 {
			values := gjson.GetBytes(res, data.Lists[i].Name.ValueString())
			if values.Exists() {
				data.Lists[i].Values = []types.String{}
				values.ForEach(func(k, v gjson.Result) bool {
					data.Lists[i].Values = append(data.Lists[i].Values, types.StringValue(v.String()))
					return true
				})
			}
		} else if len(data.Lists[i].Items) > 0 {
			items := gjson.GetBytes(res, data.Lists[i].Name.ValueString())
			if items.Exists() {
				data.Lists[i].Items = []types.Map{}
				items.ForEach(func(k, v gjson.Result) bool {
					item := data.Lists[i].Items[0]
					attrs := make(map[string]string)
					item.ElementsAs(ctx, &attrs, false)
					for key := range attrs {
						value := gjson.Get(v.String(), key)
						if value.Exists() {
							attrs[key] = value.String()
						}
					}
					var diags diag.Diagnostics
					m, diags := types.MapValueFrom(ctx, types.StringType, attrs)
					if !diags.HasError() {
						data.Lists[i].Items = append(data.Lists[i].Items, m)
					}
					return true
				})
			}
		}
	}

	return nil
}

func (data *Gnmi) getDeletedItems(ctx context.Context, state Gnmi) []string {
	deletedItems := make([]string, 0)
	return deletedItems
}

func (data *Gnmi) getEmptyLeafsDelete(ctx context.Context) []string {
	emptyLeafsDelete := make([]string, 0)
	return emptyLeafsDelete
}

func (data *Gnmi) getDeletePaths(ctx context.Context) []string {
	var deletePaths []string
	return deletePaths
}
