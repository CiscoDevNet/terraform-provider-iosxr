// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports
import (
	"context"
	"fmt"
	"reflect"
	"strconv"
	"strings"

	"github.com/CiscoDevNet/terraform-provider-iosxr/internal/provider/helpers"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/netascode/go-netconf"
	"github.com/netascode/xmldot"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin types
type IPSLA struct {
	Device                     types.String      `tfsdk:"device"`
	Id                         types.String      `tfsdk:"id"`
	DeleteMode                 types.String      `tfsdk:"delete_mode"`
	LowMemory                  types.Int64       `tfsdk:"low_memory"`
	KeyChain                   types.String      `tfsdk:"key_chain"`
	HwTimestampDisable         types.Bool        `tfsdk:"hw_timestamp_disable"`
	Operations                 []IPSLAOperations `tfsdk:"operations"`
	Schedules                  []IPSLASchedules  `tfsdk:"schedules"`
	ServerTwamp                types.Bool        `tfsdk:"server_twamp"`
	ServerTwampPort            types.Int64       `tfsdk:"server_twamp_port"`
	ServerTwampTimerInactivity types.Int64       `tfsdk:"server_twamp_timer_inactivity"`
}

type IPSLAData struct {
	Device                     types.String      `tfsdk:"device"`
	Id                         types.String      `tfsdk:"id"`
	LowMemory                  types.Int64       `tfsdk:"low_memory"`
	KeyChain                   types.String      `tfsdk:"key_chain"`
	HwTimestampDisable         types.Bool        `tfsdk:"hw_timestamp_disable"`
	Operations                 []IPSLAOperations `tfsdk:"operations"`
	Schedules                  []IPSLASchedules  `tfsdk:"schedules"`
	ServerTwamp                types.Bool        `tfsdk:"server_twamp"`
	ServerTwampPort            types.Int64       `tfsdk:"server_twamp_port"`
	ServerTwampTimerInactivity types.Int64       `tfsdk:"server_twamp_timer_inactivity"`
}
type IPSLAOperations struct {
	OperationNumber                                  types.Int64                                     `tfsdk:"operation_number"`
	IcmpEcho                                         types.Bool                                      `tfsdk:"icmp_echo"`
	IcmpEchoTag                                      types.String                                    `tfsdk:"icmp_echo_tag"`
	IcmpEchoFrequency                                types.Int64                                     `tfsdk:"icmp_echo_frequency"`
	IcmpEchoDatasizeRequest                          types.Int64                                     `tfsdk:"icmp_echo_datasize_request"`
	IcmpEchoTimeout                                  types.Int64                                     `tfsdk:"icmp_echo_timeout"`
	IcmpEchoSourceIpv4                               types.String                                    `tfsdk:"icmp_echo_source_ipv4"`
	IcmpEchoSourceIpv6                               types.String                                    `tfsdk:"icmp_echo_source_ipv6"`
	IcmpEchoTos                                      types.Int64                                     `tfsdk:"icmp_echo_tos"`
	IcmpEchoVrf                                      types.String                                    `tfsdk:"icmp_echo_vrf"`
	IcmpEchoDestinationIpv4                          types.String                                    `tfsdk:"icmp_echo_destination_ipv4"`
	IcmpEchoDestinationIpv6                          types.String                                    `tfsdk:"icmp_echo_destination_ipv6"`
	IcmpEchoHistoryBuckets                           types.Int64                                     `tfsdk:"icmp_echo_history_buckets"`
	IcmpEchoHistoryFilterAll                         types.Bool                                      `tfsdk:"icmp_echo_history_filter_all"`
	IcmpEchoHistoryFilterFailures                    types.Bool                                      `tfsdk:"icmp_echo_history_filter_failures"`
	IcmpEchoHistoryLives                             types.Int64                                     `tfsdk:"icmp_echo_history_lives"`
	IcmpEchoStatisticsHourlyBuckets                  types.Int64                                     `tfsdk:"icmp_echo_statistics_hourly_buckets"`
	IcmpEchoStatisticsHourlyDistributionCount        types.Int64                                     `tfsdk:"icmp_echo_statistics_hourly_distribution_count"`
	IcmpEchoStatisticsHourlyDistributionInterval     types.Int64                                     `tfsdk:"icmp_echo_statistics_hourly_distribution_interval"`
	IcmpEchoStatisticsIntervals                      []IPSLAOperationsIcmpEchoStatisticsIntervals    `tfsdk:"icmp_echo_statistics_intervals"`
	IcmpPathEcho                                     types.Bool                                      `tfsdk:"icmp_path_echo"`
	IcmpPathEchoTag                                  types.String                                    `tfsdk:"icmp_path_echo_tag"`
	IcmpPathEchoFrequency                            types.Int64                                     `tfsdk:"icmp_path_echo_frequency"`
	IcmpPathEchoDatasizeRequest                      types.Int64                                     `tfsdk:"icmp_path_echo_datasize_request"`
	IcmpPathEchoTimeout                              types.Int64                                     `tfsdk:"icmp_path_echo_timeout"`
	IcmpPathEchoSourceIpv4                           types.String                                    `tfsdk:"icmp_path_echo_source_ipv4"`
	IcmpPathEchoTos                                  types.Int64                                     `tfsdk:"icmp_path_echo_tos"`
	IcmpPathEchoDestinationIpv4                      types.String                                    `tfsdk:"icmp_path_echo_destination_ipv4"`
	IcmpPathEchoHistoryBuckets                       types.Int64                                     `tfsdk:"icmp_path_echo_history_buckets"`
	IcmpPathEchoHistoryFilterAll                     types.Bool                                      `tfsdk:"icmp_path_echo_history_filter_all"`
	IcmpPathEchoHistoryFilterFailures                types.Bool                                      `tfsdk:"icmp_path_echo_history_filter_failures"`
	IcmpPathEchoHistoryLives                         types.Int64                                     `tfsdk:"icmp_path_echo_history_lives"`
	IcmpPathEchoHistorySamples                       types.Int64                                     `tfsdk:"icmp_path_echo_history_samples"`
	IcmpPathEchoStatisticsHourlyBuckets              types.Int64                                     `tfsdk:"icmp_path_echo_statistics_hourly_buckets"`
	IcmpPathEchoStatisticsHourlyDistributionCount    types.Int64                                     `tfsdk:"icmp_path_echo_statistics_hourly_distribution_count"`
	IcmpPathEchoStatisticsHourlyDistributionInterval types.Int64                                     `tfsdk:"icmp_path_echo_statistics_hourly_distribution_interval"`
	IcmpPathEchoStatisticsHourlyMaximumHops          types.Int64                                     `tfsdk:"icmp_path_echo_statistics_hourly_maximum_hops"`
	IcmpPathEchoStatisticsHourlyMaximumPaths         types.Int64                                     `tfsdk:"icmp_path_echo_statistics_hourly_maximum_paths"`
	IcmpPathJitter                                   types.Bool                                      `tfsdk:"icmp_path_jitter"`
	IcmpPathJitterTag                                types.String                                    `tfsdk:"icmp_path_jitter_tag"`
	IcmpPathJitterFrequency                          types.Int64                                     `tfsdk:"icmp_path_jitter_frequency"`
	IcmpPathJitterDatasizeRequest                    types.Int64                                     `tfsdk:"icmp_path_jitter_datasize_request"`
	IcmpPathJitterTimeout                            types.Int64                                     `tfsdk:"icmp_path_jitter_timeout"`
	IcmpPathJitterSourceIpv4                         types.String                                    `tfsdk:"icmp_path_jitter_source_ipv4"`
	IcmpPathJitterPacketCount                        types.Int64                                     `tfsdk:"icmp_path_jitter_packet_count"`
	IcmpPathJitterPacketInterval                     types.Int64                                     `tfsdk:"icmp_path_jitter_packet_interval"`
	IcmpPathJitterTos                                types.Int64                                     `tfsdk:"icmp_path_jitter_tos"`
	IcmpPathJitterDestinationIpv4                    types.String                                    `tfsdk:"icmp_path_jitter_destination_ipv4"`
	UdpEcho                                          types.Bool                                      `tfsdk:"udp_echo"`
	UdpEchoTag                                       types.String                                    `tfsdk:"udp_echo_tag"`
	UdpEchoFrequency                                 types.Int64                                     `tfsdk:"udp_echo_frequency"`
	UdpEchoDatasizeRequest                           types.Int64                                     `tfsdk:"udp_echo_datasize_request"`
	UdpEchoTimeout                                   types.Int64                                     `tfsdk:"udp_echo_timeout"`
	UdpEchoSourceIpv4                                types.String                                    `tfsdk:"udp_echo_source_ipv4"`
	UdpEchoSourcePort                                types.Int64                                     `tfsdk:"udp_echo_source_port"`
	UdpEchoDestinationIpv4                           types.String                                    `tfsdk:"udp_echo_destination_ipv4"`
	UdpEchoDestinationPort                           types.Int64                                     `tfsdk:"udp_echo_destination_port"`
	UdpEchoControlDisable                            types.Bool                                      `tfsdk:"udp_echo_control_disable"`
	UdpEchoVerifyData                                types.Bool                                      `tfsdk:"udp_echo_verify_data"`
	UdpEchoTos                                       types.Int64                                     `tfsdk:"udp_echo_tos"`
	UdpEchoVrf                                       types.String                                    `tfsdk:"udp_echo_vrf"`
	UdpEchoStatisticsHourlyBuckets                   types.Int64                                     `tfsdk:"udp_echo_statistics_hourly_buckets"`
	UdpEchoStatisticsHourlyDistributionCount         types.Int64                                     `tfsdk:"udp_echo_statistics_hourly_distribution_count"`
	UdpEchoStatisticsHourlyDistributionInterval      types.Int64                                     `tfsdk:"udp_echo_statistics_hourly_distribution_interval"`
	UdpEchoStatisticsIntervals                       []IPSLAOperationsUdpEchoStatisticsIntervals     `tfsdk:"udp_echo_statistics_intervals"`
	UdpEchoHistoryBuckets                            types.Int64                                     `tfsdk:"udp_echo_history_buckets"`
	UdpEchoHistoryFilterAll                          types.Bool                                      `tfsdk:"udp_echo_history_filter_all"`
	UdpEchoHistoryFilterFailures                     types.Bool                                      `tfsdk:"udp_echo_history_filter_failures"`
	UdpEchoHistoryLives                              types.Int64                                     `tfsdk:"udp_echo_history_lives"`
	UdpJitter                                        types.Bool                                      `tfsdk:"udp_jitter"`
	UdpJitterTag                                     types.String                                    `tfsdk:"udp_jitter_tag"`
	UdpJitterFrequency                               types.Int64                                     `tfsdk:"udp_jitter_frequency"`
	UdpJitterDatasizeRequest                         types.Int64                                     `tfsdk:"udp_jitter_datasize_request"`
	UdpJitterTimeout                                 types.Int64                                     `tfsdk:"udp_jitter_timeout"`
	UdpJitterSourceIpv4                              types.String                                    `tfsdk:"udp_jitter_source_ipv4"`
	UdpJitterSourcePort                              types.Int64                                     `tfsdk:"udp_jitter_source_port"`
	UdpJitterDestinationIpv4                         types.String                                    `tfsdk:"udp_jitter_destination_ipv4"`
	UdpJitterDestinationPort                         types.Int64                                     `tfsdk:"udp_jitter_destination_port"`
	UdpJitterPacketCount                             types.Int64                                     `tfsdk:"udp_jitter_packet_count"`
	UdpJitterPacketInterval                          types.Int64                                     `tfsdk:"udp_jitter_packet_interval"`
	UdpJitterTos                                     types.Int64                                     `tfsdk:"udp_jitter_tos"`
	UdpJitterVrf                                     types.String                                    `tfsdk:"udp_jitter_vrf"`
	UdpJitterControlDisable                          types.Bool                                      `tfsdk:"udp_jitter_control_disable"`
	UdpJitterVerifyData                              types.Bool                                      `tfsdk:"udp_jitter_verify_data"`
	UdpJitterStatisticsHourlyBuckets                 types.Int64                                     `tfsdk:"udp_jitter_statistics_hourly_buckets"`
	UdpJitterStatisticsHourlyDistributionCount       types.Int64                                     `tfsdk:"udp_jitter_statistics_hourly_distribution_count"`
	UdpJitterStatisticsHourlyDistributionInterval    types.Int64                                     `tfsdk:"udp_jitter_statistics_hourly_distribution_interval"`
	UdpJitterStatisticsIntervals                     []IPSLAOperationsUdpJitterStatisticsIntervals   `tfsdk:"udp_jitter_statistics_intervals"`
	MplsLspPing                                      types.Bool                                      `tfsdk:"mpls_lsp_ping"`
	MplsLspPingTag                                   types.String                                    `tfsdk:"mpls_lsp_ping_tag"`
	MplsLspPingFrequency                             types.Int64                                     `tfsdk:"mpls_lsp_ping_frequency"`
	MplsLspPingDatasizeRequest                       types.Int64                                     `tfsdk:"mpls_lsp_ping_datasize_request"`
	MplsLspPingTimeout                               types.Int64                                     `tfsdk:"mpls_lsp_ping_timeout"`
	MplsLspPingSourceIpv4                            types.String                                    `tfsdk:"mpls_lsp_ping_source_ipv4"`
	MplsLspPingTargetIpv4                            types.String                                    `tfsdk:"mpls_lsp_ping_target_ipv4"`
	MplsLspPingTargetIpv4Mask                        types.String                                    `tfsdk:"mpls_lsp_ping_target_ipv4_mask"`
	MplsLspPingTargetTeTunnel                        types.Int64                                     `tfsdk:"mpls_lsp_ping_target_te_tunnel"`
	MplsLspPingTargetPseudowireAddress               types.String                                    `tfsdk:"mpls_lsp_ping_target_pseudowire_address"`
	MplsLspPingTargetPseudowireVcId                  types.Int64                                     `tfsdk:"mpls_lsp_ping_target_pseudowire_vc_id"`
	MplsLspPingStatisticsHourlyBuckets               types.Int64                                     `tfsdk:"mpls_lsp_ping_statistics_hourly_buckets"`
	MplsLspPingStatisticsHourlyDistributionCount     types.Int64                                     `tfsdk:"mpls_lsp_ping_statistics_hourly_distribution_count"`
	MplsLspPingStatisticsHourlyDistributionInterval  types.Int64                                     `tfsdk:"mpls_lsp_ping_statistics_hourly_distribution_interval"`
	MplsLspPingStatisticsIntervals                   []IPSLAOperationsMplsLspPingStatisticsIntervals `tfsdk:"mpls_lsp_ping_statistics_intervals"`
	MplsLspTrace                                     types.Bool                                      `tfsdk:"mpls_lsp_trace"`
	MplsLspTraceTag                                  types.String                                    `tfsdk:"mpls_lsp_trace_tag"`
	MplsLspTraceFrequency                            types.Int64                                     `tfsdk:"mpls_lsp_trace_frequency"`
	MplsLspTraceTimeout                              types.Int64                                     `tfsdk:"mpls_lsp_trace_timeout"`
	MplsLspTraceSourceIpv4                           types.String                                    `tfsdk:"mpls_lsp_trace_source_ipv4"`
	MplsLspTraceTargetIpv4                           types.String                                    `tfsdk:"mpls_lsp_trace_target_ipv4"`
	MplsLspTraceTargetIpv4Mask                       types.String                                    `tfsdk:"mpls_lsp_trace_target_ipv4_mask"`
	MplsLspTraceTargetTeTunnel                       types.Int64                                     `tfsdk:"mpls_lsp_trace_target_te_tunnel"`
	MplsLspTraceTargetPseudowireAddress              types.String                                    `tfsdk:"mpls_lsp_trace_target_pseudowire_address"`
	MplsLspTraceTargetPseudowireVcId                 types.Int64                                     `tfsdk:"mpls_lsp_trace_target_pseudowire_vc_id"`
	MplsLspTraceStatisticsHourlyBuckets              types.Int64                                     `tfsdk:"mpls_lsp_trace_statistics_hourly_buckets"`
	MplsLspTraceStatisticsHourlyDistributionCount    types.Int64                                     `tfsdk:"mpls_lsp_trace_statistics_hourly_distribution_count"`
	MplsLspTraceStatisticsHourlyDistributionInterval types.Int64                                     `tfsdk:"mpls_lsp_trace_statistics_hourly_distribution_interval"`
}
type IPSLASchedules struct {
	OperationNumber  types.Int64  `tfsdk:"operation_number"`
	LifeForever      types.Bool   `tfsdk:"life_forever"`
	LifeTime         types.Int64  `tfsdk:"life_time"`
	StartHour        types.Int64  `tfsdk:"start_hour"`
	StartMinute      types.Int64  `tfsdk:"start_minute"`
	StartSecond      types.Int64  `tfsdk:"start_second"`
	StartMonth       types.String `tfsdk:"start_month"`
	StartDayOfMonth  types.Int64  `tfsdk:"start_day_of_month"`
	StartYear        types.Int64  `tfsdk:"start_year"`
	StartPending     types.Bool   `tfsdk:"start_pending"`
	StartAfterHour   types.Int64  `tfsdk:"start_after_hour"`
	StartAfterMinute types.Int64  `tfsdk:"start_after_minute"`
	StartAfterSecond types.Int64  `tfsdk:"start_after_second"`
	StartNow         types.Bool   `tfsdk:"start_now"`
	Recurring        types.Bool   `tfsdk:"recurring"`
	Ageout           types.Int64  `tfsdk:"ageout"`
}
type IPSLAOperationsIcmpEchoStatisticsIntervals struct {
	Interval types.Int64 `tfsdk:"interval"`
	Buckets  types.Int64 `tfsdk:"buckets"`
}
type IPSLAOperationsUdpEchoStatisticsIntervals struct {
	Interval types.Int64 `tfsdk:"interval"`
	Buckets  types.Int64 `tfsdk:"buckets"`
}
type IPSLAOperationsUdpJitterStatisticsIntervals struct {
	Interval types.Int64 `tfsdk:"interval"`
	Buckets  types.Int64 `tfsdk:"buckets"`
}
type IPSLAOperationsMplsLspPingStatisticsIntervals struct {
	Interval types.Int64 `tfsdk:"interval"`
	Buckets  types.Int64 `tfsdk:"buckets"`
}

// End of section. //template:end types

// Section below is generated&owned by "gen/generator.go". //template:begin getPath

func (data IPSLA) getPath() string {
	return "Cisco-IOS-XR-um-ipsla-cfg:/ipsla"
}

func (data IPSLAData) getPath() string {
	return "Cisco-IOS-XR-um-ipsla-cfg:/ipsla"
}

// getXPath returns the XPath for NETCONF operations
func (data IPSLA) getXPath() string {
	path := "Cisco-IOS-XR-um-ipsla-cfg:/ipsla"
	return path
}

func (data IPSLAData) getXPath() string {
	path := "Cisco-IOS-XR-um-ipsla-cfg:/ipsla"
	return path
}

// End of section. //template:end getPath

// Section below is generated&owned by "gen/generator.go". //template:begin toBody

func (data IPSLA) toBody(ctx context.Context) string {
	body := "{}"
	if !data.LowMemory.IsNull() && !data.LowMemory.IsUnknown() {
		body, _ = sjson.Set(body, "low-memory", strconv.FormatInt(data.LowMemory.ValueInt64(), 10))
	}
	if !data.KeyChain.IsNull() && !data.KeyChain.IsUnknown() {
		body, _ = sjson.Set(body, "key-chain", data.KeyChain.ValueString())
	}
	if !data.HwTimestampDisable.IsNull() && !data.HwTimestampDisable.IsUnknown() {
		if data.HwTimestampDisable.ValueBool() {
			body, _ = sjson.Set(body, "hw-timestamp.disable", map[string]string{})
		}
	}
	if !data.ServerTwamp.IsNull() && !data.ServerTwamp.IsUnknown() {
		if data.ServerTwamp.ValueBool() {
			body, _ = sjson.Set(body, "server.twamp", map[string]string{})
		}
	}
	if !data.ServerTwampPort.IsNull() && !data.ServerTwampPort.IsUnknown() {
		body, _ = sjson.Set(body, "server.twamp.port", strconv.FormatInt(data.ServerTwampPort.ValueInt64(), 10))
	}
	if !data.ServerTwampTimerInactivity.IsNull() && !data.ServerTwampTimerInactivity.IsUnknown() {
		body, _ = sjson.Set(body, "server.twamp.timer.inactivity", strconv.FormatInt(data.ServerTwampTimerInactivity.ValueInt64(), 10))
	}
	if len(data.Operations) > 0 {
		body, _ = sjson.Set(body, "operations.operation", []interface{}{})
		for index, item := range data.Operations {
			if !item.OperationNumber.IsNull() && !item.OperationNumber.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"operation-number", strconv.FormatInt(item.OperationNumber.ValueInt64(), 10))
			}
			if !item.IcmpEcho.IsNull() && !item.IcmpEcho.IsUnknown() {
				if item.IcmpEcho.ValueBool() {
					body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.echo", map[string]string{})
				}
			}
			if !item.IcmpEchoTag.IsNull() && !item.IcmpEchoTag.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.echo.tag", item.IcmpEchoTag.ValueString())
			}
			if !item.IcmpEchoFrequency.IsNull() && !item.IcmpEchoFrequency.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.echo.frequency", strconv.FormatInt(item.IcmpEchoFrequency.ValueInt64(), 10))
			}
			if !item.IcmpEchoDatasizeRequest.IsNull() && !item.IcmpEchoDatasizeRequest.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.echo.datasize.request.enter-request-datasize-in-byte", strconv.FormatInt(item.IcmpEchoDatasizeRequest.ValueInt64(), 10))
			}
			if !item.IcmpEchoTimeout.IsNull() && !item.IcmpEchoTimeout.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.echo.timeout", strconv.FormatInt(item.IcmpEchoTimeout.ValueInt64(), 10))
			}
			if !item.IcmpEchoSourceIpv4.IsNull() && !item.IcmpEchoSourceIpv4.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.echo.source.address.ipv4-address", item.IcmpEchoSourceIpv4.ValueString())
			}
			if !item.IcmpEchoSourceIpv6.IsNull() && !item.IcmpEchoSourceIpv6.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.echo.source.address.ipv6-address", item.IcmpEchoSourceIpv6.ValueString())
			}
			if !item.IcmpEchoTos.IsNull() && !item.IcmpEchoTos.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.echo.tos", strconv.FormatInt(item.IcmpEchoTos.ValueInt64(), 10))
			}
			if !item.IcmpEchoVrf.IsNull() && !item.IcmpEchoVrf.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.echo.vrf", item.IcmpEchoVrf.ValueString())
			}
			if !item.IcmpEchoDestinationIpv4.IsNull() && !item.IcmpEchoDestinationIpv4.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.echo.destination.address.ipv4-address", item.IcmpEchoDestinationIpv4.ValueString())
			}
			if !item.IcmpEchoDestinationIpv6.IsNull() && !item.IcmpEchoDestinationIpv6.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.echo.destination.address.ipv6-address", item.IcmpEchoDestinationIpv6.ValueString())
			}
			if !item.IcmpEchoHistoryBuckets.IsNull() && !item.IcmpEchoHistoryBuckets.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.echo.history.buckets", strconv.FormatInt(item.IcmpEchoHistoryBuckets.ValueInt64(), 10))
			}
			if !item.IcmpEchoHistoryFilterAll.IsNull() && !item.IcmpEchoHistoryFilterAll.IsUnknown() {
				if item.IcmpEchoHistoryFilterAll.ValueBool() {
					body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.echo.history.filter.all", map[string]string{})
				}
			}
			if !item.IcmpEchoHistoryFilterFailures.IsNull() && !item.IcmpEchoHistoryFilterFailures.IsUnknown() {
				if item.IcmpEchoHistoryFilterFailures.ValueBool() {
					body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.echo.history.filter.failures", map[string]string{})
				}
			}
			if !item.IcmpEchoHistoryLives.IsNull() && !item.IcmpEchoHistoryLives.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.echo.history.lives", strconv.FormatInt(item.IcmpEchoHistoryLives.ValueInt64(), 10))
			}
			if !item.IcmpEchoStatisticsHourlyBuckets.IsNull() && !item.IcmpEchoStatisticsHourlyBuckets.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.echo.statistics.hourly.buckets", strconv.FormatInt(item.IcmpEchoStatisticsHourlyBuckets.ValueInt64(), 10))
			}
			if !item.IcmpEchoStatisticsHourlyDistributionCount.IsNull() && !item.IcmpEchoStatisticsHourlyDistributionCount.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.echo.statistics.hourly.distribution.count", strconv.FormatInt(item.IcmpEchoStatisticsHourlyDistributionCount.ValueInt64(), 10))
			}
			if !item.IcmpEchoStatisticsHourlyDistributionInterval.IsNull() && !item.IcmpEchoStatisticsHourlyDistributionInterval.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.echo.statistics.hourly.distribution.interval", strconv.FormatInt(item.IcmpEchoStatisticsHourlyDistributionInterval.ValueInt64(), 10))
			}
			if !item.IcmpPathEcho.IsNull() && !item.IcmpPathEcho.IsUnknown() {
				if item.IcmpPathEcho.ValueBool() {
					body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-echo", map[string]string{})
				}
			}
			if !item.IcmpPathEchoTag.IsNull() && !item.IcmpPathEchoTag.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-echo.tag", item.IcmpPathEchoTag.ValueString())
			}
			if !item.IcmpPathEchoFrequency.IsNull() && !item.IcmpPathEchoFrequency.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-echo.frequency", strconv.FormatInt(item.IcmpPathEchoFrequency.ValueInt64(), 10))
			}
			if !item.IcmpPathEchoDatasizeRequest.IsNull() && !item.IcmpPathEchoDatasizeRequest.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-echo.datasize.request.enter-request-datasize-in-byte", strconv.FormatInt(item.IcmpPathEchoDatasizeRequest.ValueInt64(), 10))
			}
			if !item.IcmpPathEchoTimeout.IsNull() && !item.IcmpPathEchoTimeout.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-echo.timeout", strconv.FormatInt(item.IcmpPathEchoTimeout.ValueInt64(), 10))
			}
			if !item.IcmpPathEchoSourceIpv4.IsNull() && !item.IcmpPathEchoSourceIpv4.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-echo.source.address.ipv4-address", item.IcmpPathEchoSourceIpv4.ValueString())
			}
			if !item.IcmpPathEchoTos.IsNull() && !item.IcmpPathEchoTos.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-echo.tos", strconv.FormatInt(item.IcmpPathEchoTos.ValueInt64(), 10))
			}
			if !item.IcmpPathEchoDestinationIpv4.IsNull() && !item.IcmpPathEchoDestinationIpv4.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-echo.destination.address.address", item.IcmpPathEchoDestinationIpv4.ValueString())
			}
			if !item.IcmpPathEchoHistoryBuckets.IsNull() && !item.IcmpPathEchoHistoryBuckets.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-echo.history.buckets", strconv.FormatInt(item.IcmpPathEchoHistoryBuckets.ValueInt64(), 10))
			}
			if !item.IcmpPathEchoHistoryFilterAll.IsNull() && !item.IcmpPathEchoHistoryFilterAll.IsUnknown() {
				if item.IcmpPathEchoHistoryFilterAll.ValueBool() {
					body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-echo.history.filter.all", map[string]string{})
				}
			}
			if !item.IcmpPathEchoHistoryFilterFailures.IsNull() && !item.IcmpPathEchoHistoryFilterFailures.IsUnknown() {
				if item.IcmpPathEchoHistoryFilterFailures.ValueBool() {
					body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-echo.history.filter.failures", map[string]string{})
				}
			}
			if !item.IcmpPathEchoHistoryLives.IsNull() && !item.IcmpPathEchoHistoryLives.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-echo.history.lives", strconv.FormatInt(item.IcmpPathEchoHistoryLives.ValueInt64(), 10))
			}
			if !item.IcmpPathEchoHistorySamples.IsNull() && !item.IcmpPathEchoHistorySamples.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-echo.history.samples", strconv.FormatInt(item.IcmpPathEchoHistorySamples.ValueInt64(), 10))
			}
			if !item.IcmpPathEchoStatisticsHourlyBuckets.IsNull() && !item.IcmpPathEchoStatisticsHourlyBuckets.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-echo.statistics.hourly.buckets", strconv.FormatInt(item.IcmpPathEchoStatisticsHourlyBuckets.ValueInt64(), 10))
			}
			if !item.IcmpPathEchoStatisticsHourlyDistributionCount.IsNull() && !item.IcmpPathEchoStatisticsHourlyDistributionCount.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-echo.statistics.hourly.distribution.count", strconv.FormatInt(item.IcmpPathEchoStatisticsHourlyDistributionCount.ValueInt64(), 10))
			}
			if !item.IcmpPathEchoStatisticsHourlyDistributionInterval.IsNull() && !item.IcmpPathEchoStatisticsHourlyDistributionInterval.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-echo.statistics.hourly.distribution.interval", strconv.FormatInt(item.IcmpPathEchoStatisticsHourlyDistributionInterval.ValueInt64(), 10))
			}
			if !item.IcmpPathEchoStatisticsHourlyMaximumHops.IsNull() && !item.IcmpPathEchoStatisticsHourlyMaximumHops.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-echo.statistics.hourly.maximum.hops", strconv.FormatInt(item.IcmpPathEchoStatisticsHourlyMaximumHops.ValueInt64(), 10))
			}
			if !item.IcmpPathEchoStatisticsHourlyMaximumPaths.IsNull() && !item.IcmpPathEchoStatisticsHourlyMaximumPaths.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-echo.statistics.hourly.maximum.paths", strconv.FormatInt(item.IcmpPathEchoStatisticsHourlyMaximumPaths.ValueInt64(), 10))
			}
			if !item.IcmpPathJitter.IsNull() && !item.IcmpPathJitter.IsUnknown() {
				if item.IcmpPathJitter.ValueBool() {
					body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-jitter", map[string]string{})
				}
			}
			if !item.IcmpPathJitterTag.IsNull() && !item.IcmpPathJitterTag.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-jitter.tag", item.IcmpPathJitterTag.ValueString())
			}
			if !item.IcmpPathJitterFrequency.IsNull() && !item.IcmpPathJitterFrequency.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-jitter.frequency", strconv.FormatInt(item.IcmpPathJitterFrequency.ValueInt64(), 10))
			}
			if !item.IcmpPathJitterDatasizeRequest.IsNull() && !item.IcmpPathJitterDatasizeRequest.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-jitter.datasize.request.enter-request-datasize-in-byte", strconv.FormatInt(item.IcmpPathJitterDatasizeRequest.ValueInt64(), 10))
			}
			if !item.IcmpPathJitterTimeout.IsNull() && !item.IcmpPathJitterTimeout.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-jitter.timeout", strconv.FormatInt(item.IcmpPathJitterTimeout.ValueInt64(), 10))
			}
			if !item.IcmpPathJitterSourceIpv4.IsNull() && !item.IcmpPathJitterSourceIpv4.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-jitter.source.address.ipv4-address", item.IcmpPathJitterSourceIpv4.ValueString())
			}
			if !item.IcmpPathJitterPacketCount.IsNull() && !item.IcmpPathJitterPacketCount.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-jitter.packet.count", strconv.FormatInt(item.IcmpPathJitterPacketCount.ValueInt64(), 10))
			}
			if !item.IcmpPathJitterPacketInterval.IsNull() && !item.IcmpPathJitterPacketInterval.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-jitter.packet.interval", strconv.FormatInt(item.IcmpPathJitterPacketInterval.ValueInt64(), 10))
			}
			if !item.IcmpPathJitterTos.IsNull() && !item.IcmpPathJitterTos.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-jitter.tos", strconv.FormatInt(item.IcmpPathJitterTos.ValueInt64(), 10))
			}
			if !item.IcmpPathJitterDestinationIpv4.IsNull() && !item.IcmpPathJitterDestinationIpv4.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.path-jitter.destination.address.address", item.IcmpPathJitterDestinationIpv4.ValueString())
			}
			if !item.UdpEcho.IsNull() && !item.UdpEcho.IsUnknown() {
				if item.UdpEcho.ValueBool() {
					body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo", map[string]string{})
				}
			}
			if !item.UdpEchoTag.IsNull() && !item.UdpEchoTag.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo.tag", item.UdpEchoTag.ValueString())
			}
			if !item.UdpEchoFrequency.IsNull() && !item.UdpEchoFrequency.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo.frequency", strconv.FormatInt(item.UdpEchoFrequency.ValueInt64(), 10))
			}
			if !item.UdpEchoDatasizeRequest.IsNull() && !item.UdpEchoDatasizeRequest.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo.datasize.request.enter-request-datasize-in-byte", strconv.FormatInt(item.UdpEchoDatasizeRequest.ValueInt64(), 10))
			}
			if !item.UdpEchoTimeout.IsNull() && !item.UdpEchoTimeout.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo.timeout", strconv.FormatInt(item.UdpEchoTimeout.ValueInt64(), 10))
			}
			if !item.UdpEchoSourceIpv4.IsNull() && !item.UdpEchoSourceIpv4.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo.source.address.ipv4-address", item.UdpEchoSourceIpv4.ValueString())
			}
			if !item.UdpEchoSourcePort.IsNull() && !item.UdpEchoSourcePort.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo.source.port", strconv.FormatInt(item.UdpEchoSourcePort.ValueInt64(), 10))
			}
			if !item.UdpEchoDestinationIpv4.IsNull() && !item.UdpEchoDestinationIpv4.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo.destination.address", item.UdpEchoDestinationIpv4.ValueString())
			}
			if !item.UdpEchoDestinationPort.IsNull() && !item.UdpEchoDestinationPort.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo.destination.port", strconv.FormatInt(item.UdpEchoDestinationPort.ValueInt64(), 10))
			}
			if !item.UdpEchoControlDisable.IsNull() && !item.UdpEchoControlDisable.IsUnknown() {
				if item.UdpEchoControlDisable.ValueBool() {
					body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo.control.disable", map[string]string{})
				}
			}
			if !item.UdpEchoVerifyData.IsNull() && !item.UdpEchoVerifyData.IsUnknown() {
				if item.UdpEchoVerifyData.ValueBool() {
					body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo.verify-data", map[string]string{})
				}
			}
			if !item.UdpEchoTos.IsNull() && !item.UdpEchoTos.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo.tos", strconv.FormatInt(item.UdpEchoTos.ValueInt64(), 10))
			}
			if !item.UdpEchoVrf.IsNull() && !item.UdpEchoVrf.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo.vrf", item.UdpEchoVrf.ValueString())
			}
			if !item.UdpEchoStatisticsHourlyBuckets.IsNull() && !item.UdpEchoStatisticsHourlyBuckets.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo.statistics.hourly.buckets", strconv.FormatInt(item.UdpEchoStatisticsHourlyBuckets.ValueInt64(), 10))
			}
			if !item.UdpEchoStatisticsHourlyDistributionCount.IsNull() && !item.UdpEchoStatisticsHourlyDistributionCount.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo.statistics.hourly.distribution.count", strconv.FormatInt(item.UdpEchoStatisticsHourlyDistributionCount.ValueInt64(), 10))
			}
			if !item.UdpEchoStatisticsHourlyDistributionInterval.IsNull() && !item.UdpEchoStatisticsHourlyDistributionInterval.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo.statistics.hourly.distribution.interval", strconv.FormatInt(item.UdpEchoStatisticsHourlyDistributionInterval.ValueInt64(), 10))
			}
			if !item.UdpEchoHistoryBuckets.IsNull() && !item.UdpEchoHistoryBuckets.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo.history.buckets", strconv.FormatInt(item.UdpEchoHistoryBuckets.ValueInt64(), 10))
			}
			if !item.UdpEchoHistoryFilterAll.IsNull() && !item.UdpEchoHistoryFilterAll.IsUnknown() {
				if item.UdpEchoHistoryFilterAll.ValueBool() {
					body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo.history.filter.all", map[string]string{})
				}
			}
			if !item.UdpEchoHistoryFilterFailures.IsNull() && !item.UdpEchoHistoryFilterFailures.IsUnknown() {
				if item.UdpEchoHistoryFilterFailures.ValueBool() {
					body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo.history.filter.failures", map[string]string{})
				}
			}
			if !item.UdpEchoHistoryLives.IsNull() && !item.UdpEchoHistoryLives.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo.history.lives", strconv.FormatInt(item.UdpEchoHistoryLives.ValueInt64(), 10))
			}
			if !item.UdpJitter.IsNull() && !item.UdpJitter.IsUnknown() {
				if item.UdpJitter.ValueBool() {
					body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.jitter", map[string]string{})
				}
			}
			if !item.UdpJitterTag.IsNull() && !item.UdpJitterTag.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.jitter.tag", item.UdpJitterTag.ValueString())
			}
			if !item.UdpJitterFrequency.IsNull() && !item.UdpJitterFrequency.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.jitter.frequency", strconv.FormatInt(item.UdpJitterFrequency.ValueInt64(), 10))
			}
			if !item.UdpJitterDatasizeRequest.IsNull() && !item.UdpJitterDatasizeRequest.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.jitter.datasize.request.enter-request-datasize-in-byte", strconv.FormatInt(item.UdpJitterDatasizeRequest.ValueInt64(), 10))
			}
			if !item.UdpJitterTimeout.IsNull() && !item.UdpJitterTimeout.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.jitter.timeout", strconv.FormatInt(item.UdpJitterTimeout.ValueInt64(), 10))
			}
			if !item.UdpJitterSourceIpv4.IsNull() && !item.UdpJitterSourceIpv4.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.jitter.source.address.ipv4-address", item.UdpJitterSourceIpv4.ValueString())
			}
			if !item.UdpJitterSourcePort.IsNull() && !item.UdpJitterSourcePort.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.jitter.source.port", strconv.FormatInt(item.UdpJitterSourcePort.ValueInt64(), 10))
			}
			if !item.UdpJitterDestinationIpv4.IsNull() && !item.UdpJitterDestinationIpv4.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.jitter.destination.address", item.UdpJitterDestinationIpv4.ValueString())
			}
			if !item.UdpJitterDestinationPort.IsNull() && !item.UdpJitterDestinationPort.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.jitter.destination.port", strconv.FormatInt(item.UdpJitterDestinationPort.ValueInt64(), 10))
			}
			if !item.UdpJitterPacketCount.IsNull() && !item.UdpJitterPacketCount.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.jitter.packet.count", strconv.FormatInt(item.UdpJitterPacketCount.ValueInt64(), 10))
			}
			if !item.UdpJitterPacketInterval.IsNull() && !item.UdpJitterPacketInterval.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.jitter.packet.interval", strconv.FormatInt(item.UdpJitterPacketInterval.ValueInt64(), 10))
			}
			if !item.UdpJitterTos.IsNull() && !item.UdpJitterTos.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.jitter.tos", strconv.FormatInt(item.UdpJitterTos.ValueInt64(), 10))
			}
			if !item.UdpJitterVrf.IsNull() && !item.UdpJitterVrf.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.jitter.vrf", item.UdpJitterVrf.ValueString())
			}
			if !item.UdpJitterControlDisable.IsNull() && !item.UdpJitterControlDisable.IsUnknown() {
				if item.UdpJitterControlDisable.ValueBool() {
					body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.jitter.control.disable", map[string]string{})
				}
			}
			if !item.UdpJitterVerifyData.IsNull() && !item.UdpJitterVerifyData.IsUnknown() {
				if item.UdpJitterVerifyData.ValueBool() {
					body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.jitter.verify-data", map[string]string{})
				}
			}
			if !item.UdpJitterStatisticsHourlyBuckets.IsNull() && !item.UdpJitterStatisticsHourlyBuckets.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.jitter.statistics.hourly.buckets", strconv.FormatInt(item.UdpJitterStatisticsHourlyBuckets.ValueInt64(), 10))
			}
			if !item.UdpJitterStatisticsHourlyDistributionCount.IsNull() && !item.UdpJitterStatisticsHourlyDistributionCount.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.jitter.statistics.hourly.distribution.count", strconv.FormatInt(item.UdpJitterStatisticsHourlyDistributionCount.ValueInt64(), 10))
			}
			if !item.UdpJitterStatisticsHourlyDistributionInterval.IsNull() && !item.UdpJitterStatisticsHourlyDistributionInterval.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.jitter.statistics.hourly.distribution.interval", strconv.FormatInt(item.UdpJitterStatisticsHourlyDistributionInterval.ValueInt64(), 10))
			}
			if !item.MplsLspPing.IsNull() && !item.MplsLspPing.IsUnknown() {
				if item.MplsLspPing.ValueBool() {
					body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.ping", map[string]string{})
				}
			}
			if !item.MplsLspPingTag.IsNull() && !item.MplsLspPingTag.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.ping.tag", item.MplsLspPingTag.ValueString())
			}
			if !item.MplsLspPingFrequency.IsNull() && !item.MplsLspPingFrequency.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.ping.frequency", strconv.FormatInt(item.MplsLspPingFrequency.ValueInt64(), 10))
			}
			if !item.MplsLspPingDatasizeRequest.IsNull() && !item.MplsLspPingDatasizeRequest.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.ping.datasize.request.enter-request-datasize-in-byte", strconv.FormatInt(item.MplsLspPingDatasizeRequest.ValueInt64(), 10))
			}
			if !item.MplsLspPingTimeout.IsNull() && !item.MplsLspPingTimeout.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.ping.timeout", strconv.FormatInt(item.MplsLspPingTimeout.ValueInt64(), 10))
			}
			if !item.MplsLspPingSourceIpv4.IsNull() && !item.MplsLspPingSourceIpv4.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.ping.source.address.ipv4-address", item.MplsLspPingSourceIpv4.ValueString())
			}
			if !item.MplsLspPingTargetIpv4.IsNull() && !item.MplsLspPingTargetIpv4.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.ping.target.ipv4.address", item.MplsLspPingTargetIpv4.ValueString())
			}
			if !item.MplsLspPingTargetIpv4Mask.IsNull() && !item.MplsLspPingTargetIpv4Mask.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.ping.target.ipv4.mask", item.MplsLspPingTargetIpv4Mask.ValueString())
			}
			if !item.MplsLspPingTargetTeTunnel.IsNull() && !item.MplsLspPingTargetTeTunnel.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.ping.target.traffic-eng.tunnel", strconv.FormatInt(item.MplsLspPingTargetTeTunnel.ValueInt64(), 10))
			}
			if !item.MplsLspPingTargetPseudowireAddress.IsNull() && !item.MplsLspPingTargetPseudowireAddress.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.ping.target.pseudowire.address", item.MplsLspPingTargetPseudowireAddress.ValueString())
			}
			if !item.MplsLspPingTargetPseudowireVcId.IsNull() && !item.MplsLspPingTargetPseudowireVcId.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.ping.target.pseudowire.virtual-circuit-id", strconv.FormatInt(item.MplsLspPingTargetPseudowireVcId.ValueInt64(), 10))
			}
			if !item.MplsLspPingStatisticsHourlyBuckets.IsNull() && !item.MplsLspPingStatisticsHourlyBuckets.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.ping.statistics.hourly.buckets", strconv.FormatInt(item.MplsLspPingStatisticsHourlyBuckets.ValueInt64(), 10))
			}
			if !item.MplsLspPingStatisticsHourlyDistributionCount.IsNull() && !item.MplsLspPingStatisticsHourlyDistributionCount.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.ping.statistics.hourly.distribution.count", strconv.FormatInt(item.MplsLspPingStatisticsHourlyDistributionCount.ValueInt64(), 10))
			}
			if !item.MplsLspPingStatisticsHourlyDistributionInterval.IsNull() && !item.MplsLspPingStatisticsHourlyDistributionInterval.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.ping.statistics.hourly.distribution.interval", strconv.FormatInt(item.MplsLspPingStatisticsHourlyDistributionInterval.ValueInt64(), 10))
			}
			if !item.MplsLspTrace.IsNull() && !item.MplsLspTrace.IsUnknown() {
				if item.MplsLspTrace.ValueBool() {
					body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.trace", map[string]string{})
				}
			}
			if !item.MplsLspTraceTag.IsNull() && !item.MplsLspTraceTag.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.trace.tag", item.MplsLspTraceTag.ValueString())
			}
			if !item.MplsLspTraceFrequency.IsNull() && !item.MplsLspTraceFrequency.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.trace.frequency", strconv.FormatInt(item.MplsLspTraceFrequency.ValueInt64(), 10))
			}
			if !item.MplsLspTraceTimeout.IsNull() && !item.MplsLspTraceTimeout.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.trace.timeout", strconv.FormatInt(item.MplsLspTraceTimeout.ValueInt64(), 10))
			}
			if !item.MplsLspTraceSourceIpv4.IsNull() && !item.MplsLspTraceSourceIpv4.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.trace.source.address.ipv4-address", item.MplsLspTraceSourceIpv4.ValueString())
			}
			if !item.MplsLspTraceTargetIpv4.IsNull() && !item.MplsLspTraceTargetIpv4.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.trace.target.ipv4.address", item.MplsLspTraceTargetIpv4.ValueString())
			}
			if !item.MplsLspTraceTargetIpv4Mask.IsNull() && !item.MplsLspTraceTargetIpv4Mask.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.trace.target.ipv4.mask", item.MplsLspTraceTargetIpv4Mask.ValueString())
			}
			if !item.MplsLspTraceTargetTeTunnel.IsNull() && !item.MplsLspTraceTargetTeTunnel.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.trace.target.traffic-eng.tunnel", strconv.FormatInt(item.MplsLspTraceTargetTeTunnel.ValueInt64(), 10))
			}
			if !item.MplsLspTraceTargetPseudowireAddress.IsNull() && !item.MplsLspTraceTargetPseudowireAddress.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.trace.target.pseudowire.address", item.MplsLspTraceTargetPseudowireAddress.ValueString())
			}
			if !item.MplsLspTraceTargetPseudowireVcId.IsNull() && !item.MplsLspTraceTargetPseudowireVcId.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.trace.target.pseudowire.virtual-circuit-id", strconv.FormatInt(item.MplsLspTraceTargetPseudowireVcId.ValueInt64(), 10))
			}
			if !item.MplsLspTraceStatisticsHourlyBuckets.IsNull() && !item.MplsLspTraceStatisticsHourlyBuckets.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.trace.statistics.hourly.buckets", strconv.FormatInt(item.MplsLspTraceStatisticsHourlyBuckets.ValueInt64(), 10))
			}
			if !item.MplsLspTraceStatisticsHourlyDistributionCount.IsNull() && !item.MplsLspTraceStatisticsHourlyDistributionCount.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.trace.statistics.hourly.distribution.count", strconv.FormatInt(item.MplsLspTraceStatisticsHourlyDistributionCount.ValueInt64(), 10))
			}
			if !item.MplsLspTraceStatisticsHourlyDistributionInterval.IsNull() && !item.MplsLspTraceStatisticsHourlyDistributionInterval.IsUnknown() {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.trace.statistics.hourly.distribution.interval", strconv.FormatInt(item.MplsLspTraceStatisticsHourlyDistributionInterval.ValueInt64(), 10))
			}
			if len(item.IcmpEchoStatisticsIntervals) > 0 {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.echo.statistics.intervals.interval", []interface{}{})
				for cindex, citem := range item.IcmpEchoStatisticsIntervals {
					if !citem.Interval.IsNull() && !citem.Interval.IsUnknown() {
						body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.echo.statistics.intervals.interval"+"."+strconv.Itoa(cindex)+"."+"interval-time", strconv.FormatInt(citem.Interval.ValueInt64(), 10))
					}
					if !citem.Buckets.IsNull() && !citem.Buckets.IsUnknown() {
						body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.icmp.echo.statistics.intervals.interval"+"."+strconv.Itoa(cindex)+"."+"buckets", strconv.FormatInt(citem.Buckets.ValueInt64(), 10))
					}
				}
			}
			if len(item.UdpEchoStatisticsIntervals) > 0 {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo.statistics.intervals.interval", []interface{}{})
				for cindex, citem := range item.UdpEchoStatisticsIntervals {
					if !citem.Interval.IsNull() && !citem.Interval.IsUnknown() {
						body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo.statistics.intervals.interval"+"."+strconv.Itoa(cindex)+"."+"interval-time", strconv.FormatInt(citem.Interval.ValueInt64(), 10))
					}
					if !citem.Buckets.IsNull() && !citem.Buckets.IsUnknown() {
						body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.echo.statistics.intervals.interval"+"."+strconv.Itoa(cindex)+"."+"buckets", strconv.FormatInt(citem.Buckets.ValueInt64(), 10))
					}
				}
			}
			if len(item.UdpJitterStatisticsIntervals) > 0 {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.jitter.statistics.intervals.interval", []interface{}{})
				for cindex, citem := range item.UdpJitterStatisticsIntervals {
					if !citem.Interval.IsNull() && !citem.Interval.IsUnknown() {
						body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.jitter.statistics.intervals.interval"+"."+strconv.Itoa(cindex)+"."+"interval-time", strconv.FormatInt(citem.Interval.ValueInt64(), 10))
					}
					if !citem.Buckets.IsNull() && !citem.Buckets.IsUnknown() {
						body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.udp.jitter.statistics.intervals.interval"+"."+strconv.Itoa(cindex)+"."+"buckets", strconv.FormatInt(citem.Buckets.ValueInt64(), 10))
					}
				}
			}
			if len(item.MplsLspPingStatisticsIntervals) > 0 {
				body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.ping.statistics.intervals.interval", []interface{}{})
				for cindex, citem := range item.MplsLspPingStatisticsIntervals {
					if !citem.Interval.IsNull() && !citem.Interval.IsUnknown() {
						body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.ping.statistics.intervals.interval"+"."+strconv.Itoa(cindex)+"."+"interval-time", strconv.FormatInt(citem.Interval.ValueInt64(), 10))
					}
					if !citem.Buckets.IsNull() && !citem.Buckets.IsUnknown() {
						body, _ = sjson.Set(body, "operations.operation"+"."+strconv.Itoa(index)+"."+"type.mpls.lsp.ping.statistics.intervals.interval"+"."+strconv.Itoa(cindex)+"."+"buckets", strconv.FormatInt(citem.Buckets.ValueInt64(), 10))
					}
				}
			}
		}
	}
	if len(data.Schedules) > 0 {
		body, _ = sjson.Set(body, "schedule.operations.operation", []interface{}{})
		for index, item := range data.Schedules {
			if !item.OperationNumber.IsNull() && !item.OperationNumber.IsUnknown() {
				body, _ = sjson.Set(body, "schedule.operations.operation"+"."+strconv.Itoa(index)+"."+"operation-number", strconv.FormatInt(item.OperationNumber.ValueInt64(), 10))
			}
			if !item.LifeForever.IsNull() && !item.LifeForever.IsUnknown() {
				if item.LifeForever.ValueBool() {
					body, _ = sjson.Set(body, "schedule.operations.operation"+"."+strconv.Itoa(index)+"."+"life.forever", map[string]string{})
				}
			}
			if !item.LifeTime.IsNull() && !item.LifeTime.IsUnknown() {
				body, _ = sjson.Set(body, "schedule.operations.operation"+"."+strconv.Itoa(index)+"."+"life.length-of-time", strconv.FormatInt(item.LifeTime.ValueInt64(), 10))
			}
			if !item.StartHour.IsNull() && !item.StartHour.IsUnknown() {
				body, _ = sjson.Set(body, "schedule.operations.operation"+"."+strconv.Itoa(index)+"."+"start-time.time-and-date.hour", strconv.FormatInt(item.StartHour.ValueInt64(), 10))
			}
			if !item.StartMinute.IsNull() && !item.StartMinute.IsUnknown() {
				body, _ = sjson.Set(body, "schedule.operations.operation"+"."+strconv.Itoa(index)+"."+"start-time.time-and-date.minute", strconv.FormatInt(item.StartMinute.ValueInt64(), 10))
			}
			if !item.StartSecond.IsNull() && !item.StartSecond.IsUnknown() {
				body, _ = sjson.Set(body, "schedule.operations.operation"+"."+strconv.Itoa(index)+"."+"start-time.time-and-date.second", strconv.FormatInt(item.StartSecond.ValueInt64(), 10))
			}
			if !item.StartMonth.IsNull() && !item.StartMonth.IsUnknown() {
				body, _ = sjson.Set(body, "schedule.operations.operation"+"."+strconv.Itoa(index)+"."+"start-time.time-and-date.month", item.StartMonth.ValueString())
			}
			if !item.StartDayOfMonth.IsNull() && !item.StartDayOfMonth.IsUnknown() {
				body, _ = sjson.Set(body, "schedule.operations.operation"+"."+strconv.Itoa(index)+"."+"start-time.time-and-date.day-of-month", strconv.FormatInt(item.StartDayOfMonth.ValueInt64(), 10))
			}
			if !item.StartYear.IsNull() && !item.StartYear.IsUnknown() {
				body, _ = sjson.Set(body, "schedule.operations.operation"+"."+strconv.Itoa(index)+"."+"start-time.time-and-date.year", strconv.FormatInt(item.StartYear.ValueInt64(), 10))
			}
			if !item.StartPending.IsNull() && !item.StartPending.IsUnknown() {
				if item.StartPending.ValueBool() {
					body, _ = sjson.Set(body, "schedule.operations.operation"+"."+strconv.Itoa(index)+"."+"start-time.pending", map[string]string{})
				}
			}
			if !item.StartAfterHour.IsNull() && !item.StartAfterHour.IsUnknown() {
				body, _ = sjson.Set(body, "schedule.operations.operation"+"."+strconv.Itoa(index)+"."+"start-time.after.time.hour", strconv.FormatInt(item.StartAfterHour.ValueInt64(), 10))
			}
			if !item.StartAfterMinute.IsNull() && !item.StartAfterMinute.IsUnknown() {
				body, _ = sjson.Set(body, "schedule.operations.operation"+"."+strconv.Itoa(index)+"."+"start-time.after.time.minute", strconv.FormatInt(item.StartAfterMinute.ValueInt64(), 10))
			}
			if !item.StartAfterSecond.IsNull() && !item.StartAfterSecond.IsUnknown() {
				body, _ = sjson.Set(body, "schedule.operations.operation"+"."+strconv.Itoa(index)+"."+"start-time.after.time.second", strconv.FormatInt(item.StartAfterSecond.ValueInt64(), 10))
			}
			if !item.StartNow.IsNull() && !item.StartNow.IsUnknown() {
				if item.StartNow.ValueBool() {
					body, _ = sjson.Set(body, "schedule.operations.operation"+"."+strconv.Itoa(index)+"."+"start-time.now", map[string]string{})
				}
			}
			if !item.Recurring.IsNull() && !item.Recurring.IsUnknown() {
				if item.Recurring.ValueBool() {
					body, _ = sjson.Set(body, "schedule.operations.operation"+"."+strconv.Itoa(index)+"."+"recurring", map[string]string{})
				}
			}
			if !item.Ageout.IsNull() && !item.Ageout.IsUnknown() {
				body, _ = sjson.Set(body, "schedule.operations.operation"+"."+strconv.Itoa(index)+"."+"ageout", strconv.FormatInt(item.Ageout.ValueInt64(), 10))
			}
		}
	}
	return body
}

// End of section. //template:end toBody

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBody

func (data *IPSLA) updateFromBody(ctx context.Context, res []byte) {
	if value := gjson.GetBytes(res, "low-memory"); value.Exists() && !data.LowMemory.IsNull() {
		data.LowMemory = types.Int64Value(value.Int())
	} else {
		data.LowMemory = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "key-chain"); value.Exists() && !data.KeyChain.IsNull() {
		data.KeyChain = types.StringValue(value.String())
	} else {
		data.KeyChain = types.StringNull()
	}
	if value := gjson.GetBytes(res, "hw-timestamp.disable"); value.Exists() {
		if !data.HwTimestampDisable.IsNull() {
			data.HwTimestampDisable = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.HwTimestampDisable.IsNull() {
			data.HwTimestampDisable = types.BoolNull()
		}
	}
	for i := range data.Operations {
		keys := [...]string{"operation-number"}
		keyValues := [...]string{strconv.FormatInt(data.Operations[i].OperationNumber.ValueInt64(), 10)}

		var r gjson.Result
		gjson.GetBytes(res, "operations.operation").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("operation-number"); value.Exists() && !data.Operations[i].OperationNumber.IsNull() {
			data.Operations[i].OperationNumber = types.Int64Value(value.Int())
		} else {
			data.Operations[i].OperationNumber = types.Int64Null()
		}
		if value := r.Get("type.icmp.echo"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Operations[i].IcmpEcho.IsNull() && !data.Operations[i].IcmpEcho.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Operations[i].IcmpEcho = types.BoolValue(false)
			} else if !data.Operations[i].IcmpEcho.IsNull() {
				data.Operations[i].IcmpEcho = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Operations[i].IcmpEcho.IsNull() {
				data.Operations[i].IcmpEcho = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Operations[i].IcmpEcho = types.BoolValue(false)
			}
		}
		if value := r.Get("type.icmp.echo.tag"); value.Exists() && !data.Operations[i].IcmpEchoTag.IsNull() {
			data.Operations[i].IcmpEchoTag = types.StringValue(value.String())
		} else {
			data.Operations[i].IcmpEchoTag = types.StringNull()
		}
		if value := r.Get("type.icmp.echo.frequency"); value.Exists() && !data.Operations[i].IcmpEchoFrequency.IsNull() {
			data.Operations[i].IcmpEchoFrequency = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpEchoFrequency = types.Int64Null()
		}
		if value := r.Get("type.icmp.echo.datasize.request.enter-request-datasize-in-byte"); value.Exists() && !data.Operations[i].IcmpEchoDatasizeRequest.IsNull() {
			data.Operations[i].IcmpEchoDatasizeRequest = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpEchoDatasizeRequest = types.Int64Null()
		}
		if value := r.Get("type.icmp.echo.timeout"); value.Exists() && !data.Operations[i].IcmpEchoTimeout.IsNull() {
			data.Operations[i].IcmpEchoTimeout = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpEchoTimeout = types.Int64Null()
		}
		if value := r.Get("type.icmp.echo.source.address.ipv4-address"); value.Exists() && !data.Operations[i].IcmpEchoSourceIpv4.IsNull() {
			data.Operations[i].IcmpEchoSourceIpv4 = types.StringValue(value.String())
		} else {
			data.Operations[i].IcmpEchoSourceIpv4 = types.StringNull()
		}
		if value := r.Get("type.icmp.echo.source.address.ipv6-address"); value.Exists() && !data.Operations[i].IcmpEchoSourceIpv6.IsNull() {
			data.Operations[i].IcmpEchoSourceIpv6 = types.StringValue(value.String())
		} else {
			data.Operations[i].IcmpEchoSourceIpv6 = types.StringNull()
		}
		if value := r.Get("type.icmp.echo.tos"); value.Exists() && !data.Operations[i].IcmpEchoTos.IsNull() {
			data.Operations[i].IcmpEchoTos = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpEchoTos = types.Int64Null()
		}
		if value := r.Get("type.icmp.echo.vrf"); value.Exists() && !data.Operations[i].IcmpEchoVrf.IsNull() {
			data.Operations[i].IcmpEchoVrf = types.StringValue(value.String())
		} else {
			data.Operations[i].IcmpEchoVrf = types.StringNull()
		}
		if value := r.Get("type.icmp.echo.destination.address.ipv4-address"); value.Exists() && !data.Operations[i].IcmpEchoDestinationIpv4.IsNull() {
			data.Operations[i].IcmpEchoDestinationIpv4 = types.StringValue(value.String())
		} else {
			data.Operations[i].IcmpEchoDestinationIpv4 = types.StringNull()
		}
		if value := r.Get("type.icmp.echo.destination.address.ipv6-address"); value.Exists() && !data.Operations[i].IcmpEchoDestinationIpv6.IsNull() {
			data.Operations[i].IcmpEchoDestinationIpv6 = types.StringValue(value.String())
		} else {
			data.Operations[i].IcmpEchoDestinationIpv6 = types.StringNull()
		}
		if value := r.Get("type.icmp.echo.history.buckets"); value.Exists() && !data.Operations[i].IcmpEchoHistoryBuckets.IsNull() {
			data.Operations[i].IcmpEchoHistoryBuckets = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpEchoHistoryBuckets = types.Int64Null()
		}
		if value := r.Get("type.icmp.echo.history.filter.all"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Operations[i].IcmpEchoHistoryFilterAll.IsNull() && !data.Operations[i].IcmpEchoHistoryFilterAll.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Operations[i].IcmpEchoHistoryFilterAll = types.BoolValue(false)
			} else if !data.Operations[i].IcmpEchoHistoryFilterAll.IsNull() {
				data.Operations[i].IcmpEchoHistoryFilterAll = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Operations[i].IcmpEchoHistoryFilterAll.IsNull() {
				data.Operations[i].IcmpEchoHistoryFilterAll = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Operations[i].IcmpEchoHistoryFilterAll = types.BoolValue(false)
			}
		}
		if value := r.Get("type.icmp.echo.history.filter.failures"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Operations[i].IcmpEchoHistoryFilterFailures.IsNull() && !data.Operations[i].IcmpEchoHistoryFilterFailures.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Operations[i].IcmpEchoHistoryFilterFailures = types.BoolValue(false)
			} else if !data.Operations[i].IcmpEchoHistoryFilterFailures.IsNull() {
				data.Operations[i].IcmpEchoHistoryFilterFailures = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Operations[i].IcmpEchoHistoryFilterFailures.IsNull() {
				data.Operations[i].IcmpEchoHistoryFilterFailures = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Operations[i].IcmpEchoHistoryFilterFailures = types.BoolValue(false)
			}
		}
		if value := r.Get("type.icmp.echo.history.lives"); value.Exists() && !data.Operations[i].IcmpEchoHistoryLives.IsNull() {
			data.Operations[i].IcmpEchoHistoryLives = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpEchoHistoryLives = types.Int64Null()
		}
		if value := r.Get("type.icmp.echo.statistics.hourly.buckets"); value.Exists() && !data.Operations[i].IcmpEchoStatisticsHourlyBuckets.IsNull() {
			data.Operations[i].IcmpEchoStatisticsHourlyBuckets = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpEchoStatisticsHourlyBuckets = types.Int64Null()
		}
		if value := r.Get("type.icmp.echo.statistics.hourly.distribution.count"); value.Exists() && !data.Operations[i].IcmpEchoStatisticsHourlyDistributionCount.IsNull() {
			data.Operations[i].IcmpEchoStatisticsHourlyDistributionCount = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpEchoStatisticsHourlyDistributionCount = types.Int64Null()
		}
		if value := r.Get("type.icmp.echo.statistics.hourly.distribution.interval"); value.Exists() && !data.Operations[i].IcmpEchoStatisticsHourlyDistributionInterval.IsNull() {
			data.Operations[i].IcmpEchoStatisticsHourlyDistributionInterval = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpEchoStatisticsHourlyDistributionInterval = types.Int64Null()
		}
		// Rebuild nested list from device response
		if value := r.Get("type.icmp.echo.statistics.intervals.interval"); value.Exists() {
			// Store existing state items for matching
			existingItems := data.Operations[i].IcmpEchoStatisticsIntervals
			data.Operations[i].IcmpEchoStatisticsIntervals = make([]IPSLAOperationsIcmpEchoStatisticsIntervals, 0)
			value.ForEach(func(_, cr gjson.Result) bool {
				citem := IPSLAOperationsIcmpEchoStatisticsIntervals{}
				if cValue := cr.Get("interval-time"); cValue.Exists() {
					citem.Interval = types.Int64Value(cValue.Int())
				}
				if cValue := cr.Get("buckets"); cValue.Exists() {
					citem.Buckets = types.Int64Value(cValue.Int())
				}

				// Match with existing state item by key fields
				for _, existingItem := range existingItems {
					match := true
					if !existingItem.Interval.Equal(citem.Interval) {
						match = false
					}

					if match {
						// Preserve false values for presence-based booleans
						break
					}
				}

				data.Operations[i].IcmpEchoStatisticsIntervals = append(data.Operations[i].IcmpEchoStatisticsIntervals, citem)
				return true
			})
		}
		if value := r.Get("type.icmp.path-echo"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Operations[i].IcmpPathEcho.IsNull() && !data.Operations[i].IcmpPathEcho.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Operations[i].IcmpPathEcho = types.BoolValue(false)
			} else if !data.Operations[i].IcmpPathEcho.IsNull() {
				data.Operations[i].IcmpPathEcho = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Operations[i].IcmpPathEcho.IsNull() {
				data.Operations[i].IcmpPathEcho = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Operations[i].IcmpPathEcho = types.BoolValue(false)
			}
		}
		if value := r.Get("type.icmp.path-echo.tag"); value.Exists() && !data.Operations[i].IcmpPathEchoTag.IsNull() {
			data.Operations[i].IcmpPathEchoTag = types.StringValue(value.String())
		} else {
			data.Operations[i].IcmpPathEchoTag = types.StringNull()
		}
		if value := r.Get("type.icmp.path-echo.frequency"); value.Exists() && !data.Operations[i].IcmpPathEchoFrequency.IsNull() {
			data.Operations[i].IcmpPathEchoFrequency = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpPathEchoFrequency = types.Int64Null()
		}
		if value := r.Get("type.icmp.path-echo.datasize.request.enter-request-datasize-in-byte"); value.Exists() && !data.Operations[i].IcmpPathEchoDatasizeRequest.IsNull() {
			data.Operations[i].IcmpPathEchoDatasizeRequest = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpPathEchoDatasizeRequest = types.Int64Null()
		}
		if value := r.Get("type.icmp.path-echo.timeout"); value.Exists() && !data.Operations[i].IcmpPathEchoTimeout.IsNull() {
			data.Operations[i].IcmpPathEchoTimeout = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpPathEchoTimeout = types.Int64Null()
		}
		if value := r.Get("type.icmp.path-echo.source.address.ipv4-address"); value.Exists() && !data.Operations[i].IcmpPathEchoSourceIpv4.IsNull() {
			data.Operations[i].IcmpPathEchoSourceIpv4 = types.StringValue(value.String())
		} else {
			data.Operations[i].IcmpPathEchoSourceIpv4 = types.StringNull()
		}
		if value := r.Get("type.icmp.path-echo.tos"); value.Exists() && !data.Operations[i].IcmpPathEchoTos.IsNull() {
			data.Operations[i].IcmpPathEchoTos = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpPathEchoTos = types.Int64Null()
		}
		if value := r.Get("type.icmp.path-echo.destination.address.address"); value.Exists() && !data.Operations[i].IcmpPathEchoDestinationIpv4.IsNull() {
			data.Operations[i].IcmpPathEchoDestinationIpv4 = types.StringValue(value.String())
		} else {
			data.Operations[i].IcmpPathEchoDestinationIpv4 = types.StringNull()
		}
		if value := r.Get("type.icmp.path-echo.history.buckets"); value.Exists() && !data.Operations[i].IcmpPathEchoHistoryBuckets.IsNull() {
			data.Operations[i].IcmpPathEchoHistoryBuckets = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpPathEchoHistoryBuckets = types.Int64Null()
		}
		if value := r.Get("type.icmp.path-echo.history.filter.all"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Operations[i].IcmpPathEchoHistoryFilterAll.IsNull() && !data.Operations[i].IcmpPathEchoHistoryFilterAll.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Operations[i].IcmpPathEchoHistoryFilterAll = types.BoolValue(false)
			} else if !data.Operations[i].IcmpPathEchoHistoryFilterAll.IsNull() {
				data.Operations[i].IcmpPathEchoHistoryFilterAll = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Operations[i].IcmpPathEchoHistoryFilterAll.IsNull() {
				data.Operations[i].IcmpPathEchoHistoryFilterAll = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Operations[i].IcmpPathEchoHistoryFilterAll = types.BoolValue(false)
			}
		}
		if value := r.Get("type.icmp.path-echo.history.filter.failures"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Operations[i].IcmpPathEchoHistoryFilterFailures.IsNull() && !data.Operations[i].IcmpPathEchoHistoryFilterFailures.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Operations[i].IcmpPathEchoHistoryFilterFailures = types.BoolValue(false)
			} else if !data.Operations[i].IcmpPathEchoHistoryFilterFailures.IsNull() {
				data.Operations[i].IcmpPathEchoHistoryFilterFailures = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Operations[i].IcmpPathEchoHistoryFilterFailures.IsNull() {
				data.Operations[i].IcmpPathEchoHistoryFilterFailures = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Operations[i].IcmpPathEchoHistoryFilterFailures = types.BoolValue(false)
			}
		}
		if value := r.Get("type.icmp.path-echo.history.lives"); value.Exists() && !data.Operations[i].IcmpPathEchoHistoryLives.IsNull() {
			data.Operations[i].IcmpPathEchoHistoryLives = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpPathEchoHistoryLives = types.Int64Null()
		}
		if value := r.Get("type.icmp.path-echo.history.samples"); value.Exists() && !data.Operations[i].IcmpPathEchoHistorySamples.IsNull() {
			data.Operations[i].IcmpPathEchoHistorySamples = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpPathEchoHistorySamples = types.Int64Null()
		}
		if value := r.Get("type.icmp.path-echo.statistics.hourly.buckets"); value.Exists() && !data.Operations[i].IcmpPathEchoStatisticsHourlyBuckets.IsNull() {
			data.Operations[i].IcmpPathEchoStatisticsHourlyBuckets = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpPathEchoStatisticsHourlyBuckets = types.Int64Null()
		}
		if value := r.Get("type.icmp.path-echo.statistics.hourly.distribution.count"); value.Exists() && !data.Operations[i].IcmpPathEchoStatisticsHourlyDistributionCount.IsNull() {
			data.Operations[i].IcmpPathEchoStatisticsHourlyDistributionCount = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpPathEchoStatisticsHourlyDistributionCount = types.Int64Null()
		}
		if value := r.Get("type.icmp.path-echo.statistics.hourly.distribution.interval"); value.Exists() && !data.Operations[i].IcmpPathEchoStatisticsHourlyDistributionInterval.IsNull() {
			data.Operations[i].IcmpPathEchoStatisticsHourlyDistributionInterval = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpPathEchoStatisticsHourlyDistributionInterval = types.Int64Null()
		}
		if value := r.Get("type.icmp.path-echo.statistics.hourly.maximum.hops"); value.Exists() && !data.Operations[i].IcmpPathEchoStatisticsHourlyMaximumHops.IsNull() {
			data.Operations[i].IcmpPathEchoStatisticsHourlyMaximumHops = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpPathEchoStatisticsHourlyMaximumHops = types.Int64Null()
		}
		if value := r.Get("type.icmp.path-echo.statistics.hourly.maximum.paths"); value.Exists() && !data.Operations[i].IcmpPathEchoStatisticsHourlyMaximumPaths.IsNull() {
			data.Operations[i].IcmpPathEchoStatisticsHourlyMaximumPaths = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpPathEchoStatisticsHourlyMaximumPaths = types.Int64Null()
		}
		if value := r.Get("type.icmp.path-jitter"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Operations[i].IcmpPathJitter.IsNull() && !data.Operations[i].IcmpPathJitter.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Operations[i].IcmpPathJitter = types.BoolValue(false)
			} else if !data.Operations[i].IcmpPathJitter.IsNull() {
				data.Operations[i].IcmpPathJitter = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Operations[i].IcmpPathJitter.IsNull() {
				data.Operations[i].IcmpPathJitter = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Operations[i].IcmpPathJitter = types.BoolValue(false)
			}
		}
		if value := r.Get("type.icmp.path-jitter.tag"); value.Exists() && !data.Operations[i].IcmpPathJitterTag.IsNull() {
			data.Operations[i].IcmpPathJitterTag = types.StringValue(value.String())
		} else {
			data.Operations[i].IcmpPathJitterTag = types.StringNull()
		}
		if value := r.Get("type.icmp.path-jitter.frequency"); value.Exists() && !data.Operations[i].IcmpPathJitterFrequency.IsNull() {
			data.Operations[i].IcmpPathJitterFrequency = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpPathJitterFrequency = types.Int64Null()
		}
		if value := r.Get("type.icmp.path-jitter.datasize.request.enter-request-datasize-in-byte"); value.Exists() && !data.Operations[i].IcmpPathJitterDatasizeRequest.IsNull() {
			data.Operations[i].IcmpPathJitterDatasizeRequest = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpPathJitterDatasizeRequest = types.Int64Null()
		}
		if value := r.Get("type.icmp.path-jitter.timeout"); value.Exists() && !data.Operations[i].IcmpPathJitterTimeout.IsNull() {
			data.Operations[i].IcmpPathJitterTimeout = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpPathJitterTimeout = types.Int64Null()
		}
		if value := r.Get("type.icmp.path-jitter.source.address.ipv4-address"); value.Exists() && !data.Operations[i].IcmpPathJitterSourceIpv4.IsNull() {
			data.Operations[i].IcmpPathJitterSourceIpv4 = types.StringValue(value.String())
		} else {
			data.Operations[i].IcmpPathJitterSourceIpv4 = types.StringNull()
		}
		if value := r.Get("type.icmp.path-jitter.packet.count"); value.Exists() && !data.Operations[i].IcmpPathJitterPacketCount.IsNull() {
			data.Operations[i].IcmpPathJitterPacketCount = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpPathJitterPacketCount = types.Int64Null()
		}
		if value := r.Get("type.icmp.path-jitter.packet.interval"); value.Exists() && !data.Operations[i].IcmpPathJitterPacketInterval.IsNull() {
			data.Operations[i].IcmpPathJitterPacketInterval = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpPathJitterPacketInterval = types.Int64Null()
		}
		if value := r.Get("type.icmp.path-jitter.tos"); value.Exists() && !data.Operations[i].IcmpPathJitterTos.IsNull() {
			data.Operations[i].IcmpPathJitterTos = types.Int64Value(value.Int())
		} else {
			data.Operations[i].IcmpPathJitterTos = types.Int64Null()
		}
		if value := r.Get("type.icmp.path-jitter.destination.address.address"); value.Exists() && !data.Operations[i].IcmpPathJitterDestinationIpv4.IsNull() {
			data.Operations[i].IcmpPathJitterDestinationIpv4 = types.StringValue(value.String())
		} else {
			data.Operations[i].IcmpPathJitterDestinationIpv4 = types.StringNull()
		}
		if value := r.Get("type.udp.echo"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Operations[i].UdpEcho.IsNull() && !data.Operations[i].UdpEcho.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Operations[i].UdpEcho = types.BoolValue(false)
			} else if !data.Operations[i].UdpEcho.IsNull() {
				data.Operations[i].UdpEcho = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Operations[i].UdpEcho.IsNull() {
				data.Operations[i].UdpEcho = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Operations[i].UdpEcho = types.BoolValue(false)
			}
		}
		if value := r.Get("type.udp.echo.tag"); value.Exists() && !data.Operations[i].UdpEchoTag.IsNull() {
			data.Operations[i].UdpEchoTag = types.StringValue(value.String())
		} else {
			data.Operations[i].UdpEchoTag = types.StringNull()
		}
		if value := r.Get("type.udp.echo.frequency"); value.Exists() && !data.Operations[i].UdpEchoFrequency.IsNull() {
			data.Operations[i].UdpEchoFrequency = types.Int64Value(value.Int())
		} else {
			data.Operations[i].UdpEchoFrequency = types.Int64Null()
		}
		if value := r.Get("type.udp.echo.datasize.request.enter-request-datasize-in-byte"); value.Exists() && !data.Operations[i].UdpEchoDatasizeRequest.IsNull() {
			data.Operations[i].UdpEchoDatasizeRequest = types.Int64Value(value.Int())
		} else {
			data.Operations[i].UdpEchoDatasizeRequest = types.Int64Null()
		}
		if value := r.Get("type.udp.echo.timeout"); value.Exists() && !data.Operations[i].UdpEchoTimeout.IsNull() {
			data.Operations[i].UdpEchoTimeout = types.Int64Value(value.Int())
		} else {
			data.Operations[i].UdpEchoTimeout = types.Int64Null()
		}
		if value := r.Get("type.udp.echo.source.address.ipv4-address"); value.Exists() && !data.Operations[i].UdpEchoSourceIpv4.IsNull() {
			data.Operations[i].UdpEchoSourceIpv4 = types.StringValue(value.String())
		} else {
			data.Operations[i].UdpEchoSourceIpv4 = types.StringNull()
		}
		if value := r.Get("type.udp.echo.source.port"); value.Exists() && !data.Operations[i].UdpEchoSourcePort.IsNull() {
			data.Operations[i].UdpEchoSourcePort = types.Int64Value(value.Int())
		} else {
			data.Operations[i].UdpEchoSourcePort = types.Int64Null()
		}
		if value := r.Get("type.udp.echo.destination.address"); value.Exists() && !data.Operations[i].UdpEchoDestinationIpv4.IsNull() {
			data.Operations[i].UdpEchoDestinationIpv4 = types.StringValue(value.String())
		} else {
			data.Operations[i].UdpEchoDestinationIpv4 = types.StringNull()
		}
		if value := r.Get("type.udp.echo.destination.port"); value.Exists() && !data.Operations[i].UdpEchoDestinationPort.IsNull() {
			data.Operations[i].UdpEchoDestinationPort = types.Int64Value(value.Int())
		} else {
			data.Operations[i].UdpEchoDestinationPort = types.Int64Null()
		}
		if value := r.Get("type.udp.echo.control.disable"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Operations[i].UdpEchoControlDisable.IsNull() && !data.Operations[i].UdpEchoControlDisable.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Operations[i].UdpEchoControlDisable = types.BoolValue(false)
			} else if !data.Operations[i].UdpEchoControlDisable.IsNull() {
				data.Operations[i].UdpEchoControlDisable = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Operations[i].UdpEchoControlDisable.IsNull() {
				data.Operations[i].UdpEchoControlDisable = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Operations[i].UdpEchoControlDisable = types.BoolValue(false)
			}
		}
		if value := r.Get("type.udp.echo.verify-data"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Operations[i].UdpEchoVerifyData.IsNull() && !data.Operations[i].UdpEchoVerifyData.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Operations[i].UdpEchoVerifyData = types.BoolValue(false)
			} else if !data.Operations[i].UdpEchoVerifyData.IsNull() {
				data.Operations[i].UdpEchoVerifyData = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Operations[i].UdpEchoVerifyData.IsNull() {
				data.Operations[i].UdpEchoVerifyData = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Operations[i].UdpEchoVerifyData = types.BoolValue(false)
			}
		}
		if value := r.Get("type.udp.echo.tos"); value.Exists() && !data.Operations[i].UdpEchoTos.IsNull() {
			data.Operations[i].UdpEchoTos = types.Int64Value(value.Int())
		} else {
			data.Operations[i].UdpEchoTos = types.Int64Null()
		}
		if value := r.Get("type.udp.echo.vrf"); value.Exists() && !data.Operations[i].UdpEchoVrf.IsNull() {
			data.Operations[i].UdpEchoVrf = types.StringValue(value.String())
		} else {
			data.Operations[i].UdpEchoVrf = types.StringNull()
		}
		if value := r.Get("type.udp.echo.statistics.hourly.buckets"); value.Exists() && !data.Operations[i].UdpEchoStatisticsHourlyBuckets.IsNull() {
			data.Operations[i].UdpEchoStatisticsHourlyBuckets = types.Int64Value(value.Int())
		} else {
			data.Operations[i].UdpEchoStatisticsHourlyBuckets = types.Int64Null()
		}
		if value := r.Get("type.udp.echo.statistics.hourly.distribution.count"); value.Exists() && !data.Operations[i].UdpEchoStatisticsHourlyDistributionCount.IsNull() {
			data.Operations[i].UdpEchoStatisticsHourlyDistributionCount = types.Int64Value(value.Int())
		} else {
			data.Operations[i].UdpEchoStatisticsHourlyDistributionCount = types.Int64Null()
		}
		if value := r.Get("type.udp.echo.statistics.hourly.distribution.interval"); value.Exists() && !data.Operations[i].UdpEchoStatisticsHourlyDistributionInterval.IsNull() {
			data.Operations[i].UdpEchoStatisticsHourlyDistributionInterval = types.Int64Value(value.Int())
		} else {
			data.Operations[i].UdpEchoStatisticsHourlyDistributionInterval = types.Int64Null()
		}
		// Rebuild nested list from device response
		if value := r.Get("type.udp.echo.statistics.intervals.interval"); value.Exists() {
			// Store existing state items for matching
			existingItems := data.Operations[i].UdpEchoStatisticsIntervals
			data.Operations[i].UdpEchoStatisticsIntervals = make([]IPSLAOperationsUdpEchoStatisticsIntervals, 0)
			value.ForEach(func(_, cr gjson.Result) bool {
				citem := IPSLAOperationsUdpEchoStatisticsIntervals{}
				if cValue := cr.Get("interval-time"); cValue.Exists() {
					citem.Interval = types.Int64Value(cValue.Int())
				}
				if cValue := cr.Get("buckets"); cValue.Exists() {
					citem.Buckets = types.Int64Value(cValue.Int())
				}

				// Match with existing state item by key fields
				for _, existingItem := range existingItems {
					match := true
					if !existingItem.Interval.Equal(citem.Interval) {
						match = false
					}

					if match {
						// Preserve false values for presence-based booleans
						break
					}
				}

				data.Operations[i].UdpEchoStatisticsIntervals = append(data.Operations[i].UdpEchoStatisticsIntervals, citem)
				return true
			})
		}
		if value := r.Get("type.udp.echo.history.buckets"); value.Exists() && !data.Operations[i].UdpEchoHistoryBuckets.IsNull() {
			data.Operations[i].UdpEchoHistoryBuckets = types.Int64Value(value.Int())
		} else {
			data.Operations[i].UdpEchoHistoryBuckets = types.Int64Null()
		}
		if value := r.Get("type.udp.echo.history.filter.all"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Operations[i].UdpEchoHistoryFilterAll.IsNull() && !data.Operations[i].UdpEchoHistoryFilterAll.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Operations[i].UdpEchoHistoryFilterAll = types.BoolValue(false)
			} else if !data.Operations[i].UdpEchoHistoryFilterAll.IsNull() {
				data.Operations[i].UdpEchoHistoryFilterAll = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Operations[i].UdpEchoHistoryFilterAll.IsNull() {
				data.Operations[i].UdpEchoHistoryFilterAll = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Operations[i].UdpEchoHistoryFilterAll = types.BoolValue(false)
			}
		}
		if value := r.Get("type.udp.echo.history.filter.failures"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Operations[i].UdpEchoHistoryFilterFailures.IsNull() && !data.Operations[i].UdpEchoHistoryFilterFailures.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Operations[i].UdpEchoHistoryFilterFailures = types.BoolValue(false)
			} else if !data.Operations[i].UdpEchoHistoryFilterFailures.IsNull() {
				data.Operations[i].UdpEchoHistoryFilterFailures = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Operations[i].UdpEchoHistoryFilterFailures.IsNull() {
				data.Operations[i].UdpEchoHistoryFilterFailures = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Operations[i].UdpEchoHistoryFilterFailures = types.BoolValue(false)
			}
		}
		if value := r.Get("type.udp.echo.history.lives"); value.Exists() && !data.Operations[i].UdpEchoHistoryLives.IsNull() {
			data.Operations[i].UdpEchoHistoryLives = types.Int64Value(value.Int())
		} else {
			data.Operations[i].UdpEchoHistoryLives = types.Int64Null()
		}
		if value := r.Get("type.udp.jitter"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Operations[i].UdpJitter.IsNull() && !data.Operations[i].UdpJitter.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Operations[i].UdpJitter = types.BoolValue(false)
			} else if !data.Operations[i].UdpJitter.IsNull() {
				data.Operations[i].UdpJitter = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Operations[i].UdpJitter.IsNull() {
				data.Operations[i].UdpJitter = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Operations[i].UdpJitter = types.BoolValue(false)
			}
		}
		if value := r.Get("type.udp.jitter.tag"); value.Exists() && !data.Operations[i].UdpJitterTag.IsNull() {
			data.Operations[i].UdpJitterTag = types.StringValue(value.String())
		} else {
			data.Operations[i].UdpJitterTag = types.StringNull()
		}
		if value := r.Get("type.udp.jitter.frequency"); value.Exists() && !data.Operations[i].UdpJitterFrequency.IsNull() {
			data.Operations[i].UdpJitterFrequency = types.Int64Value(value.Int())
		} else {
			data.Operations[i].UdpJitterFrequency = types.Int64Null()
		}
		if value := r.Get("type.udp.jitter.datasize.request.enter-request-datasize-in-byte"); value.Exists() && !data.Operations[i].UdpJitterDatasizeRequest.IsNull() {
			data.Operations[i].UdpJitterDatasizeRequest = types.Int64Value(value.Int())
		} else {
			data.Operations[i].UdpJitterDatasizeRequest = types.Int64Null()
		}
		if value := r.Get("type.udp.jitter.timeout"); value.Exists() && !data.Operations[i].UdpJitterTimeout.IsNull() {
			data.Operations[i].UdpJitterTimeout = types.Int64Value(value.Int())
		} else {
			data.Operations[i].UdpJitterTimeout = types.Int64Null()
		}
		if value := r.Get("type.udp.jitter.source.address.ipv4-address"); value.Exists() && !data.Operations[i].UdpJitterSourceIpv4.IsNull() {
			data.Operations[i].UdpJitterSourceIpv4 = types.StringValue(value.String())
		} else {
			data.Operations[i].UdpJitterSourceIpv4 = types.StringNull()
		}
		if value := r.Get("type.udp.jitter.source.port"); value.Exists() && !data.Operations[i].UdpJitterSourcePort.IsNull() {
			data.Operations[i].UdpJitterSourcePort = types.Int64Value(value.Int())
		} else {
			data.Operations[i].UdpJitterSourcePort = types.Int64Null()
		}
		if value := r.Get("type.udp.jitter.destination.address"); value.Exists() && !data.Operations[i].UdpJitterDestinationIpv4.IsNull() {
			data.Operations[i].UdpJitterDestinationIpv4 = types.StringValue(value.String())
		} else {
			data.Operations[i].UdpJitterDestinationIpv4 = types.StringNull()
		}
		if value := r.Get("type.udp.jitter.destination.port"); value.Exists() && !data.Operations[i].UdpJitterDestinationPort.IsNull() {
			data.Operations[i].UdpJitterDestinationPort = types.Int64Value(value.Int())
		} else {
			data.Operations[i].UdpJitterDestinationPort = types.Int64Null()
		}
		if value := r.Get("type.udp.jitter.packet.count"); value.Exists() && !data.Operations[i].UdpJitterPacketCount.IsNull() {
			data.Operations[i].UdpJitterPacketCount = types.Int64Value(value.Int())
		} else {
			data.Operations[i].UdpJitterPacketCount = types.Int64Null()
		}
		if value := r.Get("type.udp.jitter.packet.interval"); value.Exists() && !data.Operations[i].UdpJitterPacketInterval.IsNull() {
			data.Operations[i].UdpJitterPacketInterval = types.Int64Value(value.Int())
		} else {
			data.Operations[i].UdpJitterPacketInterval = types.Int64Null()
		}
		if value := r.Get("type.udp.jitter.tos"); value.Exists() && !data.Operations[i].UdpJitterTos.IsNull() {
			data.Operations[i].UdpJitterTos = types.Int64Value(value.Int())
		} else {
			data.Operations[i].UdpJitterTos = types.Int64Null()
		}
		if value := r.Get("type.udp.jitter.vrf"); value.Exists() && !data.Operations[i].UdpJitterVrf.IsNull() {
			data.Operations[i].UdpJitterVrf = types.StringValue(value.String())
		} else {
			data.Operations[i].UdpJitterVrf = types.StringNull()
		}
		if value := r.Get("type.udp.jitter.control.disable"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Operations[i].UdpJitterControlDisable.IsNull() && !data.Operations[i].UdpJitterControlDisable.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Operations[i].UdpJitterControlDisable = types.BoolValue(false)
			} else if !data.Operations[i].UdpJitterControlDisable.IsNull() {
				data.Operations[i].UdpJitterControlDisable = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Operations[i].UdpJitterControlDisable.IsNull() {
				data.Operations[i].UdpJitterControlDisable = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Operations[i].UdpJitterControlDisable = types.BoolValue(false)
			}
		}
		if value := r.Get("type.udp.jitter.verify-data"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Operations[i].UdpJitterVerifyData.IsNull() && !data.Operations[i].UdpJitterVerifyData.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Operations[i].UdpJitterVerifyData = types.BoolValue(false)
			} else if !data.Operations[i].UdpJitterVerifyData.IsNull() {
				data.Operations[i].UdpJitterVerifyData = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Operations[i].UdpJitterVerifyData.IsNull() {
				data.Operations[i].UdpJitterVerifyData = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Operations[i].UdpJitterVerifyData = types.BoolValue(false)
			}
		}
		if value := r.Get("type.udp.jitter.statistics.hourly.buckets"); value.Exists() && !data.Operations[i].UdpJitterStatisticsHourlyBuckets.IsNull() {
			data.Operations[i].UdpJitterStatisticsHourlyBuckets = types.Int64Value(value.Int())
		} else {
			data.Operations[i].UdpJitterStatisticsHourlyBuckets = types.Int64Null()
		}
		if value := r.Get("type.udp.jitter.statistics.hourly.distribution.count"); value.Exists() && !data.Operations[i].UdpJitterStatisticsHourlyDistributionCount.IsNull() {
			data.Operations[i].UdpJitterStatisticsHourlyDistributionCount = types.Int64Value(value.Int())
		} else {
			data.Operations[i].UdpJitterStatisticsHourlyDistributionCount = types.Int64Null()
		}
		if value := r.Get("type.udp.jitter.statistics.hourly.distribution.interval"); value.Exists() && !data.Operations[i].UdpJitterStatisticsHourlyDistributionInterval.IsNull() {
			data.Operations[i].UdpJitterStatisticsHourlyDistributionInterval = types.Int64Value(value.Int())
		} else {
			data.Operations[i].UdpJitterStatisticsHourlyDistributionInterval = types.Int64Null()
		}
		// Rebuild nested list from device response
		if value := r.Get("type.udp.jitter.statistics.intervals.interval"); value.Exists() {
			// Store existing state items for matching
			existingItems := data.Operations[i].UdpJitterStatisticsIntervals
			data.Operations[i].UdpJitterStatisticsIntervals = make([]IPSLAOperationsUdpJitterStatisticsIntervals, 0)
			value.ForEach(func(_, cr gjson.Result) bool {
				citem := IPSLAOperationsUdpJitterStatisticsIntervals{}
				if cValue := cr.Get("interval-time"); cValue.Exists() {
					citem.Interval = types.Int64Value(cValue.Int())
				}
				if cValue := cr.Get("buckets"); cValue.Exists() {
					citem.Buckets = types.Int64Value(cValue.Int())
				}

				// Match with existing state item by key fields
				for _, existingItem := range existingItems {
					match := true
					if !existingItem.Interval.Equal(citem.Interval) {
						match = false
					}

					if match {
						// Preserve false values for presence-based booleans
						break
					}
				}

				data.Operations[i].UdpJitterStatisticsIntervals = append(data.Operations[i].UdpJitterStatisticsIntervals, citem)
				return true
			})
		}
		if value := r.Get("type.mpls.lsp.ping"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Operations[i].MplsLspPing.IsNull() && !data.Operations[i].MplsLspPing.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Operations[i].MplsLspPing = types.BoolValue(false)
			} else if !data.Operations[i].MplsLspPing.IsNull() {
				data.Operations[i].MplsLspPing = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Operations[i].MplsLspPing.IsNull() {
				data.Operations[i].MplsLspPing = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Operations[i].MplsLspPing = types.BoolValue(false)
			}
		}
		if value := r.Get("type.mpls.lsp.ping.tag"); value.Exists() && !data.Operations[i].MplsLspPingTag.IsNull() {
			data.Operations[i].MplsLspPingTag = types.StringValue(value.String())
		} else {
			data.Operations[i].MplsLspPingTag = types.StringNull()
		}
		if value := r.Get("type.mpls.lsp.ping.frequency"); value.Exists() && !data.Operations[i].MplsLspPingFrequency.IsNull() {
			data.Operations[i].MplsLspPingFrequency = types.Int64Value(value.Int())
		} else {
			data.Operations[i].MplsLspPingFrequency = types.Int64Null()
		}
		if value := r.Get("type.mpls.lsp.ping.datasize.request.enter-request-datasize-in-byte"); value.Exists() && !data.Operations[i].MplsLspPingDatasizeRequest.IsNull() {
			data.Operations[i].MplsLspPingDatasizeRequest = types.Int64Value(value.Int())
		} else {
			data.Operations[i].MplsLspPingDatasizeRequest = types.Int64Null()
		}
		if value := r.Get("type.mpls.lsp.ping.timeout"); value.Exists() && !data.Operations[i].MplsLspPingTimeout.IsNull() {
			data.Operations[i].MplsLspPingTimeout = types.Int64Value(value.Int())
		} else {
			data.Operations[i].MplsLspPingTimeout = types.Int64Null()
		}
		if value := r.Get("type.mpls.lsp.ping.source.address.ipv4-address"); value.Exists() && !data.Operations[i].MplsLspPingSourceIpv4.IsNull() {
			data.Operations[i].MplsLspPingSourceIpv4 = types.StringValue(value.String())
		} else {
			data.Operations[i].MplsLspPingSourceIpv4 = types.StringNull()
		}
		if value := r.Get("type.mpls.lsp.ping.target.ipv4.address"); value.Exists() && !data.Operations[i].MplsLspPingTargetIpv4.IsNull() {
			data.Operations[i].MplsLspPingTargetIpv4 = types.StringValue(value.String())
		} else {
			data.Operations[i].MplsLspPingTargetIpv4 = types.StringNull()
		}
		if value := r.Get("type.mpls.lsp.ping.target.ipv4.mask"); value.Exists() && !data.Operations[i].MplsLspPingTargetIpv4Mask.IsNull() {
			data.Operations[i].MplsLspPingTargetIpv4Mask = types.StringValue(value.String())
		} else {
			data.Operations[i].MplsLspPingTargetIpv4Mask = types.StringNull()
		}
		if value := r.Get("type.mpls.lsp.ping.target.traffic-eng.tunnel"); value.Exists() && !data.Operations[i].MplsLspPingTargetTeTunnel.IsNull() {
			data.Operations[i].MplsLspPingTargetTeTunnel = types.Int64Value(value.Int())
		} else {
			data.Operations[i].MplsLspPingTargetTeTunnel = types.Int64Null()
		}
		if value := r.Get("type.mpls.lsp.ping.target.pseudowire.address"); value.Exists() && !data.Operations[i].MplsLspPingTargetPseudowireAddress.IsNull() {
			data.Operations[i].MplsLspPingTargetPseudowireAddress = types.StringValue(value.String())
		} else {
			data.Operations[i].MplsLspPingTargetPseudowireAddress = types.StringNull()
		}
		if value := r.Get("type.mpls.lsp.ping.target.pseudowire.virtual-circuit-id"); value.Exists() && !data.Operations[i].MplsLspPingTargetPseudowireVcId.IsNull() {
			data.Operations[i].MplsLspPingTargetPseudowireVcId = types.Int64Value(value.Int())
		} else {
			data.Operations[i].MplsLspPingTargetPseudowireVcId = types.Int64Null()
		}
		if value := r.Get("type.mpls.lsp.ping.statistics.hourly.buckets"); value.Exists() && !data.Operations[i].MplsLspPingStatisticsHourlyBuckets.IsNull() {
			data.Operations[i].MplsLspPingStatisticsHourlyBuckets = types.Int64Value(value.Int())
		} else {
			data.Operations[i].MplsLspPingStatisticsHourlyBuckets = types.Int64Null()
		}
		if value := r.Get("type.mpls.lsp.ping.statistics.hourly.distribution.count"); value.Exists() && !data.Operations[i].MplsLspPingStatisticsHourlyDistributionCount.IsNull() {
			data.Operations[i].MplsLspPingStatisticsHourlyDistributionCount = types.Int64Value(value.Int())
		} else {
			data.Operations[i].MplsLspPingStatisticsHourlyDistributionCount = types.Int64Null()
		}
		if value := r.Get("type.mpls.lsp.ping.statistics.hourly.distribution.interval"); value.Exists() && !data.Operations[i].MplsLspPingStatisticsHourlyDistributionInterval.IsNull() {
			data.Operations[i].MplsLspPingStatisticsHourlyDistributionInterval = types.Int64Value(value.Int())
		} else {
			data.Operations[i].MplsLspPingStatisticsHourlyDistributionInterval = types.Int64Null()
		}
		// Rebuild nested list from device response
		if value := r.Get("type.mpls.lsp.ping.statistics.intervals.interval"); value.Exists() {
			// Store existing state items for matching
			existingItems := data.Operations[i].MplsLspPingStatisticsIntervals
			data.Operations[i].MplsLspPingStatisticsIntervals = make([]IPSLAOperationsMplsLspPingStatisticsIntervals, 0)
			value.ForEach(func(_, cr gjson.Result) bool {
				citem := IPSLAOperationsMplsLspPingStatisticsIntervals{}
				if cValue := cr.Get("interval-time"); cValue.Exists() {
					citem.Interval = types.Int64Value(cValue.Int())
				}
				if cValue := cr.Get("buckets"); cValue.Exists() {
					citem.Buckets = types.Int64Value(cValue.Int())
				}

				// Match with existing state item by key fields
				for _, existingItem := range existingItems {
					match := true
					if !existingItem.Interval.Equal(citem.Interval) {
						match = false
					}

					if match {
						// Preserve false values for presence-based booleans
						break
					}
				}

				data.Operations[i].MplsLspPingStatisticsIntervals = append(data.Operations[i].MplsLspPingStatisticsIntervals, citem)
				return true
			})
		}
		if value := r.Get("type.mpls.lsp.trace"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Operations[i].MplsLspTrace.IsNull() && !data.Operations[i].MplsLspTrace.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Operations[i].MplsLspTrace = types.BoolValue(false)
			} else if !data.Operations[i].MplsLspTrace.IsNull() {
				data.Operations[i].MplsLspTrace = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Operations[i].MplsLspTrace.IsNull() {
				data.Operations[i].MplsLspTrace = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Operations[i].MplsLspTrace = types.BoolValue(false)
			}
		}
		if value := r.Get("type.mpls.lsp.trace.tag"); value.Exists() && !data.Operations[i].MplsLspTraceTag.IsNull() {
			data.Operations[i].MplsLspTraceTag = types.StringValue(value.String())
		} else {
			data.Operations[i].MplsLspTraceTag = types.StringNull()
		}
		if value := r.Get("type.mpls.lsp.trace.frequency"); value.Exists() && !data.Operations[i].MplsLspTraceFrequency.IsNull() {
			data.Operations[i].MplsLspTraceFrequency = types.Int64Value(value.Int())
		} else {
			data.Operations[i].MplsLspTraceFrequency = types.Int64Null()
		}
		if value := r.Get("type.mpls.lsp.trace.timeout"); value.Exists() && !data.Operations[i].MplsLspTraceTimeout.IsNull() {
			data.Operations[i].MplsLspTraceTimeout = types.Int64Value(value.Int())
		} else {
			data.Operations[i].MplsLspTraceTimeout = types.Int64Null()
		}
		if value := r.Get("type.mpls.lsp.trace.source.address.ipv4-address"); value.Exists() && !data.Operations[i].MplsLspTraceSourceIpv4.IsNull() {
			data.Operations[i].MplsLspTraceSourceIpv4 = types.StringValue(value.String())
		} else {
			data.Operations[i].MplsLspTraceSourceIpv4 = types.StringNull()
		}
		if value := r.Get("type.mpls.lsp.trace.target.ipv4.address"); value.Exists() && !data.Operations[i].MplsLspTraceTargetIpv4.IsNull() {
			data.Operations[i].MplsLspTraceTargetIpv4 = types.StringValue(value.String())
		} else {
			data.Operations[i].MplsLspTraceTargetIpv4 = types.StringNull()
		}
		if value := r.Get("type.mpls.lsp.trace.target.ipv4.mask"); value.Exists() && !data.Operations[i].MplsLspTraceTargetIpv4Mask.IsNull() {
			data.Operations[i].MplsLspTraceTargetIpv4Mask = types.StringValue(value.String())
		} else {
			data.Operations[i].MplsLspTraceTargetIpv4Mask = types.StringNull()
		}
		if value := r.Get("type.mpls.lsp.trace.target.traffic-eng.tunnel"); value.Exists() && !data.Operations[i].MplsLspTraceTargetTeTunnel.IsNull() {
			data.Operations[i].MplsLspTraceTargetTeTunnel = types.Int64Value(value.Int())
		} else {
			data.Operations[i].MplsLspTraceTargetTeTunnel = types.Int64Null()
		}
		if value := r.Get("type.mpls.lsp.trace.target.pseudowire.address"); value.Exists() && !data.Operations[i].MplsLspTraceTargetPseudowireAddress.IsNull() {
			data.Operations[i].MplsLspTraceTargetPseudowireAddress = types.StringValue(value.String())
		} else {
			data.Operations[i].MplsLspTraceTargetPseudowireAddress = types.StringNull()
		}
		if value := r.Get("type.mpls.lsp.trace.target.pseudowire.virtual-circuit-id"); value.Exists() && !data.Operations[i].MplsLspTraceTargetPseudowireVcId.IsNull() {
			data.Operations[i].MplsLspTraceTargetPseudowireVcId = types.Int64Value(value.Int())
		} else {
			data.Operations[i].MplsLspTraceTargetPseudowireVcId = types.Int64Null()
		}
		if value := r.Get("type.mpls.lsp.trace.statistics.hourly.buckets"); value.Exists() && !data.Operations[i].MplsLspTraceStatisticsHourlyBuckets.IsNull() {
			data.Operations[i].MplsLspTraceStatisticsHourlyBuckets = types.Int64Value(value.Int())
		} else {
			data.Operations[i].MplsLspTraceStatisticsHourlyBuckets = types.Int64Null()
		}
		if value := r.Get("type.mpls.lsp.trace.statistics.hourly.distribution.count"); value.Exists() && !data.Operations[i].MplsLspTraceStatisticsHourlyDistributionCount.IsNull() {
			data.Operations[i].MplsLspTraceStatisticsHourlyDistributionCount = types.Int64Value(value.Int())
		} else {
			data.Operations[i].MplsLspTraceStatisticsHourlyDistributionCount = types.Int64Null()
		}
		if value := r.Get("type.mpls.lsp.trace.statistics.hourly.distribution.interval"); value.Exists() && !data.Operations[i].MplsLspTraceStatisticsHourlyDistributionInterval.IsNull() {
			data.Operations[i].MplsLspTraceStatisticsHourlyDistributionInterval = types.Int64Value(value.Int())
		} else {
			data.Operations[i].MplsLspTraceStatisticsHourlyDistributionInterval = types.Int64Null()
		}
	}
	for i := range data.Schedules {
		keys := [...]string{"operation-number"}
		keyValues := [...]string{strconv.FormatInt(data.Schedules[i].OperationNumber.ValueInt64(), 10)}

		var r gjson.Result
		gjson.GetBytes(res, "schedule.operations.operation").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("operation-number"); value.Exists() && !data.Schedules[i].OperationNumber.IsNull() {
			data.Schedules[i].OperationNumber = types.Int64Value(value.Int())
		} else {
			data.Schedules[i].OperationNumber = types.Int64Null()
		}
		if value := r.Get("life.forever"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Schedules[i].LifeForever.IsNull() && !data.Schedules[i].LifeForever.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Schedules[i].LifeForever = types.BoolValue(false)
			} else if !data.Schedules[i].LifeForever.IsNull() {
				data.Schedules[i].LifeForever = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Schedules[i].LifeForever.IsNull() {
				data.Schedules[i].LifeForever = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Schedules[i].LifeForever = types.BoolValue(false)
			}
		}
		if value := r.Get("life.length-of-time"); value.Exists() && !data.Schedules[i].LifeTime.IsNull() {
			data.Schedules[i].LifeTime = types.Int64Value(value.Int())
		} else {
			data.Schedules[i].LifeTime = types.Int64Null()
		}
		if value := r.Get("start-time.time-and-date.hour"); value.Exists() && !data.Schedules[i].StartHour.IsNull() {
			data.Schedules[i].StartHour = types.Int64Value(value.Int())
		} else {
			data.Schedules[i].StartHour = types.Int64Null()
		}
		if value := r.Get("start-time.time-and-date.minute"); value.Exists() && !data.Schedules[i].StartMinute.IsNull() {
			data.Schedules[i].StartMinute = types.Int64Value(value.Int())
		} else {
			data.Schedules[i].StartMinute = types.Int64Null()
		}
		if value := r.Get("start-time.time-and-date.second"); value.Exists() && !data.Schedules[i].StartSecond.IsNull() {
			data.Schedules[i].StartSecond = types.Int64Value(value.Int())
		} else {
			data.Schedules[i].StartSecond = types.Int64Null()
		}
		if value := r.Get("start-time.time-and-date.month"); value.Exists() && !data.Schedules[i].StartMonth.IsNull() {
			data.Schedules[i].StartMonth = types.StringValue(value.String())
		} else {
			data.Schedules[i].StartMonth = types.StringNull()
		}
		if value := r.Get("start-time.time-and-date.day-of-month"); value.Exists() && !data.Schedules[i].StartDayOfMonth.IsNull() {
			data.Schedules[i].StartDayOfMonth = types.Int64Value(value.Int())
		} else {
			data.Schedules[i].StartDayOfMonth = types.Int64Null()
		}
		if value := r.Get("start-time.time-and-date.year"); value.Exists() && !data.Schedules[i].StartYear.IsNull() {
			data.Schedules[i].StartYear = types.Int64Value(value.Int())
		} else {
			data.Schedules[i].StartYear = types.Int64Null()
		}
		if value := r.Get("start-time.pending"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Schedules[i].StartPending.IsNull() && !data.Schedules[i].StartPending.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Schedules[i].StartPending = types.BoolValue(false)
			} else if !data.Schedules[i].StartPending.IsNull() {
				data.Schedules[i].StartPending = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Schedules[i].StartPending.IsNull() {
				data.Schedules[i].StartPending = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Schedules[i].StartPending = types.BoolValue(false)
			}
		}
		if value := r.Get("start-time.after.time.hour"); value.Exists() && !data.Schedules[i].StartAfterHour.IsNull() {
			data.Schedules[i].StartAfterHour = types.Int64Value(value.Int())
		} else {
			data.Schedules[i].StartAfterHour = types.Int64Null()
		}
		if value := r.Get("start-time.after.time.minute"); value.Exists() && !data.Schedules[i].StartAfterMinute.IsNull() {
			data.Schedules[i].StartAfterMinute = types.Int64Value(value.Int())
		} else {
			data.Schedules[i].StartAfterMinute = types.Int64Null()
		}
		if value := r.Get("start-time.after.time.second"); value.Exists() && !data.Schedules[i].StartAfterSecond.IsNull() {
			data.Schedules[i].StartAfterSecond = types.Int64Value(value.Int())
		} else {
			data.Schedules[i].StartAfterSecond = types.Int64Null()
		}
		if value := r.Get("start-time.now"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Schedules[i].StartNow.IsNull() && !data.Schedules[i].StartNow.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Schedules[i].StartNow = types.BoolValue(false)
			} else if !data.Schedules[i].StartNow.IsNull() {
				data.Schedules[i].StartNow = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Schedules[i].StartNow.IsNull() {
				data.Schedules[i].StartNow = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Schedules[i].StartNow = types.BoolValue(false)
			}
		}
		if value := r.Get("recurring"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Schedules[i].Recurring.IsNull() && !data.Schedules[i].Recurring.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Schedules[i].Recurring = types.BoolValue(false)
			} else if !data.Schedules[i].Recurring.IsNull() {
				data.Schedules[i].Recurring = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Schedules[i].Recurring.IsNull() {
				data.Schedules[i].Recurring = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Schedules[i].Recurring = types.BoolValue(false)
			}
		}
		if value := r.Get("ageout"); value.Exists() && !data.Schedules[i].Ageout.IsNull() {
			data.Schedules[i].Ageout = types.Int64Value(value.Int())
		} else {
			data.Schedules[i].Ageout = types.Int64Null()
		}
	}
	if value := gjson.GetBytes(res, "server.twamp"); value.Exists() {
		if !data.ServerTwamp.IsNull() {
			data.ServerTwamp = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.ServerTwamp.IsNull() {
			data.ServerTwamp = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "server.twamp.port"); value.Exists() && !data.ServerTwampPort.IsNull() {
		data.ServerTwampPort = types.Int64Value(value.Int())
	} else {
		data.ServerTwampPort = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "server.twamp.timer.inactivity"); value.Exists() && !data.ServerTwampTimerInactivity.IsNull() {
		data.ServerTwampTimerInactivity = types.Int64Value(value.Int())
	} else {
		data.ServerTwampTimerInactivity = types.Int64Null()
	}
}

// End of section. //template:end updateFromBody
// Section below is generated&owned by "gen/generator.go". //template:begin toBodyXML

func (data IPSLA) toBodyXML(ctx context.Context) string {
	body := netconf.Body{}
	if !data.LowMemory.IsNull() && !data.LowMemory.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/low-memory", strconv.FormatInt(data.LowMemory.ValueInt64(), 10))
	}
	if !data.KeyChain.IsNull() && !data.KeyChain.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/key-chain", data.KeyChain.ValueString())
	}
	if !data.HwTimestampDisable.IsNull() && !data.HwTimestampDisable.IsUnknown() {
		if data.HwTimestampDisable.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/hw-timestamp/disable", "")
		}
	}
	if len(data.Operations) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.Operations {
			cBody := netconf.Body{}
			if !item.OperationNumber.IsNull() && !item.OperationNumber.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "operation-number", strconv.FormatInt(item.OperationNumber.ValueInt64(), 10))
			}
			if !item.IcmpEcho.IsNull() && !item.IcmpEcho.IsUnknown() {
				if item.IcmpEcho.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "type/icmp/echo", "")
				}
			}
			if !item.IcmpEchoTag.IsNull() && !item.IcmpEchoTag.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/echo/tag", item.IcmpEchoTag.ValueString())
			}
			if !item.IcmpEchoFrequency.IsNull() && !item.IcmpEchoFrequency.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/echo/frequency", strconv.FormatInt(item.IcmpEchoFrequency.ValueInt64(), 10))
			}
			if !item.IcmpEchoDatasizeRequest.IsNull() && !item.IcmpEchoDatasizeRequest.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/echo/datasize/request/enter-request-datasize-in-byte", strconv.FormatInt(item.IcmpEchoDatasizeRequest.ValueInt64(), 10))
			}
			if !item.IcmpEchoTimeout.IsNull() && !item.IcmpEchoTimeout.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/echo/timeout", strconv.FormatInt(item.IcmpEchoTimeout.ValueInt64(), 10))
			}
			if !item.IcmpEchoSourceIpv4.IsNull() && !item.IcmpEchoSourceIpv4.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/echo/source/address/ipv4-address", item.IcmpEchoSourceIpv4.ValueString())
			}
			if !item.IcmpEchoSourceIpv6.IsNull() && !item.IcmpEchoSourceIpv6.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/echo/source/address/ipv6-address", item.IcmpEchoSourceIpv6.ValueString())
			}
			if !item.IcmpEchoTos.IsNull() && !item.IcmpEchoTos.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/echo/tos", strconv.FormatInt(item.IcmpEchoTos.ValueInt64(), 10))
			}
			if !item.IcmpEchoVrf.IsNull() && !item.IcmpEchoVrf.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/echo/vrf", item.IcmpEchoVrf.ValueString())
			}
			if !item.IcmpEchoDestinationIpv4.IsNull() && !item.IcmpEchoDestinationIpv4.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/echo/destination/address/ipv4-address", item.IcmpEchoDestinationIpv4.ValueString())
			}
			if !item.IcmpEchoDestinationIpv6.IsNull() && !item.IcmpEchoDestinationIpv6.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/echo/destination/address/ipv6-address", item.IcmpEchoDestinationIpv6.ValueString())
			}
			if !item.IcmpEchoHistoryBuckets.IsNull() && !item.IcmpEchoHistoryBuckets.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/echo/history/buckets", strconv.FormatInt(item.IcmpEchoHistoryBuckets.ValueInt64(), 10))
			}
			if !item.IcmpEchoHistoryFilterAll.IsNull() && !item.IcmpEchoHistoryFilterAll.IsUnknown() {
				if item.IcmpEchoHistoryFilterAll.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "type/icmp/echo/history/filter/all", "")
				}
			}
			if !item.IcmpEchoHistoryFilterFailures.IsNull() && !item.IcmpEchoHistoryFilterFailures.IsUnknown() {
				if item.IcmpEchoHistoryFilterFailures.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "type/icmp/echo/history/filter/failures", "")
				}
			}
			if !item.IcmpEchoHistoryLives.IsNull() && !item.IcmpEchoHistoryLives.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/echo/history/lives", strconv.FormatInt(item.IcmpEchoHistoryLives.ValueInt64(), 10))
			}
			if !item.IcmpEchoStatisticsHourlyBuckets.IsNull() && !item.IcmpEchoStatisticsHourlyBuckets.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/echo/statistics/hourly/buckets", strconv.FormatInt(item.IcmpEchoStatisticsHourlyBuckets.ValueInt64(), 10))
			}
			if !item.IcmpEchoStatisticsHourlyDistributionCount.IsNull() && !item.IcmpEchoStatisticsHourlyDistributionCount.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/echo/statistics/hourly/distribution/count", strconv.FormatInt(item.IcmpEchoStatisticsHourlyDistributionCount.ValueInt64(), 10))
			}
			if !item.IcmpEchoStatisticsHourlyDistributionInterval.IsNull() && !item.IcmpEchoStatisticsHourlyDistributionInterval.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/echo/statistics/hourly/distribution/interval", strconv.FormatInt(item.IcmpEchoStatisticsHourlyDistributionInterval.ValueInt64(), 10))
			}
			if len(item.IcmpEchoStatisticsIntervals) > 0 {
				for _, citem := range item.IcmpEchoStatisticsIntervals {
					ccBody := netconf.Body{}
					if !citem.Interval.IsNull() && !citem.Interval.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "interval-time", strconv.FormatInt(citem.Interval.ValueInt64(), 10))
					}
					if !citem.Buckets.IsNull() && !citem.Buckets.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "buckets", strconv.FormatInt(citem.Buckets.ValueInt64(), 10))
					}
					cBody = helpers.SetRawFromXPath(cBody, "type/icmp/echo/statistics/intervals/interval", ccBody.Res())
				}
			}
			if !item.IcmpPathEcho.IsNull() && !item.IcmpPathEcho.IsUnknown() {
				if item.IcmpPathEcho.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "type/icmp/path-echo", "")
				}
			}
			if !item.IcmpPathEchoTag.IsNull() && !item.IcmpPathEchoTag.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-echo/tag", item.IcmpPathEchoTag.ValueString())
			}
			if !item.IcmpPathEchoFrequency.IsNull() && !item.IcmpPathEchoFrequency.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-echo/frequency", strconv.FormatInt(item.IcmpPathEchoFrequency.ValueInt64(), 10))
			}
			if !item.IcmpPathEchoDatasizeRequest.IsNull() && !item.IcmpPathEchoDatasizeRequest.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-echo/datasize/request/enter-request-datasize-in-byte", strconv.FormatInt(item.IcmpPathEchoDatasizeRequest.ValueInt64(), 10))
			}
			if !item.IcmpPathEchoTimeout.IsNull() && !item.IcmpPathEchoTimeout.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-echo/timeout", strconv.FormatInt(item.IcmpPathEchoTimeout.ValueInt64(), 10))
			}
			if !item.IcmpPathEchoSourceIpv4.IsNull() && !item.IcmpPathEchoSourceIpv4.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-echo/source/address/ipv4-address", item.IcmpPathEchoSourceIpv4.ValueString())
			}
			if !item.IcmpPathEchoTos.IsNull() && !item.IcmpPathEchoTos.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-echo/tos", strconv.FormatInt(item.IcmpPathEchoTos.ValueInt64(), 10))
			}
			if !item.IcmpPathEchoDestinationIpv4.IsNull() && !item.IcmpPathEchoDestinationIpv4.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-echo/destination/address/address", item.IcmpPathEchoDestinationIpv4.ValueString())
			}
			if !item.IcmpPathEchoHistoryBuckets.IsNull() && !item.IcmpPathEchoHistoryBuckets.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-echo/history/buckets", strconv.FormatInt(item.IcmpPathEchoHistoryBuckets.ValueInt64(), 10))
			}
			if !item.IcmpPathEchoHistoryFilterAll.IsNull() && !item.IcmpPathEchoHistoryFilterAll.IsUnknown() {
				if item.IcmpPathEchoHistoryFilterAll.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "type/icmp/path-echo/history/filter/all", "")
				}
			}
			if !item.IcmpPathEchoHistoryFilterFailures.IsNull() && !item.IcmpPathEchoHistoryFilterFailures.IsUnknown() {
				if item.IcmpPathEchoHistoryFilterFailures.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "type/icmp/path-echo/history/filter/failures", "")
				}
			}
			if !item.IcmpPathEchoHistoryLives.IsNull() && !item.IcmpPathEchoHistoryLives.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-echo/history/lives", strconv.FormatInt(item.IcmpPathEchoHistoryLives.ValueInt64(), 10))
			}
			if !item.IcmpPathEchoHistorySamples.IsNull() && !item.IcmpPathEchoHistorySamples.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-echo/history/samples", strconv.FormatInt(item.IcmpPathEchoHistorySamples.ValueInt64(), 10))
			}
			if !item.IcmpPathEchoStatisticsHourlyBuckets.IsNull() && !item.IcmpPathEchoStatisticsHourlyBuckets.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-echo/statistics/hourly/buckets", strconv.FormatInt(item.IcmpPathEchoStatisticsHourlyBuckets.ValueInt64(), 10))
			}
			if !item.IcmpPathEchoStatisticsHourlyDistributionCount.IsNull() && !item.IcmpPathEchoStatisticsHourlyDistributionCount.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-echo/statistics/hourly/distribution/count", strconv.FormatInt(item.IcmpPathEchoStatisticsHourlyDistributionCount.ValueInt64(), 10))
			}
			if !item.IcmpPathEchoStatisticsHourlyDistributionInterval.IsNull() && !item.IcmpPathEchoStatisticsHourlyDistributionInterval.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-echo/statistics/hourly/distribution/interval", strconv.FormatInt(item.IcmpPathEchoStatisticsHourlyDistributionInterval.ValueInt64(), 10))
			}
			if !item.IcmpPathEchoStatisticsHourlyMaximumHops.IsNull() && !item.IcmpPathEchoStatisticsHourlyMaximumHops.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-echo/statistics/hourly/maximum/hops", strconv.FormatInt(item.IcmpPathEchoStatisticsHourlyMaximumHops.ValueInt64(), 10))
			}
			if !item.IcmpPathEchoStatisticsHourlyMaximumPaths.IsNull() && !item.IcmpPathEchoStatisticsHourlyMaximumPaths.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-echo/statistics/hourly/maximum/paths", strconv.FormatInt(item.IcmpPathEchoStatisticsHourlyMaximumPaths.ValueInt64(), 10))
			}
			if !item.IcmpPathJitter.IsNull() && !item.IcmpPathJitter.IsUnknown() {
				if item.IcmpPathJitter.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "type/icmp/path-jitter", "")
				}
			}
			if !item.IcmpPathJitterTag.IsNull() && !item.IcmpPathJitterTag.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-jitter/tag", item.IcmpPathJitterTag.ValueString())
			}
			if !item.IcmpPathJitterFrequency.IsNull() && !item.IcmpPathJitterFrequency.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-jitter/frequency", strconv.FormatInt(item.IcmpPathJitterFrequency.ValueInt64(), 10))
			}
			if !item.IcmpPathJitterDatasizeRequest.IsNull() && !item.IcmpPathJitterDatasizeRequest.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-jitter/datasize/request/enter-request-datasize-in-byte", strconv.FormatInt(item.IcmpPathJitterDatasizeRequest.ValueInt64(), 10))
			}
			if !item.IcmpPathJitterTimeout.IsNull() && !item.IcmpPathJitterTimeout.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-jitter/timeout", strconv.FormatInt(item.IcmpPathJitterTimeout.ValueInt64(), 10))
			}
			if !item.IcmpPathJitterSourceIpv4.IsNull() && !item.IcmpPathJitterSourceIpv4.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-jitter/source/address/ipv4-address", item.IcmpPathJitterSourceIpv4.ValueString())
			}
			if !item.IcmpPathJitterPacketCount.IsNull() && !item.IcmpPathJitterPacketCount.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-jitter/packet/count", strconv.FormatInt(item.IcmpPathJitterPacketCount.ValueInt64(), 10))
			}
			if !item.IcmpPathJitterPacketInterval.IsNull() && !item.IcmpPathJitterPacketInterval.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-jitter/packet/interval", strconv.FormatInt(item.IcmpPathJitterPacketInterval.ValueInt64(), 10))
			}
			if !item.IcmpPathJitterTos.IsNull() && !item.IcmpPathJitterTos.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-jitter/tos", strconv.FormatInt(item.IcmpPathJitterTos.ValueInt64(), 10))
			}
			if !item.IcmpPathJitterDestinationIpv4.IsNull() && !item.IcmpPathJitterDestinationIpv4.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/icmp/path-jitter/destination/address/address", item.IcmpPathJitterDestinationIpv4.ValueString())
			}
			if !item.UdpEcho.IsNull() && !item.UdpEcho.IsUnknown() {
				if item.UdpEcho.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "type/udp/echo", "")
				}
			}
			if !item.UdpEchoTag.IsNull() && !item.UdpEchoTag.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/echo/tag", item.UdpEchoTag.ValueString())
			}
			if !item.UdpEchoFrequency.IsNull() && !item.UdpEchoFrequency.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/echo/frequency", strconv.FormatInt(item.UdpEchoFrequency.ValueInt64(), 10))
			}
			if !item.UdpEchoDatasizeRequest.IsNull() && !item.UdpEchoDatasizeRequest.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/echo/datasize/request/enter-request-datasize-in-byte", strconv.FormatInt(item.UdpEchoDatasizeRequest.ValueInt64(), 10))
			}
			if !item.UdpEchoTimeout.IsNull() && !item.UdpEchoTimeout.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/echo/timeout", strconv.FormatInt(item.UdpEchoTimeout.ValueInt64(), 10))
			}
			if !item.UdpEchoSourceIpv4.IsNull() && !item.UdpEchoSourceIpv4.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/echo/source/address/ipv4-address", item.UdpEchoSourceIpv4.ValueString())
			}
			if !item.UdpEchoSourcePort.IsNull() && !item.UdpEchoSourcePort.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/echo/source/port", strconv.FormatInt(item.UdpEchoSourcePort.ValueInt64(), 10))
			}
			if !item.UdpEchoDestinationIpv4.IsNull() && !item.UdpEchoDestinationIpv4.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/echo/destination/address", item.UdpEchoDestinationIpv4.ValueString())
			}
			if !item.UdpEchoDestinationPort.IsNull() && !item.UdpEchoDestinationPort.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/echo/destination/port", strconv.FormatInt(item.UdpEchoDestinationPort.ValueInt64(), 10))
			}
			if !item.UdpEchoControlDisable.IsNull() && !item.UdpEchoControlDisable.IsUnknown() {
				if item.UdpEchoControlDisable.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "type/udp/echo/control/disable", "")
				}
			}
			if !item.UdpEchoVerifyData.IsNull() && !item.UdpEchoVerifyData.IsUnknown() {
				if item.UdpEchoVerifyData.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "type/udp/echo/verify-data", "")
				}
			}
			if !item.UdpEchoTos.IsNull() && !item.UdpEchoTos.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/echo/tos", strconv.FormatInt(item.UdpEchoTos.ValueInt64(), 10))
			}
			if !item.UdpEchoVrf.IsNull() && !item.UdpEchoVrf.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/echo/vrf", item.UdpEchoVrf.ValueString())
			}
			if !item.UdpEchoStatisticsHourlyBuckets.IsNull() && !item.UdpEchoStatisticsHourlyBuckets.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/echo/statistics/hourly/buckets", strconv.FormatInt(item.UdpEchoStatisticsHourlyBuckets.ValueInt64(), 10))
			}
			if !item.UdpEchoStatisticsHourlyDistributionCount.IsNull() && !item.UdpEchoStatisticsHourlyDistributionCount.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/echo/statistics/hourly/distribution/count", strconv.FormatInt(item.UdpEchoStatisticsHourlyDistributionCount.ValueInt64(), 10))
			}
			if !item.UdpEchoStatisticsHourlyDistributionInterval.IsNull() && !item.UdpEchoStatisticsHourlyDistributionInterval.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/echo/statistics/hourly/distribution/interval", strconv.FormatInt(item.UdpEchoStatisticsHourlyDistributionInterval.ValueInt64(), 10))
			}
			if len(item.UdpEchoStatisticsIntervals) > 0 {
				for _, citem := range item.UdpEchoStatisticsIntervals {
					ccBody := netconf.Body{}
					if !citem.Interval.IsNull() && !citem.Interval.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "interval-time", strconv.FormatInt(citem.Interval.ValueInt64(), 10))
					}
					if !citem.Buckets.IsNull() && !citem.Buckets.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "buckets", strconv.FormatInt(citem.Buckets.ValueInt64(), 10))
					}
					cBody = helpers.SetRawFromXPath(cBody, "type/udp/echo/statistics/intervals/interval", ccBody.Res())
				}
			}
			if !item.UdpEchoHistoryBuckets.IsNull() && !item.UdpEchoHistoryBuckets.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/echo/history/buckets", strconv.FormatInt(item.UdpEchoHistoryBuckets.ValueInt64(), 10))
			}
			if !item.UdpEchoHistoryFilterAll.IsNull() && !item.UdpEchoHistoryFilterAll.IsUnknown() {
				if item.UdpEchoHistoryFilterAll.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "type/udp/echo/history/filter/all", "")
				}
			}
			if !item.UdpEchoHistoryFilterFailures.IsNull() && !item.UdpEchoHistoryFilterFailures.IsUnknown() {
				if item.UdpEchoHistoryFilterFailures.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "type/udp/echo/history/filter/failures", "")
				}
			}
			if !item.UdpEchoHistoryLives.IsNull() && !item.UdpEchoHistoryLives.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/echo/history/lives", strconv.FormatInt(item.UdpEchoHistoryLives.ValueInt64(), 10))
			}
			if !item.UdpJitter.IsNull() && !item.UdpJitter.IsUnknown() {
				if item.UdpJitter.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "type/udp/jitter", "")
				}
			}
			if !item.UdpJitterTag.IsNull() && !item.UdpJitterTag.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/jitter/tag", item.UdpJitterTag.ValueString())
			}
			if !item.UdpJitterFrequency.IsNull() && !item.UdpJitterFrequency.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/jitter/frequency", strconv.FormatInt(item.UdpJitterFrequency.ValueInt64(), 10))
			}
			if !item.UdpJitterDatasizeRequest.IsNull() && !item.UdpJitterDatasizeRequest.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/jitter/datasize/request/enter-request-datasize-in-byte", strconv.FormatInt(item.UdpJitterDatasizeRequest.ValueInt64(), 10))
			}
			if !item.UdpJitterTimeout.IsNull() && !item.UdpJitterTimeout.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/jitter/timeout", strconv.FormatInt(item.UdpJitterTimeout.ValueInt64(), 10))
			}
			if !item.UdpJitterSourceIpv4.IsNull() && !item.UdpJitterSourceIpv4.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/jitter/source/address/ipv4-address", item.UdpJitterSourceIpv4.ValueString())
			}
			if !item.UdpJitterSourcePort.IsNull() && !item.UdpJitterSourcePort.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/jitter/source/port", strconv.FormatInt(item.UdpJitterSourcePort.ValueInt64(), 10))
			}
			if !item.UdpJitterDestinationIpv4.IsNull() && !item.UdpJitterDestinationIpv4.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/jitter/destination/address", item.UdpJitterDestinationIpv4.ValueString())
			}
			if !item.UdpJitterDestinationPort.IsNull() && !item.UdpJitterDestinationPort.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/jitter/destination/port", strconv.FormatInt(item.UdpJitterDestinationPort.ValueInt64(), 10))
			}
			if !item.UdpJitterPacketCount.IsNull() && !item.UdpJitterPacketCount.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/jitter/packet/count", strconv.FormatInt(item.UdpJitterPacketCount.ValueInt64(), 10))
			}
			if !item.UdpJitterPacketInterval.IsNull() && !item.UdpJitterPacketInterval.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/jitter/packet/interval", strconv.FormatInt(item.UdpJitterPacketInterval.ValueInt64(), 10))
			}
			if !item.UdpJitterTos.IsNull() && !item.UdpJitterTos.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/jitter/tos", strconv.FormatInt(item.UdpJitterTos.ValueInt64(), 10))
			}
			if !item.UdpJitterVrf.IsNull() && !item.UdpJitterVrf.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/jitter/vrf", item.UdpJitterVrf.ValueString())
			}
			if !item.UdpJitterControlDisable.IsNull() && !item.UdpJitterControlDisable.IsUnknown() {
				if item.UdpJitterControlDisable.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "type/udp/jitter/control/disable", "")
				}
			}
			if !item.UdpJitterVerifyData.IsNull() && !item.UdpJitterVerifyData.IsUnknown() {
				if item.UdpJitterVerifyData.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "type/udp/jitter/verify-data", "")
				}
			}
			if !item.UdpJitterStatisticsHourlyBuckets.IsNull() && !item.UdpJitterStatisticsHourlyBuckets.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/jitter/statistics/hourly/buckets", strconv.FormatInt(item.UdpJitterStatisticsHourlyBuckets.ValueInt64(), 10))
			}
			if !item.UdpJitterStatisticsHourlyDistributionCount.IsNull() && !item.UdpJitterStatisticsHourlyDistributionCount.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/jitter/statistics/hourly/distribution/count", strconv.FormatInt(item.UdpJitterStatisticsHourlyDistributionCount.ValueInt64(), 10))
			}
			if !item.UdpJitterStatisticsHourlyDistributionInterval.IsNull() && !item.UdpJitterStatisticsHourlyDistributionInterval.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/udp/jitter/statistics/hourly/distribution/interval", strconv.FormatInt(item.UdpJitterStatisticsHourlyDistributionInterval.ValueInt64(), 10))
			}
			if len(item.UdpJitterStatisticsIntervals) > 0 {
				for _, citem := range item.UdpJitterStatisticsIntervals {
					ccBody := netconf.Body{}
					if !citem.Interval.IsNull() && !citem.Interval.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "interval-time", strconv.FormatInt(citem.Interval.ValueInt64(), 10))
					}
					if !citem.Buckets.IsNull() && !citem.Buckets.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "buckets", strconv.FormatInt(citem.Buckets.ValueInt64(), 10))
					}
					cBody = helpers.SetRawFromXPath(cBody, "type/udp/jitter/statistics/intervals/interval", ccBody.Res())
				}
			}
			if !item.MplsLspPing.IsNull() && !item.MplsLspPing.IsUnknown() {
				if item.MplsLspPing.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/ping", "")
				}
			}
			if !item.MplsLspPingTag.IsNull() && !item.MplsLspPingTag.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/ping/tag", item.MplsLspPingTag.ValueString())
			}
			if !item.MplsLspPingFrequency.IsNull() && !item.MplsLspPingFrequency.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/ping/frequency", strconv.FormatInt(item.MplsLspPingFrequency.ValueInt64(), 10))
			}
			if !item.MplsLspPingDatasizeRequest.IsNull() && !item.MplsLspPingDatasizeRequest.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/ping/datasize/request/enter-request-datasize-in-byte", strconv.FormatInt(item.MplsLspPingDatasizeRequest.ValueInt64(), 10))
			}
			if !item.MplsLspPingTimeout.IsNull() && !item.MplsLspPingTimeout.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/ping/timeout", strconv.FormatInt(item.MplsLspPingTimeout.ValueInt64(), 10))
			}
			if !item.MplsLspPingSourceIpv4.IsNull() && !item.MplsLspPingSourceIpv4.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/ping/source/address/ipv4-address", item.MplsLspPingSourceIpv4.ValueString())
			}
			if !item.MplsLspPingTargetIpv4.IsNull() && !item.MplsLspPingTargetIpv4.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/ping/target/ipv4/address", item.MplsLspPingTargetIpv4.ValueString())
			}
			if !item.MplsLspPingTargetIpv4Mask.IsNull() && !item.MplsLspPingTargetIpv4Mask.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/ping/target/ipv4/mask", item.MplsLspPingTargetIpv4Mask.ValueString())
			}
			if !item.MplsLspPingTargetTeTunnel.IsNull() && !item.MplsLspPingTargetTeTunnel.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/ping/target/traffic-eng/tunnel", strconv.FormatInt(item.MplsLspPingTargetTeTunnel.ValueInt64(), 10))
			}
			if !item.MplsLspPingTargetPseudowireAddress.IsNull() && !item.MplsLspPingTargetPseudowireAddress.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/ping/target/pseudowire/address", item.MplsLspPingTargetPseudowireAddress.ValueString())
			}
			if !item.MplsLspPingTargetPseudowireVcId.IsNull() && !item.MplsLspPingTargetPseudowireVcId.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/ping/target/pseudowire/virtual-circuit-id", strconv.FormatInt(item.MplsLspPingTargetPseudowireVcId.ValueInt64(), 10))
			}
			if !item.MplsLspPingStatisticsHourlyBuckets.IsNull() && !item.MplsLspPingStatisticsHourlyBuckets.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/ping/statistics/hourly/buckets", strconv.FormatInt(item.MplsLspPingStatisticsHourlyBuckets.ValueInt64(), 10))
			}
			if !item.MplsLspPingStatisticsHourlyDistributionCount.IsNull() && !item.MplsLspPingStatisticsHourlyDistributionCount.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/ping/statistics/hourly/distribution/count", strconv.FormatInt(item.MplsLspPingStatisticsHourlyDistributionCount.ValueInt64(), 10))
			}
			if !item.MplsLspPingStatisticsHourlyDistributionInterval.IsNull() && !item.MplsLspPingStatisticsHourlyDistributionInterval.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/ping/statistics/hourly/distribution/interval", strconv.FormatInt(item.MplsLspPingStatisticsHourlyDistributionInterval.ValueInt64(), 10))
			}
			if len(item.MplsLspPingStatisticsIntervals) > 0 {
				for _, citem := range item.MplsLspPingStatisticsIntervals {
					ccBody := netconf.Body{}
					if !citem.Interval.IsNull() && !citem.Interval.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "interval-time", strconv.FormatInt(citem.Interval.ValueInt64(), 10))
					}
					if !citem.Buckets.IsNull() && !citem.Buckets.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "buckets", strconv.FormatInt(citem.Buckets.ValueInt64(), 10))
					}
					cBody = helpers.SetRawFromXPath(cBody, "type/mpls/lsp/ping/statistics/intervals/interval", ccBody.Res())
				}
			}
			if !item.MplsLspTrace.IsNull() && !item.MplsLspTrace.IsUnknown() {
				if item.MplsLspTrace.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/trace", "")
				}
			}
			if !item.MplsLspTraceTag.IsNull() && !item.MplsLspTraceTag.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/trace/tag", item.MplsLspTraceTag.ValueString())
			}
			if !item.MplsLspTraceFrequency.IsNull() && !item.MplsLspTraceFrequency.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/trace/frequency", strconv.FormatInt(item.MplsLspTraceFrequency.ValueInt64(), 10))
			}
			if !item.MplsLspTraceTimeout.IsNull() && !item.MplsLspTraceTimeout.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/trace/timeout", strconv.FormatInt(item.MplsLspTraceTimeout.ValueInt64(), 10))
			}
			if !item.MplsLspTraceSourceIpv4.IsNull() && !item.MplsLspTraceSourceIpv4.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/trace/source/address/ipv4-address", item.MplsLspTraceSourceIpv4.ValueString())
			}
			if !item.MplsLspTraceTargetIpv4.IsNull() && !item.MplsLspTraceTargetIpv4.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/trace/target/ipv4/address", item.MplsLspTraceTargetIpv4.ValueString())
			}
			if !item.MplsLspTraceTargetIpv4Mask.IsNull() && !item.MplsLspTraceTargetIpv4Mask.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/trace/target/ipv4/mask", item.MplsLspTraceTargetIpv4Mask.ValueString())
			}
			if !item.MplsLspTraceTargetTeTunnel.IsNull() && !item.MplsLspTraceTargetTeTunnel.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/trace/target/traffic-eng/tunnel", strconv.FormatInt(item.MplsLspTraceTargetTeTunnel.ValueInt64(), 10))
			}
			if !item.MplsLspTraceTargetPseudowireAddress.IsNull() && !item.MplsLspTraceTargetPseudowireAddress.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/trace/target/pseudowire/address", item.MplsLspTraceTargetPseudowireAddress.ValueString())
			}
			if !item.MplsLspTraceTargetPseudowireVcId.IsNull() && !item.MplsLspTraceTargetPseudowireVcId.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/trace/target/pseudowire/virtual-circuit-id", strconv.FormatInt(item.MplsLspTraceTargetPseudowireVcId.ValueInt64(), 10))
			}
			if !item.MplsLspTraceStatisticsHourlyBuckets.IsNull() && !item.MplsLspTraceStatisticsHourlyBuckets.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/trace/statistics/hourly/buckets", strconv.FormatInt(item.MplsLspTraceStatisticsHourlyBuckets.ValueInt64(), 10))
			}
			if !item.MplsLspTraceStatisticsHourlyDistributionCount.IsNull() && !item.MplsLspTraceStatisticsHourlyDistributionCount.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/trace/statistics/hourly/distribution/count", strconv.FormatInt(item.MplsLspTraceStatisticsHourlyDistributionCount.ValueInt64(), 10))
			}
			if !item.MplsLspTraceStatisticsHourlyDistributionInterval.IsNull() && !item.MplsLspTraceStatisticsHourlyDistributionInterval.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "type/mpls/lsp/trace/statistics/hourly/distribution/interval", strconv.FormatInt(item.MplsLspTraceStatisticsHourlyDistributionInterval.ValueInt64(), 10))
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"operations/operation", cBody.Res())
		}
	}
	if len(data.Schedules) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.Schedules {
			cBody := netconf.Body{}
			if !item.OperationNumber.IsNull() && !item.OperationNumber.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "operation-number", strconv.FormatInt(item.OperationNumber.ValueInt64(), 10))
			}
			if !item.LifeForever.IsNull() && !item.LifeForever.IsUnknown() {
				if item.LifeForever.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "life/forever", "")
				}
			}
			if !item.LifeTime.IsNull() && !item.LifeTime.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "life/length-of-time", strconv.FormatInt(item.LifeTime.ValueInt64(), 10))
			}
			if !item.StartHour.IsNull() && !item.StartHour.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "start-time/time-and-date/hour", strconv.FormatInt(item.StartHour.ValueInt64(), 10))
			}
			if !item.StartMinute.IsNull() && !item.StartMinute.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "start-time/time-and-date/minute", strconv.FormatInt(item.StartMinute.ValueInt64(), 10))
			}
			if !item.StartSecond.IsNull() && !item.StartSecond.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "start-time/time-and-date/second", strconv.FormatInt(item.StartSecond.ValueInt64(), 10))
			}
			if !item.StartMonth.IsNull() && !item.StartMonth.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "start-time/time-and-date/month", item.StartMonth.ValueString())
			}
			if !item.StartDayOfMonth.IsNull() && !item.StartDayOfMonth.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "start-time/time-and-date/day-of-month", strconv.FormatInt(item.StartDayOfMonth.ValueInt64(), 10))
			}
			if !item.StartYear.IsNull() && !item.StartYear.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "start-time/time-and-date/year", strconv.FormatInt(item.StartYear.ValueInt64(), 10))
			}
			if !item.StartPending.IsNull() && !item.StartPending.IsUnknown() {
				if item.StartPending.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "start-time/pending", "")
				}
			}
			if !item.StartAfterHour.IsNull() && !item.StartAfterHour.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "start-time/after/time/hour", strconv.FormatInt(item.StartAfterHour.ValueInt64(), 10))
			}
			if !item.StartAfterMinute.IsNull() && !item.StartAfterMinute.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "start-time/after/time/minute", strconv.FormatInt(item.StartAfterMinute.ValueInt64(), 10))
			}
			if !item.StartAfterSecond.IsNull() && !item.StartAfterSecond.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "start-time/after/time/second", strconv.FormatInt(item.StartAfterSecond.ValueInt64(), 10))
			}
			if !item.StartNow.IsNull() && !item.StartNow.IsUnknown() {
				if item.StartNow.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "start-time/now", "")
				}
			}
			if !item.Recurring.IsNull() && !item.Recurring.IsUnknown() {
				if item.Recurring.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "recurring", "")
				}
			}
			if !item.Ageout.IsNull() && !item.Ageout.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "ageout", strconv.FormatInt(item.Ageout.ValueInt64(), 10))
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"schedule/operations/operation", cBody.Res())
		}
	}
	if !data.ServerTwamp.IsNull() && !data.ServerTwamp.IsUnknown() {
		if data.ServerTwamp.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/server/twamp", "")
		}
	}
	if !data.ServerTwampPort.IsNull() && !data.ServerTwampPort.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/server/twamp/port", strconv.FormatInt(data.ServerTwampPort.ValueInt64(), 10))
	}
	if !data.ServerTwampTimerInactivity.IsNull() && !data.ServerTwampTimerInactivity.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/server/twamp/timer/inactivity", strconv.FormatInt(data.ServerTwampTimerInactivity.ValueInt64(), 10))
	}
	bodyString, err := body.String()
	if err != nil {
		tflog.Error(ctx, fmt.Sprintf("Error converting body to string: %s", err))
	}
	return bodyString
}

// End of section. //template:end toBodyXML
// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBodyXML

func (data *IPSLA) updateFromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/low-memory"); value.Exists() {
		data.LowMemory = types.Int64Value(value.Int())
	} else if data.LowMemory.IsNull() {
		data.LowMemory = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/key-chain"); value.Exists() {
		data.KeyChain = types.StringValue(value.String())
	} else if data.KeyChain.IsNull() {
		data.KeyChain = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/hw-timestamp/disable"); value.Exists() {
		data.HwTimestampDisable = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.HwTimestampDisable.IsNull() {
			data.HwTimestampDisable = types.BoolNull()
		}
	}
	for i := range data.Operations {
		keys := [...]string{"operation-number"}
		keyValues := [...]string{strconv.FormatInt(data.Operations[i].OperationNumber.ValueInt64(), 10)}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/operations/operation").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "operation-number"); value.Exists() {
			data.Operations[i].OperationNumber = types.Int64Value(value.Int())
		} else if data.Operations[i].OperationNumber.IsNull() {
			data.Operations[i].OperationNumber = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/echo"); value.Exists() {
			data.Operations[i].IcmpEcho = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Operations[i].IcmpEcho.IsNull() {
				data.Operations[i].IcmpEcho = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "type/icmp/echo/tag"); value.Exists() {
			data.Operations[i].IcmpEchoTag = types.StringValue(value.String())
		} else if data.Operations[i].IcmpEchoTag.IsNull() {
			data.Operations[i].IcmpEchoTag = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/echo/frequency"); value.Exists() {
			data.Operations[i].IcmpEchoFrequency = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpEchoFrequency.IsNull() {
			data.Operations[i].IcmpEchoFrequency = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/echo/datasize/request/enter-request-datasize-in-byte"); value.Exists() {
			data.Operations[i].IcmpEchoDatasizeRequest = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpEchoDatasizeRequest.IsNull() {
			data.Operations[i].IcmpEchoDatasizeRequest = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/echo/timeout"); value.Exists() {
			data.Operations[i].IcmpEchoTimeout = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpEchoTimeout.IsNull() {
			data.Operations[i].IcmpEchoTimeout = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/echo/source/address/ipv4-address"); value.Exists() {
			data.Operations[i].IcmpEchoSourceIpv4 = types.StringValue(value.String())
		} else if data.Operations[i].IcmpEchoSourceIpv4.IsNull() {
			data.Operations[i].IcmpEchoSourceIpv4 = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/echo/source/address/ipv6-address"); value.Exists() {
			data.Operations[i].IcmpEchoSourceIpv6 = types.StringValue(value.String())
		} else if data.Operations[i].IcmpEchoSourceIpv6.IsNull() {
			data.Operations[i].IcmpEchoSourceIpv6 = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/echo/tos"); value.Exists() {
			data.Operations[i].IcmpEchoTos = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpEchoTos.IsNull() {
			data.Operations[i].IcmpEchoTos = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/echo/vrf"); value.Exists() {
			data.Operations[i].IcmpEchoVrf = types.StringValue(value.String())
		} else if data.Operations[i].IcmpEchoVrf.IsNull() {
			data.Operations[i].IcmpEchoVrf = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/echo/destination/address/ipv4-address"); value.Exists() {
			data.Operations[i].IcmpEchoDestinationIpv4 = types.StringValue(value.String())
		} else if data.Operations[i].IcmpEchoDestinationIpv4.IsNull() {
			data.Operations[i].IcmpEchoDestinationIpv4 = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/echo/destination/address/ipv6-address"); value.Exists() {
			data.Operations[i].IcmpEchoDestinationIpv6 = types.StringValue(value.String())
		} else if data.Operations[i].IcmpEchoDestinationIpv6.IsNull() {
			data.Operations[i].IcmpEchoDestinationIpv6 = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/echo/history/buckets"); value.Exists() {
			data.Operations[i].IcmpEchoHistoryBuckets = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpEchoHistoryBuckets.IsNull() {
			data.Operations[i].IcmpEchoHistoryBuckets = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/echo/history/filter/all"); value.Exists() {
			data.Operations[i].IcmpEchoHistoryFilterAll = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Operations[i].IcmpEchoHistoryFilterAll.IsNull() {
				data.Operations[i].IcmpEchoHistoryFilterAll = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "type/icmp/echo/history/filter/failures"); value.Exists() {
			data.Operations[i].IcmpEchoHistoryFilterFailures = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Operations[i].IcmpEchoHistoryFilterFailures.IsNull() {
				data.Operations[i].IcmpEchoHistoryFilterFailures = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "type/icmp/echo/history/lives"); value.Exists() {
			data.Operations[i].IcmpEchoHistoryLives = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpEchoHistoryLives.IsNull() {
			data.Operations[i].IcmpEchoHistoryLives = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/echo/statistics/hourly/buckets"); value.Exists() {
			data.Operations[i].IcmpEchoStatisticsHourlyBuckets = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpEchoStatisticsHourlyBuckets.IsNull() {
			data.Operations[i].IcmpEchoStatisticsHourlyBuckets = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/echo/statistics/hourly/distribution/count"); value.Exists() {
			data.Operations[i].IcmpEchoStatisticsHourlyDistributionCount = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpEchoStatisticsHourlyDistributionCount.IsNull() {
			data.Operations[i].IcmpEchoStatisticsHourlyDistributionCount = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/echo/statistics/hourly/distribution/interval"); value.Exists() {
			data.Operations[i].IcmpEchoStatisticsHourlyDistributionInterval = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpEchoStatisticsHourlyDistributionInterval.IsNull() {
			data.Operations[i].IcmpEchoStatisticsHourlyDistributionInterval = types.Int64Null()
		}
		// Rebuild nested list from device XML response
		if value := helpers.GetFromXPath(r, "type/icmp/echo/statistics/intervals/interval"); value.Exists() {
			// Match existing state items with device response by key fields
			existingItems := data.Operations[i].IcmpEchoStatisticsIntervals
			data.Operations[i].IcmpEchoStatisticsIntervals = make([]IPSLAOperationsIcmpEchoStatisticsIntervals, 0)

			value.ForEach(func(_ int, cr xmldot.Result) bool {
				citem := IPSLAOperationsIcmpEchoStatisticsIntervals{}

				// First, populate all fields from device
				if cValue := helpers.GetFromXPath(cr, "interval-time"); cValue.Exists() {
					citem.Interval = types.Int64Value(cValue.Int())
				}
				if cValue := helpers.GetFromXPath(cr, "buckets"); cValue.Exists() {
					citem.Buckets = types.Int64Value(cValue.Int())
				}

				// Try to find matching item in existing state to preserve field states
				for _, existingItem := range existingItems {
					match := true
					if !existingItem.Interval.Equal(citem.Interval) {
						match = false
					}

					if match {
						// Found matching item - preserve state for fields not in device response
						break
					}
				}

				data.Operations[i].IcmpEchoStatisticsIntervals = append(data.Operations[i].IcmpEchoStatisticsIntervals, citem)
				return true
			})
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-echo"); value.Exists() {
			data.Operations[i].IcmpPathEcho = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Operations[i].IcmpPathEcho.IsNull() {
				data.Operations[i].IcmpPathEcho = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-echo/tag"); value.Exists() {
			data.Operations[i].IcmpPathEchoTag = types.StringValue(value.String())
		} else if data.Operations[i].IcmpPathEchoTag.IsNull() {
			data.Operations[i].IcmpPathEchoTag = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-echo/frequency"); value.Exists() {
			data.Operations[i].IcmpPathEchoFrequency = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpPathEchoFrequency.IsNull() {
			data.Operations[i].IcmpPathEchoFrequency = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-echo/datasize/request/enter-request-datasize-in-byte"); value.Exists() {
			data.Operations[i].IcmpPathEchoDatasizeRequest = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpPathEchoDatasizeRequest.IsNull() {
			data.Operations[i].IcmpPathEchoDatasizeRequest = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-echo/timeout"); value.Exists() {
			data.Operations[i].IcmpPathEchoTimeout = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpPathEchoTimeout.IsNull() {
			data.Operations[i].IcmpPathEchoTimeout = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-echo/source/address/ipv4-address"); value.Exists() {
			data.Operations[i].IcmpPathEchoSourceIpv4 = types.StringValue(value.String())
		} else if data.Operations[i].IcmpPathEchoSourceIpv4.IsNull() {
			data.Operations[i].IcmpPathEchoSourceIpv4 = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-echo/tos"); value.Exists() {
			data.Operations[i].IcmpPathEchoTos = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpPathEchoTos.IsNull() {
			data.Operations[i].IcmpPathEchoTos = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-echo/destination/address/address"); value.Exists() {
			data.Operations[i].IcmpPathEchoDestinationIpv4 = types.StringValue(value.String())
		} else if data.Operations[i].IcmpPathEchoDestinationIpv4.IsNull() {
			data.Operations[i].IcmpPathEchoDestinationIpv4 = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-echo/history/buckets"); value.Exists() {
			data.Operations[i].IcmpPathEchoHistoryBuckets = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpPathEchoHistoryBuckets.IsNull() {
			data.Operations[i].IcmpPathEchoHistoryBuckets = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-echo/history/filter/all"); value.Exists() {
			data.Operations[i].IcmpPathEchoHistoryFilterAll = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Operations[i].IcmpPathEchoHistoryFilterAll.IsNull() {
				data.Operations[i].IcmpPathEchoHistoryFilterAll = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-echo/history/filter/failures"); value.Exists() {
			data.Operations[i].IcmpPathEchoHistoryFilterFailures = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Operations[i].IcmpPathEchoHistoryFilterFailures.IsNull() {
				data.Operations[i].IcmpPathEchoHistoryFilterFailures = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-echo/history/lives"); value.Exists() {
			data.Operations[i].IcmpPathEchoHistoryLives = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpPathEchoHistoryLives.IsNull() {
			data.Operations[i].IcmpPathEchoHistoryLives = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-echo/history/samples"); value.Exists() {
			data.Operations[i].IcmpPathEchoHistorySamples = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpPathEchoHistorySamples.IsNull() {
			data.Operations[i].IcmpPathEchoHistorySamples = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-echo/statistics/hourly/buckets"); value.Exists() {
			data.Operations[i].IcmpPathEchoStatisticsHourlyBuckets = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpPathEchoStatisticsHourlyBuckets.IsNull() {
			data.Operations[i].IcmpPathEchoStatisticsHourlyBuckets = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-echo/statistics/hourly/distribution/count"); value.Exists() {
			data.Operations[i].IcmpPathEchoStatisticsHourlyDistributionCount = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpPathEchoStatisticsHourlyDistributionCount.IsNull() {
			data.Operations[i].IcmpPathEchoStatisticsHourlyDistributionCount = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-echo/statistics/hourly/distribution/interval"); value.Exists() {
			data.Operations[i].IcmpPathEchoStatisticsHourlyDistributionInterval = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpPathEchoStatisticsHourlyDistributionInterval.IsNull() {
			data.Operations[i].IcmpPathEchoStatisticsHourlyDistributionInterval = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-echo/statistics/hourly/maximum/hops"); value.Exists() {
			data.Operations[i].IcmpPathEchoStatisticsHourlyMaximumHops = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpPathEchoStatisticsHourlyMaximumHops.IsNull() {
			data.Operations[i].IcmpPathEchoStatisticsHourlyMaximumHops = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-echo/statistics/hourly/maximum/paths"); value.Exists() {
			data.Operations[i].IcmpPathEchoStatisticsHourlyMaximumPaths = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpPathEchoStatisticsHourlyMaximumPaths.IsNull() {
			data.Operations[i].IcmpPathEchoStatisticsHourlyMaximumPaths = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-jitter"); value.Exists() {
			data.Operations[i].IcmpPathJitter = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Operations[i].IcmpPathJitter.IsNull() {
				data.Operations[i].IcmpPathJitter = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-jitter/tag"); value.Exists() {
			data.Operations[i].IcmpPathJitterTag = types.StringValue(value.String())
		} else if data.Operations[i].IcmpPathJitterTag.IsNull() {
			data.Operations[i].IcmpPathJitterTag = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-jitter/frequency"); value.Exists() {
			data.Operations[i].IcmpPathJitterFrequency = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpPathJitterFrequency.IsNull() {
			data.Operations[i].IcmpPathJitterFrequency = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-jitter/datasize/request/enter-request-datasize-in-byte"); value.Exists() {
			data.Operations[i].IcmpPathJitterDatasizeRequest = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpPathJitterDatasizeRequest.IsNull() {
			data.Operations[i].IcmpPathJitterDatasizeRequest = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-jitter/timeout"); value.Exists() {
			data.Operations[i].IcmpPathJitterTimeout = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpPathJitterTimeout.IsNull() {
			data.Operations[i].IcmpPathJitterTimeout = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-jitter/source/address/ipv4-address"); value.Exists() {
			data.Operations[i].IcmpPathJitterSourceIpv4 = types.StringValue(value.String())
		} else if data.Operations[i].IcmpPathJitterSourceIpv4.IsNull() {
			data.Operations[i].IcmpPathJitterSourceIpv4 = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-jitter/packet/count"); value.Exists() {
			data.Operations[i].IcmpPathJitterPacketCount = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpPathJitterPacketCount.IsNull() {
			data.Operations[i].IcmpPathJitterPacketCount = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-jitter/packet/interval"); value.Exists() {
			data.Operations[i].IcmpPathJitterPacketInterval = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpPathJitterPacketInterval.IsNull() {
			data.Operations[i].IcmpPathJitterPacketInterval = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-jitter/tos"); value.Exists() {
			data.Operations[i].IcmpPathJitterTos = types.Int64Value(value.Int())
		} else if data.Operations[i].IcmpPathJitterTos.IsNull() {
			data.Operations[i].IcmpPathJitterTos = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/icmp/path-jitter/destination/address/address"); value.Exists() {
			data.Operations[i].IcmpPathJitterDestinationIpv4 = types.StringValue(value.String())
		} else if data.Operations[i].IcmpPathJitterDestinationIpv4.IsNull() {
			data.Operations[i].IcmpPathJitterDestinationIpv4 = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/udp/echo"); value.Exists() {
			data.Operations[i].UdpEcho = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Operations[i].UdpEcho.IsNull() {
				data.Operations[i].UdpEcho = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "type/udp/echo/tag"); value.Exists() {
			data.Operations[i].UdpEchoTag = types.StringValue(value.String())
		} else if data.Operations[i].UdpEchoTag.IsNull() {
			data.Operations[i].UdpEchoTag = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/udp/echo/frequency"); value.Exists() {
			data.Operations[i].UdpEchoFrequency = types.Int64Value(value.Int())
		} else if data.Operations[i].UdpEchoFrequency.IsNull() {
			data.Operations[i].UdpEchoFrequency = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/udp/echo/datasize/request/enter-request-datasize-in-byte"); value.Exists() {
			data.Operations[i].UdpEchoDatasizeRequest = types.Int64Value(value.Int())
		} else if data.Operations[i].UdpEchoDatasizeRequest.IsNull() {
			data.Operations[i].UdpEchoDatasizeRequest = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/udp/echo/timeout"); value.Exists() {
			data.Operations[i].UdpEchoTimeout = types.Int64Value(value.Int())
		} else if data.Operations[i].UdpEchoTimeout.IsNull() {
			data.Operations[i].UdpEchoTimeout = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/udp/echo/source/address/ipv4-address"); value.Exists() {
			data.Operations[i].UdpEchoSourceIpv4 = types.StringValue(value.String())
		} else if data.Operations[i].UdpEchoSourceIpv4.IsNull() {
			data.Operations[i].UdpEchoSourceIpv4 = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/udp/echo/source/port"); value.Exists() {
			data.Operations[i].UdpEchoSourcePort = types.Int64Value(value.Int())
		} else if data.Operations[i].UdpEchoSourcePort.IsNull() {
			data.Operations[i].UdpEchoSourcePort = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/udp/echo/destination/address"); value.Exists() {
			data.Operations[i].UdpEchoDestinationIpv4 = types.StringValue(value.String())
		} else if data.Operations[i].UdpEchoDestinationIpv4.IsNull() {
			data.Operations[i].UdpEchoDestinationIpv4 = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/udp/echo/destination/port"); value.Exists() {
			data.Operations[i].UdpEchoDestinationPort = types.Int64Value(value.Int())
		} else if data.Operations[i].UdpEchoDestinationPort.IsNull() {
			data.Operations[i].UdpEchoDestinationPort = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/udp/echo/control/disable"); value.Exists() {
			data.Operations[i].UdpEchoControlDisable = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Operations[i].UdpEchoControlDisable.IsNull() {
				data.Operations[i].UdpEchoControlDisable = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "type/udp/echo/verify-data"); value.Exists() {
			data.Operations[i].UdpEchoVerifyData = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Operations[i].UdpEchoVerifyData.IsNull() {
				data.Operations[i].UdpEchoVerifyData = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "type/udp/echo/tos"); value.Exists() {
			data.Operations[i].UdpEchoTos = types.Int64Value(value.Int())
		} else if data.Operations[i].UdpEchoTos.IsNull() {
			data.Operations[i].UdpEchoTos = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/udp/echo/vrf"); value.Exists() {
			data.Operations[i].UdpEchoVrf = types.StringValue(value.String())
		} else if data.Operations[i].UdpEchoVrf.IsNull() {
			data.Operations[i].UdpEchoVrf = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/udp/echo/statistics/hourly/buckets"); value.Exists() {
			data.Operations[i].UdpEchoStatisticsHourlyBuckets = types.Int64Value(value.Int())
		} else if data.Operations[i].UdpEchoStatisticsHourlyBuckets.IsNull() {
			data.Operations[i].UdpEchoStatisticsHourlyBuckets = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/udp/echo/statistics/hourly/distribution/count"); value.Exists() {
			data.Operations[i].UdpEchoStatisticsHourlyDistributionCount = types.Int64Value(value.Int())
		} else if data.Operations[i].UdpEchoStatisticsHourlyDistributionCount.IsNull() {
			data.Operations[i].UdpEchoStatisticsHourlyDistributionCount = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/udp/echo/statistics/hourly/distribution/interval"); value.Exists() {
			data.Operations[i].UdpEchoStatisticsHourlyDistributionInterval = types.Int64Value(value.Int())
		} else if data.Operations[i].UdpEchoStatisticsHourlyDistributionInterval.IsNull() {
			data.Operations[i].UdpEchoStatisticsHourlyDistributionInterval = types.Int64Null()
		}
		// Rebuild nested list from device XML response
		if value := helpers.GetFromXPath(r, "type/udp/echo/statistics/intervals/interval"); value.Exists() {
			// Match existing state items with device response by key fields
			existingItems := data.Operations[i].UdpEchoStatisticsIntervals
			data.Operations[i].UdpEchoStatisticsIntervals = make([]IPSLAOperationsUdpEchoStatisticsIntervals, 0)

			value.ForEach(func(_ int, cr xmldot.Result) bool {
				citem := IPSLAOperationsUdpEchoStatisticsIntervals{}

				// First, populate all fields from device
				if cValue := helpers.GetFromXPath(cr, "interval-time"); cValue.Exists() {
					citem.Interval = types.Int64Value(cValue.Int())
				}
				if cValue := helpers.GetFromXPath(cr, "buckets"); cValue.Exists() {
					citem.Buckets = types.Int64Value(cValue.Int())
				}

				// Try to find matching item in existing state to preserve field states
				for _, existingItem := range existingItems {
					match := true
					if !existingItem.Interval.Equal(citem.Interval) {
						match = false
					}

					if match {
						// Found matching item - preserve state for fields not in device response
						break
					}
				}

				data.Operations[i].UdpEchoStatisticsIntervals = append(data.Operations[i].UdpEchoStatisticsIntervals, citem)
				return true
			})
		}
		if value := helpers.GetFromXPath(r, "type/udp/echo/history/buckets"); value.Exists() {
			data.Operations[i].UdpEchoHistoryBuckets = types.Int64Value(value.Int())
		} else if data.Operations[i].UdpEchoHistoryBuckets.IsNull() {
			data.Operations[i].UdpEchoHistoryBuckets = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/udp/echo/history/filter/all"); value.Exists() {
			data.Operations[i].UdpEchoHistoryFilterAll = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Operations[i].UdpEchoHistoryFilterAll.IsNull() {
				data.Operations[i].UdpEchoHistoryFilterAll = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "type/udp/echo/history/filter/failures"); value.Exists() {
			data.Operations[i].UdpEchoHistoryFilterFailures = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Operations[i].UdpEchoHistoryFilterFailures.IsNull() {
				data.Operations[i].UdpEchoHistoryFilterFailures = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "type/udp/echo/history/lives"); value.Exists() {
			data.Operations[i].UdpEchoHistoryLives = types.Int64Value(value.Int())
		} else if data.Operations[i].UdpEchoHistoryLives.IsNull() {
			data.Operations[i].UdpEchoHistoryLives = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/udp/jitter"); value.Exists() {
			data.Operations[i].UdpJitter = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Operations[i].UdpJitter.IsNull() {
				data.Operations[i].UdpJitter = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "type/udp/jitter/tag"); value.Exists() {
			data.Operations[i].UdpJitterTag = types.StringValue(value.String())
		} else if data.Operations[i].UdpJitterTag.IsNull() {
			data.Operations[i].UdpJitterTag = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/udp/jitter/frequency"); value.Exists() {
			data.Operations[i].UdpJitterFrequency = types.Int64Value(value.Int())
		} else if data.Operations[i].UdpJitterFrequency.IsNull() {
			data.Operations[i].UdpJitterFrequency = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/udp/jitter/datasize/request/enter-request-datasize-in-byte"); value.Exists() {
			data.Operations[i].UdpJitterDatasizeRequest = types.Int64Value(value.Int())
		} else if data.Operations[i].UdpJitterDatasizeRequest.IsNull() {
			data.Operations[i].UdpJitterDatasizeRequest = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/udp/jitter/timeout"); value.Exists() {
			data.Operations[i].UdpJitterTimeout = types.Int64Value(value.Int())
		} else if data.Operations[i].UdpJitterTimeout.IsNull() {
			data.Operations[i].UdpJitterTimeout = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/udp/jitter/source/address/ipv4-address"); value.Exists() {
			data.Operations[i].UdpJitterSourceIpv4 = types.StringValue(value.String())
		} else if data.Operations[i].UdpJitterSourceIpv4.IsNull() {
			data.Operations[i].UdpJitterSourceIpv4 = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/udp/jitter/source/port"); value.Exists() {
			data.Operations[i].UdpJitterSourcePort = types.Int64Value(value.Int())
		} else if data.Operations[i].UdpJitterSourcePort.IsNull() {
			data.Operations[i].UdpJitterSourcePort = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/udp/jitter/destination/address"); value.Exists() {
			data.Operations[i].UdpJitterDestinationIpv4 = types.StringValue(value.String())
		} else if data.Operations[i].UdpJitterDestinationIpv4.IsNull() {
			data.Operations[i].UdpJitterDestinationIpv4 = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/udp/jitter/destination/port"); value.Exists() {
			data.Operations[i].UdpJitterDestinationPort = types.Int64Value(value.Int())
		} else if data.Operations[i].UdpJitterDestinationPort.IsNull() {
			data.Operations[i].UdpJitterDestinationPort = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/udp/jitter/packet/count"); value.Exists() {
			data.Operations[i].UdpJitterPacketCount = types.Int64Value(value.Int())
		} else if data.Operations[i].UdpJitterPacketCount.IsNull() {
			data.Operations[i].UdpJitterPacketCount = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/udp/jitter/packet/interval"); value.Exists() {
			data.Operations[i].UdpJitterPacketInterval = types.Int64Value(value.Int())
		} else if data.Operations[i].UdpJitterPacketInterval.IsNull() {
			data.Operations[i].UdpJitterPacketInterval = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/udp/jitter/tos"); value.Exists() {
			data.Operations[i].UdpJitterTos = types.Int64Value(value.Int())
		} else if data.Operations[i].UdpJitterTos.IsNull() {
			data.Operations[i].UdpJitterTos = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/udp/jitter/vrf"); value.Exists() {
			data.Operations[i].UdpJitterVrf = types.StringValue(value.String())
		} else if data.Operations[i].UdpJitterVrf.IsNull() {
			data.Operations[i].UdpJitterVrf = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/udp/jitter/control/disable"); value.Exists() {
			data.Operations[i].UdpJitterControlDisable = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Operations[i].UdpJitterControlDisable.IsNull() {
				data.Operations[i].UdpJitterControlDisable = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "type/udp/jitter/verify-data"); value.Exists() {
			data.Operations[i].UdpJitterVerifyData = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Operations[i].UdpJitterVerifyData.IsNull() {
				data.Operations[i].UdpJitterVerifyData = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "type/udp/jitter/statistics/hourly/buckets"); value.Exists() {
			data.Operations[i].UdpJitterStatisticsHourlyBuckets = types.Int64Value(value.Int())
		} else if data.Operations[i].UdpJitterStatisticsHourlyBuckets.IsNull() {
			data.Operations[i].UdpJitterStatisticsHourlyBuckets = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/udp/jitter/statistics/hourly/distribution/count"); value.Exists() {
			data.Operations[i].UdpJitterStatisticsHourlyDistributionCount = types.Int64Value(value.Int())
		} else if data.Operations[i].UdpJitterStatisticsHourlyDistributionCount.IsNull() {
			data.Operations[i].UdpJitterStatisticsHourlyDistributionCount = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/udp/jitter/statistics/hourly/distribution/interval"); value.Exists() {
			data.Operations[i].UdpJitterStatisticsHourlyDistributionInterval = types.Int64Value(value.Int())
		} else if data.Operations[i].UdpJitterStatisticsHourlyDistributionInterval.IsNull() {
			data.Operations[i].UdpJitterStatisticsHourlyDistributionInterval = types.Int64Null()
		}
		// Rebuild nested list from device XML response
		if value := helpers.GetFromXPath(r, "type/udp/jitter/statistics/intervals/interval"); value.Exists() {
			// Match existing state items with device response by key fields
			existingItems := data.Operations[i].UdpJitterStatisticsIntervals
			data.Operations[i].UdpJitterStatisticsIntervals = make([]IPSLAOperationsUdpJitterStatisticsIntervals, 0)

			value.ForEach(func(_ int, cr xmldot.Result) bool {
				citem := IPSLAOperationsUdpJitterStatisticsIntervals{}

				// First, populate all fields from device
				if cValue := helpers.GetFromXPath(cr, "interval-time"); cValue.Exists() {
					citem.Interval = types.Int64Value(cValue.Int())
				}
				if cValue := helpers.GetFromXPath(cr, "buckets"); cValue.Exists() {
					citem.Buckets = types.Int64Value(cValue.Int())
				}

				// Try to find matching item in existing state to preserve field states
				for _, existingItem := range existingItems {
					match := true
					if !existingItem.Interval.Equal(citem.Interval) {
						match = false
					}

					if match {
						// Found matching item - preserve state for fields not in device response
						break
					}
				}

				data.Operations[i].UdpJitterStatisticsIntervals = append(data.Operations[i].UdpJitterStatisticsIntervals, citem)
				return true
			})
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/ping"); value.Exists() {
			data.Operations[i].MplsLspPing = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Operations[i].MplsLspPing.IsNull() {
				data.Operations[i].MplsLspPing = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/ping/tag"); value.Exists() {
			data.Operations[i].MplsLspPingTag = types.StringValue(value.String())
		} else if data.Operations[i].MplsLspPingTag.IsNull() {
			data.Operations[i].MplsLspPingTag = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/ping/frequency"); value.Exists() {
			data.Operations[i].MplsLspPingFrequency = types.Int64Value(value.Int())
		} else if data.Operations[i].MplsLspPingFrequency.IsNull() {
			data.Operations[i].MplsLspPingFrequency = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/ping/datasize/request/enter-request-datasize-in-byte"); value.Exists() {
			data.Operations[i].MplsLspPingDatasizeRequest = types.Int64Value(value.Int())
		} else if data.Operations[i].MplsLspPingDatasizeRequest.IsNull() {
			data.Operations[i].MplsLspPingDatasizeRequest = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/ping/timeout"); value.Exists() {
			data.Operations[i].MplsLspPingTimeout = types.Int64Value(value.Int())
		} else if data.Operations[i].MplsLspPingTimeout.IsNull() {
			data.Operations[i].MplsLspPingTimeout = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/ping/source/address/ipv4-address"); value.Exists() {
			data.Operations[i].MplsLspPingSourceIpv4 = types.StringValue(value.String())
		} else if data.Operations[i].MplsLspPingSourceIpv4.IsNull() {
			data.Operations[i].MplsLspPingSourceIpv4 = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/ping/target/ipv4/address"); value.Exists() {
			data.Operations[i].MplsLspPingTargetIpv4 = types.StringValue(value.String())
		} else if data.Operations[i].MplsLspPingTargetIpv4.IsNull() {
			data.Operations[i].MplsLspPingTargetIpv4 = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/ping/target/ipv4/mask"); value.Exists() {
			data.Operations[i].MplsLspPingTargetIpv4Mask = types.StringValue(value.String())
		} else if data.Operations[i].MplsLspPingTargetIpv4Mask.IsNull() {
			data.Operations[i].MplsLspPingTargetIpv4Mask = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/ping/target/traffic-eng/tunnel"); value.Exists() {
			data.Operations[i].MplsLspPingTargetTeTunnel = types.Int64Value(value.Int())
		} else if data.Operations[i].MplsLspPingTargetTeTunnel.IsNull() {
			data.Operations[i].MplsLspPingTargetTeTunnel = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/ping/target/pseudowire/address"); value.Exists() {
			data.Operations[i].MplsLspPingTargetPseudowireAddress = types.StringValue(value.String())
		} else if data.Operations[i].MplsLspPingTargetPseudowireAddress.IsNull() {
			data.Operations[i].MplsLspPingTargetPseudowireAddress = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/ping/target/pseudowire/virtual-circuit-id"); value.Exists() {
			data.Operations[i].MplsLspPingTargetPseudowireVcId = types.Int64Value(value.Int())
		} else if data.Operations[i].MplsLspPingTargetPseudowireVcId.IsNull() {
			data.Operations[i].MplsLspPingTargetPseudowireVcId = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/ping/statistics/hourly/buckets"); value.Exists() {
			data.Operations[i].MplsLspPingStatisticsHourlyBuckets = types.Int64Value(value.Int())
		} else if data.Operations[i].MplsLspPingStatisticsHourlyBuckets.IsNull() {
			data.Operations[i].MplsLspPingStatisticsHourlyBuckets = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/ping/statistics/hourly/distribution/count"); value.Exists() {
			data.Operations[i].MplsLspPingStatisticsHourlyDistributionCount = types.Int64Value(value.Int())
		} else if data.Operations[i].MplsLspPingStatisticsHourlyDistributionCount.IsNull() {
			data.Operations[i].MplsLspPingStatisticsHourlyDistributionCount = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/ping/statistics/hourly/distribution/interval"); value.Exists() {
			data.Operations[i].MplsLspPingStatisticsHourlyDistributionInterval = types.Int64Value(value.Int())
		} else if data.Operations[i].MplsLspPingStatisticsHourlyDistributionInterval.IsNull() {
			data.Operations[i].MplsLspPingStatisticsHourlyDistributionInterval = types.Int64Null()
		}
		// Rebuild nested list from device XML response
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/ping/statistics/intervals/interval"); value.Exists() {
			// Match existing state items with device response by key fields
			existingItems := data.Operations[i].MplsLspPingStatisticsIntervals
			data.Operations[i].MplsLspPingStatisticsIntervals = make([]IPSLAOperationsMplsLspPingStatisticsIntervals, 0)

			value.ForEach(func(_ int, cr xmldot.Result) bool {
				citem := IPSLAOperationsMplsLspPingStatisticsIntervals{}

				// First, populate all fields from device
				if cValue := helpers.GetFromXPath(cr, "interval-time"); cValue.Exists() {
					citem.Interval = types.Int64Value(cValue.Int())
				}
				if cValue := helpers.GetFromXPath(cr, "buckets"); cValue.Exists() {
					citem.Buckets = types.Int64Value(cValue.Int())
				}

				// Try to find matching item in existing state to preserve field states
				for _, existingItem := range existingItems {
					match := true
					if !existingItem.Interval.Equal(citem.Interval) {
						match = false
					}

					if match {
						// Found matching item - preserve state for fields not in device response
						break
					}
				}

				data.Operations[i].MplsLspPingStatisticsIntervals = append(data.Operations[i].MplsLspPingStatisticsIntervals, citem)
				return true
			})
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/trace"); value.Exists() {
			data.Operations[i].MplsLspTrace = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Operations[i].MplsLspTrace.IsNull() {
				data.Operations[i].MplsLspTrace = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/trace/tag"); value.Exists() {
			data.Operations[i].MplsLspTraceTag = types.StringValue(value.String())
		} else if data.Operations[i].MplsLspTraceTag.IsNull() {
			data.Operations[i].MplsLspTraceTag = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/trace/frequency"); value.Exists() {
			data.Operations[i].MplsLspTraceFrequency = types.Int64Value(value.Int())
		} else if data.Operations[i].MplsLspTraceFrequency.IsNull() {
			data.Operations[i].MplsLspTraceFrequency = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/trace/timeout"); value.Exists() {
			data.Operations[i].MplsLspTraceTimeout = types.Int64Value(value.Int())
		} else if data.Operations[i].MplsLspTraceTimeout.IsNull() {
			data.Operations[i].MplsLspTraceTimeout = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/trace/source/address/ipv4-address"); value.Exists() {
			data.Operations[i].MplsLspTraceSourceIpv4 = types.StringValue(value.String())
		} else if data.Operations[i].MplsLspTraceSourceIpv4.IsNull() {
			data.Operations[i].MplsLspTraceSourceIpv4 = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/trace/target/ipv4/address"); value.Exists() {
			data.Operations[i].MplsLspTraceTargetIpv4 = types.StringValue(value.String())
		} else if data.Operations[i].MplsLspTraceTargetIpv4.IsNull() {
			data.Operations[i].MplsLspTraceTargetIpv4 = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/trace/target/ipv4/mask"); value.Exists() {
			data.Operations[i].MplsLspTraceTargetIpv4Mask = types.StringValue(value.String())
		} else if data.Operations[i].MplsLspTraceTargetIpv4Mask.IsNull() {
			data.Operations[i].MplsLspTraceTargetIpv4Mask = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/trace/target/traffic-eng/tunnel"); value.Exists() {
			data.Operations[i].MplsLspTraceTargetTeTunnel = types.Int64Value(value.Int())
		} else if data.Operations[i].MplsLspTraceTargetTeTunnel.IsNull() {
			data.Operations[i].MplsLspTraceTargetTeTunnel = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/trace/target/pseudowire/address"); value.Exists() {
			data.Operations[i].MplsLspTraceTargetPseudowireAddress = types.StringValue(value.String())
		} else if data.Operations[i].MplsLspTraceTargetPseudowireAddress.IsNull() {
			data.Operations[i].MplsLspTraceTargetPseudowireAddress = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/trace/target/pseudowire/virtual-circuit-id"); value.Exists() {
			data.Operations[i].MplsLspTraceTargetPseudowireVcId = types.Int64Value(value.Int())
		} else if data.Operations[i].MplsLspTraceTargetPseudowireVcId.IsNull() {
			data.Operations[i].MplsLspTraceTargetPseudowireVcId = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/trace/statistics/hourly/buckets"); value.Exists() {
			data.Operations[i].MplsLspTraceStatisticsHourlyBuckets = types.Int64Value(value.Int())
		} else if data.Operations[i].MplsLspTraceStatisticsHourlyBuckets.IsNull() {
			data.Operations[i].MplsLspTraceStatisticsHourlyBuckets = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/trace/statistics/hourly/distribution/count"); value.Exists() {
			data.Operations[i].MplsLspTraceStatisticsHourlyDistributionCount = types.Int64Value(value.Int())
		} else if data.Operations[i].MplsLspTraceStatisticsHourlyDistributionCount.IsNull() {
			data.Operations[i].MplsLspTraceStatisticsHourlyDistributionCount = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "type/mpls/lsp/trace/statistics/hourly/distribution/interval"); value.Exists() {
			data.Operations[i].MplsLspTraceStatisticsHourlyDistributionInterval = types.Int64Value(value.Int())
		} else if data.Operations[i].MplsLspTraceStatisticsHourlyDistributionInterval.IsNull() {
			data.Operations[i].MplsLspTraceStatisticsHourlyDistributionInterval = types.Int64Null()
		}
	}
	for i := range data.Schedules {
		keys := [...]string{"operation-number"}
		keyValues := [...]string{strconv.FormatInt(data.Schedules[i].OperationNumber.ValueInt64(), 10)}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/schedule/operations/operation").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "operation-number"); value.Exists() {
			data.Schedules[i].OperationNumber = types.Int64Value(value.Int())
		} else if data.Schedules[i].OperationNumber.IsNull() {
			data.Schedules[i].OperationNumber = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "life/forever"); value.Exists() {
			data.Schedules[i].LifeForever = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Schedules[i].LifeForever.IsNull() {
				data.Schedules[i].LifeForever = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "life/length-of-time"); value.Exists() {
			data.Schedules[i].LifeTime = types.Int64Value(value.Int())
		} else if data.Schedules[i].LifeTime.IsNull() {
			data.Schedules[i].LifeTime = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "start-time/time-and-date/hour"); value.Exists() {
			data.Schedules[i].StartHour = types.Int64Value(value.Int())
		} else if data.Schedules[i].StartHour.IsNull() {
			data.Schedules[i].StartHour = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "start-time/time-and-date/minute"); value.Exists() {
			data.Schedules[i].StartMinute = types.Int64Value(value.Int())
		} else if data.Schedules[i].StartMinute.IsNull() {
			data.Schedules[i].StartMinute = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "start-time/time-and-date/second"); value.Exists() {
			data.Schedules[i].StartSecond = types.Int64Value(value.Int())
		} else if data.Schedules[i].StartSecond.IsNull() {
			data.Schedules[i].StartSecond = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "start-time/time-and-date/month"); value.Exists() {
			data.Schedules[i].StartMonth = types.StringValue(value.String())
		} else if data.Schedules[i].StartMonth.IsNull() {
			data.Schedules[i].StartMonth = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "start-time/time-and-date/day-of-month"); value.Exists() {
			data.Schedules[i].StartDayOfMonth = types.Int64Value(value.Int())
		} else if data.Schedules[i].StartDayOfMonth.IsNull() {
			data.Schedules[i].StartDayOfMonth = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "start-time/time-and-date/year"); value.Exists() {
			data.Schedules[i].StartYear = types.Int64Value(value.Int())
		} else if data.Schedules[i].StartYear.IsNull() {
			data.Schedules[i].StartYear = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "start-time/pending"); value.Exists() {
			data.Schedules[i].StartPending = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Schedules[i].StartPending.IsNull() {
				data.Schedules[i].StartPending = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "start-time/after/time/hour"); value.Exists() {
			data.Schedules[i].StartAfterHour = types.Int64Value(value.Int())
		} else if data.Schedules[i].StartAfterHour.IsNull() {
			data.Schedules[i].StartAfterHour = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "start-time/after/time/minute"); value.Exists() {
			data.Schedules[i].StartAfterMinute = types.Int64Value(value.Int())
		} else if data.Schedules[i].StartAfterMinute.IsNull() {
			data.Schedules[i].StartAfterMinute = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "start-time/after/time/second"); value.Exists() {
			data.Schedules[i].StartAfterSecond = types.Int64Value(value.Int())
		} else if data.Schedules[i].StartAfterSecond.IsNull() {
			data.Schedules[i].StartAfterSecond = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "start-time/now"); value.Exists() {
			data.Schedules[i].StartNow = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Schedules[i].StartNow.IsNull() {
				data.Schedules[i].StartNow = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "recurring"); value.Exists() {
			data.Schedules[i].Recurring = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Schedules[i].Recurring.IsNull() {
				data.Schedules[i].Recurring = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "ageout"); value.Exists() {
			data.Schedules[i].Ageout = types.Int64Value(value.Int())
		} else if data.Schedules[i].Ageout.IsNull() {
			data.Schedules[i].Ageout = types.Int64Null()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/server/twamp"); value.Exists() {
		data.ServerTwamp = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.ServerTwamp.IsNull() {
			data.ServerTwamp = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/server/twamp/port"); value.Exists() {
		data.ServerTwampPort = types.Int64Value(value.Int())
	} else if data.ServerTwampPort.IsNull() {
		data.ServerTwampPort = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/server/twamp/timer/inactivity"); value.Exists() {
		data.ServerTwampTimerInactivity = types.Int64Value(value.Int())
	} else if data.ServerTwampTimerInactivity.IsNull() {
		data.ServerTwampTimerInactivity = types.Int64Null()
	}
}

// End of section. //template:end updateFromBodyXML
// Section below is generated&owned by "gen/generator.go". //template:begin fromBody

func (data *IPSLA) fromBody(ctx context.Context, res gjson.Result) {
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	if value := res.Get(prefix + "low-memory"); value.Exists() {
		data.LowMemory = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "key-chain"); value.Exists() {
		data.KeyChain = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "hw-timestamp.disable"); value.Exists() {
		data.HwTimestampDisable = types.BoolValue(true)
	} else {
		data.HwTimestampDisable = types.BoolNull()
	}
	if value := res.Get(prefix + "operations.operation"); value.Exists() {
		data.Operations = make([]IPSLAOperations, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := IPSLAOperations{}
			if cValue := v.Get("operation-number"); cValue.Exists() {
				item.OperationNumber = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.echo"); cValue.Exists() {
				item.IcmpEcho = types.BoolValue(true)
			} else {
				item.IcmpEcho = types.BoolNull()
			}
			if cValue := v.Get("type.icmp.echo.tag"); cValue.Exists() {
				item.IcmpEchoTag = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.icmp.echo.frequency"); cValue.Exists() {
				item.IcmpEchoFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.echo.datasize.request.enter-request-datasize-in-byte"); cValue.Exists() {
				item.IcmpEchoDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.echo.timeout"); cValue.Exists() {
				item.IcmpEchoTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.echo.source.address.ipv4-address"); cValue.Exists() {
				item.IcmpEchoSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.icmp.echo.source.address.ipv6-address"); cValue.Exists() {
				item.IcmpEchoSourceIpv6 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.icmp.echo.tos"); cValue.Exists() {
				item.IcmpEchoTos = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.echo.vrf"); cValue.Exists() {
				item.IcmpEchoVrf = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.icmp.echo.destination.address.ipv4-address"); cValue.Exists() {
				item.IcmpEchoDestinationIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.icmp.echo.destination.address.ipv6-address"); cValue.Exists() {
				item.IcmpEchoDestinationIpv6 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.icmp.echo.history.buckets"); cValue.Exists() {
				item.IcmpEchoHistoryBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.echo.history.filter.all"); cValue.Exists() {
				item.IcmpEchoHistoryFilterAll = types.BoolValue(true)
			} else {
				item.IcmpEchoHistoryFilterAll = types.BoolNull()
			}
			if cValue := v.Get("type.icmp.echo.history.filter.failures"); cValue.Exists() {
				item.IcmpEchoHistoryFilterFailures = types.BoolValue(true)
			} else {
				item.IcmpEchoHistoryFilterFailures = types.BoolNull()
			}
			if cValue := v.Get("type.icmp.echo.history.lives"); cValue.Exists() {
				item.IcmpEchoHistoryLives = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.echo.statistics.hourly.buckets"); cValue.Exists() {
				item.IcmpEchoStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.echo.statistics.hourly.distribution.count"); cValue.Exists() {
				item.IcmpEchoStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.echo.statistics.hourly.distribution.interval"); cValue.Exists() {
				item.IcmpEchoStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.echo.statistics.intervals.interval"); cValue.Exists() {
				item.IcmpEchoStatisticsIntervals = make([]IPSLAOperationsIcmpEchoStatisticsIntervals, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := IPSLAOperationsIcmpEchoStatisticsIntervals{}
					if ccValue := cv.Get("interval-time"); ccValue.Exists() {
						cItem.Interval = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("buckets"); ccValue.Exists() {
						cItem.Buckets = types.Int64Value(ccValue.Int())
					}
					item.IcmpEchoStatisticsIntervals = append(item.IcmpEchoStatisticsIntervals, cItem)
					return true
				})
			}
			if cValue := v.Get("type.icmp.path-echo"); cValue.Exists() {
				item.IcmpPathEcho = types.BoolValue(true)
			} else {
				item.IcmpPathEcho = types.BoolNull()
			}
			if cValue := v.Get("type.icmp.path-echo.tag"); cValue.Exists() {
				item.IcmpPathEchoTag = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.icmp.path-echo.frequency"); cValue.Exists() {
				item.IcmpPathEchoFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-echo.datasize.request.enter-request-datasize-in-byte"); cValue.Exists() {
				item.IcmpPathEchoDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-echo.timeout"); cValue.Exists() {
				item.IcmpPathEchoTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-echo.source.address.ipv4-address"); cValue.Exists() {
				item.IcmpPathEchoSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.icmp.path-echo.tos"); cValue.Exists() {
				item.IcmpPathEchoTos = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-echo.destination.address.address"); cValue.Exists() {
				item.IcmpPathEchoDestinationIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.icmp.path-echo.history.buckets"); cValue.Exists() {
				item.IcmpPathEchoHistoryBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-echo.history.filter.all"); cValue.Exists() {
				item.IcmpPathEchoHistoryFilterAll = types.BoolValue(true)
			} else {
				item.IcmpPathEchoHistoryFilterAll = types.BoolNull()
			}
			if cValue := v.Get("type.icmp.path-echo.history.filter.failures"); cValue.Exists() {
				item.IcmpPathEchoHistoryFilterFailures = types.BoolValue(true)
			} else {
				item.IcmpPathEchoHistoryFilterFailures = types.BoolNull()
			}
			if cValue := v.Get("type.icmp.path-echo.history.lives"); cValue.Exists() {
				item.IcmpPathEchoHistoryLives = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-echo.history.samples"); cValue.Exists() {
				item.IcmpPathEchoHistorySamples = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-echo.statistics.hourly.buckets"); cValue.Exists() {
				item.IcmpPathEchoStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-echo.statistics.hourly.distribution.count"); cValue.Exists() {
				item.IcmpPathEchoStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-echo.statistics.hourly.distribution.interval"); cValue.Exists() {
				item.IcmpPathEchoStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-echo.statistics.hourly.maximum.hops"); cValue.Exists() {
				item.IcmpPathEchoStatisticsHourlyMaximumHops = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-echo.statistics.hourly.maximum.paths"); cValue.Exists() {
				item.IcmpPathEchoStatisticsHourlyMaximumPaths = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-jitter"); cValue.Exists() {
				item.IcmpPathJitter = types.BoolValue(true)
			} else {
				item.IcmpPathJitter = types.BoolNull()
			}
			if cValue := v.Get("type.icmp.path-jitter.tag"); cValue.Exists() {
				item.IcmpPathJitterTag = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.icmp.path-jitter.frequency"); cValue.Exists() {
				item.IcmpPathJitterFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-jitter.datasize.request.enter-request-datasize-in-byte"); cValue.Exists() {
				item.IcmpPathJitterDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-jitter.timeout"); cValue.Exists() {
				item.IcmpPathJitterTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-jitter.source.address.ipv4-address"); cValue.Exists() {
				item.IcmpPathJitterSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.icmp.path-jitter.packet.count"); cValue.Exists() {
				item.IcmpPathJitterPacketCount = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-jitter.packet.interval"); cValue.Exists() {
				item.IcmpPathJitterPacketInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-jitter.tos"); cValue.Exists() {
				item.IcmpPathJitterTos = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-jitter.destination.address.address"); cValue.Exists() {
				item.IcmpPathJitterDestinationIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.udp.echo"); cValue.Exists() {
				item.UdpEcho = types.BoolValue(true)
			} else {
				item.UdpEcho = types.BoolNull()
			}
			if cValue := v.Get("type.udp.echo.tag"); cValue.Exists() {
				item.UdpEchoTag = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.udp.echo.frequency"); cValue.Exists() {
				item.UdpEchoFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.echo.datasize.request.enter-request-datasize-in-byte"); cValue.Exists() {
				item.UdpEchoDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.echo.timeout"); cValue.Exists() {
				item.UdpEchoTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.echo.source.address.ipv4-address"); cValue.Exists() {
				item.UdpEchoSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.udp.echo.source.port"); cValue.Exists() {
				item.UdpEchoSourcePort = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.echo.destination.address"); cValue.Exists() {
				item.UdpEchoDestinationIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.udp.echo.destination.port"); cValue.Exists() {
				item.UdpEchoDestinationPort = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.echo.control.disable"); cValue.Exists() {
				item.UdpEchoControlDisable = types.BoolValue(true)
			} else {
				item.UdpEchoControlDisable = types.BoolNull()
			}
			if cValue := v.Get("type.udp.echo.verify-data"); cValue.Exists() {
				item.UdpEchoVerifyData = types.BoolValue(true)
			} else {
				item.UdpEchoVerifyData = types.BoolNull()
			}
			if cValue := v.Get("type.udp.echo.tos"); cValue.Exists() {
				item.UdpEchoTos = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.echo.vrf"); cValue.Exists() {
				item.UdpEchoVrf = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.udp.echo.statistics.hourly.buckets"); cValue.Exists() {
				item.UdpEchoStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.echo.statistics.hourly.distribution.count"); cValue.Exists() {
				item.UdpEchoStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.echo.statistics.hourly.distribution.interval"); cValue.Exists() {
				item.UdpEchoStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.echo.statistics.intervals.interval"); cValue.Exists() {
				item.UdpEchoStatisticsIntervals = make([]IPSLAOperationsUdpEchoStatisticsIntervals, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := IPSLAOperationsUdpEchoStatisticsIntervals{}
					if ccValue := cv.Get("interval-time"); ccValue.Exists() {
						cItem.Interval = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("buckets"); ccValue.Exists() {
						cItem.Buckets = types.Int64Value(ccValue.Int())
					}
					item.UdpEchoStatisticsIntervals = append(item.UdpEchoStatisticsIntervals, cItem)
					return true
				})
			}
			if cValue := v.Get("type.udp.echo.history.buckets"); cValue.Exists() {
				item.UdpEchoHistoryBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.echo.history.filter.all"); cValue.Exists() {
				item.UdpEchoHistoryFilterAll = types.BoolValue(true)
			} else {
				item.UdpEchoHistoryFilterAll = types.BoolNull()
			}
			if cValue := v.Get("type.udp.echo.history.filter.failures"); cValue.Exists() {
				item.UdpEchoHistoryFilterFailures = types.BoolValue(true)
			} else {
				item.UdpEchoHistoryFilterFailures = types.BoolNull()
			}
			if cValue := v.Get("type.udp.echo.history.lives"); cValue.Exists() {
				item.UdpEchoHistoryLives = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter"); cValue.Exists() {
				item.UdpJitter = types.BoolValue(true)
			} else {
				item.UdpJitter = types.BoolNull()
			}
			if cValue := v.Get("type.udp.jitter.tag"); cValue.Exists() {
				item.UdpJitterTag = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.udp.jitter.frequency"); cValue.Exists() {
				item.UdpJitterFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter.datasize.request.enter-request-datasize-in-byte"); cValue.Exists() {
				item.UdpJitterDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter.timeout"); cValue.Exists() {
				item.UdpJitterTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter.source.address.ipv4-address"); cValue.Exists() {
				item.UdpJitterSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.udp.jitter.source.port"); cValue.Exists() {
				item.UdpJitterSourcePort = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter.destination.address"); cValue.Exists() {
				item.UdpJitterDestinationIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.udp.jitter.destination.port"); cValue.Exists() {
				item.UdpJitterDestinationPort = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter.packet.count"); cValue.Exists() {
				item.UdpJitterPacketCount = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter.packet.interval"); cValue.Exists() {
				item.UdpJitterPacketInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter.tos"); cValue.Exists() {
				item.UdpJitterTos = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter.vrf"); cValue.Exists() {
				item.UdpJitterVrf = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.udp.jitter.control.disable"); cValue.Exists() {
				item.UdpJitterControlDisable = types.BoolValue(true)
			} else {
				item.UdpJitterControlDisable = types.BoolNull()
			}
			if cValue := v.Get("type.udp.jitter.verify-data"); cValue.Exists() {
				item.UdpJitterVerifyData = types.BoolValue(true)
			} else {
				item.UdpJitterVerifyData = types.BoolNull()
			}
			if cValue := v.Get("type.udp.jitter.statistics.hourly.buckets"); cValue.Exists() {
				item.UdpJitterStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter.statistics.hourly.distribution.count"); cValue.Exists() {
				item.UdpJitterStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter.statistics.hourly.distribution.interval"); cValue.Exists() {
				item.UdpJitterStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter.statistics.intervals.interval"); cValue.Exists() {
				item.UdpJitterStatisticsIntervals = make([]IPSLAOperationsUdpJitterStatisticsIntervals, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := IPSLAOperationsUdpJitterStatisticsIntervals{}
					if ccValue := cv.Get("interval-time"); ccValue.Exists() {
						cItem.Interval = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("buckets"); ccValue.Exists() {
						cItem.Buckets = types.Int64Value(ccValue.Int())
					}
					item.UdpJitterStatisticsIntervals = append(item.UdpJitterStatisticsIntervals, cItem)
					return true
				})
			}
			if cValue := v.Get("type.mpls.lsp.ping"); cValue.Exists() {
				item.MplsLspPing = types.BoolValue(true)
			} else {
				item.MplsLspPing = types.BoolNull()
			}
			if cValue := v.Get("type.mpls.lsp.ping.tag"); cValue.Exists() {
				item.MplsLspPingTag = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.mpls.lsp.ping.frequency"); cValue.Exists() {
				item.MplsLspPingFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.ping.datasize.request.enter-request-datasize-in-byte"); cValue.Exists() {
				item.MplsLspPingDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.ping.timeout"); cValue.Exists() {
				item.MplsLspPingTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.ping.source.address.ipv4-address"); cValue.Exists() {
				item.MplsLspPingSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.mpls.lsp.ping.target.ipv4.address"); cValue.Exists() {
				item.MplsLspPingTargetIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.mpls.lsp.ping.target.ipv4.mask"); cValue.Exists() {
				item.MplsLspPingTargetIpv4Mask = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.mpls.lsp.ping.target.traffic-eng.tunnel"); cValue.Exists() {
				item.MplsLspPingTargetTeTunnel = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.ping.target.pseudowire.address"); cValue.Exists() {
				item.MplsLspPingTargetPseudowireAddress = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.mpls.lsp.ping.target.pseudowire.virtual-circuit-id"); cValue.Exists() {
				item.MplsLspPingTargetPseudowireVcId = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.ping.statistics.hourly.buckets"); cValue.Exists() {
				item.MplsLspPingStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.ping.statistics.hourly.distribution.count"); cValue.Exists() {
				item.MplsLspPingStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.ping.statistics.hourly.distribution.interval"); cValue.Exists() {
				item.MplsLspPingStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.ping.statistics.intervals.interval"); cValue.Exists() {
				item.MplsLspPingStatisticsIntervals = make([]IPSLAOperationsMplsLspPingStatisticsIntervals, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := IPSLAOperationsMplsLspPingStatisticsIntervals{}
					if ccValue := cv.Get("interval-time"); ccValue.Exists() {
						cItem.Interval = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("buckets"); ccValue.Exists() {
						cItem.Buckets = types.Int64Value(ccValue.Int())
					}
					item.MplsLspPingStatisticsIntervals = append(item.MplsLspPingStatisticsIntervals, cItem)
					return true
				})
			}
			if cValue := v.Get("type.mpls.lsp.trace"); cValue.Exists() {
				item.MplsLspTrace = types.BoolValue(true)
			} else {
				item.MplsLspTrace = types.BoolNull()
			}
			if cValue := v.Get("type.mpls.lsp.trace.tag"); cValue.Exists() {
				item.MplsLspTraceTag = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.mpls.lsp.trace.frequency"); cValue.Exists() {
				item.MplsLspTraceFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.trace.timeout"); cValue.Exists() {
				item.MplsLspTraceTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.trace.source.address.ipv4-address"); cValue.Exists() {
				item.MplsLspTraceSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.mpls.lsp.trace.target.ipv4.address"); cValue.Exists() {
				item.MplsLspTraceTargetIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.mpls.lsp.trace.target.ipv4.mask"); cValue.Exists() {
				item.MplsLspTraceTargetIpv4Mask = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.mpls.lsp.trace.target.traffic-eng.tunnel"); cValue.Exists() {
				item.MplsLspTraceTargetTeTunnel = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.trace.target.pseudowire.address"); cValue.Exists() {
				item.MplsLspTraceTargetPseudowireAddress = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.mpls.lsp.trace.target.pseudowire.virtual-circuit-id"); cValue.Exists() {
				item.MplsLspTraceTargetPseudowireVcId = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.trace.statistics.hourly.buckets"); cValue.Exists() {
				item.MplsLspTraceStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.trace.statistics.hourly.distribution.count"); cValue.Exists() {
				item.MplsLspTraceStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.trace.statistics.hourly.distribution.interval"); cValue.Exists() {
				item.MplsLspTraceStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			data.Operations = append(data.Operations, item)
			return true
		})
	}
	if value := res.Get(prefix + "schedule.operations.operation"); value.Exists() {
		data.Schedules = make([]IPSLASchedules, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := IPSLASchedules{}
			if cValue := v.Get("operation-number"); cValue.Exists() {
				item.OperationNumber = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("life.forever"); cValue.Exists() {
				item.LifeForever = types.BoolValue(true)
			} else {
				item.LifeForever = types.BoolNull()
			}
			if cValue := v.Get("life.length-of-time"); cValue.Exists() {
				item.LifeTime = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("start-time.time-and-date.hour"); cValue.Exists() {
				item.StartHour = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("start-time.time-and-date.minute"); cValue.Exists() {
				item.StartMinute = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("start-time.time-and-date.second"); cValue.Exists() {
				item.StartSecond = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("start-time.time-and-date.month"); cValue.Exists() {
				item.StartMonth = types.StringValue(cValue.String())
			}
			if cValue := v.Get("start-time.time-and-date.day-of-month"); cValue.Exists() {
				item.StartDayOfMonth = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("start-time.time-and-date.year"); cValue.Exists() {
				item.StartYear = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("start-time.pending"); cValue.Exists() {
				item.StartPending = types.BoolValue(true)
			} else {
				item.StartPending = types.BoolNull()
			}
			if cValue := v.Get("start-time.after.time.hour"); cValue.Exists() {
				item.StartAfterHour = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("start-time.after.time.minute"); cValue.Exists() {
				item.StartAfterMinute = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("start-time.after.time.second"); cValue.Exists() {
				item.StartAfterSecond = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("start-time.now"); cValue.Exists() {
				item.StartNow = types.BoolValue(true)
			} else {
				item.StartNow = types.BoolNull()
			}
			if cValue := v.Get("recurring"); cValue.Exists() {
				item.Recurring = types.BoolValue(true)
			} else {
				item.Recurring = types.BoolNull()
			}
			if cValue := v.Get("ageout"); cValue.Exists() {
				item.Ageout = types.Int64Value(cValue.Int())
			}
			data.Schedules = append(data.Schedules, item)
			return true
		})
	}
	if value := res.Get(prefix + "server.twamp"); value.Exists() {
		data.ServerTwamp = types.BoolValue(true)
	} else {
		data.ServerTwamp = types.BoolNull()
	}
	if value := res.Get(prefix + "server.twamp.port"); value.Exists() {
		data.ServerTwampPort = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "server.twamp.timer.inactivity"); value.Exists() {
		data.ServerTwampTimerInactivity = types.Int64Value(value.Int())
	}
}

// End of section. //template:end fromBody
// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyData

func (data *IPSLAData) fromBody(ctx context.Context, res gjson.Result) {
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	if value := res.Get(prefix + "low-memory"); value.Exists() {
		data.LowMemory = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "key-chain"); value.Exists() {
		data.KeyChain = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "hw-timestamp.disable"); value.Exists() {
		data.HwTimestampDisable = types.BoolValue(true)
	} else {
		data.HwTimestampDisable = types.BoolNull()
	}
	if value := res.Get(prefix + "operations.operation"); value.Exists() {
		data.Operations = make([]IPSLAOperations, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := IPSLAOperations{}
			if cValue := v.Get("operation-number"); cValue.Exists() {
				item.OperationNumber = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.echo"); cValue.Exists() {
				item.IcmpEcho = types.BoolValue(true)
			} else {
				item.IcmpEcho = types.BoolNull()
			}
			if cValue := v.Get("type.icmp.echo.tag"); cValue.Exists() {
				item.IcmpEchoTag = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.icmp.echo.frequency"); cValue.Exists() {
				item.IcmpEchoFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.echo.datasize.request.enter-request-datasize-in-byte"); cValue.Exists() {
				item.IcmpEchoDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.echo.timeout"); cValue.Exists() {
				item.IcmpEchoTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.echo.source.address.ipv4-address"); cValue.Exists() {
				item.IcmpEchoSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.icmp.echo.source.address.ipv6-address"); cValue.Exists() {
				item.IcmpEchoSourceIpv6 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.icmp.echo.tos"); cValue.Exists() {
				item.IcmpEchoTos = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.echo.vrf"); cValue.Exists() {
				item.IcmpEchoVrf = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.icmp.echo.destination.address.ipv4-address"); cValue.Exists() {
				item.IcmpEchoDestinationIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.icmp.echo.destination.address.ipv6-address"); cValue.Exists() {
				item.IcmpEchoDestinationIpv6 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.icmp.echo.history.buckets"); cValue.Exists() {
				item.IcmpEchoHistoryBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.echo.history.filter.all"); cValue.Exists() {
				item.IcmpEchoHistoryFilterAll = types.BoolValue(true)
			} else {
				item.IcmpEchoHistoryFilterAll = types.BoolNull()
			}
			if cValue := v.Get("type.icmp.echo.history.filter.failures"); cValue.Exists() {
				item.IcmpEchoHistoryFilterFailures = types.BoolValue(true)
			} else {
				item.IcmpEchoHistoryFilterFailures = types.BoolNull()
			}
			if cValue := v.Get("type.icmp.echo.history.lives"); cValue.Exists() {
				item.IcmpEchoHistoryLives = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.echo.statistics.hourly.buckets"); cValue.Exists() {
				item.IcmpEchoStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.echo.statistics.hourly.distribution.count"); cValue.Exists() {
				item.IcmpEchoStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.echo.statistics.hourly.distribution.interval"); cValue.Exists() {
				item.IcmpEchoStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.echo.statistics.intervals.interval"); cValue.Exists() {
				item.IcmpEchoStatisticsIntervals = make([]IPSLAOperationsIcmpEchoStatisticsIntervals, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := IPSLAOperationsIcmpEchoStatisticsIntervals{}
					if ccValue := cv.Get("interval-time"); ccValue.Exists() {
						cItem.Interval = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("buckets"); ccValue.Exists() {
						cItem.Buckets = types.Int64Value(ccValue.Int())
					}
					item.IcmpEchoStatisticsIntervals = append(item.IcmpEchoStatisticsIntervals, cItem)
					return true
				})
			}
			if cValue := v.Get("type.icmp.path-echo"); cValue.Exists() {
				item.IcmpPathEcho = types.BoolValue(true)
			} else {
				item.IcmpPathEcho = types.BoolNull()
			}
			if cValue := v.Get("type.icmp.path-echo.tag"); cValue.Exists() {
				item.IcmpPathEchoTag = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.icmp.path-echo.frequency"); cValue.Exists() {
				item.IcmpPathEchoFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-echo.datasize.request.enter-request-datasize-in-byte"); cValue.Exists() {
				item.IcmpPathEchoDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-echo.timeout"); cValue.Exists() {
				item.IcmpPathEchoTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-echo.source.address.ipv4-address"); cValue.Exists() {
				item.IcmpPathEchoSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.icmp.path-echo.tos"); cValue.Exists() {
				item.IcmpPathEchoTos = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-echo.destination.address.address"); cValue.Exists() {
				item.IcmpPathEchoDestinationIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.icmp.path-echo.history.buckets"); cValue.Exists() {
				item.IcmpPathEchoHistoryBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-echo.history.filter.all"); cValue.Exists() {
				item.IcmpPathEchoHistoryFilterAll = types.BoolValue(true)
			} else {
				item.IcmpPathEchoHistoryFilterAll = types.BoolNull()
			}
			if cValue := v.Get("type.icmp.path-echo.history.filter.failures"); cValue.Exists() {
				item.IcmpPathEchoHistoryFilterFailures = types.BoolValue(true)
			} else {
				item.IcmpPathEchoHistoryFilterFailures = types.BoolNull()
			}
			if cValue := v.Get("type.icmp.path-echo.history.lives"); cValue.Exists() {
				item.IcmpPathEchoHistoryLives = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-echo.history.samples"); cValue.Exists() {
				item.IcmpPathEchoHistorySamples = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-echo.statistics.hourly.buckets"); cValue.Exists() {
				item.IcmpPathEchoStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-echo.statistics.hourly.distribution.count"); cValue.Exists() {
				item.IcmpPathEchoStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-echo.statistics.hourly.distribution.interval"); cValue.Exists() {
				item.IcmpPathEchoStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-echo.statistics.hourly.maximum.hops"); cValue.Exists() {
				item.IcmpPathEchoStatisticsHourlyMaximumHops = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-echo.statistics.hourly.maximum.paths"); cValue.Exists() {
				item.IcmpPathEchoStatisticsHourlyMaximumPaths = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-jitter"); cValue.Exists() {
				item.IcmpPathJitter = types.BoolValue(true)
			} else {
				item.IcmpPathJitter = types.BoolNull()
			}
			if cValue := v.Get("type.icmp.path-jitter.tag"); cValue.Exists() {
				item.IcmpPathJitterTag = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.icmp.path-jitter.frequency"); cValue.Exists() {
				item.IcmpPathJitterFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-jitter.datasize.request.enter-request-datasize-in-byte"); cValue.Exists() {
				item.IcmpPathJitterDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-jitter.timeout"); cValue.Exists() {
				item.IcmpPathJitterTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-jitter.source.address.ipv4-address"); cValue.Exists() {
				item.IcmpPathJitterSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.icmp.path-jitter.packet.count"); cValue.Exists() {
				item.IcmpPathJitterPacketCount = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-jitter.packet.interval"); cValue.Exists() {
				item.IcmpPathJitterPacketInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-jitter.tos"); cValue.Exists() {
				item.IcmpPathJitterTos = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.icmp.path-jitter.destination.address.address"); cValue.Exists() {
				item.IcmpPathJitterDestinationIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.udp.echo"); cValue.Exists() {
				item.UdpEcho = types.BoolValue(true)
			} else {
				item.UdpEcho = types.BoolNull()
			}
			if cValue := v.Get("type.udp.echo.tag"); cValue.Exists() {
				item.UdpEchoTag = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.udp.echo.frequency"); cValue.Exists() {
				item.UdpEchoFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.echo.datasize.request.enter-request-datasize-in-byte"); cValue.Exists() {
				item.UdpEchoDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.echo.timeout"); cValue.Exists() {
				item.UdpEchoTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.echo.source.address.ipv4-address"); cValue.Exists() {
				item.UdpEchoSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.udp.echo.source.port"); cValue.Exists() {
				item.UdpEchoSourcePort = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.echo.destination.address"); cValue.Exists() {
				item.UdpEchoDestinationIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.udp.echo.destination.port"); cValue.Exists() {
				item.UdpEchoDestinationPort = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.echo.control.disable"); cValue.Exists() {
				item.UdpEchoControlDisable = types.BoolValue(true)
			} else {
				item.UdpEchoControlDisable = types.BoolNull()
			}
			if cValue := v.Get("type.udp.echo.verify-data"); cValue.Exists() {
				item.UdpEchoVerifyData = types.BoolValue(true)
			} else {
				item.UdpEchoVerifyData = types.BoolNull()
			}
			if cValue := v.Get("type.udp.echo.tos"); cValue.Exists() {
				item.UdpEchoTos = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.echo.vrf"); cValue.Exists() {
				item.UdpEchoVrf = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.udp.echo.statistics.hourly.buckets"); cValue.Exists() {
				item.UdpEchoStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.echo.statistics.hourly.distribution.count"); cValue.Exists() {
				item.UdpEchoStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.echo.statistics.hourly.distribution.interval"); cValue.Exists() {
				item.UdpEchoStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.echo.statistics.intervals.interval"); cValue.Exists() {
				item.UdpEchoStatisticsIntervals = make([]IPSLAOperationsUdpEchoStatisticsIntervals, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := IPSLAOperationsUdpEchoStatisticsIntervals{}
					if ccValue := cv.Get("interval-time"); ccValue.Exists() {
						cItem.Interval = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("buckets"); ccValue.Exists() {
						cItem.Buckets = types.Int64Value(ccValue.Int())
					}
					item.UdpEchoStatisticsIntervals = append(item.UdpEchoStatisticsIntervals, cItem)
					return true
				})
			}
			if cValue := v.Get("type.udp.echo.history.buckets"); cValue.Exists() {
				item.UdpEchoHistoryBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.echo.history.filter.all"); cValue.Exists() {
				item.UdpEchoHistoryFilterAll = types.BoolValue(true)
			} else {
				item.UdpEchoHistoryFilterAll = types.BoolNull()
			}
			if cValue := v.Get("type.udp.echo.history.filter.failures"); cValue.Exists() {
				item.UdpEchoHistoryFilterFailures = types.BoolValue(true)
			} else {
				item.UdpEchoHistoryFilterFailures = types.BoolNull()
			}
			if cValue := v.Get("type.udp.echo.history.lives"); cValue.Exists() {
				item.UdpEchoHistoryLives = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter"); cValue.Exists() {
				item.UdpJitter = types.BoolValue(true)
			} else {
				item.UdpJitter = types.BoolNull()
			}
			if cValue := v.Get("type.udp.jitter.tag"); cValue.Exists() {
				item.UdpJitterTag = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.udp.jitter.frequency"); cValue.Exists() {
				item.UdpJitterFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter.datasize.request.enter-request-datasize-in-byte"); cValue.Exists() {
				item.UdpJitterDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter.timeout"); cValue.Exists() {
				item.UdpJitterTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter.source.address.ipv4-address"); cValue.Exists() {
				item.UdpJitterSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.udp.jitter.source.port"); cValue.Exists() {
				item.UdpJitterSourcePort = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter.destination.address"); cValue.Exists() {
				item.UdpJitterDestinationIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.udp.jitter.destination.port"); cValue.Exists() {
				item.UdpJitterDestinationPort = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter.packet.count"); cValue.Exists() {
				item.UdpJitterPacketCount = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter.packet.interval"); cValue.Exists() {
				item.UdpJitterPacketInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter.tos"); cValue.Exists() {
				item.UdpJitterTos = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter.vrf"); cValue.Exists() {
				item.UdpJitterVrf = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.udp.jitter.control.disable"); cValue.Exists() {
				item.UdpJitterControlDisable = types.BoolValue(true)
			} else {
				item.UdpJitterControlDisable = types.BoolNull()
			}
			if cValue := v.Get("type.udp.jitter.verify-data"); cValue.Exists() {
				item.UdpJitterVerifyData = types.BoolValue(true)
			} else {
				item.UdpJitterVerifyData = types.BoolNull()
			}
			if cValue := v.Get("type.udp.jitter.statistics.hourly.buckets"); cValue.Exists() {
				item.UdpJitterStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter.statistics.hourly.distribution.count"); cValue.Exists() {
				item.UdpJitterStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter.statistics.hourly.distribution.interval"); cValue.Exists() {
				item.UdpJitterStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.udp.jitter.statistics.intervals.interval"); cValue.Exists() {
				item.UdpJitterStatisticsIntervals = make([]IPSLAOperationsUdpJitterStatisticsIntervals, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := IPSLAOperationsUdpJitterStatisticsIntervals{}
					if ccValue := cv.Get("interval-time"); ccValue.Exists() {
						cItem.Interval = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("buckets"); ccValue.Exists() {
						cItem.Buckets = types.Int64Value(ccValue.Int())
					}
					item.UdpJitterStatisticsIntervals = append(item.UdpJitterStatisticsIntervals, cItem)
					return true
				})
			}
			if cValue := v.Get("type.mpls.lsp.ping"); cValue.Exists() {
				item.MplsLspPing = types.BoolValue(true)
			} else {
				item.MplsLspPing = types.BoolNull()
			}
			if cValue := v.Get("type.mpls.lsp.ping.tag"); cValue.Exists() {
				item.MplsLspPingTag = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.mpls.lsp.ping.frequency"); cValue.Exists() {
				item.MplsLspPingFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.ping.datasize.request.enter-request-datasize-in-byte"); cValue.Exists() {
				item.MplsLspPingDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.ping.timeout"); cValue.Exists() {
				item.MplsLspPingTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.ping.source.address.ipv4-address"); cValue.Exists() {
				item.MplsLspPingSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.mpls.lsp.ping.target.ipv4.address"); cValue.Exists() {
				item.MplsLspPingTargetIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.mpls.lsp.ping.target.ipv4.mask"); cValue.Exists() {
				item.MplsLspPingTargetIpv4Mask = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.mpls.lsp.ping.target.traffic-eng.tunnel"); cValue.Exists() {
				item.MplsLspPingTargetTeTunnel = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.ping.target.pseudowire.address"); cValue.Exists() {
				item.MplsLspPingTargetPseudowireAddress = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.mpls.lsp.ping.target.pseudowire.virtual-circuit-id"); cValue.Exists() {
				item.MplsLspPingTargetPseudowireVcId = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.ping.statistics.hourly.buckets"); cValue.Exists() {
				item.MplsLspPingStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.ping.statistics.hourly.distribution.count"); cValue.Exists() {
				item.MplsLspPingStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.ping.statistics.hourly.distribution.interval"); cValue.Exists() {
				item.MplsLspPingStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.ping.statistics.intervals.interval"); cValue.Exists() {
				item.MplsLspPingStatisticsIntervals = make([]IPSLAOperationsMplsLspPingStatisticsIntervals, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := IPSLAOperationsMplsLspPingStatisticsIntervals{}
					if ccValue := cv.Get("interval-time"); ccValue.Exists() {
						cItem.Interval = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("buckets"); ccValue.Exists() {
						cItem.Buckets = types.Int64Value(ccValue.Int())
					}
					item.MplsLspPingStatisticsIntervals = append(item.MplsLspPingStatisticsIntervals, cItem)
					return true
				})
			}
			if cValue := v.Get("type.mpls.lsp.trace"); cValue.Exists() {
				item.MplsLspTrace = types.BoolValue(true)
			} else {
				item.MplsLspTrace = types.BoolNull()
			}
			if cValue := v.Get("type.mpls.lsp.trace.tag"); cValue.Exists() {
				item.MplsLspTraceTag = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.mpls.lsp.trace.frequency"); cValue.Exists() {
				item.MplsLspTraceFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.trace.timeout"); cValue.Exists() {
				item.MplsLspTraceTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.trace.source.address.ipv4-address"); cValue.Exists() {
				item.MplsLspTraceSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.mpls.lsp.trace.target.ipv4.address"); cValue.Exists() {
				item.MplsLspTraceTargetIpv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.mpls.lsp.trace.target.ipv4.mask"); cValue.Exists() {
				item.MplsLspTraceTargetIpv4Mask = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.mpls.lsp.trace.target.traffic-eng.tunnel"); cValue.Exists() {
				item.MplsLspTraceTargetTeTunnel = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.trace.target.pseudowire.address"); cValue.Exists() {
				item.MplsLspTraceTargetPseudowireAddress = types.StringValue(cValue.String())
			}
			if cValue := v.Get("type.mpls.lsp.trace.target.pseudowire.virtual-circuit-id"); cValue.Exists() {
				item.MplsLspTraceTargetPseudowireVcId = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.trace.statistics.hourly.buckets"); cValue.Exists() {
				item.MplsLspTraceStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.trace.statistics.hourly.distribution.count"); cValue.Exists() {
				item.MplsLspTraceStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("type.mpls.lsp.trace.statistics.hourly.distribution.interval"); cValue.Exists() {
				item.MplsLspTraceStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			data.Operations = append(data.Operations, item)
			return true
		})
	}
	if value := res.Get(prefix + "schedule.operations.operation"); value.Exists() {
		data.Schedules = make([]IPSLASchedules, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := IPSLASchedules{}
			if cValue := v.Get("operation-number"); cValue.Exists() {
				item.OperationNumber = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("life.forever"); cValue.Exists() {
				item.LifeForever = types.BoolValue(true)
			} else {
				item.LifeForever = types.BoolNull()
			}
			if cValue := v.Get("life.length-of-time"); cValue.Exists() {
				item.LifeTime = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("start-time.time-and-date.hour"); cValue.Exists() {
				item.StartHour = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("start-time.time-and-date.minute"); cValue.Exists() {
				item.StartMinute = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("start-time.time-and-date.second"); cValue.Exists() {
				item.StartSecond = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("start-time.time-and-date.month"); cValue.Exists() {
				item.StartMonth = types.StringValue(cValue.String())
			}
			if cValue := v.Get("start-time.time-and-date.day-of-month"); cValue.Exists() {
				item.StartDayOfMonth = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("start-time.time-and-date.year"); cValue.Exists() {
				item.StartYear = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("start-time.pending"); cValue.Exists() {
				item.StartPending = types.BoolValue(true)
			} else {
				item.StartPending = types.BoolNull()
			}
			if cValue := v.Get("start-time.after.time.hour"); cValue.Exists() {
				item.StartAfterHour = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("start-time.after.time.minute"); cValue.Exists() {
				item.StartAfterMinute = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("start-time.after.time.second"); cValue.Exists() {
				item.StartAfterSecond = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("start-time.now"); cValue.Exists() {
				item.StartNow = types.BoolValue(true)
			} else {
				item.StartNow = types.BoolNull()
			}
			if cValue := v.Get("recurring"); cValue.Exists() {
				item.Recurring = types.BoolValue(true)
			} else {
				item.Recurring = types.BoolNull()
			}
			if cValue := v.Get("ageout"); cValue.Exists() {
				item.Ageout = types.Int64Value(cValue.Int())
			}
			data.Schedules = append(data.Schedules, item)
			return true
		})
	}
	if value := res.Get(prefix + "server.twamp"); value.Exists() {
		data.ServerTwamp = types.BoolValue(true)
	} else {
		data.ServerTwamp = types.BoolNull()
	}
	if value := res.Get(prefix + "server.twamp.port"); value.Exists() {
		data.ServerTwampPort = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "server.twamp.timer.inactivity"); value.Exists() {
		data.ServerTwampTimerInactivity = types.Int64Value(value.Int())
	}
}

// End of section. //template:end fromBodyData
// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyXML

func (data *IPSLA) fromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/low-memory"); value.Exists() {
		data.LowMemory = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/key-chain"); value.Exists() {
		data.KeyChain = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/hw-timestamp/disable"); value.Exists() {
		data.HwTimestampDisable = types.BoolValue(true)
	} else {
		data.HwTimestampDisable = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/operations/operation"); value.Exists() {
		data.Operations = make([]IPSLAOperations, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := IPSLAOperations{}
			if cValue := helpers.GetFromXPath(v, "operation-number"); cValue.Exists() {
				item.OperationNumber = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo"); cValue.Exists() {
				item.IcmpEcho = types.BoolValue(true)
			} else {
				item.IcmpEcho = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/tag"); cValue.Exists() {
				item.IcmpEchoTag = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/frequency"); cValue.Exists() {
				item.IcmpEchoFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/datasize/request/enter-request-datasize-in-byte"); cValue.Exists() {
				item.IcmpEchoDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/timeout"); cValue.Exists() {
				item.IcmpEchoTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/source/address/ipv4-address"); cValue.Exists() {
				item.IcmpEchoSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/source/address/ipv6-address"); cValue.Exists() {
				item.IcmpEchoSourceIpv6 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/tos"); cValue.Exists() {
				item.IcmpEchoTos = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/vrf"); cValue.Exists() {
				item.IcmpEchoVrf = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/destination/address/ipv4-address"); cValue.Exists() {
				item.IcmpEchoDestinationIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/destination/address/ipv6-address"); cValue.Exists() {
				item.IcmpEchoDestinationIpv6 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/history/buckets"); cValue.Exists() {
				item.IcmpEchoHistoryBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/history/filter/all"); cValue.Exists() {
				item.IcmpEchoHistoryFilterAll = types.BoolValue(true)
			} else {
				item.IcmpEchoHistoryFilterAll = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/history/filter/failures"); cValue.Exists() {
				item.IcmpEchoHistoryFilterFailures = types.BoolValue(true)
			} else {
				item.IcmpEchoHistoryFilterFailures = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/history/lives"); cValue.Exists() {
				item.IcmpEchoHistoryLives = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/statistics/hourly/buckets"); cValue.Exists() {
				item.IcmpEchoStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/statistics/hourly/distribution/count"); cValue.Exists() {
				item.IcmpEchoStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/statistics/hourly/distribution/interval"); cValue.Exists() {
				item.IcmpEchoStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/statistics/intervals/interval"); cValue.Exists() {
				item.IcmpEchoStatisticsIntervals = make([]IPSLAOperationsIcmpEchoStatisticsIntervals, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := IPSLAOperationsIcmpEchoStatisticsIntervals{}
					if ccValue := helpers.GetFromXPath(cv, "interval-time"); ccValue.Exists() {
						cItem.Interval = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "buckets"); ccValue.Exists() {
						cItem.Buckets = types.Int64Value(ccValue.Int())
					}
					item.IcmpEchoStatisticsIntervals = append(item.IcmpEchoStatisticsIntervals, cItem)
					return true
				})
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo"); cValue.Exists() {
				item.IcmpPathEcho = types.BoolValue(true)
			} else {
				item.IcmpPathEcho = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/tag"); cValue.Exists() {
				item.IcmpPathEchoTag = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/frequency"); cValue.Exists() {
				item.IcmpPathEchoFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/datasize/request/enter-request-datasize-in-byte"); cValue.Exists() {
				item.IcmpPathEchoDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/timeout"); cValue.Exists() {
				item.IcmpPathEchoTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/source/address/ipv4-address"); cValue.Exists() {
				item.IcmpPathEchoSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/tos"); cValue.Exists() {
				item.IcmpPathEchoTos = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/destination/address/address"); cValue.Exists() {
				item.IcmpPathEchoDestinationIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/history/buckets"); cValue.Exists() {
				item.IcmpPathEchoHistoryBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/history/filter/all"); cValue.Exists() {
				item.IcmpPathEchoHistoryFilterAll = types.BoolValue(true)
			} else {
				item.IcmpPathEchoHistoryFilterAll = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/history/filter/failures"); cValue.Exists() {
				item.IcmpPathEchoHistoryFilterFailures = types.BoolValue(true)
			} else {
				item.IcmpPathEchoHistoryFilterFailures = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/history/lives"); cValue.Exists() {
				item.IcmpPathEchoHistoryLives = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/history/samples"); cValue.Exists() {
				item.IcmpPathEchoHistorySamples = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/statistics/hourly/buckets"); cValue.Exists() {
				item.IcmpPathEchoStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/statistics/hourly/distribution/count"); cValue.Exists() {
				item.IcmpPathEchoStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/statistics/hourly/distribution/interval"); cValue.Exists() {
				item.IcmpPathEchoStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/statistics/hourly/maximum/hops"); cValue.Exists() {
				item.IcmpPathEchoStatisticsHourlyMaximumHops = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/statistics/hourly/maximum/paths"); cValue.Exists() {
				item.IcmpPathEchoStatisticsHourlyMaximumPaths = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-jitter"); cValue.Exists() {
				item.IcmpPathJitter = types.BoolValue(true)
			} else {
				item.IcmpPathJitter = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-jitter/tag"); cValue.Exists() {
				item.IcmpPathJitterTag = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-jitter/frequency"); cValue.Exists() {
				item.IcmpPathJitterFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-jitter/datasize/request/enter-request-datasize-in-byte"); cValue.Exists() {
				item.IcmpPathJitterDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-jitter/timeout"); cValue.Exists() {
				item.IcmpPathJitterTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-jitter/source/address/ipv4-address"); cValue.Exists() {
				item.IcmpPathJitterSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-jitter/packet/count"); cValue.Exists() {
				item.IcmpPathJitterPacketCount = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-jitter/packet/interval"); cValue.Exists() {
				item.IcmpPathJitterPacketInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-jitter/tos"); cValue.Exists() {
				item.IcmpPathJitterTos = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-jitter/destination/address/address"); cValue.Exists() {
				item.IcmpPathJitterDestinationIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo"); cValue.Exists() {
				item.UdpEcho = types.BoolValue(true)
			} else {
				item.UdpEcho = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/tag"); cValue.Exists() {
				item.UdpEchoTag = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/frequency"); cValue.Exists() {
				item.UdpEchoFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/datasize/request/enter-request-datasize-in-byte"); cValue.Exists() {
				item.UdpEchoDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/timeout"); cValue.Exists() {
				item.UdpEchoTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/source/address/ipv4-address"); cValue.Exists() {
				item.UdpEchoSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/source/port"); cValue.Exists() {
				item.UdpEchoSourcePort = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/destination/address"); cValue.Exists() {
				item.UdpEchoDestinationIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/destination/port"); cValue.Exists() {
				item.UdpEchoDestinationPort = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/control/disable"); cValue.Exists() {
				item.UdpEchoControlDisable = types.BoolValue(true)
			} else {
				item.UdpEchoControlDisable = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/verify-data"); cValue.Exists() {
				item.UdpEchoVerifyData = types.BoolValue(true)
			} else {
				item.UdpEchoVerifyData = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/tos"); cValue.Exists() {
				item.UdpEchoTos = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/vrf"); cValue.Exists() {
				item.UdpEchoVrf = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/statistics/hourly/buckets"); cValue.Exists() {
				item.UdpEchoStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/statistics/hourly/distribution/count"); cValue.Exists() {
				item.UdpEchoStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/statistics/hourly/distribution/interval"); cValue.Exists() {
				item.UdpEchoStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/statistics/intervals/interval"); cValue.Exists() {
				item.UdpEchoStatisticsIntervals = make([]IPSLAOperationsUdpEchoStatisticsIntervals, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := IPSLAOperationsUdpEchoStatisticsIntervals{}
					if ccValue := helpers.GetFromXPath(cv, "interval-time"); ccValue.Exists() {
						cItem.Interval = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "buckets"); ccValue.Exists() {
						cItem.Buckets = types.Int64Value(ccValue.Int())
					}
					item.UdpEchoStatisticsIntervals = append(item.UdpEchoStatisticsIntervals, cItem)
					return true
				})
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/history/buckets"); cValue.Exists() {
				item.UdpEchoHistoryBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/history/filter/all"); cValue.Exists() {
				item.UdpEchoHistoryFilterAll = types.BoolValue(true)
			} else {
				item.UdpEchoHistoryFilterAll = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/history/filter/failures"); cValue.Exists() {
				item.UdpEchoHistoryFilterFailures = types.BoolValue(true)
			} else {
				item.UdpEchoHistoryFilterFailures = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/history/lives"); cValue.Exists() {
				item.UdpEchoHistoryLives = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter"); cValue.Exists() {
				item.UdpJitter = types.BoolValue(true)
			} else {
				item.UdpJitter = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/tag"); cValue.Exists() {
				item.UdpJitterTag = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/frequency"); cValue.Exists() {
				item.UdpJitterFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/datasize/request/enter-request-datasize-in-byte"); cValue.Exists() {
				item.UdpJitterDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/timeout"); cValue.Exists() {
				item.UdpJitterTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/source/address/ipv4-address"); cValue.Exists() {
				item.UdpJitterSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/source/port"); cValue.Exists() {
				item.UdpJitterSourcePort = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/destination/address"); cValue.Exists() {
				item.UdpJitterDestinationIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/destination/port"); cValue.Exists() {
				item.UdpJitterDestinationPort = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/packet/count"); cValue.Exists() {
				item.UdpJitterPacketCount = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/packet/interval"); cValue.Exists() {
				item.UdpJitterPacketInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/tos"); cValue.Exists() {
				item.UdpJitterTos = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/vrf"); cValue.Exists() {
				item.UdpJitterVrf = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/control/disable"); cValue.Exists() {
				item.UdpJitterControlDisable = types.BoolValue(true)
			} else {
				item.UdpJitterControlDisable = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/verify-data"); cValue.Exists() {
				item.UdpJitterVerifyData = types.BoolValue(true)
			} else {
				item.UdpJitterVerifyData = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/statistics/hourly/buckets"); cValue.Exists() {
				item.UdpJitterStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/statistics/hourly/distribution/count"); cValue.Exists() {
				item.UdpJitterStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/statistics/hourly/distribution/interval"); cValue.Exists() {
				item.UdpJitterStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/statistics/intervals/interval"); cValue.Exists() {
				item.UdpJitterStatisticsIntervals = make([]IPSLAOperationsUdpJitterStatisticsIntervals, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := IPSLAOperationsUdpJitterStatisticsIntervals{}
					if ccValue := helpers.GetFromXPath(cv, "interval-time"); ccValue.Exists() {
						cItem.Interval = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "buckets"); ccValue.Exists() {
						cItem.Buckets = types.Int64Value(ccValue.Int())
					}
					item.UdpJitterStatisticsIntervals = append(item.UdpJitterStatisticsIntervals, cItem)
					return true
				})
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping"); cValue.Exists() {
				item.MplsLspPing = types.BoolValue(true)
			} else {
				item.MplsLspPing = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/tag"); cValue.Exists() {
				item.MplsLspPingTag = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/frequency"); cValue.Exists() {
				item.MplsLspPingFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/datasize/request/enter-request-datasize-in-byte"); cValue.Exists() {
				item.MplsLspPingDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/timeout"); cValue.Exists() {
				item.MplsLspPingTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/source/address/ipv4-address"); cValue.Exists() {
				item.MplsLspPingSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/target/ipv4/address"); cValue.Exists() {
				item.MplsLspPingTargetIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/target/ipv4/mask"); cValue.Exists() {
				item.MplsLspPingTargetIpv4Mask = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/target/traffic-eng/tunnel"); cValue.Exists() {
				item.MplsLspPingTargetTeTunnel = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/target/pseudowire/address"); cValue.Exists() {
				item.MplsLspPingTargetPseudowireAddress = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/target/pseudowire/virtual-circuit-id"); cValue.Exists() {
				item.MplsLspPingTargetPseudowireVcId = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/statistics/hourly/buckets"); cValue.Exists() {
				item.MplsLspPingStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/statistics/hourly/distribution/count"); cValue.Exists() {
				item.MplsLspPingStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/statistics/hourly/distribution/interval"); cValue.Exists() {
				item.MplsLspPingStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/statistics/intervals/interval"); cValue.Exists() {
				item.MplsLspPingStatisticsIntervals = make([]IPSLAOperationsMplsLspPingStatisticsIntervals, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := IPSLAOperationsMplsLspPingStatisticsIntervals{}
					if ccValue := helpers.GetFromXPath(cv, "interval-time"); ccValue.Exists() {
						cItem.Interval = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "buckets"); ccValue.Exists() {
						cItem.Buckets = types.Int64Value(ccValue.Int())
					}
					item.MplsLspPingStatisticsIntervals = append(item.MplsLspPingStatisticsIntervals, cItem)
					return true
				})
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace"); cValue.Exists() {
				item.MplsLspTrace = types.BoolValue(true)
			} else {
				item.MplsLspTrace = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/tag"); cValue.Exists() {
				item.MplsLspTraceTag = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/frequency"); cValue.Exists() {
				item.MplsLspTraceFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/timeout"); cValue.Exists() {
				item.MplsLspTraceTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/source/address/ipv4-address"); cValue.Exists() {
				item.MplsLspTraceSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/target/ipv4/address"); cValue.Exists() {
				item.MplsLspTraceTargetIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/target/ipv4/mask"); cValue.Exists() {
				item.MplsLspTraceTargetIpv4Mask = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/target/traffic-eng/tunnel"); cValue.Exists() {
				item.MplsLspTraceTargetTeTunnel = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/target/pseudowire/address"); cValue.Exists() {
				item.MplsLspTraceTargetPseudowireAddress = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/target/pseudowire/virtual-circuit-id"); cValue.Exists() {
				item.MplsLspTraceTargetPseudowireVcId = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/statistics/hourly/buckets"); cValue.Exists() {
				item.MplsLspTraceStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/statistics/hourly/distribution/count"); cValue.Exists() {
				item.MplsLspTraceStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/statistics/hourly/distribution/interval"); cValue.Exists() {
				item.MplsLspTraceStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			data.Operations = append(data.Operations, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/schedule/operations/operation"); value.Exists() {
		data.Schedules = make([]IPSLASchedules, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := IPSLASchedules{}
			if cValue := helpers.GetFromXPath(v, "operation-number"); cValue.Exists() {
				item.OperationNumber = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "life/forever"); cValue.Exists() {
				item.LifeForever = types.BoolValue(true)
			} else {
				item.LifeForever = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "life/length-of-time"); cValue.Exists() {
				item.LifeTime = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "start-time/time-and-date/hour"); cValue.Exists() {
				item.StartHour = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "start-time/time-and-date/minute"); cValue.Exists() {
				item.StartMinute = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "start-time/time-and-date/second"); cValue.Exists() {
				item.StartSecond = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "start-time/time-and-date/month"); cValue.Exists() {
				item.StartMonth = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "start-time/time-and-date/day-of-month"); cValue.Exists() {
				item.StartDayOfMonth = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "start-time/time-and-date/year"); cValue.Exists() {
				item.StartYear = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "start-time/pending"); cValue.Exists() {
				item.StartPending = types.BoolValue(true)
			} else {
				item.StartPending = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "start-time/after/time/hour"); cValue.Exists() {
				item.StartAfterHour = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "start-time/after/time/minute"); cValue.Exists() {
				item.StartAfterMinute = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "start-time/after/time/second"); cValue.Exists() {
				item.StartAfterSecond = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "start-time/now"); cValue.Exists() {
				item.StartNow = types.BoolValue(true)
			} else {
				item.StartNow = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "recurring"); cValue.Exists() {
				item.Recurring = types.BoolValue(true)
			} else {
				item.Recurring = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "ageout"); cValue.Exists() {
				item.Ageout = types.Int64Value(cValue.Int())
			}
			data.Schedules = append(data.Schedules, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/server/twamp"); value.Exists() {
		data.ServerTwamp = types.BoolValue(true)
	} else {
		data.ServerTwamp = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/server/twamp/port"); value.Exists() {
		data.ServerTwampPort = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/server/twamp/timer/inactivity"); value.Exists() {
		data.ServerTwampTimerInactivity = types.Int64Value(value.Int())
	}
}

// End of section. //template:end fromBodyXML
// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyDataXML

func (data *IPSLAData) fromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/low-memory"); value.Exists() {
		data.LowMemory = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/key-chain"); value.Exists() {
		data.KeyChain = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/hw-timestamp/disable"); value.Exists() {
		data.HwTimestampDisable = types.BoolValue(true)
	} else {
		data.HwTimestampDisable = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/operations/operation"); value.Exists() {
		data.Operations = make([]IPSLAOperations, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := IPSLAOperations{}
			if cValue := helpers.GetFromXPath(v, "operation-number"); cValue.Exists() {
				item.OperationNumber = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo"); cValue.Exists() {
				item.IcmpEcho = types.BoolValue(true)
			} else {
				item.IcmpEcho = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/tag"); cValue.Exists() {
				item.IcmpEchoTag = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/frequency"); cValue.Exists() {
				item.IcmpEchoFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/datasize/request/enter-request-datasize-in-byte"); cValue.Exists() {
				item.IcmpEchoDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/timeout"); cValue.Exists() {
				item.IcmpEchoTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/source/address/ipv4-address"); cValue.Exists() {
				item.IcmpEchoSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/source/address/ipv6-address"); cValue.Exists() {
				item.IcmpEchoSourceIpv6 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/tos"); cValue.Exists() {
				item.IcmpEchoTos = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/vrf"); cValue.Exists() {
				item.IcmpEchoVrf = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/destination/address/ipv4-address"); cValue.Exists() {
				item.IcmpEchoDestinationIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/destination/address/ipv6-address"); cValue.Exists() {
				item.IcmpEchoDestinationIpv6 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/history/buckets"); cValue.Exists() {
				item.IcmpEchoHistoryBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/history/filter/all"); cValue.Exists() {
				item.IcmpEchoHistoryFilterAll = types.BoolValue(true)
			} else {
				item.IcmpEchoHistoryFilterAll = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/history/filter/failures"); cValue.Exists() {
				item.IcmpEchoHistoryFilterFailures = types.BoolValue(true)
			} else {
				item.IcmpEchoHistoryFilterFailures = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/history/lives"); cValue.Exists() {
				item.IcmpEchoHistoryLives = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/statistics/hourly/buckets"); cValue.Exists() {
				item.IcmpEchoStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/statistics/hourly/distribution/count"); cValue.Exists() {
				item.IcmpEchoStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/statistics/hourly/distribution/interval"); cValue.Exists() {
				item.IcmpEchoStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/echo/statistics/intervals/interval"); cValue.Exists() {
				item.IcmpEchoStatisticsIntervals = make([]IPSLAOperationsIcmpEchoStatisticsIntervals, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := IPSLAOperationsIcmpEchoStatisticsIntervals{}
					if ccValue := helpers.GetFromXPath(cv, "interval-time"); ccValue.Exists() {
						cItem.Interval = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "buckets"); ccValue.Exists() {
						cItem.Buckets = types.Int64Value(ccValue.Int())
					}
					item.IcmpEchoStatisticsIntervals = append(item.IcmpEchoStatisticsIntervals, cItem)
					return true
				})
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo"); cValue.Exists() {
				item.IcmpPathEcho = types.BoolValue(true)
			} else {
				item.IcmpPathEcho = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/tag"); cValue.Exists() {
				item.IcmpPathEchoTag = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/frequency"); cValue.Exists() {
				item.IcmpPathEchoFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/datasize/request/enter-request-datasize-in-byte"); cValue.Exists() {
				item.IcmpPathEchoDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/timeout"); cValue.Exists() {
				item.IcmpPathEchoTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/source/address/ipv4-address"); cValue.Exists() {
				item.IcmpPathEchoSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/tos"); cValue.Exists() {
				item.IcmpPathEchoTos = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/destination/address/address"); cValue.Exists() {
				item.IcmpPathEchoDestinationIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/history/buckets"); cValue.Exists() {
				item.IcmpPathEchoHistoryBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/history/filter/all"); cValue.Exists() {
				item.IcmpPathEchoHistoryFilterAll = types.BoolValue(true)
			} else {
				item.IcmpPathEchoHistoryFilterAll = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/history/filter/failures"); cValue.Exists() {
				item.IcmpPathEchoHistoryFilterFailures = types.BoolValue(true)
			} else {
				item.IcmpPathEchoHistoryFilterFailures = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/history/lives"); cValue.Exists() {
				item.IcmpPathEchoHistoryLives = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/history/samples"); cValue.Exists() {
				item.IcmpPathEchoHistorySamples = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/statistics/hourly/buckets"); cValue.Exists() {
				item.IcmpPathEchoStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/statistics/hourly/distribution/count"); cValue.Exists() {
				item.IcmpPathEchoStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/statistics/hourly/distribution/interval"); cValue.Exists() {
				item.IcmpPathEchoStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/statistics/hourly/maximum/hops"); cValue.Exists() {
				item.IcmpPathEchoStatisticsHourlyMaximumHops = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-echo/statistics/hourly/maximum/paths"); cValue.Exists() {
				item.IcmpPathEchoStatisticsHourlyMaximumPaths = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-jitter"); cValue.Exists() {
				item.IcmpPathJitter = types.BoolValue(true)
			} else {
				item.IcmpPathJitter = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-jitter/tag"); cValue.Exists() {
				item.IcmpPathJitterTag = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-jitter/frequency"); cValue.Exists() {
				item.IcmpPathJitterFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-jitter/datasize/request/enter-request-datasize-in-byte"); cValue.Exists() {
				item.IcmpPathJitterDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-jitter/timeout"); cValue.Exists() {
				item.IcmpPathJitterTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-jitter/source/address/ipv4-address"); cValue.Exists() {
				item.IcmpPathJitterSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-jitter/packet/count"); cValue.Exists() {
				item.IcmpPathJitterPacketCount = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-jitter/packet/interval"); cValue.Exists() {
				item.IcmpPathJitterPacketInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-jitter/tos"); cValue.Exists() {
				item.IcmpPathJitterTos = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/icmp/path-jitter/destination/address/address"); cValue.Exists() {
				item.IcmpPathJitterDestinationIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo"); cValue.Exists() {
				item.UdpEcho = types.BoolValue(true)
			} else {
				item.UdpEcho = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/tag"); cValue.Exists() {
				item.UdpEchoTag = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/frequency"); cValue.Exists() {
				item.UdpEchoFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/datasize/request/enter-request-datasize-in-byte"); cValue.Exists() {
				item.UdpEchoDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/timeout"); cValue.Exists() {
				item.UdpEchoTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/source/address/ipv4-address"); cValue.Exists() {
				item.UdpEchoSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/source/port"); cValue.Exists() {
				item.UdpEchoSourcePort = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/destination/address"); cValue.Exists() {
				item.UdpEchoDestinationIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/destination/port"); cValue.Exists() {
				item.UdpEchoDestinationPort = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/control/disable"); cValue.Exists() {
				item.UdpEchoControlDisable = types.BoolValue(true)
			} else {
				item.UdpEchoControlDisable = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/verify-data"); cValue.Exists() {
				item.UdpEchoVerifyData = types.BoolValue(true)
			} else {
				item.UdpEchoVerifyData = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/tos"); cValue.Exists() {
				item.UdpEchoTos = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/vrf"); cValue.Exists() {
				item.UdpEchoVrf = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/statistics/hourly/buckets"); cValue.Exists() {
				item.UdpEchoStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/statistics/hourly/distribution/count"); cValue.Exists() {
				item.UdpEchoStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/statistics/hourly/distribution/interval"); cValue.Exists() {
				item.UdpEchoStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/statistics/intervals/interval"); cValue.Exists() {
				item.UdpEchoStatisticsIntervals = make([]IPSLAOperationsUdpEchoStatisticsIntervals, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := IPSLAOperationsUdpEchoStatisticsIntervals{}
					if ccValue := helpers.GetFromXPath(cv, "interval-time"); ccValue.Exists() {
						cItem.Interval = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "buckets"); ccValue.Exists() {
						cItem.Buckets = types.Int64Value(ccValue.Int())
					}
					item.UdpEchoStatisticsIntervals = append(item.UdpEchoStatisticsIntervals, cItem)
					return true
				})
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/history/buckets"); cValue.Exists() {
				item.UdpEchoHistoryBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/history/filter/all"); cValue.Exists() {
				item.UdpEchoHistoryFilterAll = types.BoolValue(true)
			} else {
				item.UdpEchoHistoryFilterAll = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/history/filter/failures"); cValue.Exists() {
				item.UdpEchoHistoryFilterFailures = types.BoolValue(true)
			} else {
				item.UdpEchoHistoryFilterFailures = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/echo/history/lives"); cValue.Exists() {
				item.UdpEchoHistoryLives = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter"); cValue.Exists() {
				item.UdpJitter = types.BoolValue(true)
			} else {
				item.UdpJitter = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/tag"); cValue.Exists() {
				item.UdpJitterTag = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/frequency"); cValue.Exists() {
				item.UdpJitterFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/datasize/request/enter-request-datasize-in-byte"); cValue.Exists() {
				item.UdpJitterDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/timeout"); cValue.Exists() {
				item.UdpJitterTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/source/address/ipv4-address"); cValue.Exists() {
				item.UdpJitterSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/source/port"); cValue.Exists() {
				item.UdpJitterSourcePort = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/destination/address"); cValue.Exists() {
				item.UdpJitterDestinationIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/destination/port"); cValue.Exists() {
				item.UdpJitterDestinationPort = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/packet/count"); cValue.Exists() {
				item.UdpJitterPacketCount = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/packet/interval"); cValue.Exists() {
				item.UdpJitterPacketInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/tos"); cValue.Exists() {
				item.UdpJitterTos = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/vrf"); cValue.Exists() {
				item.UdpJitterVrf = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/control/disable"); cValue.Exists() {
				item.UdpJitterControlDisable = types.BoolValue(true)
			} else {
				item.UdpJitterControlDisable = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/verify-data"); cValue.Exists() {
				item.UdpJitterVerifyData = types.BoolValue(true)
			} else {
				item.UdpJitterVerifyData = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/statistics/hourly/buckets"); cValue.Exists() {
				item.UdpJitterStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/statistics/hourly/distribution/count"); cValue.Exists() {
				item.UdpJitterStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/statistics/hourly/distribution/interval"); cValue.Exists() {
				item.UdpJitterStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/udp/jitter/statistics/intervals/interval"); cValue.Exists() {
				item.UdpJitterStatisticsIntervals = make([]IPSLAOperationsUdpJitterStatisticsIntervals, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := IPSLAOperationsUdpJitterStatisticsIntervals{}
					if ccValue := helpers.GetFromXPath(cv, "interval-time"); ccValue.Exists() {
						cItem.Interval = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "buckets"); ccValue.Exists() {
						cItem.Buckets = types.Int64Value(ccValue.Int())
					}
					item.UdpJitterStatisticsIntervals = append(item.UdpJitterStatisticsIntervals, cItem)
					return true
				})
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping"); cValue.Exists() {
				item.MplsLspPing = types.BoolValue(true)
			} else {
				item.MplsLspPing = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/tag"); cValue.Exists() {
				item.MplsLspPingTag = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/frequency"); cValue.Exists() {
				item.MplsLspPingFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/datasize/request/enter-request-datasize-in-byte"); cValue.Exists() {
				item.MplsLspPingDatasizeRequest = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/timeout"); cValue.Exists() {
				item.MplsLspPingTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/source/address/ipv4-address"); cValue.Exists() {
				item.MplsLspPingSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/target/ipv4/address"); cValue.Exists() {
				item.MplsLspPingTargetIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/target/ipv4/mask"); cValue.Exists() {
				item.MplsLspPingTargetIpv4Mask = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/target/traffic-eng/tunnel"); cValue.Exists() {
				item.MplsLspPingTargetTeTunnel = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/target/pseudowire/address"); cValue.Exists() {
				item.MplsLspPingTargetPseudowireAddress = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/target/pseudowire/virtual-circuit-id"); cValue.Exists() {
				item.MplsLspPingTargetPseudowireVcId = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/statistics/hourly/buckets"); cValue.Exists() {
				item.MplsLspPingStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/statistics/hourly/distribution/count"); cValue.Exists() {
				item.MplsLspPingStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/statistics/hourly/distribution/interval"); cValue.Exists() {
				item.MplsLspPingStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/ping/statistics/intervals/interval"); cValue.Exists() {
				item.MplsLspPingStatisticsIntervals = make([]IPSLAOperationsMplsLspPingStatisticsIntervals, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := IPSLAOperationsMplsLspPingStatisticsIntervals{}
					if ccValue := helpers.GetFromXPath(cv, "interval-time"); ccValue.Exists() {
						cItem.Interval = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "buckets"); ccValue.Exists() {
						cItem.Buckets = types.Int64Value(ccValue.Int())
					}
					item.MplsLspPingStatisticsIntervals = append(item.MplsLspPingStatisticsIntervals, cItem)
					return true
				})
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace"); cValue.Exists() {
				item.MplsLspTrace = types.BoolValue(true)
			} else {
				item.MplsLspTrace = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/tag"); cValue.Exists() {
				item.MplsLspTraceTag = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/frequency"); cValue.Exists() {
				item.MplsLspTraceFrequency = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/timeout"); cValue.Exists() {
				item.MplsLspTraceTimeout = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/source/address/ipv4-address"); cValue.Exists() {
				item.MplsLspTraceSourceIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/target/ipv4/address"); cValue.Exists() {
				item.MplsLspTraceTargetIpv4 = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/target/ipv4/mask"); cValue.Exists() {
				item.MplsLspTraceTargetIpv4Mask = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/target/traffic-eng/tunnel"); cValue.Exists() {
				item.MplsLspTraceTargetTeTunnel = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/target/pseudowire/address"); cValue.Exists() {
				item.MplsLspTraceTargetPseudowireAddress = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/target/pseudowire/virtual-circuit-id"); cValue.Exists() {
				item.MplsLspTraceTargetPseudowireVcId = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/statistics/hourly/buckets"); cValue.Exists() {
				item.MplsLspTraceStatisticsHourlyBuckets = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/statistics/hourly/distribution/count"); cValue.Exists() {
				item.MplsLspTraceStatisticsHourlyDistributionCount = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "type/mpls/lsp/trace/statistics/hourly/distribution/interval"); cValue.Exists() {
				item.MplsLspTraceStatisticsHourlyDistributionInterval = types.Int64Value(cValue.Int())
			}
			data.Operations = append(data.Operations, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/schedule/operations/operation"); value.Exists() {
		data.Schedules = make([]IPSLASchedules, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := IPSLASchedules{}
			if cValue := helpers.GetFromXPath(v, "operation-number"); cValue.Exists() {
				item.OperationNumber = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "life/forever"); cValue.Exists() {
				item.LifeForever = types.BoolValue(true)
			} else {
				item.LifeForever = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "life/length-of-time"); cValue.Exists() {
				item.LifeTime = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "start-time/time-and-date/hour"); cValue.Exists() {
				item.StartHour = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "start-time/time-and-date/minute"); cValue.Exists() {
				item.StartMinute = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "start-time/time-and-date/second"); cValue.Exists() {
				item.StartSecond = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "start-time/time-and-date/month"); cValue.Exists() {
				item.StartMonth = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "start-time/time-and-date/day-of-month"); cValue.Exists() {
				item.StartDayOfMonth = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "start-time/time-and-date/year"); cValue.Exists() {
				item.StartYear = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "start-time/pending"); cValue.Exists() {
				item.StartPending = types.BoolValue(true)
			} else {
				item.StartPending = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "start-time/after/time/hour"); cValue.Exists() {
				item.StartAfterHour = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "start-time/after/time/minute"); cValue.Exists() {
				item.StartAfterMinute = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "start-time/after/time/second"); cValue.Exists() {
				item.StartAfterSecond = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "start-time/now"); cValue.Exists() {
				item.StartNow = types.BoolValue(true)
			} else {
				item.StartNow = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "recurring"); cValue.Exists() {
				item.Recurring = types.BoolValue(true)
			} else {
				item.Recurring = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "ageout"); cValue.Exists() {
				item.Ageout = types.Int64Value(cValue.Int())
			}
			data.Schedules = append(data.Schedules, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/server/twamp"); value.Exists() {
		data.ServerTwamp = types.BoolValue(true)
	} else {
		data.ServerTwamp = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/server/twamp/port"); value.Exists() {
		data.ServerTwampPort = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/server/twamp/timer/inactivity"); value.Exists() {
		data.ServerTwampTimerInactivity = types.Int64Value(value.Int())
	}
}

// End of section. //template:end fromBodyDataXML
// Section below is generated&owned by "gen/generator.go". //template:begin getDeletedItems

func (data *IPSLA) getDeletedItems(ctx context.Context, state IPSLA) []string {
	deletedItems := make([]string, 0)
	if !state.ServerTwampTimerInactivity.IsNull() && data.ServerTwampTimerInactivity.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/server/twamp/timer/inactivity", state.getPath()))
	}
	if !state.ServerTwampPort.IsNull() && data.ServerTwampPort.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/server/twamp/port", state.getPath()))
	}
	if !state.ServerTwamp.IsNull() && data.ServerTwamp.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/server/twamp", state.getPath()))
	}
	for i := range state.Schedules {
		keys := [...]string{"operation-number"}
		stateKeyValues := [...]string{strconv.FormatInt(state.Schedules[i].OperationNumber.ValueInt64(), 10)}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.Schedules[i].OperationNumber.ValueInt64()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Schedules {
			found = true
			if state.Schedules[i].OperationNumber.ValueInt64() != data.Schedules[j].OperationNumber.ValueInt64() {
				found = false
			}
			if found {
				if !state.Schedules[i].Ageout.IsNull() && data.Schedules[j].Ageout.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/schedule/operations/operation%v/ageout", state.getPath(), keyString))
				}
				if !state.Schedules[i].Recurring.IsNull() && data.Schedules[j].Recurring.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/schedule/operations/operation%v/recurring", state.getPath(), keyString))
				}
				if !state.Schedules[i].StartNow.IsNull() && data.Schedules[j].StartNow.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/schedule/operations/operation%v/start-time/now", state.getPath(), keyString))
				}
				if !state.Schedules[i].StartAfterSecond.IsNull() && data.Schedules[j].StartAfterSecond.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/schedule/operations/operation%v/start-time/after/time", state.getPath(), keyString))
				}
				if !state.Schedules[i].StartAfterMinute.IsNull() && data.Schedules[j].StartAfterMinute.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/schedule/operations/operation%v/start-time/after/time", state.getPath(), keyString))
				}
				if !state.Schedules[i].StartAfterHour.IsNull() && data.Schedules[j].StartAfterHour.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/schedule/operations/operation%v/start-time/after/time", state.getPath(), keyString))
				}
				if !state.Schedules[i].StartPending.IsNull() && data.Schedules[j].StartPending.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/schedule/operations/operation%v/start-time/pending", state.getPath(), keyString))
				}
				if !state.Schedules[i].StartYear.IsNull() && data.Schedules[j].StartYear.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/schedule/operations/operation%v/start-time/time-and-date", state.getPath(), keyString))
				}
				if !state.Schedules[i].StartDayOfMonth.IsNull() && data.Schedules[j].StartDayOfMonth.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/schedule/operations/operation%v/start-time/time-and-date", state.getPath(), keyString))
				}
				if !state.Schedules[i].StartMonth.IsNull() && data.Schedules[j].StartMonth.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/schedule/operations/operation%v/start-time/time-and-date", state.getPath(), keyString))
				}
				if !state.Schedules[i].StartSecond.IsNull() && data.Schedules[j].StartSecond.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/schedule/operations/operation%v/start-time/time-and-date", state.getPath(), keyString))
				}
				if !state.Schedules[i].StartMinute.IsNull() && data.Schedules[j].StartMinute.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/schedule/operations/operation%v/start-time/time-and-date", state.getPath(), keyString))
				}
				if !state.Schedules[i].StartHour.IsNull() && data.Schedules[j].StartHour.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/schedule/operations/operation%v/start-time/time-and-date", state.getPath(), keyString))
				}
				if !state.Schedules[i].LifeTime.IsNull() && data.Schedules[j].LifeTime.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/schedule/operations/operation%v/life/length-of-time", state.getPath(), keyString))
				}
				if !state.Schedules[i].LifeForever.IsNull() && data.Schedules[j].LifeForever.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/schedule/operations/operation%v/life/forever", state.getPath(), keyString))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/schedule/operations/operation%v", state.getPath(), keyString))
		}
	}
	for i := range state.Operations {
		keys := [...]string{"operation-number"}
		stateKeyValues := [...]string{strconv.FormatInt(state.Operations[i].OperationNumber.ValueInt64(), 10)}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.Operations[i].OperationNumber.ValueInt64()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Operations {
			found = true
			if state.Operations[i].OperationNumber.ValueInt64() != data.Operations[j].OperationNumber.ValueInt64() {
				found = false
			}
			if found {
				if !state.Operations[i].MplsLspTraceStatisticsHourlyDistributionInterval.IsNull() && data.Operations[j].MplsLspTraceStatisticsHourlyDistributionInterval.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/trace/statistics/hourly/distribution/interval", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspTraceStatisticsHourlyDistributionCount.IsNull() && data.Operations[j].MplsLspTraceStatisticsHourlyDistributionCount.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/trace/statistics/hourly/distribution/count", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspTraceStatisticsHourlyBuckets.IsNull() && data.Operations[j].MplsLspTraceStatisticsHourlyBuckets.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/trace/statistics/hourly/buckets", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspTraceTargetPseudowireVcId.IsNull() && data.Operations[j].MplsLspTraceTargetPseudowireVcId.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/trace/target/pseudowire", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspTraceTargetPseudowireAddress.IsNull() && data.Operations[j].MplsLspTraceTargetPseudowireAddress.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/trace/target/pseudowire", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspTraceTargetTeTunnel.IsNull() && data.Operations[j].MplsLspTraceTargetTeTunnel.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/trace/target/traffic-eng/tunnel", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspTraceTargetIpv4Mask.IsNull() && data.Operations[j].MplsLspTraceTargetIpv4Mask.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/trace/target/ipv4", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspTraceTargetIpv4.IsNull() && data.Operations[j].MplsLspTraceTargetIpv4.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/trace/target/ipv4", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspTraceSourceIpv4.IsNull() && data.Operations[j].MplsLspTraceSourceIpv4.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/trace/source/address/ipv4-address", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspTraceTimeout.IsNull() && data.Operations[j].MplsLspTraceTimeout.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/trace/timeout", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspTraceFrequency.IsNull() && data.Operations[j].MplsLspTraceFrequency.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/trace/frequency", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspTraceTag.IsNull() && data.Operations[j].MplsLspTraceTag.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/trace/tag", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspTrace.IsNull() && data.Operations[j].MplsLspTrace.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/trace", state.getPath(), keyString))
				}
				for ci := range state.Operations[i].MplsLspPingStatisticsIntervals {
					ckeys := [...]string{"interval-time"}
					cstateKeyValues := [...]string{strconv.FormatInt(state.Operations[i].MplsLspPingStatisticsIntervals[ci].Interval.ValueInt64(), 10)}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.Operations[i].MplsLspPingStatisticsIntervals[ci].Interval.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.Operations[j].MplsLspPingStatisticsIntervals {
						found = true
						if state.Operations[i].MplsLspPingStatisticsIntervals[ci].Interval.ValueInt64() != data.Operations[j].MplsLspPingStatisticsIntervals[cj].Interval.ValueInt64() {
							found = false
						}
						if found {
							if !state.Operations[i].MplsLspPingStatisticsIntervals[ci].Buckets.IsNull() && data.Operations[j].MplsLspPingStatisticsIntervals[cj].Buckets.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/ping/statistics/intervals/interval%v/buckets", state.getPath(), keyString, ckeyString))
							}
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/ping/statistics/intervals/interval%v", state.getPath(), keyString, ckeyString))
					}
				}
				if !state.Operations[i].MplsLspPingStatisticsHourlyDistributionInterval.IsNull() && data.Operations[j].MplsLspPingStatisticsHourlyDistributionInterval.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/ping/statistics/hourly/distribution/interval", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspPingStatisticsHourlyDistributionCount.IsNull() && data.Operations[j].MplsLspPingStatisticsHourlyDistributionCount.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/ping/statistics/hourly/distribution/count", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspPingStatisticsHourlyBuckets.IsNull() && data.Operations[j].MplsLspPingStatisticsHourlyBuckets.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/ping/statistics/hourly/buckets", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspPingTargetPseudowireVcId.IsNull() && data.Operations[j].MplsLspPingTargetPseudowireVcId.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/ping/target/pseudowire", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspPingTargetPseudowireAddress.IsNull() && data.Operations[j].MplsLspPingTargetPseudowireAddress.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/ping/target/pseudowire", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspPingTargetTeTunnel.IsNull() && data.Operations[j].MplsLspPingTargetTeTunnel.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/ping/target/traffic-eng/tunnel", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspPingTargetIpv4Mask.IsNull() && data.Operations[j].MplsLspPingTargetIpv4Mask.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/ping/target/ipv4", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspPingTargetIpv4.IsNull() && data.Operations[j].MplsLspPingTargetIpv4.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/ping/target/ipv4", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspPingSourceIpv4.IsNull() && data.Operations[j].MplsLspPingSourceIpv4.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/ping/source/address/ipv4-address", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspPingTimeout.IsNull() && data.Operations[j].MplsLspPingTimeout.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/ping/timeout", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspPingDatasizeRequest.IsNull() && data.Operations[j].MplsLspPingDatasizeRequest.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/ping/datasize/request/enter-request-datasize-in-byte", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspPingFrequency.IsNull() && data.Operations[j].MplsLspPingFrequency.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/ping/frequency", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspPingTag.IsNull() && data.Operations[j].MplsLspPingTag.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/ping/tag", state.getPath(), keyString))
				}
				if !state.Operations[i].MplsLspPing.IsNull() && data.Operations[j].MplsLspPing.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/ping", state.getPath(), keyString))
				}
				for ci := range state.Operations[i].UdpJitterStatisticsIntervals {
					ckeys := [...]string{"interval-time"}
					cstateKeyValues := [...]string{strconv.FormatInt(state.Operations[i].UdpJitterStatisticsIntervals[ci].Interval.ValueInt64(), 10)}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.Operations[i].UdpJitterStatisticsIntervals[ci].Interval.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.Operations[j].UdpJitterStatisticsIntervals {
						found = true
						if state.Operations[i].UdpJitterStatisticsIntervals[ci].Interval.ValueInt64() != data.Operations[j].UdpJitterStatisticsIntervals[cj].Interval.ValueInt64() {
							found = false
						}
						if found {
							if !state.Operations[i].UdpJitterStatisticsIntervals[ci].Buckets.IsNull() && data.Operations[j].UdpJitterStatisticsIntervals[cj].Buckets.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter/statistics/intervals/interval%v/buckets", state.getPath(), keyString, ckeyString))
							}
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter/statistics/intervals/interval%v", state.getPath(), keyString, ckeyString))
					}
				}
				if !state.Operations[i].UdpJitterStatisticsHourlyDistributionInterval.IsNull() && data.Operations[j].UdpJitterStatisticsHourlyDistributionInterval.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter/statistics/hourly/distribution/interval", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpJitterStatisticsHourlyDistributionCount.IsNull() && data.Operations[j].UdpJitterStatisticsHourlyDistributionCount.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter/statistics/hourly/distribution/count", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpJitterStatisticsHourlyBuckets.IsNull() && data.Operations[j].UdpJitterStatisticsHourlyBuckets.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter/statistics/hourly/buckets", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpJitterVerifyData.IsNull() && data.Operations[j].UdpJitterVerifyData.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter/verify-data", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpJitterControlDisable.IsNull() && data.Operations[j].UdpJitterControlDisable.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter/control/disable", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpJitterVrf.IsNull() && data.Operations[j].UdpJitterVrf.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter/vrf", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpJitterTos.IsNull() && data.Operations[j].UdpJitterTos.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter/tos", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpJitterPacketInterval.IsNull() && data.Operations[j].UdpJitterPacketInterval.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter/packet/interval", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpJitterPacketCount.IsNull() && data.Operations[j].UdpJitterPacketCount.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter/packet/count", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpJitterDestinationPort.IsNull() && data.Operations[j].UdpJitterDestinationPort.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter/destination/port", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpJitterDestinationIpv4.IsNull() && data.Operations[j].UdpJitterDestinationIpv4.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter/destination/address", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpJitterSourcePort.IsNull() && data.Operations[j].UdpJitterSourcePort.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter/source/port", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpJitterSourceIpv4.IsNull() && data.Operations[j].UdpJitterSourceIpv4.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter/source/address/ipv4-address", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpJitterTimeout.IsNull() && data.Operations[j].UdpJitterTimeout.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter/timeout", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpJitterDatasizeRequest.IsNull() && data.Operations[j].UdpJitterDatasizeRequest.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter/datasize/request/enter-request-datasize-in-byte", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpJitterFrequency.IsNull() && data.Operations[j].UdpJitterFrequency.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter/frequency", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpJitterTag.IsNull() && data.Operations[j].UdpJitterTag.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter/tag", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpJitter.IsNull() && data.Operations[j].UdpJitter.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpEchoHistoryLives.IsNull() && data.Operations[j].UdpEchoHistoryLives.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/history/lives", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpEchoHistoryFilterFailures.IsNull() && data.Operations[j].UdpEchoHistoryFilterFailures.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/history/filter/failures", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpEchoHistoryFilterAll.IsNull() && data.Operations[j].UdpEchoHistoryFilterAll.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/history/filter/all", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpEchoHistoryBuckets.IsNull() && data.Operations[j].UdpEchoHistoryBuckets.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/history/buckets", state.getPath(), keyString))
				}
				for ci := range state.Operations[i].UdpEchoStatisticsIntervals {
					ckeys := [...]string{"interval-time"}
					cstateKeyValues := [...]string{strconv.FormatInt(state.Operations[i].UdpEchoStatisticsIntervals[ci].Interval.ValueInt64(), 10)}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.Operations[i].UdpEchoStatisticsIntervals[ci].Interval.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.Operations[j].UdpEchoStatisticsIntervals {
						found = true
						if state.Operations[i].UdpEchoStatisticsIntervals[ci].Interval.ValueInt64() != data.Operations[j].UdpEchoStatisticsIntervals[cj].Interval.ValueInt64() {
							found = false
						}
						if found {
							if !state.Operations[i].UdpEchoStatisticsIntervals[ci].Buckets.IsNull() && data.Operations[j].UdpEchoStatisticsIntervals[cj].Buckets.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/statistics/intervals/interval%v/buckets", state.getPath(), keyString, ckeyString))
							}
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/statistics/intervals/interval%v", state.getPath(), keyString, ckeyString))
					}
				}
				if !state.Operations[i].UdpEchoStatisticsHourlyDistributionInterval.IsNull() && data.Operations[j].UdpEchoStatisticsHourlyDistributionInterval.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/statistics/hourly/distribution/interval", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpEchoStatisticsHourlyDistributionCount.IsNull() && data.Operations[j].UdpEchoStatisticsHourlyDistributionCount.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/statistics/hourly/distribution/count", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpEchoStatisticsHourlyBuckets.IsNull() && data.Operations[j].UdpEchoStatisticsHourlyBuckets.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/statistics/hourly/buckets", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpEchoVrf.IsNull() && data.Operations[j].UdpEchoVrf.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/vrf", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpEchoTos.IsNull() && data.Operations[j].UdpEchoTos.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/tos", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpEchoVerifyData.IsNull() && data.Operations[j].UdpEchoVerifyData.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/verify-data", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpEchoControlDisable.IsNull() && data.Operations[j].UdpEchoControlDisable.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/control/disable", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpEchoDestinationPort.IsNull() && data.Operations[j].UdpEchoDestinationPort.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/destination/port", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpEchoDestinationIpv4.IsNull() && data.Operations[j].UdpEchoDestinationIpv4.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/destination/address", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpEchoSourcePort.IsNull() && data.Operations[j].UdpEchoSourcePort.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/source/port", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpEchoSourceIpv4.IsNull() && data.Operations[j].UdpEchoSourceIpv4.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/source/address/ipv4-address", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpEchoTimeout.IsNull() && data.Operations[j].UdpEchoTimeout.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/timeout", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpEchoDatasizeRequest.IsNull() && data.Operations[j].UdpEchoDatasizeRequest.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/datasize/request/enter-request-datasize-in-byte", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpEchoFrequency.IsNull() && data.Operations[j].UdpEchoFrequency.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/frequency", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpEchoTag.IsNull() && data.Operations[j].UdpEchoTag.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/tag", state.getPath(), keyString))
				}
				if !state.Operations[i].UdpEcho.IsNull() && data.Operations[j].UdpEcho.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/udp/echo", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathJitterDestinationIpv4.IsNull() && data.Operations[j].IcmpPathJitterDestinationIpv4.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-jitter/destination/address/address", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathJitterTos.IsNull() && data.Operations[j].IcmpPathJitterTos.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-jitter/tos", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathJitterPacketInterval.IsNull() && data.Operations[j].IcmpPathJitterPacketInterval.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-jitter/packet/interval", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathJitterPacketCount.IsNull() && data.Operations[j].IcmpPathJitterPacketCount.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-jitter/packet/count", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathJitterSourceIpv4.IsNull() && data.Operations[j].IcmpPathJitterSourceIpv4.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-jitter/source/address/ipv4-address", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathJitterTimeout.IsNull() && data.Operations[j].IcmpPathJitterTimeout.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-jitter/timeout", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathJitterDatasizeRequest.IsNull() && data.Operations[j].IcmpPathJitterDatasizeRequest.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-jitter/datasize/request/enter-request-datasize-in-byte", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathJitterFrequency.IsNull() && data.Operations[j].IcmpPathJitterFrequency.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-jitter/frequency", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathJitterTag.IsNull() && data.Operations[j].IcmpPathJitterTag.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-jitter/tag", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathJitter.IsNull() && data.Operations[j].IcmpPathJitter.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-jitter", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathEchoStatisticsHourlyMaximumPaths.IsNull() && data.Operations[j].IcmpPathEchoStatisticsHourlyMaximumPaths.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-echo/statistics/hourly/maximum/paths", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathEchoStatisticsHourlyMaximumHops.IsNull() && data.Operations[j].IcmpPathEchoStatisticsHourlyMaximumHops.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-echo/statistics/hourly/maximum/hops", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathEchoStatisticsHourlyDistributionInterval.IsNull() && data.Operations[j].IcmpPathEchoStatisticsHourlyDistributionInterval.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-echo/statistics/hourly/distribution/interval", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathEchoStatisticsHourlyDistributionCount.IsNull() && data.Operations[j].IcmpPathEchoStatisticsHourlyDistributionCount.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-echo/statistics/hourly/distribution/count", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathEchoStatisticsHourlyBuckets.IsNull() && data.Operations[j].IcmpPathEchoStatisticsHourlyBuckets.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-echo/statistics/hourly/buckets", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathEchoHistorySamples.IsNull() && data.Operations[j].IcmpPathEchoHistorySamples.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-echo/history/samples", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathEchoHistoryLives.IsNull() && data.Operations[j].IcmpPathEchoHistoryLives.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-echo/history/lives", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathEchoHistoryFilterFailures.IsNull() && data.Operations[j].IcmpPathEchoHistoryFilterFailures.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-echo/history/filter/failures", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathEchoHistoryFilterAll.IsNull() && data.Operations[j].IcmpPathEchoHistoryFilterAll.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-echo/history/filter/all", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathEchoHistoryBuckets.IsNull() && data.Operations[j].IcmpPathEchoHistoryBuckets.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-echo/history/buckets", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathEchoDestinationIpv4.IsNull() && data.Operations[j].IcmpPathEchoDestinationIpv4.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-echo/destination/address/address", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathEchoTos.IsNull() && data.Operations[j].IcmpPathEchoTos.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-echo/tos", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathEchoSourceIpv4.IsNull() && data.Operations[j].IcmpPathEchoSourceIpv4.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-echo/source/address/ipv4-address", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathEchoTimeout.IsNull() && data.Operations[j].IcmpPathEchoTimeout.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-echo/timeout", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathEchoDatasizeRequest.IsNull() && data.Operations[j].IcmpPathEchoDatasizeRequest.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-echo/datasize/request/enter-request-datasize-in-byte", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathEchoFrequency.IsNull() && data.Operations[j].IcmpPathEchoFrequency.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-echo/frequency", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathEchoTag.IsNull() && data.Operations[j].IcmpPathEchoTag.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-echo/tag", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpPathEcho.IsNull() && data.Operations[j].IcmpPathEcho.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-echo", state.getPath(), keyString))
				}
				for ci := range state.Operations[i].IcmpEchoStatisticsIntervals {
					ckeys := [...]string{"interval-time"}
					cstateKeyValues := [...]string{strconv.FormatInt(state.Operations[i].IcmpEchoStatisticsIntervals[ci].Interval.ValueInt64(), 10)}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.Operations[i].IcmpEchoStatisticsIntervals[ci].Interval.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.Operations[j].IcmpEchoStatisticsIntervals {
						found = true
						if state.Operations[i].IcmpEchoStatisticsIntervals[ci].Interval.ValueInt64() != data.Operations[j].IcmpEchoStatisticsIntervals[cj].Interval.ValueInt64() {
							found = false
						}
						if found {
							if !state.Operations[i].IcmpEchoStatisticsIntervals[ci].Buckets.IsNull() && data.Operations[j].IcmpEchoStatisticsIntervals[cj].Buckets.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo/statistics/intervals/interval%v/buckets", state.getPath(), keyString, ckeyString))
							}
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo/statistics/intervals/interval%v", state.getPath(), keyString, ckeyString))
					}
				}
				if !state.Operations[i].IcmpEchoStatisticsHourlyDistributionInterval.IsNull() && data.Operations[j].IcmpEchoStatisticsHourlyDistributionInterval.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo/statistics/hourly/distribution/interval", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpEchoStatisticsHourlyDistributionCount.IsNull() && data.Operations[j].IcmpEchoStatisticsHourlyDistributionCount.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo/statistics/hourly/distribution/count", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpEchoStatisticsHourlyBuckets.IsNull() && data.Operations[j].IcmpEchoStatisticsHourlyBuckets.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo/statistics/hourly/buckets", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpEchoHistoryLives.IsNull() && data.Operations[j].IcmpEchoHistoryLives.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo/history/lives", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpEchoHistoryFilterFailures.IsNull() && data.Operations[j].IcmpEchoHistoryFilterFailures.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo/history/filter/failures", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpEchoHistoryFilterAll.IsNull() && data.Operations[j].IcmpEchoHistoryFilterAll.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo/history/filter/all", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpEchoHistoryBuckets.IsNull() && data.Operations[j].IcmpEchoHistoryBuckets.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo/history/buckets", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpEchoDestinationIpv6.IsNull() && data.Operations[j].IcmpEchoDestinationIpv6.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo/destination/address/ipv6-address", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpEchoDestinationIpv4.IsNull() && data.Operations[j].IcmpEchoDestinationIpv4.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo/destination/address/ipv4-address", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpEchoVrf.IsNull() && data.Operations[j].IcmpEchoVrf.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo/vrf", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpEchoTos.IsNull() && data.Operations[j].IcmpEchoTos.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo/tos", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpEchoSourceIpv6.IsNull() && data.Operations[j].IcmpEchoSourceIpv6.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo/source/address/ipv6-address", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpEchoSourceIpv4.IsNull() && data.Operations[j].IcmpEchoSourceIpv4.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo/source/address/ipv4-address", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpEchoTimeout.IsNull() && data.Operations[j].IcmpEchoTimeout.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo/timeout", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpEchoDatasizeRequest.IsNull() && data.Operations[j].IcmpEchoDatasizeRequest.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo/datasize/request/enter-request-datasize-in-byte", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpEchoFrequency.IsNull() && data.Operations[j].IcmpEchoFrequency.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo/frequency", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpEchoTag.IsNull() && data.Operations[j].IcmpEchoTag.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo/tag", state.getPath(), keyString))
				}
				if !state.Operations[i].IcmpEcho.IsNull() && data.Operations[j].IcmpEcho.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo", state.getPath(), keyString))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/operations/operation%v", state.getPath(), keyString))
		}
	}
	if !state.HwTimestampDisable.IsNull() && data.HwTimestampDisable.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/hw-timestamp/disable", state.getPath()))
	}
	if !state.KeyChain.IsNull() && data.KeyChain.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/key-chain", state.getPath()))
	}
	if !state.LowMemory.IsNull() && data.LowMemory.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/low-memory", state.getPath()))
	}
	return deletedItems
}

// End of section. //template:end getDeletedItems
// Section below is generated&owned by "gen/generator.go". //template:begin getEmptyLeafsDelete

func (data *IPSLA) getEmptyLeafsDelete(ctx context.Context, state *IPSLA) []string {
	emptyLeafsDelete := make([]string, 0)
	// Only delete if state has true and plan has false
	if !data.ServerTwamp.IsNull() && !data.ServerTwamp.ValueBool() {
		if state != nil && !state.ServerTwamp.IsNull() && state.ServerTwamp.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/server/twamp", data.getXPath()))
		}
	}
	for i := range data.Schedules {
		keys := [...]string{"operation-number"}
		keyValues := [...]string{strconv.FormatInt(data.Schedules[i].OperationNumber.ValueInt64(), 10)}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		// Only delete if state has true and plan has false
		if !data.Schedules[i].Recurring.IsNull() && !data.Schedules[i].Recurring.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Schedules) && !state.Schedules[i].Recurring.IsNull() && state.Schedules[i].Recurring.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/schedule/operations/operation%v/recurring", data.getXPath(), keyString))
			}
		}
		// Only delete if state has true and plan has false
		if !data.Schedules[i].StartNow.IsNull() && !data.Schedules[i].StartNow.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Schedules) && !state.Schedules[i].StartNow.IsNull() && state.Schedules[i].StartNow.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/schedule/operations/operation%v/start-time/now", data.getXPath(), keyString))
			}
		}
		// Only delete if state has true and plan has false
		if !data.Schedules[i].StartPending.IsNull() && !data.Schedules[i].StartPending.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Schedules) && !state.Schedules[i].StartPending.IsNull() && state.Schedules[i].StartPending.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/schedule/operations/operation%v/start-time/pending", data.getXPath(), keyString))
			}
		}
		// Only delete if state has true and plan has false
		if !data.Schedules[i].LifeForever.IsNull() && !data.Schedules[i].LifeForever.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Schedules) && !state.Schedules[i].LifeForever.IsNull() && state.Schedules[i].LifeForever.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/schedule/operations/operation%v/life/forever", data.getXPath(), keyString))
			}
		}
	}
	for i := range data.Operations {
		keys := [...]string{"operation-number"}
		keyValues := [...]string{strconv.FormatInt(data.Operations[i].OperationNumber.ValueInt64(), 10)}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		// Only delete if state has true and plan has false
		if !data.Operations[i].MplsLspTrace.IsNull() && !data.Operations[i].MplsLspTrace.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Operations) && !state.Operations[i].MplsLspTrace.IsNull() && state.Operations[i].MplsLspTrace.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/trace", data.getXPath(), keyString))
			}
		}
		for ci := range data.Operations[i].MplsLspPingStatisticsIntervals {
			ckeys := [...]string{"interval-time"}
			ckeyValues := [...]string{strconv.FormatInt(data.Operations[i].MplsLspPingStatisticsIntervals[ci].Interval.ValueInt64(), 10)}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
		}
		// Only delete if state has true and plan has false
		if !data.Operations[i].MplsLspPing.IsNull() && !data.Operations[i].MplsLspPing.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Operations) && !state.Operations[i].MplsLspPing.IsNull() && state.Operations[i].MplsLspPing.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/operations/operation%v/type/mpls/lsp/ping", data.getXPath(), keyString))
			}
		}
		for ci := range data.Operations[i].UdpJitterStatisticsIntervals {
			ckeys := [...]string{"interval-time"}
			ckeyValues := [...]string{strconv.FormatInt(data.Operations[i].UdpJitterStatisticsIntervals[ci].Interval.ValueInt64(), 10)}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
		}
		// Only delete if state has true and plan has false
		if !data.Operations[i].UdpJitterVerifyData.IsNull() && !data.Operations[i].UdpJitterVerifyData.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Operations) && !state.Operations[i].UdpJitterVerifyData.IsNull() && state.Operations[i].UdpJitterVerifyData.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter/verify-data", data.getXPath(), keyString))
			}
		}
		// Only delete if state has true and plan has false
		if !data.Operations[i].UdpJitterControlDisable.IsNull() && !data.Operations[i].UdpJitterControlDisable.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Operations) && !state.Operations[i].UdpJitterControlDisable.IsNull() && state.Operations[i].UdpJitterControlDisable.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter/control/disable", data.getXPath(), keyString))
			}
		}
		// Only delete if state has true and plan has false
		if !data.Operations[i].UdpJitter.IsNull() && !data.Operations[i].UdpJitter.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Operations) && !state.Operations[i].UdpJitter.IsNull() && state.Operations[i].UdpJitter.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/operations/operation%v/type/udp/jitter", data.getXPath(), keyString))
			}
		}
		// Only delete if state has true and plan has false
		if !data.Operations[i].UdpEchoHistoryFilterFailures.IsNull() && !data.Operations[i].UdpEchoHistoryFilterFailures.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Operations) && !state.Operations[i].UdpEchoHistoryFilterFailures.IsNull() && state.Operations[i].UdpEchoHistoryFilterFailures.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/history/filter/failures", data.getXPath(), keyString))
			}
		}
		// Only delete if state has true and plan has false
		if !data.Operations[i].UdpEchoHistoryFilterAll.IsNull() && !data.Operations[i].UdpEchoHistoryFilterAll.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Operations) && !state.Operations[i].UdpEchoHistoryFilterAll.IsNull() && state.Operations[i].UdpEchoHistoryFilterAll.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/history/filter/all", data.getXPath(), keyString))
			}
		}
		for ci := range data.Operations[i].UdpEchoStatisticsIntervals {
			ckeys := [...]string{"interval-time"}
			ckeyValues := [...]string{strconv.FormatInt(data.Operations[i].UdpEchoStatisticsIntervals[ci].Interval.ValueInt64(), 10)}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
		}
		// Only delete if state has true and plan has false
		if !data.Operations[i].UdpEchoVerifyData.IsNull() && !data.Operations[i].UdpEchoVerifyData.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Operations) && !state.Operations[i].UdpEchoVerifyData.IsNull() && state.Operations[i].UdpEchoVerifyData.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/verify-data", data.getXPath(), keyString))
			}
		}
		// Only delete if state has true and plan has false
		if !data.Operations[i].UdpEchoControlDisable.IsNull() && !data.Operations[i].UdpEchoControlDisable.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Operations) && !state.Operations[i].UdpEchoControlDisable.IsNull() && state.Operations[i].UdpEchoControlDisable.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/operations/operation%v/type/udp/echo/control/disable", data.getXPath(), keyString))
			}
		}
		// Only delete if state has true and plan has false
		if !data.Operations[i].UdpEcho.IsNull() && !data.Operations[i].UdpEcho.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Operations) && !state.Operations[i].UdpEcho.IsNull() && state.Operations[i].UdpEcho.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/operations/operation%v/type/udp/echo", data.getXPath(), keyString))
			}
		}
		// Only delete if state has true and plan has false
		if !data.Operations[i].IcmpPathJitter.IsNull() && !data.Operations[i].IcmpPathJitter.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Operations) && !state.Operations[i].IcmpPathJitter.IsNull() && state.Operations[i].IcmpPathJitter.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-jitter", data.getXPath(), keyString))
			}
		}
		// Only delete if state has true and plan has false
		if !data.Operations[i].IcmpPathEchoHistoryFilterFailures.IsNull() && !data.Operations[i].IcmpPathEchoHistoryFilterFailures.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Operations) && !state.Operations[i].IcmpPathEchoHistoryFilterFailures.IsNull() && state.Operations[i].IcmpPathEchoHistoryFilterFailures.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-echo/history/filter/failures", data.getXPath(), keyString))
			}
		}
		// Only delete if state has true and plan has false
		if !data.Operations[i].IcmpPathEchoHistoryFilterAll.IsNull() && !data.Operations[i].IcmpPathEchoHistoryFilterAll.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Operations) && !state.Operations[i].IcmpPathEchoHistoryFilterAll.IsNull() && state.Operations[i].IcmpPathEchoHistoryFilterAll.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-echo/history/filter/all", data.getXPath(), keyString))
			}
		}
		// Only delete if state has true and plan has false
		if !data.Operations[i].IcmpPathEcho.IsNull() && !data.Operations[i].IcmpPathEcho.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Operations) && !state.Operations[i].IcmpPathEcho.IsNull() && state.Operations[i].IcmpPathEcho.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/operations/operation%v/type/icmp/path-echo", data.getXPath(), keyString))
			}
		}
		for ci := range data.Operations[i].IcmpEchoStatisticsIntervals {
			ckeys := [...]string{"interval-time"}
			ckeyValues := [...]string{strconv.FormatInt(data.Operations[i].IcmpEchoStatisticsIntervals[ci].Interval.ValueInt64(), 10)}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
		}
		// Only delete if state has true and plan has false
		if !data.Operations[i].IcmpEchoHistoryFilterFailures.IsNull() && !data.Operations[i].IcmpEchoHistoryFilterFailures.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Operations) && !state.Operations[i].IcmpEchoHistoryFilterFailures.IsNull() && state.Operations[i].IcmpEchoHistoryFilterFailures.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo/history/filter/failures", data.getXPath(), keyString))
			}
		}
		// Only delete if state has true and plan has false
		if !data.Operations[i].IcmpEchoHistoryFilterAll.IsNull() && !data.Operations[i].IcmpEchoHistoryFilterAll.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Operations) && !state.Operations[i].IcmpEchoHistoryFilterAll.IsNull() && state.Operations[i].IcmpEchoHistoryFilterAll.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo/history/filter/all", data.getXPath(), keyString))
			}
		}
		// Only delete if state has true and plan has false
		if !data.Operations[i].IcmpEcho.IsNull() && !data.Operations[i].IcmpEcho.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Operations) && !state.Operations[i].IcmpEcho.IsNull() && state.Operations[i].IcmpEcho.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/operations/operation%v/type/icmp/echo", data.getXPath(), keyString))
			}
		}
	}
	// Only delete if state has true and plan has false
	if !data.HwTimestampDisable.IsNull() && !data.HwTimestampDisable.ValueBool() {
		if state != nil && !state.HwTimestampDisable.IsNull() && state.HwTimestampDisable.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/hw-timestamp/disable", data.getXPath()))
		}
	}
	return emptyLeafsDelete
}

// End of section. //template:end getEmptyLeafsDelete
// Section below is generated&owned by "gen/generator.go". //template:begin getDeletePaths

func (data *IPSLA) getDeletePaths(ctx context.Context) []string {
	var deletePaths []string
	if !data.ServerTwampTimerInactivity.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/server/twamp/timer/inactivity", data.getPath()))
	}
	if !data.ServerTwampPort.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/server/twamp/port", data.getPath()))
	}
	if !data.ServerTwamp.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/server/twamp", data.getPath()))
	}
	for i := range data.Schedules {
		keyValues := [...]string{strconv.FormatInt(data.Schedules[i].OperationNumber.ValueInt64(), 10)}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/schedule/operations/operation=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	for i := range data.Operations {
		keyValues := [...]string{strconv.FormatInt(data.Operations[i].OperationNumber.ValueInt64(), 10)}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/operations/operation=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	if !data.HwTimestampDisable.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/hw-timestamp/disable", data.getPath()))
	}
	if !data.KeyChain.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/key-chain", data.getPath()))
	}
	if !data.LowMemory.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/low-memory", data.getPath()))
	}

	return deletePaths
}

// End of section. //template:end getDeletePaths
// Section below is generated&owned by "gen/generator.go". //template:begin addDeletedItemsXML

func (data *IPSLA) addDeletedItemsXML(ctx context.Context, state IPSLA, body string) string {
	deleteXml := ""
	deletedPaths := make(map[string]bool)
	_ = deletedPaths // Avoid unused variable error when no delete_parent attributes exist
	if !state.ServerTwampTimerInactivity.IsNull() && data.ServerTwampTimerInactivity.IsNull() {
		deletePath := state.getXPath() + "/server/twamp/timer/inactivity"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.ServerTwampPort.IsNull() && data.ServerTwampPort.IsNull() {
		deletePath := state.getXPath() + "/server/twamp/port"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.ServerTwamp.IsNull() && state.ServerTwamp.ValueBool() && data.ServerTwamp.IsNull() {
		deletePath := state.getXPath() + "/server/twamp"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	for i := range state.Schedules {
		stateKeys := [...]string{"operation-number"}
		stateKeyValues := [...]string{strconv.FormatInt(state.Schedules[i].OperationNumber.ValueInt64(), 10)}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.Schedules[i].OperationNumber.ValueInt64()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Schedules {
			found = true
			if state.Schedules[i].OperationNumber.ValueInt64() != data.Schedules[j].OperationNumber.ValueInt64() {
				found = false
			}
			if found {
				if !state.Schedules[i].Ageout.IsNull() && data.Schedules[j].Ageout.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/schedule/operations/operation%v/ageout", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Schedules[i].Recurring.IsNull() && state.Schedules[i].Recurring.ValueBool() && data.Schedules[j].Recurring.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/schedule/operations/operation%v/recurring", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Schedules[i].StartNow.IsNull() && state.Schedules[i].StartNow.ValueBool() && data.Schedules[j].StartNow.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/schedule/operations/operation%v/start-time/now", predicates))
				}
				if !state.Schedules[i].StartAfterSecond.IsNull() && data.Schedules[j].StartAfterSecond.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/schedule/operations/operation%v/start-time/after/time", predicates))
				}
				if !state.Schedules[i].StartAfterMinute.IsNull() && data.Schedules[j].StartAfterMinute.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/schedule/operations/operation%v/start-time/after/time", predicates))
				}
				if !state.Schedules[i].StartAfterHour.IsNull() && data.Schedules[j].StartAfterHour.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/schedule/operations/operation%v/start-time/after/time", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Schedules[i].StartPending.IsNull() && state.Schedules[i].StartPending.ValueBool() && data.Schedules[j].StartPending.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/schedule/operations/operation%v/start-time/pending", predicates))
				}
				if !state.Schedules[i].StartYear.IsNull() && data.Schedules[j].StartYear.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/schedule/operations/operation%v/start-time/time-and-date", predicates))
				}
				if !state.Schedules[i].StartDayOfMonth.IsNull() && data.Schedules[j].StartDayOfMonth.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/schedule/operations/operation%v/start-time/time-and-date", predicates))
				}
				if !state.Schedules[i].StartMonth.IsNull() && data.Schedules[j].StartMonth.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/schedule/operations/operation%v/start-time/time-and-date", predicates))
				}
				if !state.Schedules[i].StartSecond.IsNull() && data.Schedules[j].StartSecond.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/schedule/operations/operation%v/start-time/time-and-date", predicates))
				}
				if !state.Schedules[i].StartMinute.IsNull() && data.Schedules[j].StartMinute.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/schedule/operations/operation%v/start-time/time-and-date", predicates))
				}
				if !state.Schedules[i].StartHour.IsNull() && data.Schedules[j].StartHour.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/schedule/operations/operation%v/start-time/time-and-date", predicates))
				}
				if !state.Schedules[i].LifeTime.IsNull() && data.Schedules[j].LifeTime.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/schedule/operations/operation%v/life/length-of-time", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Schedules[i].LifeForever.IsNull() && state.Schedules[i].LifeForever.ValueBool() && data.Schedules[j].LifeForever.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/schedule/operations/operation%v/life/forever", predicates))
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/schedule/operations/operation%v", predicates))
		}
	}
	for i := range state.Operations {
		stateKeys := [...]string{"operation-number"}
		stateKeyValues := [...]string{strconv.FormatInt(state.Operations[i].OperationNumber.ValueInt64(), 10)}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.Operations[i].OperationNumber.ValueInt64()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Operations {
			found = true
			if state.Operations[i].OperationNumber.ValueInt64() != data.Operations[j].OperationNumber.ValueInt64() {
				found = false
			}
			if found {
				if !state.Operations[i].MplsLspTraceStatisticsHourlyDistributionInterval.IsNull() && data.Operations[j].MplsLspTraceStatisticsHourlyDistributionInterval.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/trace/statistics/hourly/distribution/interval", predicates))
				}
				if !state.Operations[i].MplsLspTraceStatisticsHourlyDistributionCount.IsNull() && data.Operations[j].MplsLspTraceStatisticsHourlyDistributionCount.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/trace/statistics/hourly/distribution/count", predicates))
				}
				if !state.Operations[i].MplsLspTraceStatisticsHourlyBuckets.IsNull() && data.Operations[j].MplsLspTraceStatisticsHourlyBuckets.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/trace/statistics/hourly/buckets", predicates))
				}
				if !state.Operations[i].MplsLspTraceTargetPseudowireVcId.IsNull() && data.Operations[j].MplsLspTraceTargetPseudowireVcId.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/trace/target/pseudowire", predicates))
				}
				if !state.Operations[i].MplsLspTraceTargetPseudowireAddress.IsNull() && data.Operations[j].MplsLspTraceTargetPseudowireAddress.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/trace/target/pseudowire", predicates))
				}
				if !state.Operations[i].MplsLspTraceTargetTeTunnel.IsNull() && data.Operations[j].MplsLspTraceTargetTeTunnel.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/trace/target/traffic-eng/tunnel", predicates))
				}
				if !state.Operations[i].MplsLspTraceTargetIpv4Mask.IsNull() && data.Operations[j].MplsLspTraceTargetIpv4Mask.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/trace/target/ipv4", predicates))
				}
				if !state.Operations[i].MplsLspTraceTargetIpv4.IsNull() && data.Operations[j].MplsLspTraceTargetIpv4.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/trace/target/ipv4", predicates))
				}
				if !state.Operations[i].MplsLspTraceSourceIpv4.IsNull() && data.Operations[j].MplsLspTraceSourceIpv4.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/trace/source/address/ipv4-address", predicates))
				}
				if !state.Operations[i].MplsLspTraceTimeout.IsNull() && data.Operations[j].MplsLspTraceTimeout.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/trace/timeout", predicates))
				}
				if !state.Operations[i].MplsLspTraceFrequency.IsNull() && data.Operations[j].MplsLspTraceFrequency.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/trace/frequency", predicates))
				}
				if !state.Operations[i].MplsLspTraceTag.IsNull() && data.Operations[j].MplsLspTraceTag.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/trace/tag", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Operations[i].MplsLspTrace.IsNull() && state.Operations[i].MplsLspTrace.ValueBool() && data.Operations[j].MplsLspTrace.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/trace", predicates))
				}
				for ci := range state.Operations[i].MplsLspPingStatisticsIntervals {
					cstateKeys := [...]string{"interval-time"}
					cstateKeyValues := [...]string{strconv.FormatInt(state.Operations[i].MplsLspPingStatisticsIntervals[ci].Interval.ValueInt64(), 10)}
					cpredicates := ""
					for i := range cstateKeys {
						cpredicates += fmt.Sprintf("[%s='%s']", cstateKeys[i], cstateKeyValues[i])
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.Operations[i].MplsLspPingStatisticsIntervals[ci].Interval.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.Operations[j].MplsLspPingStatisticsIntervals {
						found = true
						if state.Operations[i].MplsLspPingStatisticsIntervals[ci].Interval.ValueInt64() != data.Operations[j].MplsLspPingStatisticsIntervals[cj].Interval.ValueInt64() {
							found = false
						}
						if found {
							if !state.Operations[i].MplsLspPingStatisticsIntervals[ci].Buckets.IsNull() && data.Operations[j].MplsLspPingStatisticsIntervals[cj].Buckets.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/ping/statistics/intervals/interval%v/buckets", predicates, cpredicates))
							}
							break
						}
					}
					if !found {
						deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/ping/statistics/intervals/interval%v", predicates, cpredicates))
					}
				}
				if !state.Operations[i].MplsLspPingStatisticsHourlyDistributionInterval.IsNull() && data.Operations[j].MplsLspPingStatisticsHourlyDistributionInterval.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/ping/statistics/hourly/distribution/interval", predicates))
				}
				if !state.Operations[i].MplsLspPingStatisticsHourlyDistributionCount.IsNull() && data.Operations[j].MplsLspPingStatisticsHourlyDistributionCount.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/ping/statistics/hourly/distribution/count", predicates))
				}
				if !state.Operations[i].MplsLspPingStatisticsHourlyBuckets.IsNull() && data.Operations[j].MplsLspPingStatisticsHourlyBuckets.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/ping/statistics/hourly/buckets", predicates))
				}
				if !state.Operations[i].MplsLspPingTargetPseudowireVcId.IsNull() && data.Operations[j].MplsLspPingTargetPseudowireVcId.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/ping/target/pseudowire", predicates))
				}
				if !state.Operations[i].MplsLspPingTargetPseudowireAddress.IsNull() && data.Operations[j].MplsLspPingTargetPseudowireAddress.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/ping/target/pseudowire", predicates))
				}
				if !state.Operations[i].MplsLspPingTargetTeTunnel.IsNull() && data.Operations[j].MplsLspPingTargetTeTunnel.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/ping/target/traffic-eng/tunnel", predicates))
				}
				if !state.Operations[i].MplsLspPingTargetIpv4Mask.IsNull() && data.Operations[j].MplsLspPingTargetIpv4Mask.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/ping/target/ipv4", predicates))
				}
				if !state.Operations[i].MplsLspPingTargetIpv4.IsNull() && data.Operations[j].MplsLspPingTargetIpv4.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/ping/target/ipv4", predicates))
				}
				if !state.Operations[i].MplsLspPingSourceIpv4.IsNull() && data.Operations[j].MplsLspPingSourceIpv4.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/ping/source/address/ipv4-address", predicates))
				}
				if !state.Operations[i].MplsLspPingTimeout.IsNull() && data.Operations[j].MplsLspPingTimeout.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/ping/timeout", predicates))
				}
				if !state.Operations[i].MplsLspPingDatasizeRequest.IsNull() && data.Operations[j].MplsLspPingDatasizeRequest.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/ping/datasize/request/enter-request-datasize-in-byte", predicates))
				}
				if !state.Operations[i].MplsLspPingFrequency.IsNull() && data.Operations[j].MplsLspPingFrequency.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/ping/frequency", predicates))
				}
				if !state.Operations[i].MplsLspPingTag.IsNull() && data.Operations[j].MplsLspPingTag.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/ping/tag", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Operations[i].MplsLspPing.IsNull() && state.Operations[i].MplsLspPing.ValueBool() && data.Operations[j].MplsLspPing.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/mpls/lsp/ping", predicates))
				}
				for ci := range state.Operations[i].UdpJitterStatisticsIntervals {
					cstateKeys := [...]string{"interval-time"}
					cstateKeyValues := [...]string{strconv.FormatInt(state.Operations[i].UdpJitterStatisticsIntervals[ci].Interval.ValueInt64(), 10)}
					cpredicates := ""
					for i := range cstateKeys {
						cpredicates += fmt.Sprintf("[%s='%s']", cstateKeys[i], cstateKeyValues[i])
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.Operations[i].UdpJitterStatisticsIntervals[ci].Interval.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.Operations[j].UdpJitterStatisticsIntervals {
						found = true
						if state.Operations[i].UdpJitterStatisticsIntervals[ci].Interval.ValueInt64() != data.Operations[j].UdpJitterStatisticsIntervals[cj].Interval.ValueInt64() {
							found = false
						}
						if found {
							if !state.Operations[i].UdpJitterStatisticsIntervals[ci].Buckets.IsNull() && data.Operations[j].UdpJitterStatisticsIntervals[cj].Buckets.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/jitter/statistics/intervals/interval%v/buckets", predicates, cpredicates))
							}
							break
						}
					}
					if !found {
						deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/jitter/statistics/intervals/interval%v", predicates, cpredicates))
					}
				}
				if !state.Operations[i].UdpJitterStatisticsHourlyDistributionInterval.IsNull() && data.Operations[j].UdpJitterStatisticsHourlyDistributionInterval.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/jitter/statistics/hourly/distribution/interval", predicates))
				}
				if !state.Operations[i].UdpJitterStatisticsHourlyDistributionCount.IsNull() && data.Operations[j].UdpJitterStatisticsHourlyDistributionCount.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/jitter/statistics/hourly/distribution/count", predicates))
				}
				if !state.Operations[i].UdpJitterStatisticsHourlyBuckets.IsNull() && data.Operations[j].UdpJitterStatisticsHourlyBuckets.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/jitter/statistics/hourly/buckets", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Operations[i].UdpJitterVerifyData.IsNull() && state.Operations[i].UdpJitterVerifyData.ValueBool() && data.Operations[j].UdpJitterVerifyData.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/jitter/verify-data", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Operations[i].UdpJitterControlDisable.IsNull() && state.Operations[i].UdpJitterControlDisable.ValueBool() && data.Operations[j].UdpJitterControlDisable.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/jitter/control/disable", predicates))
				}
				if !state.Operations[i].UdpJitterVrf.IsNull() && data.Operations[j].UdpJitterVrf.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/jitter/vrf", predicates))
				}
				if !state.Operations[i].UdpJitterTos.IsNull() && data.Operations[j].UdpJitterTos.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/jitter/tos", predicates))
				}
				if !state.Operations[i].UdpJitterPacketInterval.IsNull() && data.Operations[j].UdpJitterPacketInterval.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/jitter/packet/interval", predicates))
				}
				if !state.Operations[i].UdpJitterPacketCount.IsNull() && data.Operations[j].UdpJitterPacketCount.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/jitter/packet/count", predicates))
				}
				if !state.Operations[i].UdpJitterDestinationPort.IsNull() && data.Operations[j].UdpJitterDestinationPort.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/jitter/destination/port", predicates))
				}
				if !state.Operations[i].UdpJitterDestinationIpv4.IsNull() && data.Operations[j].UdpJitterDestinationIpv4.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/jitter/destination/address", predicates))
				}
				if !state.Operations[i].UdpJitterSourcePort.IsNull() && data.Operations[j].UdpJitterSourcePort.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/jitter/source/port", predicates))
				}
				if !state.Operations[i].UdpJitterSourceIpv4.IsNull() && data.Operations[j].UdpJitterSourceIpv4.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/jitter/source/address/ipv4-address", predicates))
				}
				if !state.Operations[i].UdpJitterTimeout.IsNull() && data.Operations[j].UdpJitterTimeout.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/jitter/timeout", predicates))
				}
				if !state.Operations[i].UdpJitterDatasizeRequest.IsNull() && data.Operations[j].UdpJitterDatasizeRequest.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/jitter/datasize/request/enter-request-datasize-in-byte", predicates))
				}
				if !state.Operations[i].UdpJitterFrequency.IsNull() && data.Operations[j].UdpJitterFrequency.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/jitter/frequency", predicates))
				}
				if !state.Operations[i].UdpJitterTag.IsNull() && data.Operations[j].UdpJitterTag.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/jitter/tag", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Operations[i].UdpJitter.IsNull() && state.Operations[i].UdpJitter.ValueBool() && data.Operations[j].UdpJitter.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/jitter", predicates))
				}
				if !state.Operations[i].UdpEchoHistoryLives.IsNull() && data.Operations[j].UdpEchoHistoryLives.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/echo/history/lives", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Operations[i].UdpEchoHistoryFilterFailures.IsNull() && state.Operations[i].UdpEchoHistoryFilterFailures.ValueBool() && data.Operations[j].UdpEchoHistoryFilterFailures.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/echo/history/filter/failures", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Operations[i].UdpEchoHistoryFilterAll.IsNull() && state.Operations[i].UdpEchoHistoryFilterAll.ValueBool() && data.Operations[j].UdpEchoHistoryFilterAll.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/echo/history/filter/all", predicates))
				}
				if !state.Operations[i].UdpEchoHistoryBuckets.IsNull() && data.Operations[j].UdpEchoHistoryBuckets.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/echo/history/buckets", predicates))
				}
				for ci := range state.Operations[i].UdpEchoStatisticsIntervals {
					cstateKeys := [...]string{"interval-time"}
					cstateKeyValues := [...]string{strconv.FormatInt(state.Operations[i].UdpEchoStatisticsIntervals[ci].Interval.ValueInt64(), 10)}
					cpredicates := ""
					for i := range cstateKeys {
						cpredicates += fmt.Sprintf("[%s='%s']", cstateKeys[i], cstateKeyValues[i])
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.Operations[i].UdpEchoStatisticsIntervals[ci].Interval.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.Operations[j].UdpEchoStatisticsIntervals {
						found = true
						if state.Operations[i].UdpEchoStatisticsIntervals[ci].Interval.ValueInt64() != data.Operations[j].UdpEchoStatisticsIntervals[cj].Interval.ValueInt64() {
							found = false
						}
						if found {
							if !state.Operations[i].UdpEchoStatisticsIntervals[ci].Buckets.IsNull() && data.Operations[j].UdpEchoStatisticsIntervals[cj].Buckets.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/echo/statistics/intervals/interval%v/buckets", predicates, cpredicates))
							}
							break
						}
					}
					if !found {
						deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/echo/statistics/intervals/interval%v", predicates, cpredicates))
					}
				}
				if !state.Operations[i].UdpEchoStatisticsHourlyDistributionInterval.IsNull() && data.Operations[j].UdpEchoStatisticsHourlyDistributionInterval.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/echo/statistics/hourly/distribution/interval", predicates))
				}
				if !state.Operations[i].UdpEchoStatisticsHourlyDistributionCount.IsNull() && data.Operations[j].UdpEchoStatisticsHourlyDistributionCount.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/echo/statistics/hourly/distribution/count", predicates))
				}
				if !state.Operations[i].UdpEchoStatisticsHourlyBuckets.IsNull() && data.Operations[j].UdpEchoStatisticsHourlyBuckets.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/echo/statistics/hourly/buckets", predicates))
				}
				if !state.Operations[i].UdpEchoVrf.IsNull() && data.Operations[j].UdpEchoVrf.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/echo/vrf", predicates))
				}
				if !state.Operations[i].UdpEchoTos.IsNull() && data.Operations[j].UdpEchoTos.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/echo/tos", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Operations[i].UdpEchoVerifyData.IsNull() && state.Operations[i].UdpEchoVerifyData.ValueBool() && data.Operations[j].UdpEchoVerifyData.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/echo/verify-data", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Operations[i].UdpEchoControlDisable.IsNull() && state.Operations[i].UdpEchoControlDisable.ValueBool() && data.Operations[j].UdpEchoControlDisable.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/echo/control/disable", predicates))
				}
				if !state.Operations[i].UdpEchoDestinationPort.IsNull() && data.Operations[j].UdpEchoDestinationPort.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/echo/destination/port", predicates))
				}
				if !state.Operations[i].UdpEchoDestinationIpv4.IsNull() && data.Operations[j].UdpEchoDestinationIpv4.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/echo/destination/address", predicates))
				}
				if !state.Operations[i].UdpEchoSourcePort.IsNull() && data.Operations[j].UdpEchoSourcePort.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/echo/source/port", predicates))
				}
				if !state.Operations[i].UdpEchoSourceIpv4.IsNull() && data.Operations[j].UdpEchoSourceIpv4.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/echo/source/address/ipv4-address", predicates))
				}
				if !state.Operations[i].UdpEchoTimeout.IsNull() && data.Operations[j].UdpEchoTimeout.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/echo/timeout", predicates))
				}
				if !state.Operations[i].UdpEchoDatasizeRequest.IsNull() && data.Operations[j].UdpEchoDatasizeRequest.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/echo/datasize/request/enter-request-datasize-in-byte", predicates))
				}
				if !state.Operations[i].UdpEchoFrequency.IsNull() && data.Operations[j].UdpEchoFrequency.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/echo/frequency", predicates))
				}
				if !state.Operations[i].UdpEchoTag.IsNull() && data.Operations[j].UdpEchoTag.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/echo/tag", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Operations[i].UdpEcho.IsNull() && state.Operations[i].UdpEcho.ValueBool() && data.Operations[j].UdpEcho.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/udp/echo", predicates))
				}
				if !state.Operations[i].IcmpPathJitterDestinationIpv4.IsNull() && data.Operations[j].IcmpPathJitterDestinationIpv4.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-jitter/destination/address/address", predicates))
				}
				if !state.Operations[i].IcmpPathJitterTos.IsNull() && data.Operations[j].IcmpPathJitterTos.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-jitter/tos", predicates))
				}
				if !state.Operations[i].IcmpPathJitterPacketInterval.IsNull() && data.Operations[j].IcmpPathJitterPacketInterval.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-jitter/packet/interval", predicates))
				}
				if !state.Operations[i].IcmpPathJitterPacketCount.IsNull() && data.Operations[j].IcmpPathJitterPacketCount.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-jitter/packet/count", predicates))
				}
				if !state.Operations[i].IcmpPathJitterSourceIpv4.IsNull() && data.Operations[j].IcmpPathJitterSourceIpv4.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-jitter/source/address/ipv4-address", predicates))
				}
				if !state.Operations[i].IcmpPathJitterTimeout.IsNull() && data.Operations[j].IcmpPathJitterTimeout.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-jitter/timeout", predicates))
				}
				if !state.Operations[i].IcmpPathJitterDatasizeRequest.IsNull() && data.Operations[j].IcmpPathJitterDatasizeRequest.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-jitter/datasize/request/enter-request-datasize-in-byte", predicates))
				}
				if !state.Operations[i].IcmpPathJitterFrequency.IsNull() && data.Operations[j].IcmpPathJitterFrequency.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-jitter/frequency", predicates))
				}
				if !state.Operations[i].IcmpPathJitterTag.IsNull() && data.Operations[j].IcmpPathJitterTag.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-jitter/tag", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Operations[i].IcmpPathJitter.IsNull() && state.Operations[i].IcmpPathJitter.ValueBool() && data.Operations[j].IcmpPathJitter.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-jitter", predicates))
				}
				if !state.Operations[i].IcmpPathEchoStatisticsHourlyMaximumPaths.IsNull() && data.Operations[j].IcmpPathEchoStatisticsHourlyMaximumPaths.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-echo/statistics/hourly/maximum/paths", predicates))
				}
				if !state.Operations[i].IcmpPathEchoStatisticsHourlyMaximumHops.IsNull() && data.Operations[j].IcmpPathEchoStatisticsHourlyMaximumHops.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-echo/statistics/hourly/maximum/hops", predicates))
				}
				if !state.Operations[i].IcmpPathEchoStatisticsHourlyDistributionInterval.IsNull() && data.Operations[j].IcmpPathEchoStatisticsHourlyDistributionInterval.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-echo/statistics/hourly/distribution/interval", predicates))
				}
				if !state.Operations[i].IcmpPathEchoStatisticsHourlyDistributionCount.IsNull() && data.Operations[j].IcmpPathEchoStatisticsHourlyDistributionCount.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-echo/statistics/hourly/distribution/count", predicates))
				}
				if !state.Operations[i].IcmpPathEchoStatisticsHourlyBuckets.IsNull() && data.Operations[j].IcmpPathEchoStatisticsHourlyBuckets.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-echo/statistics/hourly/buckets", predicates))
				}
				if !state.Operations[i].IcmpPathEchoHistorySamples.IsNull() && data.Operations[j].IcmpPathEchoHistorySamples.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-echo/history/samples", predicates))
				}
				if !state.Operations[i].IcmpPathEchoHistoryLives.IsNull() && data.Operations[j].IcmpPathEchoHistoryLives.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-echo/history/lives", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Operations[i].IcmpPathEchoHistoryFilterFailures.IsNull() && state.Operations[i].IcmpPathEchoHistoryFilterFailures.ValueBool() && data.Operations[j].IcmpPathEchoHistoryFilterFailures.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-echo/history/filter/failures", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Operations[i].IcmpPathEchoHistoryFilterAll.IsNull() && state.Operations[i].IcmpPathEchoHistoryFilterAll.ValueBool() && data.Operations[j].IcmpPathEchoHistoryFilterAll.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-echo/history/filter/all", predicates))
				}
				if !state.Operations[i].IcmpPathEchoHistoryBuckets.IsNull() && data.Operations[j].IcmpPathEchoHistoryBuckets.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-echo/history/buckets", predicates))
				}
				if !state.Operations[i].IcmpPathEchoDestinationIpv4.IsNull() && data.Operations[j].IcmpPathEchoDestinationIpv4.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-echo/destination/address/address", predicates))
				}
				if !state.Operations[i].IcmpPathEchoTos.IsNull() && data.Operations[j].IcmpPathEchoTos.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-echo/tos", predicates))
				}
				if !state.Operations[i].IcmpPathEchoSourceIpv4.IsNull() && data.Operations[j].IcmpPathEchoSourceIpv4.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-echo/source/address/ipv4-address", predicates))
				}
				if !state.Operations[i].IcmpPathEchoTimeout.IsNull() && data.Operations[j].IcmpPathEchoTimeout.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-echo/timeout", predicates))
				}
				if !state.Operations[i].IcmpPathEchoDatasizeRequest.IsNull() && data.Operations[j].IcmpPathEchoDatasizeRequest.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-echo/datasize/request/enter-request-datasize-in-byte", predicates))
				}
				if !state.Operations[i].IcmpPathEchoFrequency.IsNull() && data.Operations[j].IcmpPathEchoFrequency.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-echo/frequency", predicates))
				}
				if !state.Operations[i].IcmpPathEchoTag.IsNull() && data.Operations[j].IcmpPathEchoTag.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-echo/tag", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Operations[i].IcmpPathEcho.IsNull() && state.Operations[i].IcmpPathEcho.ValueBool() && data.Operations[j].IcmpPathEcho.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/path-echo", predicates))
				}
				for ci := range state.Operations[i].IcmpEchoStatisticsIntervals {
					cstateKeys := [...]string{"interval-time"}
					cstateKeyValues := [...]string{strconv.FormatInt(state.Operations[i].IcmpEchoStatisticsIntervals[ci].Interval.ValueInt64(), 10)}
					cpredicates := ""
					for i := range cstateKeys {
						cpredicates += fmt.Sprintf("[%s='%s']", cstateKeys[i], cstateKeyValues[i])
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.Operations[i].IcmpEchoStatisticsIntervals[ci].Interval.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.Operations[j].IcmpEchoStatisticsIntervals {
						found = true
						if state.Operations[i].IcmpEchoStatisticsIntervals[ci].Interval.ValueInt64() != data.Operations[j].IcmpEchoStatisticsIntervals[cj].Interval.ValueInt64() {
							found = false
						}
						if found {
							if !state.Operations[i].IcmpEchoStatisticsIntervals[ci].Buckets.IsNull() && data.Operations[j].IcmpEchoStatisticsIntervals[cj].Buckets.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/echo/statistics/intervals/interval%v/buckets", predicates, cpredicates))
							}
							break
						}
					}
					if !found {
						deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/echo/statistics/intervals/interval%v", predicates, cpredicates))
					}
				}
				if !state.Operations[i].IcmpEchoStatisticsHourlyDistributionInterval.IsNull() && data.Operations[j].IcmpEchoStatisticsHourlyDistributionInterval.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/echo/statistics/hourly/distribution/interval", predicates))
				}
				if !state.Operations[i].IcmpEchoStatisticsHourlyDistributionCount.IsNull() && data.Operations[j].IcmpEchoStatisticsHourlyDistributionCount.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/echo/statistics/hourly/distribution/count", predicates))
				}
				if !state.Operations[i].IcmpEchoStatisticsHourlyBuckets.IsNull() && data.Operations[j].IcmpEchoStatisticsHourlyBuckets.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/echo/statistics/hourly/buckets", predicates))
				}
				if !state.Operations[i].IcmpEchoHistoryLives.IsNull() && data.Operations[j].IcmpEchoHistoryLives.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/echo/history/lives", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Operations[i].IcmpEchoHistoryFilterFailures.IsNull() && state.Operations[i].IcmpEchoHistoryFilterFailures.ValueBool() && data.Operations[j].IcmpEchoHistoryFilterFailures.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/echo/history/filter/failures", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Operations[i].IcmpEchoHistoryFilterAll.IsNull() && state.Operations[i].IcmpEchoHistoryFilterAll.ValueBool() && data.Operations[j].IcmpEchoHistoryFilterAll.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/echo/history/filter/all", predicates))
				}
				if !state.Operations[i].IcmpEchoHistoryBuckets.IsNull() && data.Operations[j].IcmpEchoHistoryBuckets.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/echo/history/buckets", predicates))
				}
				if !state.Operations[i].IcmpEchoDestinationIpv6.IsNull() && data.Operations[j].IcmpEchoDestinationIpv6.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/echo/destination/address/ipv6-address", predicates))
				}
				if !state.Operations[i].IcmpEchoDestinationIpv4.IsNull() && data.Operations[j].IcmpEchoDestinationIpv4.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/echo/destination/address/ipv4-address", predicates))
				}
				if !state.Operations[i].IcmpEchoVrf.IsNull() && data.Operations[j].IcmpEchoVrf.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/echo/vrf", predicates))
				}
				if !state.Operations[i].IcmpEchoTos.IsNull() && data.Operations[j].IcmpEchoTos.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/echo/tos", predicates))
				}
				if !state.Operations[i].IcmpEchoSourceIpv6.IsNull() && data.Operations[j].IcmpEchoSourceIpv6.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/echo/source/address/ipv6-address", predicates))
				}
				if !state.Operations[i].IcmpEchoSourceIpv4.IsNull() && data.Operations[j].IcmpEchoSourceIpv4.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/echo/source/address/ipv4-address", predicates))
				}
				if !state.Operations[i].IcmpEchoTimeout.IsNull() && data.Operations[j].IcmpEchoTimeout.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/echo/timeout", predicates))
				}
				if !state.Operations[i].IcmpEchoDatasizeRequest.IsNull() && data.Operations[j].IcmpEchoDatasizeRequest.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/echo/datasize/request/enter-request-datasize-in-byte", predicates))
				}
				if !state.Operations[i].IcmpEchoFrequency.IsNull() && data.Operations[j].IcmpEchoFrequency.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/echo/frequency", predicates))
				}
				if !state.Operations[i].IcmpEchoTag.IsNull() && data.Operations[j].IcmpEchoTag.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/echo/tag", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Operations[i].IcmpEcho.IsNull() && state.Operations[i].IcmpEcho.ValueBool() && data.Operations[j].IcmpEcho.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v/type/icmp/echo", predicates))
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/operations/operation%v", predicates))
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.HwTimestampDisable.IsNull() && state.HwTimestampDisable.ValueBool() && data.HwTimestampDisable.IsNull() {
		deletePath := state.getXPath() + "/hw-timestamp/disable"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.KeyChain.IsNull() && data.KeyChain.IsNull() {
		deletePath := state.getXPath() + "/key-chain"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.LowMemory.IsNull() && data.LowMemory.IsNull() {
		deletePath := state.getXPath() + "/low-memory"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}

	b := netconf.NewBody(deleteXml)
	b = helpers.CleanupRedundantRemoveOperations(b)
	return b.Res()
}

// End of section. //template:end addDeletedItemsXML
// Section below is generated&owned by "gen/generator.go". //template:begin addDeletePathsXML

func (data *IPSLA) addDeletePathsXML(ctx context.Context, body string) string {
	b := netconf.NewBody(body)
	if !data.ServerTwampTimerInactivity.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/server/twamp/timer/inactivity")
	}
	if !data.ServerTwampPort.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/server/twamp/port")
	}
	if !data.ServerTwamp.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/server/twamp")
	}
	for i := range data.Schedules {
		keys := [...]string{"operation-number"}
		keyValues := [...]string{strconv.FormatInt(data.Schedules[i].OperationNumber.ValueInt64(), 10)}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/schedule/operations/operation%v", predicates))
	}
	for i := range data.Operations {
		keys := [...]string{"operation-number"}
		keyValues := [...]string{strconv.FormatInt(data.Operations[i].OperationNumber.ValueInt64(), 10)}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/operations/operation%v", predicates))
	}
	if !data.HwTimestampDisable.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/hw-timestamp/disable")
	}
	if !data.KeyChain.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/key-chain")
	}
	if !data.LowMemory.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/low-memory")
	}

	b = helpers.CleanupRedundantRemoveOperations(b)
	return b.Res()
}

// End of section. //template:end addDeletePathsXML
