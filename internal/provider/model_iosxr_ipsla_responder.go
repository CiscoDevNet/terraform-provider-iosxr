// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports
import (
	"context"
	"fmt"
	"reflect"
	"strconv"
	"strings"

	"github.com/CiscoDevNet/terraform-provider-iosxr/internal/provider/helpers"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/netascode/go-netconf"
	"github.com/netascode/xmldot"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin types
type IPSLAResponder struct {
	Device             types.String                       `tfsdk:"device"`
	Id                 types.String                       `tfsdk:"id"`
	DeleteMode         types.String                       `tfsdk:"delete_mode"`
	TypeUdpIpv4        []IPSLAResponderTypeUdpIpv4        `tfsdk:"type_udp_ipv4"`
	Twamp              types.Bool                         `tfsdk:"twamp"`
	TwampTimeout       types.Int64                        `tfsdk:"twamp_timeout"`
	TwampLightSessions []IPSLAResponderTwampLightSessions `tfsdk:"twamp_light_sessions"`
}

type IPSLAResponderData struct {
	Device             types.String                       `tfsdk:"device"`
	Id                 types.String                       `tfsdk:"id"`
	TypeUdpIpv4        []IPSLAResponderTypeUdpIpv4        `tfsdk:"type_udp_ipv4"`
	Twamp              types.Bool                         `tfsdk:"twamp"`
	TwampTimeout       types.Int64                        `tfsdk:"twamp_timeout"`
	TwampLightSessions []IPSLAResponderTwampLightSessions `tfsdk:"twamp_light_sessions"`
}
type IPSLAResponderTypeUdpIpv4 struct {
	Address types.String                     `tfsdk:"address"`
	Ports   []IPSLAResponderTypeUdpIpv4Ports `tfsdk:"ports"`
}
type IPSLAResponderTwampLightSessions struct {
	SessionId          types.Int64                                          `tfsdk:"session_id"`
	LocalIpv4Addresses []IPSLAResponderTwampLightSessionsLocalIpv4Addresses `tfsdk:"local_ipv4_addresses"`
	LocalIpv6Addresses []IPSLAResponderTwampLightSessionsLocalIpv6Addresses `tfsdk:"local_ipv6_addresses"`
	Authentication     types.Bool                                           `tfsdk:"authentication"`
	Encryption         types.Bool                                           `tfsdk:"encryption"`
	Timeout            types.Int64                                          `tfsdk:"timeout"`
}
type IPSLAResponderTypeUdpIpv4Ports struct {
	PortNumber types.Int64 `tfsdk:"port_number"`
}
type IPSLAResponderTwampLightSessionsLocalIpv4Addresses struct {
	Address             types.String                                                            `tfsdk:"address"`
	LocalPort           types.Int64                                                             `tfsdk:"local_port"`
	RemoteIpv4Addresses []IPSLAResponderTwampLightSessionsLocalIpv4AddressesRemoteIpv4Addresses `tfsdk:"remote_ipv4_addresses"`
}
type IPSLAResponderTwampLightSessionsLocalIpv6Addresses struct {
	Address             types.String                                                            `tfsdk:"address"`
	LocalPort           types.Int64                                                             `tfsdk:"local_port"`
	RemoteIpv6Addresses []IPSLAResponderTwampLightSessionsLocalIpv6AddressesRemoteIpv6Addresses `tfsdk:"remote_ipv6_addresses"`
}
type IPSLAResponderTwampLightSessionsLocalIpv4AddressesRemoteIpv4Addresses struct {
	Address    types.String `tfsdk:"address"`
	RemotePort types.String `tfsdk:"remote_port"`
	Vrf        types.String `tfsdk:"vrf"`
}
type IPSLAResponderTwampLightSessionsLocalIpv6AddressesRemoteIpv6Addresses struct {
	Address    types.String `tfsdk:"address"`
	RemotePort types.String `tfsdk:"remote_port"`
	Vrf        types.String `tfsdk:"vrf"`
}

// End of section. //template:end types

// Section below is generated&owned by "gen/generator.go". //template:begin getPath

func (data IPSLAResponder) getPath() string {
	return "Cisco-IOS-XR-um-ipsla-cfg:/ipsla/responder"
}

func (data IPSLAResponderData) getPath() string {
	return "Cisco-IOS-XR-um-ipsla-cfg:/ipsla/responder"
}

// getXPath returns the XPath for NETCONF operations
func (data IPSLAResponder) getXPath() string {
	path := "Cisco-IOS-XR-um-ipsla-cfg:/ipsla/responder"
	return path
}

func (data IPSLAResponderData) getXPath() string {
	path := "Cisco-IOS-XR-um-ipsla-cfg:/ipsla/responder"
	return path
}

// End of section. //template:end getPath

// Section below is generated&owned by "gen/generator.go". //template:begin toBody

func (data IPSLAResponder) toBody(ctx context.Context) string {
	body := "{}"
	if !data.Twamp.IsNull() && !data.Twamp.IsUnknown() {
		if data.Twamp.ValueBool() {
			body, _ = sjson.Set(body, "twamp", map[string]string{})
		}
	}
	if !data.TwampTimeout.IsNull() && !data.TwampTimeout.IsUnknown() {
		body, _ = sjson.Set(body, "twamp.timeout", strconv.FormatInt(data.TwampTimeout.ValueInt64(), 10))
	}
	if len(data.TypeUdpIpv4) > 0 {
		body, _ = sjson.Set(body, "type.udp.ipv4.address", []interface{}{})
		for index, item := range data.TypeUdpIpv4 {
			if !item.Address.IsNull() && !item.Address.IsUnknown() {
				body, _ = sjson.Set(body, "type.udp.ipv4.address"+"."+strconv.Itoa(index)+"."+"address", item.Address.ValueString())
			}
			if len(item.Ports) > 0 {
				body, _ = sjson.Set(body, "type.udp.ipv4.address"+"."+strconv.Itoa(index)+"."+"port", []interface{}{})
				for cindex, citem := range item.Ports {
					if !citem.PortNumber.IsNull() && !citem.PortNumber.IsUnknown() {
						body, _ = sjson.Set(body, "type.udp.ipv4.address"+"."+strconv.Itoa(index)+"."+"port"+"."+strconv.Itoa(cindex)+"."+"port-number", strconv.FormatInt(citem.PortNumber.ValueInt64(), 10))
					}
				}
			}
		}
	}
	if len(data.TwampLightSessions) > 0 {
		body, _ = sjson.Set(body, "twamp-light.test-session.session", []interface{}{})
		for index, item := range data.TwampLightSessions {
			if !item.SessionId.IsNull() && !item.SessionId.IsUnknown() {
				body, _ = sjson.Set(body, "twamp-light.test-session.session"+"."+strconv.Itoa(index)+"."+"session-id", strconv.FormatInt(item.SessionId.ValueInt64(), 10))
			}
			if !item.Authentication.IsNull() && !item.Authentication.IsUnknown() {
				if item.Authentication.ValueBool() {
					body, _ = sjson.Set(body, "twamp-light.test-session.session"+"."+strconv.Itoa(index)+"."+"authentication", map[string]string{})
				}
			}
			if !item.Encryption.IsNull() && !item.Encryption.IsUnknown() {
				if item.Encryption.ValueBool() {
					body, _ = sjson.Set(body, "twamp-light.test-session.session"+"."+strconv.Itoa(index)+"."+"encryption", map[string]string{})
				}
			}
			if !item.Timeout.IsNull() && !item.Timeout.IsUnknown() {
				body, _ = sjson.Set(body, "twamp-light.test-session.session"+"."+strconv.Itoa(index)+"."+"timeout", strconv.FormatInt(item.Timeout.ValueInt64(), 10))
			}
			if len(item.LocalIpv4Addresses) > 0 {
				body, _ = sjson.Set(body, "twamp-light.test-session.session"+"."+strconv.Itoa(index)+"."+"local-ip.ipv4-addresses.ipv4-address", []interface{}{})
				for cindex, citem := range item.LocalIpv4Addresses {
					if !citem.Address.IsNull() && !citem.Address.IsUnknown() {
						body, _ = sjson.Set(body, "twamp-light.test-session.session"+"."+strconv.Itoa(index)+"."+"local-ip.ipv4-addresses.ipv4-address"+"."+strconv.Itoa(cindex)+"."+"address", citem.Address.ValueString())
					}
					if !citem.LocalPort.IsNull() && !citem.LocalPort.IsUnknown() {
						body, _ = sjson.Set(body, "twamp-light.test-session.session"+"."+strconv.Itoa(index)+"."+"local-ip.ipv4-addresses.ipv4-address"+"."+strconv.Itoa(cindex)+"."+"local-port", strconv.FormatInt(citem.LocalPort.ValueInt64(), 10))
					}
					if len(citem.RemoteIpv4Addresses) > 0 {
						body, _ = sjson.Set(body, "twamp-light.test-session.session"+"."+strconv.Itoa(index)+"."+"local-ip.ipv4-addresses.ipv4-address"+"."+strconv.Itoa(cindex)+"."+"remote-ip.ipv4-addresses.ipv4-address", []interface{}{})
						for ccindex, ccitem := range citem.RemoteIpv4Addresses {
							if !ccitem.Address.IsNull() && !ccitem.Address.IsUnknown() {
								body, _ = sjson.Set(body, "twamp-light.test-session.session"+"."+strconv.Itoa(index)+"."+"local-ip.ipv4-addresses.ipv4-address"+"."+strconv.Itoa(cindex)+"."+"remote-ip.ipv4-addresses.ipv4-address"+"."+strconv.Itoa(ccindex)+"."+"address", ccitem.Address.ValueString())
							}
							if !ccitem.RemotePort.IsNull() && !ccitem.RemotePort.IsUnknown() {
								body, _ = sjson.Set(body, "twamp-light.test-session.session"+"."+strconv.Itoa(index)+"."+"local-ip.ipv4-addresses.ipv4-address"+"."+strconv.Itoa(cindex)+"."+"remote-ip.ipv4-addresses.ipv4-address"+"."+strconv.Itoa(ccindex)+"."+"remote-port", ccitem.RemotePort.ValueString())
							}
							if !ccitem.Vrf.IsNull() && !ccitem.Vrf.IsUnknown() {
								body, _ = sjson.Set(body, "twamp-light.test-session.session"+"."+strconv.Itoa(index)+"."+"local-ip.ipv4-addresses.ipv4-address"+"."+strconv.Itoa(cindex)+"."+"remote-ip.ipv4-addresses.ipv4-address"+"."+strconv.Itoa(ccindex)+"."+"vrf", ccitem.Vrf.ValueString())
							}
						}
					}
				}
			}
			if len(item.LocalIpv6Addresses) > 0 {
				body, _ = sjson.Set(body, "twamp-light.test-session.session"+"."+strconv.Itoa(index)+"."+"local-ip.ipv6-addresses.ipv6-address", []interface{}{})
				for cindex, citem := range item.LocalIpv6Addresses {
					if !citem.Address.IsNull() && !citem.Address.IsUnknown() {
						body, _ = sjson.Set(body, "twamp-light.test-session.session"+"."+strconv.Itoa(index)+"."+"local-ip.ipv6-addresses.ipv6-address"+"."+strconv.Itoa(cindex)+"."+"address", citem.Address.ValueString())
					}
					if !citem.LocalPort.IsNull() && !citem.LocalPort.IsUnknown() {
						body, _ = sjson.Set(body, "twamp-light.test-session.session"+"."+strconv.Itoa(index)+"."+"local-ip.ipv6-addresses.ipv6-address"+"."+strconv.Itoa(cindex)+"."+"local-port", strconv.FormatInt(citem.LocalPort.ValueInt64(), 10))
					}
					if len(citem.RemoteIpv6Addresses) > 0 {
						body, _ = sjson.Set(body, "twamp-light.test-session.session"+"."+strconv.Itoa(index)+"."+"local-ip.ipv6-addresses.ipv6-address"+"."+strconv.Itoa(cindex)+"."+"remote-ip.ipv6-addresses.ipv6-address", []interface{}{})
						for ccindex, ccitem := range citem.RemoteIpv6Addresses {
							if !ccitem.Address.IsNull() && !ccitem.Address.IsUnknown() {
								body, _ = sjson.Set(body, "twamp-light.test-session.session"+"."+strconv.Itoa(index)+"."+"local-ip.ipv6-addresses.ipv6-address"+"."+strconv.Itoa(cindex)+"."+"remote-ip.ipv6-addresses.ipv6-address"+"."+strconv.Itoa(ccindex)+"."+"address", ccitem.Address.ValueString())
							}
							if !ccitem.RemotePort.IsNull() && !ccitem.RemotePort.IsUnknown() {
								body, _ = sjson.Set(body, "twamp-light.test-session.session"+"."+strconv.Itoa(index)+"."+"local-ip.ipv6-addresses.ipv6-address"+"."+strconv.Itoa(cindex)+"."+"remote-ip.ipv6-addresses.ipv6-address"+"."+strconv.Itoa(ccindex)+"."+"remote-port", ccitem.RemotePort.ValueString())
							}
							if !ccitem.Vrf.IsNull() && !ccitem.Vrf.IsUnknown() {
								body, _ = sjson.Set(body, "twamp-light.test-session.session"+"."+strconv.Itoa(index)+"."+"local-ip.ipv6-addresses.ipv6-address"+"."+strconv.Itoa(cindex)+"."+"remote-ip.ipv6-addresses.ipv6-address"+"."+strconv.Itoa(ccindex)+"."+"vrf", ccitem.Vrf.ValueString())
							}
						}
					}
				}
			}
		}
	}
	return body
}

// End of section. //template:end toBody

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBody

func (data *IPSLAResponder) updateFromBody(ctx context.Context, res []byte) {
	for i := range data.TypeUdpIpv4 {
		keys := [...]string{"address"}
		keyValues := [...]string{data.TypeUdpIpv4[i].Address.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "type.udp.ipv4.address").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("address"); value.Exists() && !data.TypeUdpIpv4[i].Address.IsNull() {
			data.TypeUdpIpv4[i].Address = types.StringValue(value.String())
		} else {
			data.TypeUdpIpv4[i].Address = types.StringNull()
		}
		for ci := range data.TypeUdpIpv4[i].Ports {
			keys := [...]string{"port-number"}
			keyValues := [...]string{strconv.FormatInt(data.TypeUdpIpv4[i].Ports[ci].PortNumber.ValueInt64(), 10)}

			var cr gjson.Result
			r.Get("port").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("port-number"); value.Exists() {
				data.TypeUdpIpv4[i].Ports[ci].PortNumber = types.Int64Value(value.Int())
			} else if data.TypeUdpIpv4[i].Ports[ci].PortNumber.IsNull() {
				data.TypeUdpIpv4[i].Ports[ci].PortNumber = types.Int64Null()
			}
		}
	}
	if value := gjson.GetBytes(res, "twamp"); value.Exists() {
		if !data.Twamp.IsNull() {
			data.Twamp = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.Twamp.IsNull() {
			data.Twamp = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "twamp.timeout"); value.Exists() && !data.TwampTimeout.IsNull() {
		data.TwampTimeout = types.Int64Value(value.Int())
	} else {
		data.TwampTimeout = types.Int64Null()
	}
	for i := range data.TwampLightSessions {
		keys := [...]string{"session-id"}
		keyValues := [...]string{strconv.FormatInt(data.TwampLightSessions[i].SessionId.ValueInt64(), 10)}

		var r gjson.Result
		gjson.GetBytes(res, "twamp-light.test-session.session").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("session-id"); value.Exists() && !data.TwampLightSessions[i].SessionId.IsNull() {
			data.TwampLightSessions[i].SessionId = types.Int64Value(value.Int())
		} else {
			data.TwampLightSessions[i].SessionId = types.Int64Null()
		}
		for ci := range data.TwampLightSessions[i].LocalIpv4Addresses {
			keys := [...]string{"address", "local-port"}
			keyValues := [...]string{data.TwampLightSessions[i].LocalIpv4Addresses[ci].Address.ValueString(), strconv.FormatInt(data.TwampLightSessions[i].LocalIpv4Addresses[ci].LocalPort.ValueInt64(), 10)}

			var cr gjson.Result
			r.Get("local-ip.ipv4-addresses.ipv4-address").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("address"); value.Exists() && !data.TwampLightSessions[i].LocalIpv4Addresses[ci].Address.IsNull() {
				data.TwampLightSessions[i].LocalIpv4Addresses[ci].Address = types.StringValue(value.String())
			} else {
				data.TwampLightSessions[i].LocalIpv4Addresses[ci].Address = types.StringNull()
			}
			if value := cr.Get("local-port"); value.Exists() {
				data.TwampLightSessions[i].LocalIpv4Addresses[ci].LocalPort = types.Int64Value(value.Int())
			} else if data.TwampLightSessions[i].LocalIpv4Addresses[ci].LocalPort.IsNull() {
				data.TwampLightSessions[i].LocalIpv4Addresses[ci].LocalPort = types.Int64Null()
			}
			for cci := range data.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses {
				keys := [...]string{"address", "remote-port", "vrf"}
				keyValues := [...]string{data.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].Address.ValueString(), data.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].RemotePort.ValueString(), data.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].Vrf.ValueString()}

				var ccr gjson.Result
				cr.Get("remote-ip.ipv4-addresses.ipv4-address").ForEach(
					func(_, v gjson.Result) bool {
						found := false
						for ik := range keys {
							if v.Get(keys[ik]).String() == keyValues[ik] {
								found = true
								continue
							}
							found = false
							break
						}
						if found {
							ccr = v
							return false
						}
						return true
					},
				)
				if value := ccr.Get("address"); value.Exists() && !data.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].Address.IsNull() {
					data.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].Address = types.StringValue(value.String())
				} else {
					data.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].Address = types.StringNull()
				}
				if value := ccr.Get("remote-port"); value.Exists() && !data.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].RemotePort.IsNull() {
					data.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].RemotePort = types.StringValue(value.String())
				} else {
					data.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].RemotePort = types.StringNull()
				}
				if value := ccr.Get("vrf"); value.Exists() && !data.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].Vrf.IsNull() {
					data.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].Vrf = types.StringValue(value.String())
				} else {
					data.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].Vrf = types.StringNull()
				}
			}
		}
		for ci := range data.TwampLightSessions[i].LocalIpv6Addresses {
			keys := [...]string{"address", "local-port"}
			keyValues := [...]string{data.TwampLightSessions[i].LocalIpv6Addresses[ci].Address.ValueString(), strconv.FormatInt(data.TwampLightSessions[i].LocalIpv6Addresses[ci].LocalPort.ValueInt64(), 10)}

			var cr gjson.Result
			r.Get("local-ip.ipv6-addresses.ipv6-address").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("address"); value.Exists() && !data.TwampLightSessions[i].LocalIpv6Addresses[ci].Address.IsNull() {
				data.TwampLightSessions[i].LocalIpv6Addresses[ci].Address = types.StringValue(value.String())
			} else {
				data.TwampLightSessions[i].LocalIpv6Addresses[ci].Address = types.StringNull()
			}
			if value := cr.Get("local-port"); value.Exists() {
				data.TwampLightSessions[i].LocalIpv6Addresses[ci].LocalPort = types.Int64Value(value.Int())
			} else if data.TwampLightSessions[i].LocalIpv6Addresses[ci].LocalPort.IsNull() {
				data.TwampLightSessions[i].LocalIpv6Addresses[ci].LocalPort = types.Int64Null()
			}
			for cci := range data.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses {
				keys := [...]string{"address", "remote-port", "vrf"}
				keyValues := [...]string{data.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].Address.ValueString(), data.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].RemotePort.ValueString(), data.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].Vrf.ValueString()}

				var ccr gjson.Result
				cr.Get("remote-ip.ipv6-addresses.ipv6-address").ForEach(
					func(_, v gjson.Result) bool {
						found := false
						for ik := range keys {
							if v.Get(keys[ik]).String() == keyValues[ik] {
								found = true
								continue
							}
							found = false
							break
						}
						if found {
							ccr = v
							return false
						}
						return true
					},
				)
				if value := ccr.Get("address"); value.Exists() && !data.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].Address.IsNull() {
					data.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].Address = types.StringValue(value.String())
				} else {
					data.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].Address = types.StringNull()
				}
				if value := ccr.Get("remote-port"); value.Exists() && !data.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].RemotePort.IsNull() {
					data.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].RemotePort = types.StringValue(value.String())
				} else {
					data.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].RemotePort = types.StringNull()
				}
				if value := ccr.Get("vrf"); value.Exists() && !data.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].Vrf.IsNull() {
					data.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].Vrf = types.StringValue(value.String())
				} else {
					data.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].Vrf = types.StringNull()
				}
			}
		}
		if value := r.Get("authentication"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.TwampLightSessions[i].Authentication.IsNull() && !data.TwampLightSessions[i].Authentication.ValueBool() {
				// Keep false value from state even though element exists on device
				data.TwampLightSessions[i].Authentication = types.BoolValue(false)
			} else if !data.TwampLightSessions[i].Authentication.IsNull() {
				data.TwampLightSessions[i].Authentication = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.TwampLightSessions[i].Authentication.IsNull() {
				data.TwampLightSessions[i].Authentication = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.TwampLightSessions[i].Authentication = types.BoolValue(false)
			}
		}
		if value := r.Get("encryption"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.TwampLightSessions[i].Encryption.IsNull() && !data.TwampLightSessions[i].Encryption.ValueBool() {
				// Keep false value from state even though element exists on device
				data.TwampLightSessions[i].Encryption = types.BoolValue(false)
			} else if !data.TwampLightSessions[i].Encryption.IsNull() {
				data.TwampLightSessions[i].Encryption = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.TwampLightSessions[i].Encryption.IsNull() {
				data.TwampLightSessions[i].Encryption = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.TwampLightSessions[i].Encryption = types.BoolValue(false)
			}
		}
		if value := r.Get("timeout"); value.Exists() && !data.TwampLightSessions[i].Timeout.IsNull() {
			data.TwampLightSessions[i].Timeout = types.Int64Value(value.Int())
		} else {
			data.TwampLightSessions[i].Timeout = types.Int64Null()
		}
	}
}

// End of section. //template:end updateFromBody
// Section below is generated&owned by "gen/generator.go". //template:begin toBodyXML

func (data IPSLAResponder) toBodyXML(ctx context.Context) string {
	body := netconf.Body{}
	if len(data.TypeUdpIpv4) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.TypeUdpIpv4 {
			cBody := netconf.Body{}
			if !item.Address.IsNull() && !item.Address.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "address", item.Address.ValueString())
			}
			if len(item.Ports) > 0 {
				for _, citem := range item.Ports {
					ccBody := netconf.Body{}
					_ = citem // Suppress unused variable warning when all attributes are IDs
					cBody = helpers.SetRawFromXPath(cBody, "port", ccBody.Res())
				}
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"type/udp/ipv4/address", cBody.Res())
		}
	}
	if !data.Twamp.IsNull() && !data.Twamp.IsUnknown() {
		if data.Twamp.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/twamp", "")
		}
	}
	if !data.TwampTimeout.IsNull() && !data.TwampTimeout.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/twamp/timeout", strconv.FormatInt(data.TwampTimeout.ValueInt64(), 10))
	}
	if len(data.TwampLightSessions) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.TwampLightSessions {
			cBody := netconf.Body{}
			if !item.SessionId.IsNull() && !item.SessionId.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "session-id", strconv.FormatInt(item.SessionId.ValueInt64(), 10))
			}
			if len(item.LocalIpv4Addresses) > 0 {
				for _, citem := range item.LocalIpv4Addresses {
					ccBody := netconf.Body{}
					_ = citem // Suppress unused variable warning when all attributes are IDs
					if len(citem.RemoteIpv4Addresses) > 0 {
						for _, ccitem := range citem.RemoteIpv4Addresses {
							cccBody := netconf.Body{}
							_ = ccitem // Suppress unused variable warning
							ccBody = helpers.AppendRawFromXPath(ccBody, "remote-ip/ipv4-addresses/ipv4-address", cccBody.Res())
						}
					}
					cBody = helpers.SetRawFromXPath(cBody, "local-ip/ipv4-addresses/ipv4-address", ccBody.Res())
				}
			}
			if len(item.LocalIpv6Addresses) > 0 {
				for _, citem := range item.LocalIpv6Addresses {
					ccBody := netconf.Body{}
					_ = citem // Suppress unused variable warning when all attributes are IDs
					if len(citem.RemoteIpv6Addresses) > 0 {
						for _, ccitem := range citem.RemoteIpv6Addresses {
							cccBody := netconf.Body{}
							_ = ccitem // Suppress unused variable warning
							ccBody = helpers.AppendRawFromXPath(ccBody, "remote-ip/ipv6-addresses/ipv6-address", cccBody.Res())
						}
					}
					cBody = helpers.SetRawFromXPath(cBody, "local-ip/ipv6-addresses/ipv6-address", ccBody.Res())
				}
			}
			if !item.Authentication.IsNull() && !item.Authentication.IsUnknown() {
				if item.Authentication.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "authentication", "")
				}
			}
			if !item.Encryption.IsNull() && !item.Encryption.IsUnknown() {
				if item.Encryption.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "encryption", "")
				}
			}
			if !item.Timeout.IsNull() && !item.Timeout.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "timeout", strconv.FormatInt(item.Timeout.ValueInt64(), 10))
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"twamp-light/test-session/session", cBody.Res())
		}
	}
	bodyString, err := body.String()
	if err != nil {
		tflog.Error(ctx, fmt.Sprintf("Error converting body to string: %s", err))
	}
	return bodyString
}

// End of section. //template:end toBodyXML
// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBodyXML

func (data *IPSLAResponder) updateFromBodyXML(ctx context.Context, res xmldot.Result) {
	for i := range data.TypeUdpIpv4 {
		keys := [...]string{"address"}
		keyValues := [...]string{data.TypeUdpIpv4[i].Address.ValueString()}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/type/udp/ipv4/address").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "address"); value.Exists() {
			data.TypeUdpIpv4[i].Address = types.StringValue(value.String())
		} else if data.TypeUdpIpv4[i].Address.IsNull() {
			data.TypeUdpIpv4[i].Address = types.StringNull()
		}
		for ci := range data.TypeUdpIpv4[i].Ports {
			keys := [...]string{"port-number"}
			keyValues := [...]string{strconv.FormatInt(data.TypeUdpIpv4[i].Ports[ci].PortNumber.ValueInt64(), 10)}

			var cr xmldot.Result
			helpers.GetFromXPath(r, "port").ForEach(
				func(_ int, v xmldot.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := helpers.GetFromXPath(cr, "port-number"); value.Exists() {
				data.TypeUdpIpv4[i].Ports[ci].PortNumber = types.Int64Value(value.Int())
			} else {
				data.TypeUdpIpv4[i].Ports[ci].PortNumber = types.Int64Null()
			}
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/twamp"); value.Exists() {
		data.Twamp = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.Twamp.IsNull() {
			data.Twamp = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/twamp/timeout"); value.Exists() {
		data.TwampTimeout = types.Int64Value(value.Int())
	} else if data.TwampTimeout.IsNull() {
		data.TwampTimeout = types.Int64Null()
	}
	for i := range data.TwampLightSessions {
		keys := [...]string{"session-id"}
		keyValues := [...]string{strconv.FormatInt(data.TwampLightSessions[i].SessionId.ValueInt64(), 10)}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/twamp-light/test-session/session").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "session-id"); value.Exists() {
			data.TwampLightSessions[i].SessionId = types.Int64Value(value.Int())
		} else if data.TwampLightSessions[i].SessionId.IsNull() {
			data.TwampLightSessions[i].SessionId = types.Int64Null()
		}
		for ci := range data.TwampLightSessions[i].LocalIpv4Addresses {
			keys := [...]string{"address", "local-port"}
			keyValues := [...]string{data.TwampLightSessions[i].LocalIpv4Addresses[ci].Address.ValueString(), strconv.FormatInt(data.TwampLightSessions[i].LocalIpv4Addresses[ci].LocalPort.ValueInt64(), 10)}

			var cr xmldot.Result
			helpers.GetFromXPath(r, "local-ip/ipv4-addresses/ipv4-address").ForEach(
				func(_ int, v xmldot.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := helpers.GetFromXPath(cr, "address"); value.Exists() {
				data.TwampLightSessions[i].LocalIpv4Addresses[ci].Address = types.StringValue(value.String())
			} else {
				data.TwampLightSessions[i].LocalIpv4Addresses[ci].Address = types.StringNull()
			}
			if value := helpers.GetFromXPath(cr, "local-port"); value.Exists() {
				data.TwampLightSessions[i].LocalIpv4Addresses[ci].LocalPort = types.Int64Value(value.Int())
			} else {
				data.TwampLightSessions[i].LocalIpv4Addresses[ci].LocalPort = types.Int64Null()
			}
		}
		for ci := range data.TwampLightSessions[i].LocalIpv6Addresses {
			keys := [...]string{"address", "local-port"}
			keyValues := [...]string{data.TwampLightSessions[i].LocalIpv6Addresses[ci].Address.ValueString(), strconv.FormatInt(data.TwampLightSessions[i].LocalIpv6Addresses[ci].LocalPort.ValueInt64(), 10)}

			var cr xmldot.Result
			helpers.GetFromXPath(r, "local-ip/ipv6-addresses/ipv6-address").ForEach(
				func(_ int, v xmldot.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := helpers.GetFromXPath(cr, "address"); value.Exists() {
				data.TwampLightSessions[i].LocalIpv6Addresses[ci].Address = types.StringValue(value.String())
			} else {
				data.TwampLightSessions[i].LocalIpv6Addresses[ci].Address = types.StringNull()
			}
			if value := helpers.GetFromXPath(cr, "local-port"); value.Exists() {
				data.TwampLightSessions[i].LocalIpv6Addresses[ci].LocalPort = types.Int64Value(value.Int())
			} else {
				data.TwampLightSessions[i].LocalIpv6Addresses[ci].LocalPort = types.Int64Null()
			}
		}
		if value := helpers.GetFromXPath(r, "authentication"); value.Exists() {
			data.TwampLightSessions[i].Authentication = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.TwampLightSessions[i].Authentication.IsNull() {
				data.TwampLightSessions[i].Authentication = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "encryption"); value.Exists() {
			data.TwampLightSessions[i].Encryption = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.TwampLightSessions[i].Encryption.IsNull() {
				data.TwampLightSessions[i].Encryption = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "timeout"); value.Exists() {
			data.TwampLightSessions[i].Timeout = types.Int64Value(value.Int())
		} else if data.TwampLightSessions[i].Timeout.IsNull() {
			data.TwampLightSessions[i].Timeout = types.Int64Null()
		}
	}
}

// End of section. //template:end updateFromBodyXML
// Section below is generated&owned by "gen/generator.go". //template:begin fromBody

func (data *IPSLAResponder) fromBody(ctx context.Context, res gjson.Result) {
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	if value := res.Get(prefix + "type.udp.ipv4.address"); value.Exists() {
		data.TypeUdpIpv4 = make([]IPSLAResponderTypeUdpIpv4, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := IPSLAResponderTypeUdpIpv4{}
			if cValue := v.Get("address"); cValue.Exists() {
				item.Address = types.StringValue(cValue.String())
			}
			if cValue := v.Get("port"); cValue.Exists() {
				item.Ports = make([]IPSLAResponderTypeUdpIpv4Ports, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := IPSLAResponderTypeUdpIpv4Ports{}
					if ccValue := cv.Get("port-number"); ccValue.Exists() {
						cItem.PortNumber = types.Int64Value(ccValue.Int())
					}
					item.Ports = append(item.Ports, cItem)
					return true
				})
			}
			data.TypeUdpIpv4 = append(data.TypeUdpIpv4, item)
			return true
		})
	}
	if value := res.Get(prefix + "twamp"); value.Exists() {
		data.Twamp = types.BoolValue(true)
	} else {
		data.Twamp = types.BoolNull()
	}
	if value := res.Get(prefix + "twamp.timeout"); value.Exists() {
		data.TwampTimeout = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "twamp-light.test-session.session"); value.Exists() {
		data.TwampLightSessions = make([]IPSLAResponderTwampLightSessions, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := IPSLAResponderTwampLightSessions{}
			if cValue := v.Get("session-id"); cValue.Exists() {
				item.SessionId = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("local-ip.ipv4-addresses.ipv4-address"); cValue.Exists() {
				item.LocalIpv4Addresses = make([]IPSLAResponderTwampLightSessionsLocalIpv4Addresses, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := IPSLAResponderTwampLightSessionsLocalIpv4Addresses{}
					if ccValue := cv.Get("address"); ccValue.Exists() {
						cItem.Address = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("local-port"); ccValue.Exists() {
						cItem.LocalPort = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("remote-ip.ipv4-addresses.ipv4-address"); ccValue.Exists() {
						cItem.RemoteIpv4Addresses = make([]IPSLAResponderTwampLightSessionsLocalIpv4AddressesRemoteIpv4Addresses, 0)
						ccValue.ForEach(func(cck, ccv gjson.Result) bool {
							ccItem := IPSLAResponderTwampLightSessionsLocalIpv4AddressesRemoteIpv4Addresses{}
							if cccValue := ccv.Get("address"); cccValue.Exists() {
								ccItem.Address = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("remote-port"); cccValue.Exists() {
								ccItem.RemotePort = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("vrf"); cccValue.Exists() {
								ccItem.Vrf = types.StringValue(cccValue.String())
							}
							cItem.RemoteIpv4Addresses = append(cItem.RemoteIpv4Addresses, ccItem)
							return true
						})
					}
					item.LocalIpv4Addresses = append(item.LocalIpv4Addresses, cItem)
					return true
				})
			}
			if cValue := v.Get("local-ip.ipv6-addresses.ipv6-address"); cValue.Exists() {
				item.LocalIpv6Addresses = make([]IPSLAResponderTwampLightSessionsLocalIpv6Addresses, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := IPSLAResponderTwampLightSessionsLocalIpv6Addresses{}
					if ccValue := cv.Get("address"); ccValue.Exists() {
						cItem.Address = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("local-port"); ccValue.Exists() {
						cItem.LocalPort = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("remote-ip.ipv6-addresses.ipv6-address"); ccValue.Exists() {
						cItem.RemoteIpv6Addresses = make([]IPSLAResponderTwampLightSessionsLocalIpv6AddressesRemoteIpv6Addresses, 0)
						ccValue.ForEach(func(cck, ccv gjson.Result) bool {
							ccItem := IPSLAResponderTwampLightSessionsLocalIpv6AddressesRemoteIpv6Addresses{}
							if cccValue := ccv.Get("address"); cccValue.Exists() {
								ccItem.Address = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("remote-port"); cccValue.Exists() {
								ccItem.RemotePort = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("vrf"); cccValue.Exists() {
								ccItem.Vrf = types.StringValue(cccValue.String())
							}
							cItem.RemoteIpv6Addresses = append(cItem.RemoteIpv6Addresses, ccItem)
							return true
						})
					}
					item.LocalIpv6Addresses = append(item.LocalIpv6Addresses, cItem)
					return true
				})
			}
			if cValue := v.Get("authentication"); cValue.Exists() {
				item.Authentication = types.BoolValue(true)
			} else {
				item.Authentication = types.BoolValue(false)
			}
			if cValue := v.Get("encryption"); cValue.Exists() {
				item.Encryption = types.BoolValue(true)
			} else {
				item.Encryption = types.BoolValue(false)
			}
			if cValue := v.Get("timeout"); cValue.Exists() {
				item.Timeout = types.Int64Value(cValue.Int())
			}
			data.TwampLightSessions = append(data.TwampLightSessions, item)
			return true
		})
	}
}

// End of section. //template:end fromBody
// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyData

func (data *IPSLAResponderData) fromBody(ctx context.Context, res gjson.Result) {
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	if value := res.Get(prefix + "type.udp.ipv4.address"); value.Exists() {
		data.TypeUdpIpv4 = make([]IPSLAResponderTypeUdpIpv4, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := IPSLAResponderTypeUdpIpv4{}
			if cValue := v.Get("address"); cValue.Exists() {
				item.Address = types.StringValue(cValue.String())
			}
			if cValue := v.Get("port"); cValue.Exists() {
				item.Ports = make([]IPSLAResponderTypeUdpIpv4Ports, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := IPSLAResponderTypeUdpIpv4Ports{}
					if ccValue := cv.Get("port-number"); ccValue.Exists() {
						cItem.PortNumber = types.Int64Value(ccValue.Int())
					}
					item.Ports = append(item.Ports, cItem)
					return true
				})
			}
			data.TypeUdpIpv4 = append(data.TypeUdpIpv4, item)
			return true
		})
	}
	if value := res.Get(prefix + "twamp"); value.Exists() {
		data.Twamp = types.BoolValue(true)
	} else {
		data.Twamp = types.BoolNull()
	}
	if value := res.Get(prefix + "twamp.timeout"); value.Exists() {
		data.TwampTimeout = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "twamp-light.test-session.session"); value.Exists() {
		data.TwampLightSessions = make([]IPSLAResponderTwampLightSessions, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := IPSLAResponderTwampLightSessions{}
			if cValue := v.Get("session-id"); cValue.Exists() {
				item.SessionId = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("local-ip.ipv4-addresses.ipv4-address"); cValue.Exists() {
				item.LocalIpv4Addresses = make([]IPSLAResponderTwampLightSessionsLocalIpv4Addresses, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := IPSLAResponderTwampLightSessionsLocalIpv4Addresses{}
					if ccValue := cv.Get("address"); ccValue.Exists() {
						cItem.Address = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("local-port"); ccValue.Exists() {
						cItem.LocalPort = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("remote-ip.ipv4-addresses.ipv4-address"); ccValue.Exists() {
						cItem.RemoteIpv4Addresses = make([]IPSLAResponderTwampLightSessionsLocalIpv4AddressesRemoteIpv4Addresses, 0)
						ccValue.ForEach(func(cck, ccv gjson.Result) bool {
							ccItem := IPSLAResponderTwampLightSessionsLocalIpv4AddressesRemoteIpv4Addresses{}
							if cccValue := ccv.Get("address"); cccValue.Exists() {
								ccItem.Address = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("remote-port"); cccValue.Exists() {
								ccItem.RemotePort = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("vrf"); cccValue.Exists() {
								ccItem.Vrf = types.StringValue(cccValue.String())
							}
							cItem.RemoteIpv4Addresses = append(cItem.RemoteIpv4Addresses, ccItem)
							return true
						})
					}
					item.LocalIpv4Addresses = append(item.LocalIpv4Addresses, cItem)
					return true
				})
			}
			if cValue := v.Get("local-ip.ipv6-addresses.ipv6-address"); cValue.Exists() {
				item.LocalIpv6Addresses = make([]IPSLAResponderTwampLightSessionsLocalIpv6Addresses, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := IPSLAResponderTwampLightSessionsLocalIpv6Addresses{}
					if ccValue := cv.Get("address"); ccValue.Exists() {
						cItem.Address = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("local-port"); ccValue.Exists() {
						cItem.LocalPort = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("remote-ip.ipv6-addresses.ipv6-address"); ccValue.Exists() {
						cItem.RemoteIpv6Addresses = make([]IPSLAResponderTwampLightSessionsLocalIpv6AddressesRemoteIpv6Addresses, 0)
						ccValue.ForEach(func(cck, ccv gjson.Result) bool {
							ccItem := IPSLAResponderTwampLightSessionsLocalIpv6AddressesRemoteIpv6Addresses{}
							if cccValue := ccv.Get("address"); cccValue.Exists() {
								ccItem.Address = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("remote-port"); cccValue.Exists() {
								ccItem.RemotePort = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("vrf"); cccValue.Exists() {
								ccItem.Vrf = types.StringValue(cccValue.String())
							}
							cItem.RemoteIpv6Addresses = append(cItem.RemoteIpv6Addresses, ccItem)
							return true
						})
					}
					item.LocalIpv6Addresses = append(item.LocalIpv6Addresses, cItem)
					return true
				})
			}
			if cValue := v.Get("authentication"); cValue.Exists() {
				item.Authentication = types.BoolValue(true)
			} else {
				item.Authentication = types.BoolNull()
			}
			if cValue := v.Get("encryption"); cValue.Exists() {
				item.Encryption = types.BoolValue(true)
			} else {
				item.Encryption = types.BoolNull()
			}
			if cValue := v.Get("timeout"); cValue.Exists() {
				item.Timeout = types.Int64Value(cValue.Int())
			}
			data.TwampLightSessions = append(data.TwampLightSessions, item)
			return true
		})
	}
}

// End of section. //template:end fromBodyData
// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyXML

func (data *IPSLAResponder) fromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/type/udp/ipv4/address"); value.Exists() {
		data.TypeUdpIpv4 = make([]IPSLAResponderTypeUdpIpv4, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := IPSLAResponderTypeUdpIpv4{}
			if cValue := helpers.GetFromXPath(v, "address"); cValue.Exists() {
				item.Address = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "port"); cValue.Exists() {
				item.Ports = make([]IPSLAResponderTypeUdpIpv4Ports, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := IPSLAResponderTypeUdpIpv4Ports{}
					if ccValue := helpers.GetFromXPath(cv, "port-number"); ccValue.Exists() {
						cItem.PortNumber = types.Int64Value(ccValue.Int())
					}
					item.Ports = append(item.Ports, cItem)
					return true
				})
			}
			data.TypeUdpIpv4 = append(data.TypeUdpIpv4, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/twamp"); value.Exists() {
		data.Twamp = types.BoolValue(true)
	} else {
		data.Twamp = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/twamp/timeout"); value.Exists() {
		data.TwampTimeout = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/twamp-light/test-session/session"); value.Exists() {
		data.TwampLightSessions = make([]IPSLAResponderTwampLightSessions, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := IPSLAResponderTwampLightSessions{}
			if cValue := helpers.GetFromXPath(v, "session-id"); cValue.Exists() {
				item.SessionId = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "local-ip/ipv4-addresses/ipv4-address"); cValue.Exists() {
				item.LocalIpv4Addresses = make([]IPSLAResponderTwampLightSessionsLocalIpv4Addresses, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := IPSLAResponderTwampLightSessionsLocalIpv4Addresses{}
					if ccValue := helpers.GetFromXPath(cv, "address"); ccValue.Exists() {
						cItem.Address = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "local-port"); ccValue.Exists() {
						cItem.LocalPort = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "remote-ip/ipv4-addresses/ipv4-address"); ccValue.Exists() {
						cItem.RemoteIpv4Addresses = make([]IPSLAResponderTwampLightSessionsLocalIpv4AddressesRemoteIpv4Addresses, 0)
						ccValue.ForEach(func(_ int, ccv xmldot.Result) bool {
							ccItem := IPSLAResponderTwampLightSessionsLocalIpv4AddressesRemoteIpv4Addresses{}
							if cccValue := helpers.GetFromXPath(ccv, "address"); cccValue.Exists() {
								ccItem.Address = types.StringValue(cccValue.String())
							}
							if cccValue := helpers.GetFromXPath(ccv, "remote-port"); cccValue.Exists() {
								ccItem.RemotePort = types.StringValue(cccValue.String())
							}
							if cccValue := helpers.GetFromXPath(ccv, "vrf"); cccValue.Exists() {
								ccItem.Vrf = types.StringValue(cccValue.String())
							}
							cItem.RemoteIpv4Addresses = append(cItem.RemoteIpv4Addresses, ccItem)
							return true
						})
					}
					item.LocalIpv4Addresses = append(item.LocalIpv4Addresses, cItem)
					return true
				})
			}
			if cValue := helpers.GetFromXPath(v, "local-ip/ipv6-addresses/ipv6-address"); cValue.Exists() {
				item.LocalIpv6Addresses = make([]IPSLAResponderTwampLightSessionsLocalIpv6Addresses, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := IPSLAResponderTwampLightSessionsLocalIpv6Addresses{}
					if ccValue := helpers.GetFromXPath(cv, "address"); ccValue.Exists() {
						cItem.Address = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "local-port"); ccValue.Exists() {
						cItem.LocalPort = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "remote-ip/ipv6-addresses/ipv6-address"); ccValue.Exists() {
						cItem.RemoteIpv6Addresses = make([]IPSLAResponderTwampLightSessionsLocalIpv6AddressesRemoteIpv6Addresses, 0)
						ccValue.ForEach(func(_ int, ccv xmldot.Result) bool {
							ccItem := IPSLAResponderTwampLightSessionsLocalIpv6AddressesRemoteIpv6Addresses{}
							if cccValue := helpers.GetFromXPath(ccv, "address"); cccValue.Exists() {
								ccItem.Address = types.StringValue(cccValue.String())
							}
							if cccValue := helpers.GetFromXPath(ccv, "remote-port"); cccValue.Exists() {
								ccItem.RemotePort = types.StringValue(cccValue.String())
							}
							if cccValue := helpers.GetFromXPath(ccv, "vrf"); cccValue.Exists() {
								ccItem.Vrf = types.StringValue(cccValue.String())
							}
							cItem.RemoteIpv6Addresses = append(cItem.RemoteIpv6Addresses, ccItem)
							return true
						})
					}
					item.LocalIpv6Addresses = append(item.LocalIpv6Addresses, cItem)
					return true
				})
			}
			if cValue := helpers.GetFromXPath(v, "authentication"); cValue.Exists() {
				item.Authentication = types.BoolValue(true)
			} else {
				item.Authentication = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "encryption"); cValue.Exists() {
				item.Encryption = types.BoolValue(true)
			} else {
				item.Encryption = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "timeout"); cValue.Exists() {
				item.Timeout = types.Int64Value(cValue.Int())
			}
			data.TwampLightSessions = append(data.TwampLightSessions, item)
			return true
		})
	}
}

// End of section. //template:end fromBodyXML
// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyDataXML

func (data *IPSLAResponderData) fromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/type/udp/ipv4/address"); value.Exists() {
		data.TypeUdpIpv4 = make([]IPSLAResponderTypeUdpIpv4, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := IPSLAResponderTypeUdpIpv4{}
			if cValue := helpers.GetFromXPath(v, "address"); cValue.Exists() {
				item.Address = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "port"); cValue.Exists() {
				item.Ports = make([]IPSLAResponderTypeUdpIpv4Ports, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := IPSLAResponderTypeUdpIpv4Ports{}
					if ccValue := helpers.GetFromXPath(cv, "port-number"); ccValue.Exists() {
						cItem.PortNumber = types.Int64Value(ccValue.Int())
					}
					item.Ports = append(item.Ports, cItem)
					return true
				})
			}
			data.TypeUdpIpv4 = append(data.TypeUdpIpv4, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/twamp"); value.Exists() {
		data.Twamp = types.BoolValue(true)
	} else {
		data.Twamp = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/twamp/timeout"); value.Exists() {
		data.TwampTimeout = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/twamp-light/test-session/session"); value.Exists() {
		data.TwampLightSessions = make([]IPSLAResponderTwampLightSessions, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := IPSLAResponderTwampLightSessions{}
			if cValue := helpers.GetFromXPath(v, "session-id"); cValue.Exists() {
				item.SessionId = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "local-ip/ipv4-addresses/ipv4-address"); cValue.Exists() {
				item.LocalIpv4Addresses = make([]IPSLAResponderTwampLightSessionsLocalIpv4Addresses, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := IPSLAResponderTwampLightSessionsLocalIpv4Addresses{}
					if ccValue := helpers.GetFromXPath(cv, "address"); ccValue.Exists() {
						cItem.Address = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "local-port"); ccValue.Exists() {
						cItem.LocalPort = types.Int64Value(ccValue.Int())
					}
					item.LocalIpv4Addresses = append(item.LocalIpv4Addresses, cItem)
					return true
				})
			}
			if cValue := helpers.GetFromXPath(v, "local-ip/ipv6-addresses/ipv6-address"); cValue.Exists() {
				item.LocalIpv6Addresses = make([]IPSLAResponderTwampLightSessionsLocalIpv6Addresses, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := IPSLAResponderTwampLightSessionsLocalIpv6Addresses{}
					if ccValue := helpers.GetFromXPath(cv, "address"); ccValue.Exists() {
						cItem.Address = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "local-port"); ccValue.Exists() {
						cItem.LocalPort = types.Int64Value(ccValue.Int())
					}
					item.LocalIpv6Addresses = append(item.LocalIpv6Addresses, cItem)
					return true
				})
			}
			if cValue := helpers.GetFromXPath(v, "authentication"); cValue.Exists() {
				item.Authentication = types.BoolValue(true)
			} else {
				item.Authentication = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "encryption"); cValue.Exists() {
				item.Encryption = types.BoolValue(true)
			} else {
				item.Encryption = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "timeout"); cValue.Exists() {
				item.Timeout = types.Int64Value(cValue.Int())
			}
			data.TwampLightSessions = append(data.TwampLightSessions, item)
			return true
		})
	}
}

// End of section. //template:end fromBodyDataXML
// Section below is generated&owned by "gen/generator.go". //template:begin getDeletedItems

func (data *IPSLAResponder) getDeletedItems(ctx context.Context, state IPSLAResponder) []string {
	deletedItems := make([]string, 0)
	for i := range state.TwampLightSessions {
		keys := [...]string{"session-id"}
		stateKeyValues := [...]string{strconv.FormatInt(state.TwampLightSessions[i].SessionId.ValueInt64(), 10)}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.TwampLightSessions[i].SessionId.ValueInt64()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.TwampLightSessions {
			found = true
			if state.TwampLightSessions[i].SessionId.ValueInt64() != data.TwampLightSessions[j].SessionId.ValueInt64() {
				found = false
			}
			if found {
				if !state.TwampLightSessions[i].Timeout.IsNull() && data.TwampLightSessions[j].Timeout.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/twamp-light/test-session/session%v/timeout", state.getPath(), keyString))
				}
				if !state.TwampLightSessions[i].Encryption.IsNull() && data.TwampLightSessions[j].Encryption.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/twamp-light/test-session/session%v/encryption", state.getPath(), keyString))
				}
				if !state.TwampLightSessions[i].Authentication.IsNull() && data.TwampLightSessions[j].Authentication.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/twamp-light/test-session/session%v/authentication", state.getPath(), keyString))
				}
				for ci := range state.TwampLightSessions[i].LocalIpv6Addresses {
					ckeys := [...]string{"address", "local-port"}
					cstateKeyValues := [...]string{state.TwampLightSessions[i].LocalIpv6Addresses[ci].Address.ValueString(), strconv.FormatInt(state.TwampLightSessions[i].LocalIpv6Addresses[ci].LocalPort.ValueInt64(), 10)}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.TwampLightSessions[i].LocalIpv6Addresses[ci].Address.ValueString()).IsZero() {
						cemptyKeys = false
					}
					if !reflect.ValueOf(state.TwampLightSessions[i].LocalIpv6Addresses[ci].LocalPort.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.TwampLightSessions[j].LocalIpv6Addresses {
						found = true
						if state.TwampLightSessions[i].LocalIpv6Addresses[ci].Address.ValueString() != data.TwampLightSessions[j].LocalIpv6Addresses[cj].Address.ValueString() {
							found = false
						}
						if state.TwampLightSessions[i].LocalIpv6Addresses[ci].LocalPort.ValueInt64() != data.TwampLightSessions[j].LocalIpv6Addresses[cj].LocalPort.ValueInt64() {
							found = false
						}
						if found {
							for cci := range state.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses {
								cckeys := [...]string{"address", "remote-port", "vrf"}
								ccstateKeyValues := [...]string{state.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].Address.ValueString(), state.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].RemotePort.ValueString(), state.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].Vrf.ValueString()}
								cckeyString := ""
								for ccki := range cckeys {
									cckeyString += "[" + cckeys[ccki] + "=" + ccstateKeyValues[ccki] + "]"
								}

								ccemptyKeys := true
								if !reflect.ValueOf(state.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].Address.ValueString()).IsZero() {
									ccemptyKeys = false
								}
								if !reflect.ValueOf(state.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].RemotePort.ValueString()).IsZero() {
									ccemptyKeys = false
								}
								if !reflect.ValueOf(state.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].Vrf.ValueString()).IsZero() {
									ccemptyKeys = false
								}
								if ccemptyKeys {
									continue
								}

								found := false
								for ccj := range data.TwampLightSessions[j].LocalIpv6Addresses[cj].RemoteIpv6Addresses {
									found = true
									if state.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].Address.ValueString() != data.TwampLightSessions[j].LocalIpv6Addresses[cj].RemoteIpv6Addresses[ccj].Address.ValueString() {
										found = false
									}
									if state.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].RemotePort.ValueString() != data.TwampLightSessions[j].LocalIpv6Addresses[cj].RemoteIpv6Addresses[ccj].RemotePort.ValueString() {
										found = false
									}
									if state.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].Vrf.ValueString() != data.TwampLightSessions[j].LocalIpv6Addresses[cj].RemoteIpv6Addresses[ccj].Vrf.ValueString() {
										found = false
									}
									if found {
										break
									}
								}
								if !found {
									deletedItems = append(deletedItems, fmt.Sprintf("%v/twamp-light/test-session/session%v/local-ip/ipv6-addresses/ipv6-address%v/remote-ip/ipv6-addresses/ipv6-address%v", state.getPath(), keyString, ckeyString, cckeyString))
								}
							}
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/twamp-light/test-session/session%v/local-ip/ipv6-addresses/ipv6-address%v", state.getPath(), keyString, ckeyString))
					}
				}
				for ci := range state.TwampLightSessions[i].LocalIpv4Addresses {
					ckeys := [...]string{"address", "local-port"}
					cstateKeyValues := [...]string{state.TwampLightSessions[i].LocalIpv4Addresses[ci].Address.ValueString(), strconv.FormatInt(state.TwampLightSessions[i].LocalIpv4Addresses[ci].LocalPort.ValueInt64(), 10)}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.TwampLightSessions[i].LocalIpv4Addresses[ci].Address.ValueString()).IsZero() {
						cemptyKeys = false
					}
					if !reflect.ValueOf(state.TwampLightSessions[i].LocalIpv4Addresses[ci].LocalPort.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.TwampLightSessions[j].LocalIpv4Addresses {
						found = true
						if state.TwampLightSessions[i].LocalIpv4Addresses[ci].Address.ValueString() != data.TwampLightSessions[j].LocalIpv4Addresses[cj].Address.ValueString() {
							found = false
						}
						if state.TwampLightSessions[i].LocalIpv4Addresses[ci].LocalPort.ValueInt64() != data.TwampLightSessions[j].LocalIpv4Addresses[cj].LocalPort.ValueInt64() {
							found = false
						}
						if found {
							for cci := range state.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses {
								cckeys := [...]string{"address", "remote-port", "vrf"}
								ccstateKeyValues := [...]string{state.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].Address.ValueString(), state.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].RemotePort.ValueString(), state.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].Vrf.ValueString()}
								cckeyString := ""
								for ccki := range cckeys {
									cckeyString += "[" + cckeys[ccki] + "=" + ccstateKeyValues[ccki] + "]"
								}

								ccemptyKeys := true
								if !reflect.ValueOf(state.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].Address.ValueString()).IsZero() {
									ccemptyKeys = false
								}
								if !reflect.ValueOf(state.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].RemotePort.ValueString()).IsZero() {
									ccemptyKeys = false
								}
								if !reflect.ValueOf(state.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].Vrf.ValueString()).IsZero() {
									ccemptyKeys = false
								}
								if ccemptyKeys {
									continue
								}

								found := false
								for ccj := range data.TwampLightSessions[j].LocalIpv4Addresses[cj].RemoteIpv4Addresses {
									found = true
									if state.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].Address.ValueString() != data.TwampLightSessions[j].LocalIpv4Addresses[cj].RemoteIpv4Addresses[ccj].Address.ValueString() {
										found = false
									}
									if state.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].RemotePort.ValueString() != data.TwampLightSessions[j].LocalIpv4Addresses[cj].RemoteIpv4Addresses[ccj].RemotePort.ValueString() {
										found = false
									}
									if state.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].Vrf.ValueString() != data.TwampLightSessions[j].LocalIpv4Addresses[cj].RemoteIpv4Addresses[ccj].Vrf.ValueString() {
										found = false
									}
									if found {
										break
									}
								}
								if !found {
									deletedItems = append(deletedItems, fmt.Sprintf("%v/twamp-light/test-session/session%v/local-ip/ipv4-addresses/ipv4-address%v/remote-ip/ipv4-addresses/ipv4-address%v", state.getPath(), keyString, ckeyString, cckeyString))
								}
							}
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/twamp-light/test-session/session%v/local-ip/ipv4-addresses/ipv4-address%v", state.getPath(), keyString, ckeyString))
					}
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/twamp-light/test-session/session%v", state.getPath(), keyString))
		}
	}
	if !state.TwampTimeout.IsNull() && data.TwampTimeout.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/twamp/timeout", state.getPath()))
	}
	if !state.Twamp.IsNull() && data.Twamp.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/twamp", state.getPath()))
	}
	for i := range state.TypeUdpIpv4 {
		keys := [...]string{"address"}
		stateKeyValues := [...]string{state.TypeUdpIpv4[i].Address.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.TypeUdpIpv4[i].Address.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.TypeUdpIpv4 {
			found = true
			if state.TypeUdpIpv4[i].Address.ValueString() != data.TypeUdpIpv4[j].Address.ValueString() {
				found = false
			}
			if found {
				for ci := range state.TypeUdpIpv4[i].Ports {
					ckeys := [...]string{"port-number"}
					cstateKeyValues := [...]string{strconv.FormatInt(state.TypeUdpIpv4[i].Ports[ci].PortNumber.ValueInt64(), 10)}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.TypeUdpIpv4[i].Ports[ci].PortNumber.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.TypeUdpIpv4[j].Ports {
						found = true
						if state.TypeUdpIpv4[i].Ports[ci].PortNumber.ValueInt64() != data.TypeUdpIpv4[j].Ports[cj].PortNumber.ValueInt64() {
							found = false
						}
						if found {
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/type/udp/ipv4/address%v/port%v", state.getPath(), keyString, ckeyString))
					}
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/type/udp/ipv4/address%v", state.getPath(), keyString))
		}
	}
	return deletedItems
}

// End of section. //template:end getDeletedItems
// Section below is generated&owned by "gen/generator.go". //template:begin getEmptyLeafsDelete

func (data *IPSLAResponder) getEmptyLeafsDelete(ctx context.Context, state *IPSLAResponder) []string {
	emptyLeafsDelete := make([]string, 0)
	for i := range data.TwampLightSessions {
		keys := [...]string{"session-id"}
		keyValues := [...]string{strconv.FormatInt(data.TwampLightSessions[i].SessionId.ValueInt64(), 10)}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		// Only delete if state has true and plan has false
		if !data.TwampLightSessions[i].Encryption.IsNull() && !data.TwampLightSessions[i].Encryption.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.TwampLightSessions) && !state.TwampLightSessions[i].Encryption.IsNull() && state.TwampLightSessions[i].Encryption.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/twamp-light/test-session/session%v/encryption", data.getXPath(), keyString))
			}
		}
		// Only delete if state has true and plan has false
		if !data.TwampLightSessions[i].Authentication.IsNull() && !data.TwampLightSessions[i].Authentication.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.TwampLightSessions) && !state.TwampLightSessions[i].Authentication.IsNull() && state.TwampLightSessions[i].Authentication.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/twamp-light/test-session/session%v/authentication", data.getXPath(), keyString))
			}
		}
		for ci := range data.TwampLightSessions[i].LocalIpv6Addresses {
			ckeys := [...]string{"address", "local-port"}
			ckeyValues := [...]string{data.TwampLightSessions[i].LocalIpv6Addresses[ci].Address.ValueString(), strconv.FormatInt(data.TwampLightSessions[i].LocalIpv6Addresses[ci].LocalPort.ValueInt64(), 10)}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
			for cci := range data.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses {
				cckeys := [...]string{"address", "remote-port", "vrf"}
				cckeyValues := [...]string{data.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].Address.ValueString(), data.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].RemotePort.ValueString(), data.TwampLightSessions[i].LocalIpv6Addresses[ci].RemoteIpv6Addresses[cci].Vrf.ValueString()}
				cckeyString := ""
				for ccki := range cckeys {
					cckeyString += "[" + cckeys[ccki] + "=" + cckeyValues[ccki] + "]"
				}
			}
		}
		for ci := range data.TwampLightSessions[i].LocalIpv4Addresses {
			ckeys := [...]string{"address", "local-port"}
			ckeyValues := [...]string{data.TwampLightSessions[i].LocalIpv4Addresses[ci].Address.ValueString(), strconv.FormatInt(data.TwampLightSessions[i].LocalIpv4Addresses[ci].LocalPort.ValueInt64(), 10)}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
			for cci := range data.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses {
				cckeys := [...]string{"address", "remote-port", "vrf"}
				cckeyValues := [...]string{data.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].Address.ValueString(), data.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].RemotePort.ValueString(), data.TwampLightSessions[i].LocalIpv4Addresses[ci].RemoteIpv4Addresses[cci].Vrf.ValueString()}
				cckeyString := ""
				for ccki := range cckeys {
					cckeyString += "[" + cckeys[ccki] + "=" + cckeyValues[ccki] + "]"
				}
			}
		}
	}
	// Only delete if state has true and plan has false
	if !data.Twamp.IsNull() && !data.Twamp.ValueBool() {
		if state != nil && !state.Twamp.IsNull() && state.Twamp.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/twamp", data.getXPath()))
		}
	}
	for i := range data.TypeUdpIpv4 {
		keys := [...]string{"address"}
		keyValues := [...]string{data.TypeUdpIpv4[i].Address.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		for ci := range data.TypeUdpIpv4[i].Ports {
			ckeys := [...]string{"port-number"}
			ckeyValues := [...]string{strconv.FormatInt(data.TypeUdpIpv4[i].Ports[ci].PortNumber.ValueInt64(), 10)}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
		}
	}
	return emptyLeafsDelete
}

// End of section. //template:end getEmptyLeafsDelete
// Section below is generated&owned by "gen/generator.go". //template:begin getDeletePaths

func (data *IPSLAResponder) getDeletePaths(ctx context.Context) []string {
	var deletePaths []string
	for i := range data.TwampLightSessions {
		keyValues := [...]string{strconv.FormatInt(data.TwampLightSessions[i].SessionId.ValueInt64(), 10)}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/twamp-light/test-session/session=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	if !data.TwampTimeout.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/twamp/timeout", data.getPath()))
	}
	if !data.Twamp.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/twamp", data.getPath()))
	}
	for i := range data.TypeUdpIpv4 {
		keyValues := [...]string{data.TypeUdpIpv4[i].Address.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/type/udp/ipv4/address=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}

	return deletePaths
}

// End of section. //template:end getDeletePaths
// Section below is generated&owned by "gen/generator.go". //template:begin addDeletedItemsXML

func (data *IPSLAResponder) addDeletedItemsXML(ctx context.Context, state IPSLAResponder, body string) string {
	deleteXml := ""
	deletedPaths := make(map[string]bool)
	_ = deletedPaths // Avoid unused variable error when no delete_parent attributes exist
	for i := range state.TwampLightSessions {
		stateKeys := [...]string{"session-id"}
		stateKeyValues := [...]string{strconv.FormatInt(state.TwampLightSessions[i].SessionId.ValueInt64(), 10)}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.TwampLightSessions[i].SessionId.ValueInt64()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.TwampLightSessions {
			found = true
			if state.TwampLightSessions[i].SessionId.ValueInt64() != data.TwampLightSessions[j].SessionId.ValueInt64() {
				found = false
			}
			if found {
				if !state.TwampLightSessions[i].Timeout.IsNull() && data.TwampLightSessions[j].Timeout.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/twamp-light/test-session/session%v/timeout", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.TwampLightSessions[i].Encryption.IsNull() && state.TwampLightSessions[i].Encryption.ValueBool() && data.TwampLightSessions[j].Encryption.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/twamp-light/test-session/session%v/encryption", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.TwampLightSessions[i].Authentication.IsNull() && state.TwampLightSessions[i].Authentication.ValueBool() && data.TwampLightSessions[j].Authentication.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/twamp-light/test-session/session%v/authentication", predicates))
				}
				for ci := range state.TwampLightSessions[i].LocalIpv6Addresses {
					cstateKeys := [...]string{"address", "local-port"}
					cstateKeyValues := [...]string{state.TwampLightSessions[i].LocalIpv6Addresses[ci].Address.ValueString(), strconv.FormatInt(state.TwampLightSessions[i].LocalIpv6Addresses[ci].LocalPort.ValueInt64(), 10)}
					cpredicates := ""
					for i := range cstateKeys {
						cpredicates += fmt.Sprintf("[%s='%s']", cstateKeys[i], cstateKeyValues[i])
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.TwampLightSessions[i].LocalIpv6Addresses[ci].Address.ValueString()).IsZero() {
						cemptyKeys = false
					}
					if !reflect.ValueOf(state.TwampLightSessions[i].LocalIpv6Addresses[ci].LocalPort.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.TwampLightSessions[j].LocalIpv6Addresses {
						found = true
						if state.TwampLightSessions[i].LocalIpv6Addresses[ci].Address.ValueString() != data.TwampLightSessions[j].LocalIpv6Addresses[cj].Address.ValueString() {
							found = false
						}
						if state.TwampLightSessions[i].LocalIpv6Addresses[ci].LocalPort.ValueInt64() != data.TwampLightSessions[j].LocalIpv6Addresses[cj].LocalPort.ValueInt64() {
							found = false
						}
						if found {
							break
						}
					}
					if !found {
						deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/twamp-light/test-session/session%v/local-ip/ipv6-addresses/ipv6-address%v", predicates, cpredicates))
					}
				}
				for ci := range state.TwampLightSessions[i].LocalIpv4Addresses {
					cstateKeys := [...]string{"address", "local-port"}
					cstateKeyValues := [...]string{state.TwampLightSessions[i].LocalIpv4Addresses[ci].Address.ValueString(), strconv.FormatInt(state.TwampLightSessions[i].LocalIpv4Addresses[ci].LocalPort.ValueInt64(), 10)}
					cpredicates := ""
					for i := range cstateKeys {
						cpredicates += fmt.Sprintf("[%s='%s']", cstateKeys[i], cstateKeyValues[i])
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.TwampLightSessions[i].LocalIpv4Addresses[ci].Address.ValueString()).IsZero() {
						cemptyKeys = false
					}
					if !reflect.ValueOf(state.TwampLightSessions[i].LocalIpv4Addresses[ci].LocalPort.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.TwampLightSessions[j].LocalIpv4Addresses {
						found = true
						if state.TwampLightSessions[i].LocalIpv4Addresses[ci].Address.ValueString() != data.TwampLightSessions[j].LocalIpv4Addresses[cj].Address.ValueString() {
							found = false
						}
						if state.TwampLightSessions[i].LocalIpv4Addresses[ci].LocalPort.ValueInt64() != data.TwampLightSessions[j].LocalIpv4Addresses[cj].LocalPort.ValueInt64() {
							found = false
						}
						if found {
							break
						}
					}
					if !found {
						deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/twamp-light/test-session/session%v/local-ip/ipv4-addresses/ipv4-address%v", predicates, cpredicates))
					}
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/twamp-light/test-session/session%v", predicates))
		}
	}
	if !state.TwampTimeout.IsNull() && data.TwampTimeout.IsNull() {
		deletePath := state.getXPath() + "/twamp/timeout"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.Twamp.IsNull() && state.Twamp.ValueBool() && data.Twamp.IsNull() {
		deletePath := state.getXPath() + "/twamp"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	for i := range state.TypeUdpIpv4 {
		stateKeys := [...]string{"address"}
		stateKeyValues := [...]string{state.TypeUdpIpv4[i].Address.ValueString()}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.TypeUdpIpv4[i].Address.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.TypeUdpIpv4 {
			found = true
			if state.TypeUdpIpv4[i].Address.ValueString() != data.TypeUdpIpv4[j].Address.ValueString() {
				found = false
			}
			if found {
				for ci := range state.TypeUdpIpv4[i].Ports {
					cstateKeys := [...]string{"port-number"}
					cstateKeyValues := [...]string{strconv.FormatInt(state.TypeUdpIpv4[i].Ports[ci].PortNumber.ValueInt64(), 10)}
					cpredicates := ""
					for i := range cstateKeys {
						cpredicates += fmt.Sprintf("[%s='%s']", cstateKeys[i], cstateKeyValues[i])
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.TypeUdpIpv4[i].Ports[ci].PortNumber.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.TypeUdpIpv4[j].Ports {
						found = true
						if state.TypeUdpIpv4[i].Ports[ci].PortNumber.ValueInt64() != data.TypeUdpIpv4[j].Ports[cj].PortNumber.ValueInt64() {
							found = false
						}
						if found {
							break
						}
					}
					if !found {
						deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/type/udp/ipv4/address%v/port%v", predicates, cpredicates))
					}
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/type/udp/ipv4/address%v", predicates))
		}
	}

	b := netconf.NewBody(deleteXml)
	b = helpers.CleanupRedundantRemoveOperations(b)
	return b.Res()
}

// End of section. //template:end addDeletedItemsXML
// Section below is generated&owned by "gen/generator.go". //template:begin addDeletePathsXML

func (data *IPSLAResponder) addDeletePathsXML(ctx context.Context, body string) string {
	b := netconf.NewBody(body)
	for i := range data.TwampLightSessions {
		keys := [...]string{"session-id"}
		keyValues := [...]string{strconv.FormatInt(data.TwampLightSessions[i].SessionId.ValueInt64(), 10)}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/twamp-light/test-session/session%v", predicates))
	}
	if !data.TwampTimeout.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/twamp/timeout")
	}
	if !data.Twamp.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/twamp")
	}
	for i := range data.TypeUdpIpv4 {
		keys := [...]string{"address"}
		keyValues := [...]string{data.TypeUdpIpv4[i].Address.ValueString()}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/type/udp/ipv4/address%v", predicates))
	}

	b = helpers.CleanupRedundantRemoveOperations(b)
	return b.Res()
}

// End of section. //template:end addDeletePathsXML
