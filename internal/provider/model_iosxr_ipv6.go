// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports
import (
	"context"
	"fmt"
	"sort"
	"strconv"

	"github.com/CiscoDevNet/terraform-provider-iosxr/internal/provider/helpers"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/netascode/go-netconf"
	"github.com/netascode/xmldot"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin types
type IPv6 struct {
	Device                           types.String `tfsdk:"device"`
	Id                               types.String `tfsdk:"id"`
	DeleteMode                       types.String `tfsdk:"delete_mode"`
	HopLimit                         types.Int64  `tfsdk:"hop_limit"`
	IcmpErrorInterval                types.Int64  `tfsdk:"icmp_error_interval"`
	IcmpErrorIntervalBucketSize      types.Int64  `tfsdk:"icmp_error_interval_bucket_size"`
	SourceRoute                      types.Bool   `tfsdk:"source_route"`
	AssemblerTimeout                 types.Int64  `tfsdk:"assembler_timeout"`
	AssemblerMaxPackets              types.Int64  `tfsdk:"assembler_max_packets"`
	AssemblerReassemblerDropEnable   types.Bool   `tfsdk:"assembler_reassembler_drop_enable"`
	AssemblerFragHdrIncompleteEnable types.Bool   `tfsdk:"assembler_frag_hdr_incomplete_enable"`
	AssemblerOverlapFragDropEnable   types.Bool   `tfsdk:"assembler_overlap_frag_drop_enable"`
	PathMtuEnable                    types.Bool   `tfsdk:"path_mtu_enable"`
	PathMtuTimeout                   types.Int64  `tfsdk:"path_mtu_timeout"`
}

type IPv6Data struct {
	Device                           types.String `tfsdk:"device"`
	Id                               types.String `tfsdk:"id"`
	HopLimit                         types.Int64  `tfsdk:"hop_limit"`
	IcmpErrorInterval                types.Int64  `tfsdk:"icmp_error_interval"`
	IcmpErrorIntervalBucketSize      types.Int64  `tfsdk:"icmp_error_interval_bucket_size"`
	SourceRoute                      types.Bool   `tfsdk:"source_route"`
	AssemblerTimeout                 types.Int64  `tfsdk:"assembler_timeout"`
	AssemblerMaxPackets              types.Int64  `tfsdk:"assembler_max_packets"`
	AssemblerReassemblerDropEnable   types.Bool   `tfsdk:"assembler_reassembler_drop_enable"`
	AssemblerFragHdrIncompleteEnable types.Bool   `tfsdk:"assembler_frag_hdr_incomplete_enable"`
	AssemblerOverlapFragDropEnable   types.Bool   `tfsdk:"assembler_overlap_frag_drop_enable"`
	PathMtuEnable                    types.Bool   `tfsdk:"path_mtu_enable"`
	PathMtuTimeout                   types.Int64  `tfsdk:"path_mtu_timeout"`
}

// End of section. //template:end types

// Section below is generated&owned by "gen/generator.go". //template:begin getPath

func (data IPv6) getPath() string {
	return "Cisco-IOS-XR-um-ipv6-cfg:/ipv6"
}

func (data IPv6Data) getPath() string {
	return "Cisco-IOS-XR-um-ipv6-cfg:/ipv6"
}

// getXPath returns the XPath for NETCONF operations
func (data IPv6) getXPath() string {
	path := "Cisco-IOS-XR-um-ipv6-cfg:/ipv6"
	return path
}

func (data IPv6Data) getXPath() string {
	path := "Cisco-IOS-XR-um-ipv6-cfg:/ipv6"
	return path
}

// End of section. //template:end getPath

// Section below is generated&owned by "gen/generator.go". //template:begin toBody

func (data IPv6) toBody(ctx context.Context) string {
	body := "{}"
	if !data.HopLimit.IsNull() && !data.HopLimit.IsUnknown() {
		body, _ = sjson.Set(body, "hop-limit", strconv.FormatInt(data.HopLimit.ValueInt64(), 10))
	}
	if !data.IcmpErrorInterval.IsNull() && !data.IcmpErrorInterval.IsUnknown() {
		body, _ = sjson.Set(body, "icmp.error-interval.interval-time", strconv.FormatInt(data.IcmpErrorInterval.ValueInt64(), 10))
	}
	if !data.IcmpErrorIntervalBucketSize.IsNull() && !data.IcmpErrorIntervalBucketSize.IsUnknown() {
		body, _ = sjson.Set(body, "icmp.error-interval.bucket-size", strconv.FormatInt(data.IcmpErrorIntervalBucketSize.ValueInt64(), 10))
	}
	if !data.SourceRoute.IsNull() && !data.SourceRoute.IsUnknown() {
		if data.SourceRoute.ValueBool() {
			body, _ = sjson.Set(body, "source-route", map[string]string{})
		}
	}
	if !data.AssemblerTimeout.IsNull() && !data.AssemblerTimeout.IsUnknown() {
		body, _ = sjson.Set(body, "assembler.timeout", strconv.FormatInt(data.AssemblerTimeout.ValueInt64(), 10))
	}
	if !data.AssemblerMaxPackets.IsNull() && !data.AssemblerMaxPackets.IsUnknown() {
		body, _ = sjson.Set(body, "assembler.max-packets", strconv.FormatInt(data.AssemblerMaxPackets.ValueInt64(), 10))
	}
	if !data.AssemblerReassemblerDropEnable.IsNull() && !data.AssemblerReassemblerDropEnable.IsUnknown() {
		if data.AssemblerReassemblerDropEnable.ValueBool() {
			body, _ = sjson.Set(body, "assembler.reassembler-drop.enable", map[string]string{})
		}
	}
	if !data.AssemblerFragHdrIncompleteEnable.IsNull() && !data.AssemblerFragHdrIncompleteEnable.IsUnknown() {
		if data.AssemblerFragHdrIncompleteEnable.ValueBool() {
			body, _ = sjson.Set(body, "assembler.frag-hdr-incomplete.enable", map[string]string{})
		}
	}
	if !data.AssemblerOverlapFragDropEnable.IsNull() && !data.AssemblerOverlapFragDropEnable.IsUnknown() {
		if data.AssemblerOverlapFragDropEnable.ValueBool() {
			body, _ = sjson.Set(body, "assembler.overlap-frag-drop.enable", map[string]string{})
		}
	}
	if !data.PathMtuEnable.IsNull() && !data.PathMtuEnable.IsUnknown() {
		if data.PathMtuEnable.ValueBool() {
			body, _ = sjson.Set(body, "path-mtu.enable", map[string]string{})
		}
	}
	if !data.PathMtuTimeout.IsNull() && !data.PathMtuTimeout.IsUnknown() {
		body, _ = sjson.Set(body, "path-mtu.timeout", strconv.FormatInt(data.PathMtuTimeout.ValueInt64(), 10))
	}
	return body
}

// End of section. //template:end toBody

// Section below is generated&owned by "gen/generator.go". //template:begin toBodyXML

func (data IPv6) toBodyXML(ctx context.Context) string {
	body := netconf.Body{}
	if !data.HopLimit.IsNull() && !data.HopLimit.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/hop-limit", strconv.FormatInt(data.HopLimit.ValueInt64(), 10))
	}
	if !data.IcmpErrorInterval.IsNull() && !data.IcmpErrorInterval.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/icmp/error-interval/interval-time", strconv.FormatInt(data.IcmpErrorInterval.ValueInt64(), 10))
	}
	if !data.IcmpErrorIntervalBucketSize.IsNull() && !data.IcmpErrorIntervalBucketSize.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/icmp/error-interval/bucket-size", strconv.FormatInt(data.IcmpErrorIntervalBucketSize.ValueInt64(), 10))
	}
	if !data.SourceRoute.IsNull() && !data.SourceRoute.IsUnknown() {
		if data.SourceRoute.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/source-route", "")
		}
	}
	if !data.AssemblerTimeout.IsNull() && !data.AssemblerTimeout.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/assembler/timeout", strconv.FormatInt(data.AssemblerTimeout.ValueInt64(), 10))
	}
	if !data.AssemblerMaxPackets.IsNull() && !data.AssemblerMaxPackets.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/assembler/max-packets", strconv.FormatInt(data.AssemblerMaxPackets.ValueInt64(), 10))
	}
	if !data.AssemblerReassemblerDropEnable.IsNull() && !data.AssemblerReassemblerDropEnable.IsUnknown() {
		if data.AssemblerReassemblerDropEnable.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/assembler/reassembler-drop/enable", "")
		}
	}
	if !data.AssemblerFragHdrIncompleteEnable.IsNull() && !data.AssemblerFragHdrIncompleteEnable.IsUnknown() {
		if data.AssemblerFragHdrIncompleteEnable.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/assembler/frag-hdr-incomplete/enable", "")
		}
	}
	if !data.AssemblerOverlapFragDropEnable.IsNull() && !data.AssemblerOverlapFragDropEnable.IsUnknown() {
		if data.AssemblerOverlapFragDropEnable.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/assembler/overlap-frag-drop/enable", "")
		}
	}
	if !data.PathMtuEnable.IsNull() && !data.PathMtuEnable.IsUnknown() {
		if data.PathMtuEnable.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/path-mtu/enable", "")
		}
	}
	if !data.PathMtuTimeout.IsNull() && !data.PathMtuTimeout.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/path-mtu/timeout", strconv.FormatInt(data.PathMtuTimeout.ValueInt64(), 10))
	}
	bodyString, err := body.String()
	if err != nil {
		tflog.Error(ctx, fmt.Sprintf("Error converting body to string: %s", err))
	}
	return bodyString
}

// End of section. //template:end toBodyXML

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBody

func (data *IPv6) updateFromBody(ctx context.Context, res []byte) {
	if value := gjson.GetBytes(res, "hop-limit"); value.Exists() && !data.HopLimit.IsNull() {
		data.HopLimit = types.Int64Value(value.Int())
	} else if data.HopLimit.IsNull() {
		data.HopLimit = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "icmp.error-interval.interval-time"); value.Exists() && !data.IcmpErrorInterval.IsNull() {
		data.IcmpErrorInterval = types.Int64Value(value.Int())
	} else if data.IcmpErrorInterval.IsNull() {
		data.IcmpErrorInterval = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "icmp.error-interval.bucket-size"); value.Exists() && !data.IcmpErrorIntervalBucketSize.IsNull() {
		data.IcmpErrorIntervalBucketSize = types.Int64Value(value.Int())
	} else if data.IcmpErrorIntervalBucketSize.IsNull() {
		data.IcmpErrorIntervalBucketSize = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "source-route"); value.Exists() {
		// Only set to true if it was already in the plan (not null)
		if !data.SourceRoute.IsNull() {
			data.SourceRoute = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.SourceRoute.IsNull() {
			data.SourceRoute = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "assembler.timeout"); value.Exists() && !data.AssemblerTimeout.IsNull() {
		data.AssemblerTimeout = types.Int64Value(value.Int())
	} else if data.AssemblerTimeout.IsNull() {
		data.AssemblerTimeout = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "assembler.max-packets"); value.Exists() && !data.AssemblerMaxPackets.IsNull() {
		data.AssemblerMaxPackets = types.Int64Value(value.Int())
	} else if data.AssemblerMaxPackets.IsNull() {
		data.AssemblerMaxPackets = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "assembler.reassembler-drop.enable"); value.Exists() {
		// Only set to true if it was already in the plan (not null)
		if !data.AssemblerReassemblerDropEnable.IsNull() {
			data.AssemblerReassemblerDropEnable = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.AssemblerReassemblerDropEnable.IsNull() {
			data.AssemblerReassemblerDropEnable = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "assembler.frag-hdr-incomplete.enable"); value.Exists() {
		// Only set to true if it was already in the plan (not null)
		if !data.AssemblerFragHdrIncompleteEnable.IsNull() {
			data.AssemblerFragHdrIncompleteEnable = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.AssemblerFragHdrIncompleteEnable.IsNull() {
			data.AssemblerFragHdrIncompleteEnable = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "assembler.overlap-frag-drop.enable"); value.Exists() {
		// Only set to true if it was already in the plan (not null)
		if !data.AssemblerOverlapFragDropEnable.IsNull() {
			data.AssemblerOverlapFragDropEnable = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.AssemblerOverlapFragDropEnable.IsNull() {
			data.AssemblerOverlapFragDropEnable = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "path-mtu.enable"); value.Exists() {
		// Only set to true if it was already in the plan (not null)
		if !data.PathMtuEnable.IsNull() {
			data.PathMtuEnable = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.PathMtuEnable.IsNull() {
			data.PathMtuEnable = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "path-mtu.timeout"); value.Exists() && !data.PathMtuTimeout.IsNull() {
		data.PathMtuTimeout = types.Int64Value(value.Int())
	} else if data.PathMtuTimeout.IsNull() {
		data.PathMtuTimeout = types.Int64Null()
	}
}

// End of section. //template:end updateFromBody

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBodyXML

func (data *IPv6) updateFromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/hop-limit"); value.Exists() {
		data.HopLimit = types.Int64Value(value.Int())
	} else if data.HopLimit.IsNull() {
		data.HopLimit = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/icmp/error-interval/interval-time"); value.Exists() {
		data.IcmpErrorInterval = types.Int64Value(value.Int())
	} else if data.IcmpErrorInterval.IsNull() {
		data.IcmpErrorInterval = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/icmp/error-interval/bucket-size"); value.Exists() {
		data.IcmpErrorIntervalBucketSize = types.Int64Value(value.Int())
	} else if data.IcmpErrorIntervalBucketSize.IsNull() {
		data.IcmpErrorIntervalBucketSize = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/source-route"); value.Exists() {
		// Only set to true if it was already in the plan (not null)
		if !data.SourceRoute.IsNull() {
			data.SourceRoute = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.SourceRoute.IsNull() {
			data.SourceRoute = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/assembler/timeout"); value.Exists() {
		data.AssemblerTimeout = types.Int64Value(value.Int())
	} else if data.AssemblerTimeout.IsNull() {
		data.AssemblerTimeout = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/assembler/max-packets"); value.Exists() {
		data.AssemblerMaxPackets = types.Int64Value(value.Int())
	} else if data.AssemblerMaxPackets.IsNull() {
		data.AssemblerMaxPackets = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/assembler/reassembler-drop/enable"); value.Exists() {
		// Only set to true if it was already in the plan (not null)
		if !data.AssemblerReassemblerDropEnable.IsNull() {
			data.AssemblerReassemblerDropEnable = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.AssemblerReassemblerDropEnable.IsNull() {
			data.AssemblerReassemblerDropEnable = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/assembler/frag-hdr-incomplete/enable"); value.Exists() {
		// Only set to true if it was already in the plan (not null)
		if !data.AssemblerFragHdrIncompleteEnable.IsNull() {
			data.AssemblerFragHdrIncompleteEnable = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.AssemblerFragHdrIncompleteEnable.IsNull() {
			data.AssemblerFragHdrIncompleteEnable = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/assembler/overlap-frag-drop/enable"); value.Exists() {
		// Only set to true if it was already in the plan (not null)
		if !data.AssemblerOverlapFragDropEnable.IsNull() {
			data.AssemblerOverlapFragDropEnable = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.AssemblerOverlapFragDropEnable.IsNull() {
			data.AssemblerOverlapFragDropEnable = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/path-mtu/enable"); value.Exists() {
		// Only set to true if it was already in the plan (not null)
		if !data.PathMtuEnable.IsNull() {
			data.PathMtuEnable = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.PathMtuEnable.IsNull() {
			data.PathMtuEnable = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/path-mtu/timeout"); value.Exists() {
		data.PathMtuTimeout = types.Int64Value(value.Int())
	} else if data.PathMtuTimeout.IsNull() {
		data.PathMtuTimeout = types.Int64Null()
	}
}

// End of section. //template:end updateFromBodyXML
// Section below is generated&owned by "gen/generator.go". //template:begin fromBody

func (data *IPv6) fromBody(ctx context.Context, res gjson.Result) {
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	// Check if data is at root level (gNMI response case)
	if !res.Get(helpers.LastElement(data.getPath())).Exists() {
		prefix = ""
	}
	if value := res.Get(prefix + "hop-limit"); value.Exists() {
		data.HopLimit = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "icmp.error-interval.interval-time"); value.Exists() {
		data.IcmpErrorInterval = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "icmp.error-interval.bucket-size"); value.Exists() {
		data.IcmpErrorIntervalBucketSize = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "source-route"); value.Exists() {
		data.SourceRoute = types.BoolValue(true)
	} else if !data.SourceRoute.IsNull() {
		// Only set to false if it was previously set in state
		data.SourceRoute = types.BoolValue(false)
	}
	if value := res.Get(prefix + "assembler.timeout"); value.Exists() {
		data.AssemblerTimeout = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "assembler.max-packets"); value.Exists() {
		data.AssemblerMaxPackets = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "assembler.reassembler-drop.enable"); value.Exists() {
		data.AssemblerReassemblerDropEnable = types.BoolValue(true)
	} else if !data.AssemblerReassemblerDropEnable.IsNull() {
		// Only set to false if it was previously set in state
		data.AssemblerReassemblerDropEnable = types.BoolValue(false)
	}
	if value := res.Get(prefix + "assembler.frag-hdr-incomplete.enable"); value.Exists() {
		data.AssemblerFragHdrIncompleteEnable = types.BoolValue(true)
	} else if !data.AssemblerFragHdrIncompleteEnable.IsNull() {
		// Only set to false if it was previously set in state
		data.AssemblerFragHdrIncompleteEnable = types.BoolValue(false)
	}
	if value := res.Get(prefix + "assembler.overlap-frag-drop.enable"); value.Exists() {
		data.AssemblerOverlapFragDropEnable = types.BoolValue(true)
	} else if !data.AssemblerOverlapFragDropEnable.IsNull() {
		// Only set to false if it was previously set in state
		data.AssemblerOverlapFragDropEnable = types.BoolValue(false)
	}
	if value := res.Get(prefix + "path-mtu.enable"); value.Exists() {
		data.PathMtuEnable = types.BoolValue(true)
	} else if !data.PathMtuEnable.IsNull() {
		// Only set to false if it was previously set in state
		data.PathMtuEnable = types.BoolValue(false)
	}
	if value := res.Get(prefix + "path-mtu.timeout"); value.Exists() {
		data.PathMtuTimeout = types.Int64Value(value.Int())
	}
}

// End of section. //template:end fromBody
// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyData

func (data *IPv6Data) fromBody(ctx context.Context, res gjson.Result) {

	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	// Check if data is at root level (gNMI response case)
	if !res.Get(helpers.LastElement(data.getPath())).Exists() {
		prefix = ""
	}
	if value := res.Get(prefix + "hop-limit"); value.Exists() {
		data.HopLimit = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "icmp.error-interval.interval-time"); value.Exists() {
		data.IcmpErrorInterval = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "icmp.error-interval.bucket-size"); value.Exists() {
		data.IcmpErrorIntervalBucketSize = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "source-route"); value.Exists() {
		data.SourceRoute = types.BoolValue(true)
	} else {
		data.SourceRoute = types.BoolValue(false)
	}
	if value := res.Get(prefix + "assembler.timeout"); value.Exists() {
		data.AssemblerTimeout = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "assembler.max-packets"); value.Exists() {
		data.AssemblerMaxPackets = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "assembler.reassembler-drop.enable"); value.Exists() {
		data.AssemblerReassemblerDropEnable = types.BoolValue(true)
	} else {
		data.AssemblerReassemblerDropEnable = types.BoolValue(false)
	}
	if value := res.Get(prefix + "assembler.frag-hdr-incomplete.enable"); value.Exists() {
		data.AssemblerFragHdrIncompleteEnable = types.BoolValue(true)
	} else {
		data.AssemblerFragHdrIncompleteEnable = types.BoolValue(false)
	}
	if value := res.Get(prefix + "assembler.overlap-frag-drop.enable"); value.Exists() {
		data.AssemblerOverlapFragDropEnable = types.BoolValue(true)
	} else {
		data.AssemblerOverlapFragDropEnable = types.BoolValue(false)
	}
	if value := res.Get(prefix + "path-mtu.enable"); value.Exists() {
		data.PathMtuEnable = types.BoolValue(true)
	} else {
		data.PathMtuEnable = types.BoolValue(false)
	}
	if value := res.Get(prefix + "path-mtu.timeout"); value.Exists() {
		data.PathMtuTimeout = types.Int64Value(value.Int())
	}
}

// End of section. //template:end fromBodyData
// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyXML

func (data *IPv6) fromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/hop-limit"); value.Exists() {
		data.HopLimit = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/icmp/error-interval/interval-time"); value.Exists() {
		data.IcmpErrorInterval = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/icmp/error-interval/bucket-size"); value.Exists() {
		data.IcmpErrorIntervalBucketSize = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/source-route"); value.Exists() {
		data.SourceRoute = types.BoolValue(true)
	} else {
		data.SourceRoute = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/assembler/timeout"); value.Exists() {
		data.AssemblerTimeout = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/assembler/max-packets"); value.Exists() {
		data.AssemblerMaxPackets = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/assembler/reassembler-drop/enable"); value.Exists() {
		data.AssemblerReassemblerDropEnable = types.BoolValue(true)
	} else {
		data.AssemblerReassemblerDropEnable = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/assembler/frag-hdr-incomplete/enable"); value.Exists() {
		data.AssemblerFragHdrIncompleteEnable = types.BoolValue(true)
	} else {
		data.AssemblerFragHdrIncompleteEnable = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/assembler/overlap-frag-drop/enable"); value.Exists() {
		data.AssemblerOverlapFragDropEnable = types.BoolValue(true)
	} else {
		data.AssemblerOverlapFragDropEnable = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/path-mtu/enable"); value.Exists() {
		data.PathMtuEnable = types.BoolValue(true)
	} else {
		data.PathMtuEnable = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/path-mtu/timeout"); value.Exists() {
		data.PathMtuTimeout = types.Int64Value(value.Int())
	}
}

// End of section. //template:end fromBodyXML
// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyDataXML

func (data *IPv6Data) fromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/hop-limit"); value.Exists() {
		data.HopLimit = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/icmp/error-interval/interval-time"); value.Exists() {
		data.IcmpErrorInterval = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/icmp/error-interval/bucket-size"); value.Exists() {
		data.IcmpErrorIntervalBucketSize = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/source-route"); value.Exists() {
		data.SourceRoute = types.BoolValue(true)
	} else {
		data.SourceRoute = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/assembler/timeout"); value.Exists() {
		data.AssemblerTimeout = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/assembler/max-packets"); value.Exists() {
		data.AssemblerMaxPackets = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/assembler/reassembler-drop/enable"); value.Exists() {
		data.AssemblerReassemblerDropEnable = types.BoolValue(true)
	} else {
		data.AssemblerReassemblerDropEnable = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/assembler/frag-hdr-incomplete/enable"); value.Exists() {
		data.AssemblerFragHdrIncompleteEnable = types.BoolValue(true)
	} else {
		data.AssemblerFragHdrIncompleteEnable = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/assembler/overlap-frag-drop/enable"); value.Exists() {
		data.AssemblerOverlapFragDropEnable = types.BoolValue(true)
	} else {
		data.AssemblerOverlapFragDropEnable = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/path-mtu/enable"); value.Exists() {
		data.PathMtuEnable = types.BoolValue(true)
	} else {
		data.PathMtuEnable = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data/"+data.getXPath()+"/path-mtu/timeout"); value.Exists() {
		data.PathMtuTimeout = types.Int64Value(value.Int())
	}
}

// End of section. //template:end fromBodyDataXML
// Section below is generated&owned by "gen/generator.go". //template:begin getDeletedItems

func (data *IPv6) getDeletedItems(ctx context.Context, state IPv6) []string {
	deletedItems := make([]string, 0)
	if !state.PathMtuTimeout.IsNull() && data.PathMtuTimeout.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/path-mtu/timeout", state.getPath()))
	}
	if !state.PathMtuEnable.IsNull() && data.PathMtuEnable.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/path-mtu/enable", state.getPath()))
	}
	if !state.AssemblerOverlapFragDropEnable.IsNull() && data.AssemblerOverlapFragDropEnable.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/assembler/overlap-frag-drop/enable", state.getPath()))
	}
	if !state.AssemblerFragHdrIncompleteEnable.IsNull() && data.AssemblerFragHdrIncompleteEnable.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/assembler/frag-hdr-incomplete/enable", state.getPath()))
	}
	if !state.AssemblerReassemblerDropEnable.IsNull() && data.AssemblerReassemblerDropEnable.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/assembler/reassembler-drop/enable", state.getPath()))
	}
	if !state.AssemblerMaxPackets.IsNull() && data.AssemblerMaxPackets.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/assembler/max-packets", state.getPath()))
	}
	if !state.AssemblerTimeout.IsNull() && data.AssemblerTimeout.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/assembler/timeout", state.getPath()))
	}
	if !state.SourceRoute.IsNull() && data.SourceRoute.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/source-route", state.getPath()))
	}
	if !state.IcmpErrorIntervalBucketSize.IsNull() && data.IcmpErrorIntervalBucketSize.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/icmp/error-interval", state.getPath()))
	}
	if !state.IcmpErrorInterval.IsNull() && data.IcmpErrorInterval.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/icmp/error-interval", state.getPath()))
	}
	if !state.HopLimit.IsNull() && data.HopLimit.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/hop-limit", state.getPath()))
	}
	return deletedItems
}

// End of section. //template:end getDeletedItems
// Section below is generated&owned by "gen/generator.go". //template:begin getEmptyLeafsDelete

func (data *IPv6) getEmptyLeafsDelete(ctx context.Context, state *IPv6) []string {
	emptyLeafsDelete := make([]string, 0)
	// Only delete if state has true and plan has false
	if !data.PathMtuEnable.IsNull() && !data.PathMtuEnable.ValueBool() {
		if state != nil && !state.PathMtuEnable.IsNull() && state.PathMtuEnable.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/path-mtu/enable", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.AssemblerOverlapFragDropEnable.IsNull() && !data.AssemblerOverlapFragDropEnable.ValueBool() {
		if state != nil && !state.AssemblerOverlapFragDropEnable.IsNull() && state.AssemblerOverlapFragDropEnable.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/assembler/overlap-frag-drop/enable", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.AssemblerFragHdrIncompleteEnable.IsNull() && !data.AssemblerFragHdrIncompleteEnable.ValueBool() {
		if state != nil && !state.AssemblerFragHdrIncompleteEnable.IsNull() && state.AssemblerFragHdrIncompleteEnable.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/assembler/frag-hdr-incomplete/enable", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.AssemblerReassemblerDropEnable.IsNull() && !data.AssemblerReassemblerDropEnable.ValueBool() {
		if state != nil && !state.AssemblerReassemblerDropEnable.IsNull() && state.AssemblerReassemblerDropEnable.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/assembler/reassembler-drop/enable", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.SourceRoute.IsNull() && !data.SourceRoute.ValueBool() {
		if state != nil && !state.SourceRoute.IsNull() && state.SourceRoute.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/source-route", data.getXPath()))
		}
	}
	return emptyLeafsDelete
}

// End of section. //template:end getEmptyLeafsDelete
// Section below is generated&owned by "gen/generator.go". //template:begin getDeletePaths

func (data *IPv6) getDeletePaths(ctx context.Context) []string {
	var deletePaths []string
	if !data.PathMtuTimeout.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/path-mtu/timeout", data.getPath()))
	}
	if !data.PathMtuEnable.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/path-mtu/enable", data.getPath()))
	}
	if !data.AssemblerOverlapFragDropEnable.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/assembler/overlap-frag-drop/enable", data.getPath()))
	}
	if !data.AssemblerFragHdrIncompleteEnable.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/assembler/frag-hdr-incomplete/enable", data.getPath()))
	}
	if !data.AssemblerReassemblerDropEnable.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/assembler/reassembler-drop/enable", data.getPath()))
	}
	if !data.AssemblerMaxPackets.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/assembler/max-packets", data.getPath()))
	}
	if !data.AssemblerTimeout.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/assembler/timeout", data.getPath()))
	}
	if !data.SourceRoute.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/source-route", data.getPath()))
	}
	if !data.IcmpErrorIntervalBucketSize.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/icmp/error-interval", data.getPath()))
	}
	if !data.IcmpErrorInterval.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/icmp/error-interval", data.getPath()))
	}
	if !data.HopLimit.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/hop-limit", data.getPath()))
	}

	return deletePaths
}

// End of section. //template:end getDeletePaths
// Section below is generated&owned by "gen/generator.go". //template:begin addDeletedItemsXML

func (data *IPv6) addDeletedItemsXML(ctx context.Context, state IPv6, body string) string {
	deleteXml := ""
	deletedPaths := make(map[string]bool)
	_ = deletedPaths // Avoid unused variable error when no delete_parent attributes exist
	if !state.PathMtuTimeout.IsNull() && data.PathMtuTimeout.IsNull() {
		deletePath := state.getXPath() + "/path-mtu/timeout"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.PathMtuEnable.IsNull() && state.PathMtuEnable.ValueBool() && data.PathMtuEnable.IsNull() {
		deletePath := state.getXPath() + "/path-mtu/enable"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.AssemblerOverlapFragDropEnable.IsNull() && state.AssemblerOverlapFragDropEnable.ValueBool() && data.AssemblerOverlapFragDropEnable.IsNull() {
		deletePath := state.getXPath() + "/assembler/overlap-frag-drop/enable"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.AssemblerFragHdrIncompleteEnable.IsNull() && state.AssemblerFragHdrIncompleteEnable.ValueBool() && data.AssemblerFragHdrIncompleteEnable.IsNull() {
		deletePath := state.getXPath() + "/assembler/frag-hdr-incomplete/enable"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.AssemblerReassemblerDropEnable.IsNull() && state.AssemblerReassemblerDropEnable.ValueBool() && data.AssemblerReassemblerDropEnable.IsNull() {
		deletePath := state.getXPath() + "/assembler/reassembler-drop/enable"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.AssemblerMaxPackets.IsNull() && data.AssemblerMaxPackets.IsNull() {
		deletePath := state.getXPath() + "/assembler/max-packets"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.AssemblerTimeout.IsNull() && data.AssemblerTimeout.IsNull() {
		deletePath := state.getXPath() + "/assembler/timeout"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.SourceRoute.IsNull() && state.SourceRoute.ValueBool() && data.SourceRoute.IsNull() {
		deletePath := state.getXPath() + "/source-route"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.IcmpErrorIntervalBucketSize.IsNull() && data.IcmpErrorIntervalBucketSize.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/icmp/error-interval"
		predicates := make(map[string]string)
		if !state.IcmpErrorInterval.IsNull() {
			predicates["interval-time"] = fmt.Sprintf("%v", state.IcmpErrorInterval.ValueInt64())
		}
		predicates["bucket-size"] = fmt.Sprintf("%v", state.IcmpErrorIntervalBucketSize.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.IcmpErrorInterval.IsNull() && data.IcmpErrorInterval.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/icmp/error-interval"
		predicates := make(map[string]string)
		if !state.IcmpErrorIntervalBucketSize.IsNull() {
			predicates["bucket-size"] = fmt.Sprintf("%v", state.IcmpErrorIntervalBucketSize.ValueInt64())
		}
		predicates["interval-time"] = fmt.Sprintf("%v", state.IcmpErrorInterval.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.HopLimit.IsNull() && data.HopLimit.IsNull() {
		deletePath := state.getXPath() + "/hop-limit"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}

	b := netconf.NewBody(deleteXml)
	b = helpers.CleanupRedundantRemoveOperations(b)
	return b.Res()
}

// End of section. //template:end addDeletedItemsXML
// Section below is generated&owned by "gen/generator.go". //template:begin addDeletePathsXML

func (data *IPv6) addDeletePathsXML(ctx context.Context, body string) string {
	b := netconf.NewBody(body)
	if !data.PathMtuTimeout.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/path-mtu/timeout")
	}
	if !data.PathMtuEnable.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/path-mtu/enable")
	}
	if !data.AssemblerOverlapFragDropEnable.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/assembler/overlap-frag-drop/enable")
	}
	if !data.AssemblerFragHdrIncompleteEnable.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/assembler/frag-hdr-incomplete/enable")
	}
	if !data.AssemblerReassemblerDropEnable.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/assembler/reassembler-drop/enable")
	}
	if !data.AssemblerMaxPackets.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/assembler/max-packets")
	}
	if !data.AssemblerTimeout.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/assembler/timeout")
	}
	if !data.SourceRoute.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/source-route")
	}
	if !data.IcmpErrorIntervalBucketSize.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/icmp/error-interval")
	}
	if !data.IcmpErrorInterval.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/icmp/error-interval")
	}
	if !data.HopLimit.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/hop-limit")
	}

	b = helpers.CleanupRedundantRemoveOperations(b)
	return b.Res()
}

// End of section. //template:end addDeletePathsXML
