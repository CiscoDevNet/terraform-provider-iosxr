// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports
import (
	"context"
	"fmt"
	"reflect"
	"strconv"

	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin types
type L2VPNXconnectGroup struct {
	Device     types.String             `tfsdk:"device"`
	Id         types.String             `tfsdk:"id"`
	DeleteMode types.String             `tfsdk:"delete_mode"`
	GroupName  types.String             `tfsdk:"group_name"`
	P2ps       []L2VPNXconnectGroupP2ps `tfsdk:"p2ps"`
}

type L2VPNXconnectGroupData struct {
	Device    types.String             `tfsdk:"device"`
	Id        types.String             `tfsdk:"id"`
	GroupName types.String             `tfsdk:"group_name"`
	P2ps      []L2VPNXconnectGroupP2ps `tfsdk:"p2ps"`
}
type L2VPNXconnectGroupP2ps struct {
	P2pXconnectName                    types.String                                               `tfsdk:"p2p_xconnect_name"`
	Description                        types.String                                               `tfsdk:"description"`
	Interfaces                         []L2VPNXconnectGroupP2psInterfaces                         `tfsdk:"interfaces"`
	InterworkingIpv4                   types.Bool                                                 `tfsdk:"interworking_ipv4"`
	InterworkingEthernet               types.Bool                                                 `tfsdk:"interworking_ethernet"`
	BackupInterfaces                   []L2VPNXconnectGroupP2psBackupInterfaces                   `tfsdk:"backup_interfaces"`
	Ipv4Neighbors                      []L2VPNXconnectGroupP2psIpv4Neighbors                      `tfsdk:"ipv4_neighbors"`
	Ipv6Neighbors                      []L2VPNXconnectGroupP2psIpv6Neighbors                      `tfsdk:"ipv6_neighbors"`
	EvpnTargetNeighbors                []L2VPNXconnectGroupP2psEvpnTargetNeighbors                `tfsdk:"evpn_target_neighbors"`
	EvpnServiceNeighbors               []L2VPNXconnectGroupP2psEvpnServiceNeighbors               `tfsdk:"evpn_service_neighbors"`
	EvpnTargetNeighborsSegmentRouting  []L2VPNXconnectGroupP2psEvpnTargetNeighborsSegmentRouting  `tfsdk:"evpn_target_neighbors_segment_routing"`
	EvpnServiceNeighborsSegmentRouting []L2VPNXconnectGroupP2psEvpnServiceNeighborsSegmentRouting `tfsdk:"evpn_service_neighbors_segment_routing"`
}
type L2VPNXconnectGroupP2psInterfaces struct {
	InterfaceName types.String `tfsdk:"interface_name"`
}
type L2VPNXconnectGroupP2psBackupInterfaces struct {
	InterfaceName types.String `tfsdk:"interface_name"`
}
type L2VPNXconnectGroupP2psIpv4Neighbors struct {
	Address               types.String `tfsdk:"address"`
	PwId                  types.Int64  `tfsdk:"pw_id"`
	PwClass               types.String `tfsdk:"pw_class"`
	Bandwidth             types.Int64  `tfsdk:"bandwidth"`
	BackupNeighbors       types.List   `tfsdk:"backup_neighbors"`
	MplsStaticLabelLocal  types.Int64  `tfsdk:"mpls_static_label_local"`
	MplsStaticLabelRemote types.Int64  `tfsdk:"mpls_static_label_remote"`
	TagImposeVlan         types.Int64  `tfsdk:"tag_impose_vlan"`
}
type L2VPNXconnectGroupP2psIpv6Neighbors struct {
	Address               types.String `tfsdk:"address"`
	PwId                  types.Int64  `tfsdk:"pw_id"`
	PwClass               types.String `tfsdk:"pw_class"`
	BackupNeighbors       types.List   `tfsdk:"backup_neighbors"`
	MplsStaticLabelLocal  types.Int64  `tfsdk:"mpls_static_label_local"`
	MplsStaticLabelRemote types.Int64  `tfsdk:"mpls_static_label_remote"`
	TagImposeVlan         types.Int64  `tfsdk:"tag_impose_vlan"`
	SourceIpv6Address     types.String `tfsdk:"source_ipv6_address"`
}
type L2VPNXconnectGroupP2psEvpnTargetNeighbors struct {
	VpnId      types.Int64  `tfsdk:"vpn_id"`
	RemoteAcId types.Int64  `tfsdk:"remote_ac_id"`
	Source     types.Int64  `tfsdk:"source"`
	PwClass    types.String `tfsdk:"pw_class"`
}
type L2VPNXconnectGroupP2psEvpnServiceNeighbors struct {
	VpnId     types.Int64  `tfsdk:"vpn_id"`
	ServiceId types.Int64  `tfsdk:"service_id"`
	PwClass   types.String `tfsdk:"pw_class"`
}
type L2VPNXconnectGroupP2psEvpnTargetNeighborsSegmentRouting struct {
	VpnId                     types.Int64  `tfsdk:"vpn_id"`
	RemoteAcId                types.Int64  `tfsdk:"remote_ac_id"`
	Source                    types.Int64  `tfsdk:"source"`
	SegmentRoutingSrv6Locator types.String `tfsdk:"segment_routing_srv6_locator"`
}
type L2VPNXconnectGroupP2psEvpnServiceNeighborsSegmentRouting struct {
	VpnId                     types.Int64  `tfsdk:"vpn_id"`
	ServiceId                 types.Int64  `tfsdk:"service_id"`
	SegmentRoutingSrv6Locator types.String `tfsdk:"segment_routing_srv6_locator"`
}

// End of section. //template:end types

// Section below is generated&owned by "gen/generator.go". //template:begin getPath

func (data L2VPNXconnectGroup) getPath() string {
	return fmt.Sprintf("Cisco-IOS-XR-um-l2vpn-cfg:/l2vpn/xconnect/groups/group[group-name=%s]", data.GroupName.ValueString())
}

func (data L2VPNXconnectGroupData) getPath() string {
	return fmt.Sprintf("Cisco-IOS-XR-um-l2vpn-cfg:/l2vpn/xconnect/groups/group[group-name=%s]", data.GroupName.ValueString())
}

// End of section. //template:end getPath

// Section below is generated&owned by "gen/generator.go". //template:begin toBody

func (data L2VPNXconnectGroup) toBody(ctx context.Context) string {
	body := "{}"
	if !data.GroupName.IsNull() && !data.GroupName.IsUnknown() {
		body, _ = sjson.Set(body, "group-name", data.GroupName.ValueString())
	}
	if len(data.P2ps) > 0 {
		body, _ = sjson.Set(body, "p2ps.p2p", []interface{}{})
		for index, item := range data.P2ps {
			if !item.P2pXconnectName.IsNull() && !item.P2pXconnectName.IsUnknown() {
				body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"p2p-xconnect-name", item.P2pXconnectName.ValueString())
			}
			if !item.Description.IsNull() && !item.Description.IsUnknown() {
				body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"description", item.Description.ValueString())
			}
			if !item.InterworkingIpv4.IsNull() && !item.InterworkingIpv4.IsUnknown() {
				if item.InterworkingIpv4.ValueBool() {
					body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"interworking.ipv4", map[string]string{})
				}
			}
			if !item.InterworkingEthernet.IsNull() && !item.InterworkingEthernet.IsUnknown() {
				if item.InterworkingEthernet.ValueBool() {
					body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"interworking.ethernet", map[string]string{})
				}
			}
			if len(item.Interfaces) > 0 {
				body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"interfaces.interface", []interface{}{})
				for cindex, citem := range item.Interfaces {
					if !citem.InterfaceName.IsNull() && !citem.InterfaceName.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"interfaces.interface"+"."+strconv.Itoa(cindex)+"."+"interface-name", citem.InterfaceName.ValueString())
					}
				}
			}
			if len(item.BackupInterfaces) > 0 {
				body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"backup.interface", []interface{}{})
				for cindex, citem := range item.BackupInterfaces {
					if !citem.InterfaceName.IsNull() && !citem.InterfaceName.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"backup.interface"+"."+strconv.Itoa(cindex)+"."+"interface-name", citem.InterfaceName.ValueString())
					}
				}
			}
			if len(item.Ipv4Neighbors) > 0 {
				body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.ipv4s.ipv4", []interface{}{})
				for cindex, citem := range item.Ipv4Neighbors {
					if !citem.Address.IsNull() && !citem.Address.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.ipv4s.ipv4"+"."+strconv.Itoa(cindex)+"."+"address", citem.Address.ValueString())
					}
					if !citem.PwId.IsNull() && !citem.PwId.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.ipv4s.ipv4"+"."+strconv.Itoa(cindex)+"."+"pw-id", strconv.FormatInt(citem.PwId.ValueInt64(), 10))
					}
					if !citem.PwClass.IsNull() && !citem.PwClass.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.ipv4s.ipv4"+"."+strconv.Itoa(cindex)+"."+"pw-class", citem.PwClass.ValueString())
					}
					if !citem.Bandwidth.IsNull() && !citem.Bandwidth.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.ipv4s.ipv4"+"."+strconv.Itoa(cindex)+"."+"bandwidth", strconv.FormatInt(citem.Bandwidth.ValueInt64(), 10))
					}
					if !citem.BackupNeighbors.IsNull() && !citem.BackupNeighbors.IsUnknown() {
					}
					if !citem.MplsStaticLabelLocal.IsNull() && !citem.MplsStaticLabelLocal.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.ipv4s.ipv4"+"."+strconv.Itoa(cindex)+"."+"mpls.static.label.local", strconv.FormatInt(citem.MplsStaticLabelLocal.ValueInt64(), 10))
					}
					if !citem.MplsStaticLabelRemote.IsNull() && !citem.MplsStaticLabelRemote.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.ipv4s.ipv4"+"."+strconv.Itoa(cindex)+"."+"mpls.static.label.remote", strconv.FormatInt(citem.MplsStaticLabelRemote.ValueInt64(), 10))
					}
					if !citem.TagImposeVlan.IsNull() && !citem.TagImposeVlan.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.ipv4s.ipv4"+"."+strconv.Itoa(cindex)+"."+"tag-impose.vlan", strconv.FormatInt(citem.TagImposeVlan.ValueInt64(), 10))
					}
				}
			}
			if len(item.Ipv6Neighbors) > 0 {
				body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.ipv6s.ipv6", []interface{}{})
				for cindex, citem := range item.Ipv6Neighbors {
					if !citem.Address.IsNull() && !citem.Address.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.ipv6s.ipv6"+"."+strconv.Itoa(cindex)+"."+"address", citem.Address.ValueString())
					}
					if !citem.PwId.IsNull() && !citem.PwId.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.ipv6s.ipv6"+"."+strconv.Itoa(cindex)+"."+"pw-id", strconv.FormatInt(citem.PwId.ValueInt64(), 10))
					}
					if !citem.PwClass.IsNull() && !citem.PwClass.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.ipv6s.ipv6"+"."+strconv.Itoa(cindex)+"."+"pw-class", citem.PwClass.ValueString())
					}
					if !citem.BackupNeighbors.IsNull() && !citem.BackupNeighbors.IsUnknown() {
					}
					if !citem.MplsStaticLabelLocal.IsNull() && !citem.MplsStaticLabelLocal.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.ipv6s.ipv6"+"."+strconv.Itoa(cindex)+"."+"mpls.static.label.local", strconv.FormatInt(citem.MplsStaticLabelLocal.ValueInt64(), 10))
					}
					if !citem.MplsStaticLabelRemote.IsNull() && !citem.MplsStaticLabelRemote.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.ipv6s.ipv6"+"."+strconv.Itoa(cindex)+"."+"mpls.static.label.remote", strconv.FormatInt(citem.MplsStaticLabelRemote.ValueInt64(), 10))
					}
					if !citem.TagImposeVlan.IsNull() && !citem.TagImposeVlan.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.ipv6s.ipv6"+"."+strconv.Itoa(cindex)+"."+"tag-impose.vlan", strconv.FormatInt(citem.TagImposeVlan.ValueInt64(), 10))
					}
					if !citem.SourceIpv6Address.IsNull() && !citem.SourceIpv6Address.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.ipv6s.ipv6"+"."+strconv.Itoa(cindex)+"."+"source.ipv6-address", citem.SourceIpv6Address.ValueString())
					}
				}
			}
			if len(item.EvpnTargetNeighbors) > 0 {
				body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.evpn.evi.targets.target", []interface{}{})
				for cindex, citem := range item.EvpnTargetNeighbors {
					if !citem.VpnId.IsNull() && !citem.VpnId.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.evpn.evi.targets.target"+"."+strconv.Itoa(cindex)+"."+"vpn-id", strconv.FormatInt(citem.VpnId.ValueInt64(), 10))
					}
					if !citem.RemoteAcId.IsNull() && !citem.RemoteAcId.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.evpn.evi.targets.target"+"."+strconv.Itoa(cindex)+"."+"remote-ac-id", strconv.FormatInt(citem.RemoteAcId.ValueInt64(), 10))
					}
					if !citem.Source.IsNull() && !citem.Source.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.evpn.evi.targets.target"+"."+strconv.Itoa(cindex)+"."+"source", strconv.FormatInt(citem.Source.ValueInt64(), 10))
					}
					if !citem.PwClass.IsNull() && !citem.PwClass.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.evpn.evi.targets.target"+"."+strconv.Itoa(cindex)+"."+"pw-class", citem.PwClass.ValueString())
					}
				}
			}
			if len(item.EvpnServiceNeighbors) > 0 {
				body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.evpn.evi.services.service", []interface{}{})
				for cindex, citem := range item.EvpnServiceNeighbors {
					if !citem.VpnId.IsNull() && !citem.VpnId.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.evpn.evi.services.service"+"."+strconv.Itoa(cindex)+"."+"vpn-id", strconv.FormatInt(citem.VpnId.ValueInt64(), 10))
					}
					if !citem.ServiceId.IsNull() && !citem.ServiceId.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.evpn.evi.services.service"+"."+strconv.Itoa(cindex)+"."+"service-id", strconv.FormatInt(citem.ServiceId.ValueInt64(), 10))
					}
					if !citem.PwClass.IsNull() && !citem.PwClass.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.evpn.evi.services.service"+"."+strconv.Itoa(cindex)+"."+"pw-class", citem.PwClass.ValueString())
					}
				}
			}
			if len(item.EvpnTargetNeighborsSegmentRouting) > 0 {
				body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.evpn.evi.segment-routing-targets.target", []interface{}{})
				for cindex, citem := range item.EvpnTargetNeighborsSegmentRouting {
					if !citem.VpnId.IsNull() && !citem.VpnId.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.evpn.evi.segment-routing-targets.target"+"."+strconv.Itoa(cindex)+"."+"vpn-id", strconv.FormatInt(citem.VpnId.ValueInt64(), 10))
					}
					if !citem.RemoteAcId.IsNull() && !citem.RemoteAcId.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.evpn.evi.segment-routing-targets.target"+"."+strconv.Itoa(cindex)+"."+"remote-ac-id", strconv.FormatInt(citem.RemoteAcId.ValueInt64(), 10))
					}
					if !citem.Source.IsNull() && !citem.Source.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.evpn.evi.segment-routing-targets.target"+"."+strconv.Itoa(cindex)+"."+"source", strconv.FormatInt(citem.Source.ValueInt64(), 10))
					}
					if !citem.SegmentRoutingSrv6Locator.IsNull() && !citem.SegmentRoutingSrv6Locator.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.evpn.evi.segment-routing-targets.target"+"."+strconv.Itoa(cindex)+"."+"segment-routing.srv6.locator", citem.SegmentRoutingSrv6Locator.ValueString())
					}
				}
			}
			if len(item.EvpnServiceNeighborsSegmentRouting) > 0 {
				body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.evpn.evi.segment-routing-services.service", []interface{}{})
				for cindex, citem := range item.EvpnServiceNeighborsSegmentRouting {
					if !citem.VpnId.IsNull() && !citem.VpnId.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.evpn.evi.segment-routing-services.service"+"."+strconv.Itoa(cindex)+"."+"vpn-id", strconv.FormatInt(citem.VpnId.ValueInt64(), 10))
					}
					if !citem.ServiceId.IsNull() && !citem.ServiceId.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.evpn.evi.segment-routing-services.service"+"."+strconv.Itoa(cindex)+"."+"service-id", strconv.FormatInt(citem.ServiceId.ValueInt64(), 10))
					}
					if !citem.SegmentRoutingSrv6Locator.IsNull() && !citem.SegmentRoutingSrv6Locator.IsUnknown() {
						body, _ = sjson.Set(body, "p2ps.p2p"+"."+strconv.Itoa(index)+"."+"neighbor.evpn.evi.segment-routing-services.service"+"."+strconv.Itoa(cindex)+"."+"segment-routing.srv6.locator", citem.SegmentRoutingSrv6Locator.ValueString())
					}
				}
			}
		}
	}
	return body
}

// End of section. //template:end toBody

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBody

func (data *L2VPNXconnectGroup) updateFromBody(ctx context.Context, res []byte) {
	for i := range data.P2ps {
		keys := [...]string{"p2p-xconnect-name"}
		keyValues := [...]string{data.P2ps[i].P2pXconnectName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "p2ps.p2p").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("p2p-xconnect-name"); value.Exists() && !data.P2ps[i].P2pXconnectName.IsNull() {
			data.P2ps[i].P2pXconnectName = types.StringValue(value.String())
		} else {
			data.P2ps[i].P2pXconnectName = types.StringNull()
		}
		if value := r.Get("description"); value.Exists() && !data.P2ps[i].Description.IsNull() {
			data.P2ps[i].Description = types.StringValue(value.String())
		} else {
			data.P2ps[i].Description = types.StringNull()
		}
		for ci := range data.P2ps[i].Interfaces {
			keys := [...]string{"interface-name"}
			keyValues := [...]string{data.P2ps[i].Interfaces[ci].InterfaceName.ValueString()}

			var cr gjson.Result
			r.Get("interfaces.interface").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("interface-name"); value.Exists() && !data.P2ps[i].Interfaces[ci].InterfaceName.IsNull() {
				data.P2ps[i].Interfaces[ci].InterfaceName = types.StringValue(value.String())
			} else {
				data.P2ps[i].Interfaces[ci].InterfaceName = types.StringNull()
			}
		}
		if value := r.Get("interworking.ipv4"); !data.P2ps[i].InterworkingIpv4.IsNull() {
			if value.Exists() {
				data.P2ps[i].InterworkingIpv4 = types.BoolValue(true)
			} else {
				data.P2ps[i].InterworkingIpv4 = types.BoolValue(false)
			}
		} else {
			data.P2ps[i].InterworkingIpv4 = types.BoolNull()
		}
		if value := r.Get("interworking.ethernet"); !data.P2ps[i].InterworkingEthernet.IsNull() {
			if value.Exists() {
				data.P2ps[i].InterworkingEthernet = types.BoolValue(true)
			} else {
				data.P2ps[i].InterworkingEthernet = types.BoolValue(false)
			}
		} else {
			data.P2ps[i].InterworkingEthernet = types.BoolNull()
		}
		for ci := range data.P2ps[i].BackupInterfaces {
			keys := [...]string{"interface-name"}
			keyValues := [...]string{data.P2ps[i].BackupInterfaces[ci].InterfaceName.ValueString()}

			var cr gjson.Result
			r.Get("backup.interface").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("interface-name"); value.Exists() && !data.P2ps[i].BackupInterfaces[ci].InterfaceName.IsNull() {
				data.P2ps[i].BackupInterfaces[ci].InterfaceName = types.StringValue(value.String())
			} else {
				data.P2ps[i].BackupInterfaces[ci].InterfaceName = types.StringNull()
			}
		}
		for ci := range data.P2ps[i].Ipv4Neighbors {
			keys := [...]string{"address", "pw-id"}
			keyValues := [...]string{data.P2ps[i].Ipv4Neighbors[ci].Address.ValueString(), strconv.FormatInt(data.P2ps[i].Ipv4Neighbors[ci].PwId.ValueInt64(), 10)}

			var cr gjson.Result
			r.Get("neighbor.ipv4s.ipv4").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("address"); value.Exists() && !data.P2ps[i].Ipv4Neighbors[ci].Address.IsNull() {
				data.P2ps[i].Ipv4Neighbors[ci].Address = types.StringValue(value.String())
			} else {
				data.P2ps[i].Ipv4Neighbors[ci].Address = types.StringNull()
			}
			if value := cr.Get("pw-id"); value.Exists() && !data.P2ps[i].Ipv4Neighbors[ci].PwId.IsNull() {
				data.P2ps[i].Ipv4Neighbors[ci].PwId = types.Int64Value(value.Int())
			} else {
				data.P2ps[i].Ipv4Neighbors[ci].PwId = types.Int64Null()
			}
			if value := cr.Get("pw-class"); value.Exists() && !data.P2ps[i].Ipv4Neighbors[ci].PwClass.IsNull() {
				data.P2ps[i].Ipv4Neighbors[ci].PwClass = types.StringValue(value.String())
			} else {
				data.P2ps[i].Ipv4Neighbors[ci].PwClass = types.StringNull()
			}
			if value := cr.Get("bandwidth"); value.Exists() && !data.P2ps[i].Ipv4Neighbors[ci].Bandwidth.IsNull() {
				data.P2ps[i].Ipv4Neighbors[ci].Bandwidth = types.Int64Value(value.Int())
			} else {
				data.P2ps[i].Ipv4Neighbors[ci].Bandwidth = types.Int64Null()
			}
			if value := cr.Get("mpls.static.label.local"); value.Exists() && !data.P2ps[i].Ipv4Neighbors[ci].MplsStaticLabelLocal.IsNull() {
				data.P2ps[i].Ipv4Neighbors[ci].MplsStaticLabelLocal = types.Int64Value(value.Int())
			} else {
				data.P2ps[i].Ipv4Neighbors[ci].MplsStaticLabelLocal = types.Int64Null()
			}
			if value := cr.Get("mpls.static.label.remote"); value.Exists() && !data.P2ps[i].Ipv4Neighbors[ci].MplsStaticLabelRemote.IsNull() {
				data.P2ps[i].Ipv4Neighbors[ci].MplsStaticLabelRemote = types.Int64Value(value.Int())
			} else {
				data.P2ps[i].Ipv4Neighbors[ci].MplsStaticLabelRemote = types.Int64Null()
			}
			if value := cr.Get("tag-impose.vlan"); value.Exists() && !data.P2ps[i].Ipv4Neighbors[ci].TagImposeVlan.IsNull() {
				data.P2ps[i].Ipv4Neighbors[ci].TagImposeVlan = types.Int64Value(value.Int())
			} else {
				data.P2ps[i].Ipv4Neighbors[ci].TagImposeVlan = types.Int64Null()
			}
		}
		for ci := range data.P2ps[i].Ipv6Neighbors {
			keys := [...]string{"address", "pw-id"}
			keyValues := [...]string{data.P2ps[i].Ipv6Neighbors[ci].Address.ValueString(), strconv.FormatInt(data.P2ps[i].Ipv6Neighbors[ci].PwId.ValueInt64(), 10)}

			var cr gjson.Result
			r.Get("neighbor.ipv6s.ipv6").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("address"); value.Exists() && !data.P2ps[i].Ipv6Neighbors[ci].Address.IsNull() {
				data.P2ps[i].Ipv6Neighbors[ci].Address = types.StringValue(value.String())
			} else {
				data.P2ps[i].Ipv6Neighbors[ci].Address = types.StringNull()
			}
			if value := cr.Get("pw-id"); value.Exists() && !data.P2ps[i].Ipv6Neighbors[ci].PwId.IsNull() {
				data.P2ps[i].Ipv6Neighbors[ci].PwId = types.Int64Value(value.Int())
			} else {
				data.P2ps[i].Ipv6Neighbors[ci].PwId = types.Int64Null()
			}
			if value := cr.Get("pw-class"); value.Exists() && !data.P2ps[i].Ipv6Neighbors[ci].PwClass.IsNull() {
				data.P2ps[i].Ipv6Neighbors[ci].PwClass = types.StringValue(value.String())
			} else {
				data.P2ps[i].Ipv6Neighbors[ci].PwClass = types.StringNull()
			}
			if value := cr.Get("mpls.static.label.local"); value.Exists() && !data.P2ps[i].Ipv6Neighbors[ci].MplsStaticLabelLocal.IsNull() {
				data.P2ps[i].Ipv6Neighbors[ci].MplsStaticLabelLocal = types.Int64Value(value.Int())
			} else {
				data.P2ps[i].Ipv6Neighbors[ci].MplsStaticLabelLocal = types.Int64Null()
			}
			if value := cr.Get("mpls.static.label.remote"); value.Exists() && !data.P2ps[i].Ipv6Neighbors[ci].MplsStaticLabelRemote.IsNull() {
				data.P2ps[i].Ipv6Neighbors[ci].MplsStaticLabelRemote = types.Int64Value(value.Int())
			} else {
				data.P2ps[i].Ipv6Neighbors[ci].MplsStaticLabelRemote = types.Int64Null()
			}
			if value := cr.Get("tag-impose.vlan"); value.Exists() && !data.P2ps[i].Ipv6Neighbors[ci].TagImposeVlan.IsNull() {
				data.P2ps[i].Ipv6Neighbors[ci].TagImposeVlan = types.Int64Value(value.Int())
			} else {
				data.P2ps[i].Ipv6Neighbors[ci].TagImposeVlan = types.Int64Null()
			}
			if value := cr.Get("source.ipv6-address"); value.Exists() && !data.P2ps[i].Ipv6Neighbors[ci].SourceIpv6Address.IsNull() {
				data.P2ps[i].Ipv6Neighbors[ci].SourceIpv6Address = types.StringValue(value.String())
			} else {
				data.P2ps[i].Ipv6Neighbors[ci].SourceIpv6Address = types.StringNull()
			}
		}
		for ci := range data.P2ps[i].EvpnTargetNeighbors {
			keys := [...]string{"vpn-id", "remote-ac-id", "source"}
			keyValues := [...]string{strconv.FormatInt(data.P2ps[i].EvpnTargetNeighbors[ci].VpnId.ValueInt64(), 10), strconv.FormatInt(data.P2ps[i].EvpnTargetNeighbors[ci].RemoteAcId.ValueInt64(), 10), strconv.FormatInt(data.P2ps[i].EvpnTargetNeighbors[ci].Source.ValueInt64(), 10)}

			var cr gjson.Result
			r.Get("neighbor.evpn.evi.targets.target").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("vpn-id"); value.Exists() && !data.P2ps[i].EvpnTargetNeighbors[ci].VpnId.IsNull() {
				data.P2ps[i].EvpnTargetNeighbors[ci].VpnId = types.Int64Value(value.Int())
			} else {
				data.P2ps[i].EvpnTargetNeighbors[ci].VpnId = types.Int64Null()
			}
			if value := cr.Get("remote-ac-id"); value.Exists() && !data.P2ps[i].EvpnTargetNeighbors[ci].RemoteAcId.IsNull() {
				data.P2ps[i].EvpnTargetNeighbors[ci].RemoteAcId = types.Int64Value(value.Int())
			} else {
				data.P2ps[i].EvpnTargetNeighbors[ci].RemoteAcId = types.Int64Null()
			}
			if value := cr.Get("source"); value.Exists() && !data.P2ps[i].EvpnTargetNeighbors[ci].Source.IsNull() {
				data.P2ps[i].EvpnTargetNeighbors[ci].Source = types.Int64Value(value.Int())
			} else {
				data.P2ps[i].EvpnTargetNeighbors[ci].Source = types.Int64Null()
			}
			if value := cr.Get("pw-class"); value.Exists() && !data.P2ps[i].EvpnTargetNeighbors[ci].PwClass.IsNull() {
				data.P2ps[i].EvpnTargetNeighbors[ci].PwClass = types.StringValue(value.String())
			} else {
				data.P2ps[i].EvpnTargetNeighbors[ci].PwClass = types.StringNull()
			}
		}
		for ci := range data.P2ps[i].EvpnServiceNeighbors {
			keys := [...]string{"vpn-id", "service-id"}
			keyValues := [...]string{strconv.FormatInt(data.P2ps[i].EvpnServiceNeighbors[ci].VpnId.ValueInt64(), 10), strconv.FormatInt(data.P2ps[i].EvpnServiceNeighbors[ci].ServiceId.ValueInt64(), 10)}

			var cr gjson.Result
			r.Get("neighbor.evpn.evi.services.service").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("vpn-id"); value.Exists() && !data.P2ps[i].EvpnServiceNeighbors[ci].VpnId.IsNull() {
				data.P2ps[i].EvpnServiceNeighbors[ci].VpnId = types.Int64Value(value.Int())
			} else {
				data.P2ps[i].EvpnServiceNeighbors[ci].VpnId = types.Int64Null()
			}
			if value := cr.Get("service-id"); value.Exists() && !data.P2ps[i].EvpnServiceNeighbors[ci].ServiceId.IsNull() {
				data.P2ps[i].EvpnServiceNeighbors[ci].ServiceId = types.Int64Value(value.Int())
			} else {
				data.P2ps[i].EvpnServiceNeighbors[ci].ServiceId = types.Int64Null()
			}
			if value := cr.Get("pw-class"); value.Exists() && !data.P2ps[i].EvpnServiceNeighbors[ci].PwClass.IsNull() {
				data.P2ps[i].EvpnServiceNeighbors[ci].PwClass = types.StringValue(value.String())
			} else {
				data.P2ps[i].EvpnServiceNeighbors[ci].PwClass = types.StringNull()
			}
		}
		for ci := range data.P2ps[i].EvpnTargetNeighborsSegmentRouting {
			keys := [...]string{"vpn-id", "remote-ac-id", "source"}
			keyValues := [...]string{strconv.FormatInt(data.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].VpnId.ValueInt64(), 10), strconv.FormatInt(data.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].RemoteAcId.ValueInt64(), 10), strconv.FormatInt(data.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].Source.ValueInt64(), 10)}

			var cr gjson.Result
			r.Get("neighbor.evpn.evi.segment-routing-targets.target").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("vpn-id"); value.Exists() && !data.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].VpnId.IsNull() {
				data.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].VpnId = types.Int64Value(value.Int())
			} else {
				data.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].VpnId = types.Int64Null()
			}
			if value := cr.Get("remote-ac-id"); value.Exists() && !data.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].RemoteAcId.IsNull() {
				data.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].RemoteAcId = types.Int64Value(value.Int())
			} else {
				data.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].RemoteAcId = types.Int64Null()
			}
			if value := cr.Get("source"); value.Exists() && !data.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].Source.IsNull() {
				data.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].Source = types.Int64Value(value.Int())
			} else {
				data.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].Source = types.Int64Null()
			}
			if value := cr.Get("segment-routing.srv6.locator"); value.Exists() && !data.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].SegmentRoutingSrv6Locator.IsNull() {
				data.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].SegmentRoutingSrv6Locator = types.StringValue(value.String())
			} else {
				data.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].SegmentRoutingSrv6Locator = types.StringNull()
			}
		}
		for ci := range data.P2ps[i].EvpnServiceNeighborsSegmentRouting {
			keys := [...]string{"vpn-id", "service-id"}
			keyValues := [...]string{strconv.FormatInt(data.P2ps[i].EvpnServiceNeighborsSegmentRouting[ci].VpnId.ValueInt64(), 10), strconv.FormatInt(data.P2ps[i].EvpnServiceNeighborsSegmentRouting[ci].ServiceId.ValueInt64(), 10)}

			var cr gjson.Result
			r.Get("neighbor.evpn.evi.segment-routing-services.service").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("vpn-id"); value.Exists() && !data.P2ps[i].EvpnServiceNeighborsSegmentRouting[ci].VpnId.IsNull() {
				data.P2ps[i].EvpnServiceNeighborsSegmentRouting[ci].VpnId = types.Int64Value(value.Int())
			} else {
				data.P2ps[i].EvpnServiceNeighborsSegmentRouting[ci].VpnId = types.Int64Null()
			}
			if value := cr.Get("service-id"); value.Exists() && !data.P2ps[i].EvpnServiceNeighborsSegmentRouting[ci].ServiceId.IsNull() {
				data.P2ps[i].EvpnServiceNeighborsSegmentRouting[ci].ServiceId = types.Int64Value(value.Int())
			} else {
				data.P2ps[i].EvpnServiceNeighborsSegmentRouting[ci].ServiceId = types.Int64Null()
			}
			if value := cr.Get("segment-routing.srv6.locator"); value.Exists() && !data.P2ps[i].EvpnServiceNeighborsSegmentRouting[ci].SegmentRoutingSrv6Locator.IsNull() {
				data.P2ps[i].EvpnServiceNeighborsSegmentRouting[ci].SegmentRoutingSrv6Locator = types.StringValue(value.String())
			} else {
				data.P2ps[i].EvpnServiceNeighborsSegmentRouting[ci].SegmentRoutingSrv6Locator = types.StringNull()
			}
		}
	}
}

// End of section. //template:end updateFromBody

// Section below is generated&owned by "gen/generator.go". //template:begin fromBody

func (data *L2VPNXconnectGroup) fromBody(ctx context.Context, res []byte) {
	if value := gjson.GetBytes(res, "p2ps.p2p"); value.Exists() {
		data.P2ps = make([]L2VPNXconnectGroupP2ps, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := L2VPNXconnectGroupP2ps{}
			if cValue := v.Get("p2p-xconnect-name"); cValue.Exists() {
				item.P2pXconnectName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("description"); cValue.Exists() {
				item.Description = types.StringValue(cValue.String())
			}
			if cValue := v.Get("interfaces.interface"); cValue.Exists() {
				item.Interfaces = make([]L2VPNXconnectGroupP2psInterfaces, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := L2VPNXconnectGroupP2psInterfaces{}
					if ccValue := cv.Get("interface-name"); ccValue.Exists() {
						cItem.InterfaceName = types.StringValue(ccValue.String())
					}
					item.Interfaces = append(item.Interfaces, cItem)
					return true
				})
			}
			if cValue := v.Get("interworking.ipv4"); cValue.Exists() {
				item.InterworkingIpv4 = types.BoolValue(true)
			} else {
				item.InterworkingIpv4 = types.BoolValue(false)
			}
			if cValue := v.Get("interworking.ethernet"); cValue.Exists() {
				item.InterworkingEthernet = types.BoolValue(true)
			} else {
				item.InterworkingEthernet = types.BoolValue(false)
			}
			if cValue := v.Get("backup.interface"); cValue.Exists() {
				item.BackupInterfaces = make([]L2VPNXconnectGroupP2psBackupInterfaces, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := L2VPNXconnectGroupP2psBackupInterfaces{}
					if ccValue := cv.Get("interface-name"); ccValue.Exists() {
						cItem.InterfaceName = types.StringValue(ccValue.String())
					}
					item.BackupInterfaces = append(item.BackupInterfaces, cItem)
					return true
				})
			}
			if cValue := v.Get("neighbor.ipv4s.ipv4"); cValue.Exists() {
				item.Ipv4Neighbors = make([]L2VPNXconnectGroupP2psIpv4Neighbors, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := L2VPNXconnectGroupP2psIpv4Neighbors{}
					if ccValue := cv.Get("address"); ccValue.Exists() {
						cItem.Address = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("pw-id"); ccValue.Exists() {
						cItem.PwId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("pw-class"); ccValue.Exists() {
						cItem.PwClass = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("bandwidth"); ccValue.Exists() {
						cItem.Bandwidth = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("mpls.static.label.local"); ccValue.Exists() {
						cItem.MplsStaticLabelLocal = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("mpls.static.label.remote"); ccValue.Exists() {
						cItem.MplsStaticLabelRemote = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("tag-impose.vlan"); ccValue.Exists() {
						cItem.TagImposeVlan = types.Int64Value(ccValue.Int())
					}
					item.Ipv4Neighbors = append(item.Ipv4Neighbors, cItem)
					return true
				})
			}
			if cValue := v.Get("neighbor.ipv6s.ipv6"); cValue.Exists() {
				item.Ipv6Neighbors = make([]L2VPNXconnectGroupP2psIpv6Neighbors, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := L2VPNXconnectGroupP2psIpv6Neighbors{}
					if ccValue := cv.Get("address"); ccValue.Exists() {
						cItem.Address = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("pw-id"); ccValue.Exists() {
						cItem.PwId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("pw-class"); ccValue.Exists() {
						cItem.PwClass = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("mpls.static.label.local"); ccValue.Exists() {
						cItem.MplsStaticLabelLocal = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("mpls.static.label.remote"); ccValue.Exists() {
						cItem.MplsStaticLabelRemote = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("tag-impose.vlan"); ccValue.Exists() {
						cItem.TagImposeVlan = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("source.ipv6-address"); ccValue.Exists() {
						cItem.SourceIpv6Address = types.StringValue(ccValue.String())
					}
					item.Ipv6Neighbors = append(item.Ipv6Neighbors, cItem)
					return true
				})
			}
			if cValue := v.Get("neighbor.evpn.evi.targets.target"); cValue.Exists() {
				item.EvpnTargetNeighbors = make([]L2VPNXconnectGroupP2psEvpnTargetNeighbors, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := L2VPNXconnectGroupP2psEvpnTargetNeighbors{}
					if ccValue := cv.Get("vpn-id"); ccValue.Exists() {
						cItem.VpnId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("remote-ac-id"); ccValue.Exists() {
						cItem.RemoteAcId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("source"); ccValue.Exists() {
						cItem.Source = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("pw-class"); ccValue.Exists() {
						cItem.PwClass = types.StringValue(ccValue.String())
					}
					item.EvpnTargetNeighbors = append(item.EvpnTargetNeighbors, cItem)
					return true
				})
			}
			if cValue := v.Get("neighbor.evpn.evi.services.service"); cValue.Exists() {
				item.EvpnServiceNeighbors = make([]L2VPNXconnectGroupP2psEvpnServiceNeighbors, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := L2VPNXconnectGroupP2psEvpnServiceNeighbors{}
					if ccValue := cv.Get("vpn-id"); ccValue.Exists() {
						cItem.VpnId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("service-id"); ccValue.Exists() {
						cItem.ServiceId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("pw-class"); ccValue.Exists() {
						cItem.PwClass = types.StringValue(ccValue.String())
					}
					item.EvpnServiceNeighbors = append(item.EvpnServiceNeighbors, cItem)
					return true
				})
			}
			if cValue := v.Get("neighbor.evpn.evi.segment-routing-targets.target"); cValue.Exists() {
				item.EvpnTargetNeighborsSegmentRouting = make([]L2VPNXconnectGroupP2psEvpnTargetNeighborsSegmentRouting, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := L2VPNXconnectGroupP2psEvpnTargetNeighborsSegmentRouting{}
					if ccValue := cv.Get("vpn-id"); ccValue.Exists() {
						cItem.VpnId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("remote-ac-id"); ccValue.Exists() {
						cItem.RemoteAcId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("source"); ccValue.Exists() {
						cItem.Source = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("segment-routing.srv6.locator"); ccValue.Exists() {
						cItem.SegmentRoutingSrv6Locator = types.StringValue(ccValue.String())
					}
					item.EvpnTargetNeighborsSegmentRouting = append(item.EvpnTargetNeighborsSegmentRouting, cItem)
					return true
				})
			}
			if cValue := v.Get("neighbor.evpn.evi.segment-routing-services.service"); cValue.Exists() {
				item.EvpnServiceNeighborsSegmentRouting = make([]L2VPNXconnectGroupP2psEvpnServiceNeighborsSegmentRouting, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := L2VPNXconnectGroupP2psEvpnServiceNeighborsSegmentRouting{}
					if ccValue := cv.Get("vpn-id"); ccValue.Exists() {
						cItem.VpnId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("service-id"); ccValue.Exists() {
						cItem.ServiceId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("segment-routing.srv6.locator"); ccValue.Exists() {
						cItem.SegmentRoutingSrv6Locator = types.StringValue(ccValue.String())
					}
					item.EvpnServiceNeighborsSegmentRouting = append(item.EvpnServiceNeighborsSegmentRouting, cItem)
					return true
				})
			}
			data.P2ps = append(data.P2ps, item)
			return true
		})
	}
}

// End of section. //template:end fromBody

// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyData

func (data *L2VPNXconnectGroupData) fromBody(ctx context.Context, res []byte) {
	if value := gjson.GetBytes(res, "p2ps.p2p"); value.Exists() {
		data.P2ps = make([]L2VPNXconnectGroupP2ps, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := L2VPNXconnectGroupP2ps{}
			if cValue := v.Get("p2p-xconnect-name"); cValue.Exists() {
				item.P2pXconnectName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("description"); cValue.Exists() {
				item.Description = types.StringValue(cValue.String())
			}
			if cValue := v.Get("interfaces.interface"); cValue.Exists() {
				item.Interfaces = make([]L2VPNXconnectGroupP2psInterfaces, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := L2VPNXconnectGroupP2psInterfaces{}
					if ccValue := cv.Get("interface-name"); ccValue.Exists() {
						cItem.InterfaceName = types.StringValue(ccValue.String())
					}
					item.Interfaces = append(item.Interfaces, cItem)
					return true
				})
			}
			if cValue := v.Get("interworking.ipv4"); cValue.Exists() {
				item.InterworkingIpv4 = types.BoolValue(true)
			} else {
				item.InterworkingIpv4 = types.BoolValue(false)
			}
			if cValue := v.Get("interworking.ethernet"); cValue.Exists() {
				item.InterworkingEthernet = types.BoolValue(true)
			} else {
				item.InterworkingEthernet = types.BoolValue(false)
			}
			if cValue := v.Get("backup.interface"); cValue.Exists() {
				item.BackupInterfaces = make([]L2VPNXconnectGroupP2psBackupInterfaces, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := L2VPNXconnectGroupP2psBackupInterfaces{}
					if ccValue := cv.Get("interface-name"); ccValue.Exists() {
						cItem.InterfaceName = types.StringValue(ccValue.String())
					}
					item.BackupInterfaces = append(item.BackupInterfaces, cItem)
					return true
				})
			}
			if cValue := v.Get("neighbor.ipv4s.ipv4"); cValue.Exists() {
				item.Ipv4Neighbors = make([]L2VPNXconnectGroupP2psIpv4Neighbors, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := L2VPNXconnectGroupP2psIpv4Neighbors{}
					if ccValue := cv.Get("address"); ccValue.Exists() {
						cItem.Address = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("pw-id"); ccValue.Exists() {
						cItem.PwId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("pw-class"); ccValue.Exists() {
						cItem.PwClass = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("bandwidth"); ccValue.Exists() {
						cItem.Bandwidth = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("mpls.static.label.local"); ccValue.Exists() {
						cItem.MplsStaticLabelLocal = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("mpls.static.label.remote"); ccValue.Exists() {
						cItem.MplsStaticLabelRemote = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("tag-impose.vlan"); ccValue.Exists() {
						cItem.TagImposeVlan = types.Int64Value(ccValue.Int())
					}
					item.Ipv4Neighbors = append(item.Ipv4Neighbors, cItem)
					return true
				})
			}
			if cValue := v.Get("neighbor.ipv6s.ipv6"); cValue.Exists() {
				item.Ipv6Neighbors = make([]L2VPNXconnectGroupP2psIpv6Neighbors, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := L2VPNXconnectGroupP2psIpv6Neighbors{}
					if ccValue := cv.Get("address"); ccValue.Exists() {
						cItem.Address = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("pw-id"); ccValue.Exists() {
						cItem.PwId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("pw-class"); ccValue.Exists() {
						cItem.PwClass = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("mpls.static.label.local"); ccValue.Exists() {
						cItem.MplsStaticLabelLocal = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("mpls.static.label.remote"); ccValue.Exists() {
						cItem.MplsStaticLabelRemote = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("tag-impose.vlan"); ccValue.Exists() {
						cItem.TagImposeVlan = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("source.ipv6-address"); ccValue.Exists() {
						cItem.SourceIpv6Address = types.StringValue(ccValue.String())
					}
					item.Ipv6Neighbors = append(item.Ipv6Neighbors, cItem)
					return true
				})
			}
			if cValue := v.Get("neighbor.evpn.evi.targets.target"); cValue.Exists() {
				item.EvpnTargetNeighbors = make([]L2VPNXconnectGroupP2psEvpnTargetNeighbors, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := L2VPNXconnectGroupP2psEvpnTargetNeighbors{}
					if ccValue := cv.Get("vpn-id"); ccValue.Exists() {
						cItem.VpnId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("remote-ac-id"); ccValue.Exists() {
						cItem.RemoteAcId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("source"); ccValue.Exists() {
						cItem.Source = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("pw-class"); ccValue.Exists() {
						cItem.PwClass = types.StringValue(ccValue.String())
					}
					item.EvpnTargetNeighbors = append(item.EvpnTargetNeighbors, cItem)
					return true
				})
			}
			if cValue := v.Get("neighbor.evpn.evi.services.service"); cValue.Exists() {
				item.EvpnServiceNeighbors = make([]L2VPNXconnectGroupP2psEvpnServiceNeighbors, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := L2VPNXconnectGroupP2psEvpnServiceNeighbors{}
					if ccValue := cv.Get("vpn-id"); ccValue.Exists() {
						cItem.VpnId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("service-id"); ccValue.Exists() {
						cItem.ServiceId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("pw-class"); ccValue.Exists() {
						cItem.PwClass = types.StringValue(ccValue.String())
					}
					item.EvpnServiceNeighbors = append(item.EvpnServiceNeighbors, cItem)
					return true
				})
			}
			if cValue := v.Get("neighbor.evpn.evi.segment-routing-targets.target"); cValue.Exists() {
				item.EvpnTargetNeighborsSegmentRouting = make([]L2VPNXconnectGroupP2psEvpnTargetNeighborsSegmentRouting, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := L2VPNXconnectGroupP2psEvpnTargetNeighborsSegmentRouting{}
					if ccValue := cv.Get("vpn-id"); ccValue.Exists() {
						cItem.VpnId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("remote-ac-id"); ccValue.Exists() {
						cItem.RemoteAcId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("source"); ccValue.Exists() {
						cItem.Source = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("segment-routing.srv6.locator"); ccValue.Exists() {
						cItem.SegmentRoutingSrv6Locator = types.StringValue(ccValue.String())
					}
					item.EvpnTargetNeighborsSegmentRouting = append(item.EvpnTargetNeighborsSegmentRouting, cItem)
					return true
				})
			}
			if cValue := v.Get("neighbor.evpn.evi.segment-routing-services.service"); cValue.Exists() {
				item.EvpnServiceNeighborsSegmentRouting = make([]L2VPNXconnectGroupP2psEvpnServiceNeighborsSegmentRouting, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := L2VPNXconnectGroupP2psEvpnServiceNeighborsSegmentRouting{}
					if ccValue := cv.Get("vpn-id"); ccValue.Exists() {
						cItem.VpnId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("service-id"); ccValue.Exists() {
						cItem.ServiceId = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("segment-routing.srv6.locator"); ccValue.Exists() {
						cItem.SegmentRoutingSrv6Locator = types.StringValue(ccValue.String())
					}
					item.EvpnServiceNeighborsSegmentRouting = append(item.EvpnServiceNeighborsSegmentRouting, cItem)
					return true
				})
			}
			data.P2ps = append(data.P2ps, item)
			return true
		})
	}
}

// End of section. //template:end fromBodyData

// Section below is generated&owned by "gen/generator.go". //template:begin getDeletedItems

func (data *L2VPNXconnectGroup) getDeletedItems(ctx context.Context, state L2VPNXconnectGroup) []string {
	deletedItems := make([]string, 0)
	for i := range state.P2ps {
		keys := [...]string{"p2p-xconnect-name"}
		stateKeyValues := [...]string{state.P2ps[i].P2pXconnectName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.P2ps[i].P2pXconnectName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.P2ps {
			found = true
			if state.P2ps[i].P2pXconnectName.ValueString() != data.P2ps[j].P2pXconnectName.ValueString() {
				found = false
			}
			if found {
				for ci := range state.P2ps[i].EvpnServiceNeighborsSegmentRouting {
					ckeys := [...]string{"vpn-id", "service-id"}
					cstateKeyValues := [...]string{strconv.FormatInt(state.P2ps[i].EvpnServiceNeighborsSegmentRouting[ci].VpnId.ValueInt64(), 10), strconv.FormatInt(state.P2ps[i].EvpnServiceNeighborsSegmentRouting[ci].ServiceId.ValueInt64(), 10)}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.P2ps[i].EvpnServiceNeighborsSegmentRouting[ci].VpnId.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if !reflect.ValueOf(state.P2ps[i].EvpnServiceNeighborsSegmentRouting[ci].ServiceId.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.P2ps[j].EvpnServiceNeighborsSegmentRouting {
						found = true
						if state.P2ps[i].EvpnServiceNeighborsSegmentRouting[ci].VpnId.ValueInt64() != data.P2ps[j].EvpnServiceNeighborsSegmentRouting[cj].VpnId.ValueInt64() {
							found = false
						}
						if state.P2ps[i].EvpnServiceNeighborsSegmentRouting[ci].ServiceId.ValueInt64() != data.P2ps[j].EvpnServiceNeighborsSegmentRouting[cj].ServiceId.ValueInt64() {
							found = false
						}
						if found {
							if !state.P2ps[i].EvpnServiceNeighborsSegmentRouting[ci].SegmentRoutingSrv6Locator.IsNull() && data.P2ps[j].EvpnServiceNeighborsSegmentRouting[cj].SegmentRoutingSrv6Locator.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/neighbor/evpn/evi/segment-routing-services/service%v/segment-routing/srv6/locator", state.getPath(), keyString, ckeyString))
							}
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/neighbor/evpn/evi/segment-routing-services/service%v", state.getPath(), keyString, ckeyString))
					}
				}
				for ci := range state.P2ps[i].EvpnTargetNeighborsSegmentRouting {
					ckeys := [...]string{"vpn-id", "remote-ac-id", "source"}
					cstateKeyValues := [...]string{strconv.FormatInt(state.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].VpnId.ValueInt64(), 10), strconv.FormatInt(state.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].RemoteAcId.ValueInt64(), 10), strconv.FormatInt(state.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].Source.ValueInt64(), 10)}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].VpnId.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if !reflect.ValueOf(state.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].RemoteAcId.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if !reflect.ValueOf(state.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].Source.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.P2ps[j].EvpnTargetNeighborsSegmentRouting {
						found = true
						if state.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].VpnId.ValueInt64() != data.P2ps[j].EvpnTargetNeighborsSegmentRouting[cj].VpnId.ValueInt64() {
							found = false
						}
						if state.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].RemoteAcId.ValueInt64() != data.P2ps[j].EvpnTargetNeighborsSegmentRouting[cj].RemoteAcId.ValueInt64() {
							found = false
						}
						if state.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].Source.ValueInt64() != data.P2ps[j].EvpnTargetNeighborsSegmentRouting[cj].Source.ValueInt64() {
							found = false
						}
						if found {
							if !state.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].SegmentRoutingSrv6Locator.IsNull() && data.P2ps[j].EvpnTargetNeighborsSegmentRouting[cj].SegmentRoutingSrv6Locator.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/neighbor/evpn/evi/segment-routing-targets/target%v/segment-routing/srv6/locator", state.getPath(), keyString, ckeyString))
							}
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/neighbor/evpn/evi/segment-routing-targets/target%v", state.getPath(), keyString, ckeyString))
					}
				}
				for ci := range state.P2ps[i].EvpnServiceNeighbors {
					ckeys := [...]string{"vpn-id", "service-id"}
					cstateKeyValues := [...]string{strconv.FormatInt(state.P2ps[i].EvpnServiceNeighbors[ci].VpnId.ValueInt64(), 10), strconv.FormatInt(state.P2ps[i].EvpnServiceNeighbors[ci].ServiceId.ValueInt64(), 10)}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.P2ps[i].EvpnServiceNeighbors[ci].VpnId.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if !reflect.ValueOf(state.P2ps[i].EvpnServiceNeighbors[ci].ServiceId.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.P2ps[j].EvpnServiceNeighbors {
						found = true
						if state.P2ps[i].EvpnServiceNeighbors[ci].VpnId.ValueInt64() != data.P2ps[j].EvpnServiceNeighbors[cj].VpnId.ValueInt64() {
							found = false
						}
						if state.P2ps[i].EvpnServiceNeighbors[ci].ServiceId.ValueInt64() != data.P2ps[j].EvpnServiceNeighbors[cj].ServiceId.ValueInt64() {
							found = false
						}
						if found {
							if !state.P2ps[i].EvpnServiceNeighbors[ci].PwClass.IsNull() && data.P2ps[j].EvpnServiceNeighbors[cj].PwClass.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/neighbor/evpn/evi/services/service%v/pw-class", state.getPath(), keyString, ckeyString))
							}
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/neighbor/evpn/evi/services/service%v", state.getPath(), keyString, ckeyString))
					}
				}
				for ci := range state.P2ps[i].EvpnTargetNeighbors {
					ckeys := [...]string{"vpn-id", "remote-ac-id", "source"}
					cstateKeyValues := [...]string{strconv.FormatInt(state.P2ps[i].EvpnTargetNeighbors[ci].VpnId.ValueInt64(), 10), strconv.FormatInt(state.P2ps[i].EvpnTargetNeighbors[ci].RemoteAcId.ValueInt64(), 10), strconv.FormatInt(state.P2ps[i].EvpnTargetNeighbors[ci].Source.ValueInt64(), 10)}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.P2ps[i].EvpnTargetNeighbors[ci].VpnId.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if !reflect.ValueOf(state.P2ps[i].EvpnTargetNeighbors[ci].RemoteAcId.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if !reflect.ValueOf(state.P2ps[i].EvpnTargetNeighbors[ci].Source.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.P2ps[j].EvpnTargetNeighbors {
						found = true
						if state.P2ps[i].EvpnTargetNeighbors[ci].VpnId.ValueInt64() != data.P2ps[j].EvpnTargetNeighbors[cj].VpnId.ValueInt64() {
							found = false
						}
						if state.P2ps[i].EvpnTargetNeighbors[ci].RemoteAcId.ValueInt64() != data.P2ps[j].EvpnTargetNeighbors[cj].RemoteAcId.ValueInt64() {
							found = false
						}
						if state.P2ps[i].EvpnTargetNeighbors[ci].Source.ValueInt64() != data.P2ps[j].EvpnTargetNeighbors[cj].Source.ValueInt64() {
							found = false
						}
						if found {
							if !state.P2ps[i].EvpnTargetNeighbors[ci].PwClass.IsNull() && data.P2ps[j].EvpnTargetNeighbors[cj].PwClass.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/neighbor/evpn/evi/targets/target%v/pw-class", state.getPath(), keyString, ckeyString))
							}
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/neighbor/evpn/evi/targets/target%v", state.getPath(), keyString, ckeyString))
					}
				}
				for ci := range state.P2ps[i].Ipv6Neighbors {
					ckeys := [...]string{"address", "pw-id"}
					cstateKeyValues := [...]string{state.P2ps[i].Ipv6Neighbors[ci].Address.ValueString(), strconv.FormatInt(state.P2ps[i].Ipv6Neighbors[ci].PwId.ValueInt64(), 10)}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.P2ps[i].Ipv6Neighbors[ci].Address.ValueString()).IsZero() {
						cemptyKeys = false
					}
					if !reflect.ValueOf(state.P2ps[i].Ipv6Neighbors[ci].PwId.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.P2ps[j].Ipv6Neighbors {
						found = true
						if state.P2ps[i].Ipv6Neighbors[ci].Address.ValueString() != data.P2ps[j].Ipv6Neighbors[cj].Address.ValueString() {
							found = false
						}
						if state.P2ps[i].Ipv6Neighbors[ci].PwId.ValueInt64() != data.P2ps[j].Ipv6Neighbors[cj].PwId.ValueInt64() {
							found = false
						}
						if found {
							if !state.P2ps[i].Ipv6Neighbors[ci].SourceIpv6Address.IsNull() && data.P2ps[j].Ipv6Neighbors[cj].SourceIpv6Address.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/neighbor/ipv6s/ipv6%v/source/ipv6-address", state.getPath(), keyString, ckeyString))
							}
							if !state.P2ps[i].Ipv6Neighbors[ci].TagImposeVlan.IsNull() && data.P2ps[j].Ipv6Neighbors[cj].TagImposeVlan.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/neighbor/ipv6s/ipv6%v/tag-impose/vlan", state.getPath(), keyString, ckeyString))
							}
							if !state.P2ps[i].Ipv6Neighbors[ci].MplsStaticLabelRemote.IsNull() && data.P2ps[j].Ipv6Neighbors[cj].MplsStaticLabelRemote.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/neighbor/ipv6s/ipv6%v/mpls/static/label/remote", state.getPath(), keyString, ckeyString))
							}
							if !state.P2ps[i].Ipv6Neighbors[ci].MplsStaticLabelLocal.IsNull() && data.P2ps[j].Ipv6Neighbors[cj].MplsStaticLabelLocal.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/neighbor/ipv6s/ipv6%v/mpls/static/label/local", state.getPath(), keyString, ckeyString))
							}
							if !state.P2ps[i].Ipv6Neighbors[ci].PwClass.IsNull() && data.P2ps[j].Ipv6Neighbors[cj].PwClass.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/neighbor/ipv6s/ipv6%v/pw-class", state.getPath(), keyString, ckeyString))
							}
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/neighbor/ipv6s/ipv6%v", state.getPath(), keyString, ckeyString))
					}
				}
				for ci := range state.P2ps[i].Ipv4Neighbors {
					ckeys := [...]string{"address", "pw-id"}
					cstateKeyValues := [...]string{state.P2ps[i].Ipv4Neighbors[ci].Address.ValueString(), strconv.FormatInt(state.P2ps[i].Ipv4Neighbors[ci].PwId.ValueInt64(), 10)}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.P2ps[i].Ipv4Neighbors[ci].Address.ValueString()).IsZero() {
						cemptyKeys = false
					}
					if !reflect.ValueOf(state.P2ps[i].Ipv4Neighbors[ci].PwId.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.P2ps[j].Ipv4Neighbors {
						found = true
						if state.P2ps[i].Ipv4Neighbors[ci].Address.ValueString() != data.P2ps[j].Ipv4Neighbors[cj].Address.ValueString() {
							found = false
						}
						if state.P2ps[i].Ipv4Neighbors[ci].PwId.ValueInt64() != data.P2ps[j].Ipv4Neighbors[cj].PwId.ValueInt64() {
							found = false
						}
						if found {
							if !state.P2ps[i].Ipv4Neighbors[ci].TagImposeVlan.IsNull() && data.P2ps[j].Ipv4Neighbors[cj].TagImposeVlan.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/neighbor/ipv4s/ipv4%v/tag-impose/vlan", state.getPath(), keyString, ckeyString))
							}
							if !state.P2ps[i].Ipv4Neighbors[ci].MplsStaticLabelRemote.IsNull() && data.P2ps[j].Ipv4Neighbors[cj].MplsStaticLabelRemote.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/neighbor/ipv4s/ipv4%v/mpls/static/label/remote", state.getPath(), keyString, ckeyString))
							}
							if !state.P2ps[i].Ipv4Neighbors[ci].MplsStaticLabelLocal.IsNull() && data.P2ps[j].Ipv4Neighbors[cj].MplsStaticLabelLocal.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/neighbor/ipv4s/ipv4%v/mpls/static/label/local", state.getPath(), keyString, ckeyString))
							}
							if !state.P2ps[i].Ipv4Neighbors[ci].Bandwidth.IsNull() && data.P2ps[j].Ipv4Neighbors[cj].Bandwidth.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/neighbor/ipv4s/ipv4%v/bandwidth", state.getPath(), keyString, ckeyString))
							}
							if !state.P2ps[i].Ipv4Neighbors[ci].PwClass.IsNull() && data.P2ps[j].Ipv4Neighbors[cj].PwClass.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/neighbor/ipv4s/ipv4%v/pw-class", state.getPath(), keyString, ckeyString))
							}
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/neighbor/ipv4s/ipv4%v", state.getPath(), keyString, ckeyString))
					}
				}
				for ci := range state.P2ps[i].BackupInterfaces {
					ckeys := [...]string{"interface-name"}
					cstateKeyValues := [...]string{state.P2ps[i].BackupInterfaces[ci].InterfaceName.ValueString()}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.P2ps[i].BackupInterfaces[ci].InterfaceName.ValueString()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.P2ps[j].BackupInterfaces {
						found = true
						if state.P2ps[i].BackupInterfaces[ci].InterfaceName.ValueString() != data.P2ps[j].BackupInterfaces[cj].InterfaceName.ValueString() {
							found = false
						}
						if found {
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/backup/interface%v", state.getPath(), keyString, ckeyString))
					}
				}
				if !state.P2ps[i].InterworkingEthernet.IsNull() && data.P2ps[j].InterworkingEthernet.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/interworking/ethernet", state.getPath(), keyString))
				}
				if !state.P2ps[i].InterworkingIpv4.IsNull() && data.P2ps[j].InterworkingIpv4.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/interworking/ipv4", state.getPath(), keyString))
				}
				for ci := range state.P2ps[i].Interfaces {
					ckeys := [...]string{"interface-name"}
					cstateKeyValues := [...]string{state.P2ps[i].Interfaces[ci].InterfaceName.ValueString()}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.P2ps[i].Interfaces[ci].InterfaceName.ValueString()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.P2ps[j].Interfaces {
						found = true
						if state.P2ps[i].Interfaces[ci].InterfaceName.ValueString() != data.P2ps[j].Interfaces[cj].InterfaceName.ValueString() {
							found = false
						}
						if found {
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/interfaces/interface%v", state.getPath(), keyString, ckeyString))
					}
				}
				if !state.P2ps[i].Description.IsNull() && data.P2ps[j].Description.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v/description", state.getPath(), keyString))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/p2ps/p2p%v", state.getPath(), keyString))
		}
	}
	return deletedItems
}

// End of section. //template:end getDeletedItems

// Section below is generated&owned by "gen/generator.go". //template:begin getEmptyLeafsDelete

func (data *L2VPNXconnectGroup) getEmptyLeafsDelete(ctx context.Context) []string {
	emptyLeafsDelete := make([]string, 0)
	for i := range data.P2ps {
		keys := [...]string{"p2p-xconnect-name"}
		keyValues := [...]string{data.P2ps[i].P2pXconnectName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		for ci := range data.P2ps[i].EvpnServiceNeighborsSegmentRouting {
			ckeys := [...]string{"vpn-id", "service-id"}
			ckeyValues := [...]string{strconv.FormatInt(data.P2ps[i].EvpnServiceNeighborsSegmentRouting[ci].VpnId.ValueInt64(), 10), strconv.FormatInt(data.P2ps[i].EvpnServiceNeighborsSegmentRouting[ci].ServiceId.ValueInt64(), 10)}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
		}
		for ci := range data.P2ps[i].EvpnTargetNeighborsSegmentRouting {
			ckeys := [...]string{"vpn-id", "remote-ac-id", "source"}
			ckeyValues := [...]string{strconv.FormatInt(data.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].VpnId.ValueInt64(), 10), strconv.FormatInt(data.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].RemoteAcId.ValueInt64(), 10), strconv.FormatInt(data.P2ps[i].EvpnTargetNeighborsSegmentRouting[ci].Source.ValueInt64(), 10)}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
		}
		for ci := range data.P2ps[i].EvpnServiceNeighbors {
			ckeys := [...]string{"vpn-id", "service-id"}
			ckeyValues := [...]string{strconv.FormatInt(data.P2ps[i].EvpnServiceNeighbors[ci].VpnId.ValueInt64(), 10), strconv.FormatInt(data.P2ps[i].EvpnServiceNeighbors[ci].ServiceId.ValueInt64(), 10)}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
		}
		for ci := range data.P2ps[i].EvpnTargetNeighbors {
			ckeys := [...]string{"vpn-id", "remote-ac-id", "source"}
			ckeyValues := [...]string{strconv.FormatInt(data.P2ps[i].EvpnTargetNeighbors[ci].VpnId.ValueInt64(), 10), strconv.FormatInt(data.P2ps[i].EvpnTargetNeighbors[ci].RemoteAcId.ValueInt64(), 10), strconv.FormatInt(data.P2ps[i].EvpnTargetNeighbors[ci].Source.ValueInt64(), 10)}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
		}
		for ci := range data.P2ps[i].Ipv6Neighbors {
			ckeys := [...]string{"address", "pw-id"}
			ckeyValues := [...]string{data.P2ps[i].Ipv6Neighbors[ci].Address.ValueString(), strconv.FormatInt(data.P2ps[i].Ipv6Neighbors[ci].PwId.ValueInt64(), 10)}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
		}
		for ci := range data.P2ps[i].Ipv4Neighbors {
			ckeys := [...]string{"address", "pw-id"}
			ckeyValues := [...]string{data.P2ps[i].Ipv4Neighbors[ci].Address.ValueString(), strconv.FormatInt(data.P2ps[i].Ipv4Neighbors[ci].PwId.ValueInt64(), 10)}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
		}
		for ci := range data.P2ps[i].BackupInterfaces {
			ckeys := [...]string{"interface-name"}
			ckeyValues := [...]string{data.P2ps[i].BackupInterfaces[ci].InterfaceName.ValueString()}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
		}
		if !data.P2ps[i].InterworkingEthernet.IsNull() && !data.P2ps[i].InterworkingEthernet.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/p2ps/p2p%v/interworking/ethernet", data.getPath(), keyString))
		}
		if !data.P2ps[i].InterworkingIpv4.IsNull() && !data.P2ps[i].InterworkingIpv4.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/p2ps/p2p%v/interworking/ipv4", data.getPath(), keyString))
		}
		for ci := range data.P2ps[i].Interfaces {
			ckeys := [...]string{"interface-name"}
			ckeyValues := [...]string{data.P2ps[i].Interfaces[ci].InterfaceName.ValueString()}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
		}
	}
	return emptyLeafsDelete
}

// End of section. //template:end getEmptyLeafsDelete

// Section below is generated&owned by "gen/generator.go". //template:begin getDeletePaths

func (data *L2VPNXconnectGroup) getDeletePaths(ctx context.Context) []string {
	var deletePaths []string
	for i := range data.P2ps {
		keys := [...]string{"p2p-xconnect-name"}
		keyValues := [...]string{data.P2ps[i].P2pXconnectName.ValueString()}

		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		deletePaths = append(deletePaths, fmt.Sprintf("%v/p2ps/p2p%v", data.getPath(), keyString))
	}
	return deletePaths
}

// End of section. //template:end getDeletePaths
