// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports
import (
	"context"
	"fmt"
	"reflect"
	"sort"
	"strconv"
	"strings"

	"github.com/CiscoDevNet/terraform-provider-iosxr/internal/provider/helpers"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/netascode/go-netconf"
	"github.com/netascode/xmldot"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin types
type MPLSLDPAddressFamily struct {
	Device                                     types.String                                            `tfsdk:"device"`
	Id                                         types.String                                            `tfsdk:"id"`
	DeleteMode                                 types.String                                            `tfsdk:"delete_mode"`
	AfName                                     types.String                                            `tfsdk:"af_name"`
	DiscoveryTransportAddressIpv4              types.String                                            `tfsdk:"discovery_transport_address_ipv4"`
	DiscoveryTransportAddressIpv6              types.String                                            `tfsdk:"discovery_transport_address_ipv6"`
	DiscoveryTargetedHelloAccept               types.Bool                                              `tfsdk:"discovery_targeted_hello_accept"`
	DiscoveryTargetedHelloAcceptFrom           types.String                                            `tfsdk:"discovery_targeted_hello_accept_from"`
	NeighborIpv4Targeted                       []MPLSLDPAddressFamilyNeighborIpv4Targeted              `tfsdk:"neighbor_ipv4_targeted"`
	NeighborIpv6Targeted                       []MPLSLDPAddressFamilyNeighborIpv6Targeted              `tfsdk:"neighbor_ipv6_targeted"`
	NeighborSrPolicies                         []MPLSLDPAddressFamilyNeighborSrPolicies                `tfsdk:"neighbor_sr_policies"`
	TrafficEngAutoTunnelMeshGroups             []MPLSLDPAddressFamilyTrafficEngAutoTunnelMeshGroups    `tfsdk:"traffic_eng_auto_tunnel_mesh_groups"`
	TrafficEngAutoTunnelMeshGroupsAll          types.Bool                                              `tfsdk:"traffic_eng_auto_tunnel_mesh_groups_all"`
	RedistributeBgpAs                          types.String                                            `tfsdk:"redistribute_bgp_as"`
	RedistributeBgpAdvertiseTo                 types.String                                            `tfsdk:"redistribute_bgp_advertise_to"`
	LabelLocalAllocateForAccessList            types.String                                            `tfsdk:"label_local_allocate_for_access_list"`
	LabelLocalAllocateForHostRoutes            types.Bool                                              `tfsdk:"label_local_allocate_for_host_routes"`
	LabelLocalDefaultRoute                     types.Bool                                              `tfsdk:"label_local_default_route"`
	LabelLocalImplicitNullOverrideFor          types.String                                            `tfsdk:"label_local_implicit_null_override_for"`
	LabelLocalAdvertiseExplicitNull            types.Bool                                              `tfsdk:"label_local_advertise_explicit_null"`
	LabelLocalAdvertiseExplicitNullForAcl      types.String                                            `tfsdk:"label_local_advertise_explicit_null_for_acl"`
	LabelLocalAdvertiseExplicitNullForAclToAcl types.String                                            `tfsdk:"label_local_advertise_explicit_null_for_acl_to_acl"`
	LabelLocalAdvertiseExplicitNullToAcl       types.String                                            `tfsdk:"label_local_advertise_explicit_null_to_acl"`
	LabelLocalAdvertiseToNeighbors             []MPLSLDPAddressFamilyLabelLocalAdvertiseToNeighbors    `tfsdk:"label_local_advertise_to_neighbors"`
	LabelLocalAdvertiseInterfaces              []MPLSLDPAddressFamilyLabelLocalAdvertiseInterfaces     `tfsdk:"label_local_advertise_interfaces"`
	LabelLocalAdvertiseDisable                 types.Bool                                              `tfsdk:"label_local_advertise_disable"`
	LabelLocalAdvertiseForAccessLists          []MPLSLDPAddressFamilyLabelLocalAdvertiseForAccessLists `tfsdk:"label_local_advertise_for_access_lists"`
	LabelRemoteAcceptFromNeighbors             []MPLSLDPAddressFamilyLabelRemoteAcceptFromNeighbors    `tfsdk:"label_remote_accept_from_neighbors"`
}

type MPLSLDPAddressFamilyData struct {
	Device                                     types.String                                            `tfsdk:"device"`
	Id                                         types.String                                            `tfsdk:"id"`
	AfName                                     types.String                                            `tfsdk:"af_name"`
	DiscoveryTransportAddressIpv4              types.String                                            `tfsdk:"discovery_transport_address_ipv4"`
	DiscoveryTransportAddressIpv6              types.String                                            `tfsdk:"discovery_transport_address_ipv6"`
	DiscoveryTargetedHelloAccept               types.Bool                                              `tfsdk:"discovery_targeted_hello_accept"`
	DiscoveryTargetedHelloAcceptFrom           types.String                                            `tfsdk:"discovery_targeted_hello_accept_from"`
	NeighborIpv4Targeted                       []MPLSLDPAddressFamilyNeighborIpv4Targeted              `tfsdk:"neighbor_ipv4_targeted"`
	NeighborIpv6Targeted                       []MPLSLDPAddressFamilyNeighborIpv6Targeted              `tfsdk:"neighbor_ipv6_targeted"`
	NeighborSrPolicies                         []MPLSLDPAddressFamilyNeighborSrPolicies                `tfsdk:"neighbor_sr_policies"`
	TrafficEngAutoTunnelMeshGroups             []MPLSLDPAddressFamilyTrafficEngAutoTunnelMeshGroups    `tfsdk:"traffic_eng_auto_tunnel_mesh_groups"`
	TrafficEngAutoTunnelMeshGroupsAll          types.Bool                                              `tfsdk:"traffic_eng_auto_tunnel_mesh_groups_all"`
	RedistributeBgpAs                          types.String                                            `tfsdk:"redistribute_bgp_as"`
	RedistributeBgpAdvertiseTo                 types.String                                            `tfsdk:"redistribute_bgp_advertise_to"`
	LabelLocalAllocateForAccessList            types.String                                            `tfsdk:"label_local_allocate_for_access_list"`
	LabelLocalAllocateForHostRoutes            types.Bool                                              `tfsdk:"label_local_allocate_for_host_routes"`
	LabelLocalDefaultRoute                     types.Bool                                              `tfsdk:"label_local_default_route"`
	LabelLocalImplicitNullOverrideFor          types.String                                            `tfsdk:"label_local_implicit_null_override_for"`
	LabelLocalAdvertiseExplicitNull            types.Bool                                              `tfsdk:"label_local_advertise_explicit_null"`
	LabelLocalAdvertiseExplicitNullForAcl      types.String                                            `tfsdk:"label_local_advertise_explicit_null_for_acl"`
	LabelLocalAdvertiseExplicitNullForAclToAcl types.String                                            `tfsdk:"label_local_advertise_explicit_null_for_acl_to_acl"`
	LabelLocalAdvertiseExplicitNullToAcl       types.String                                            `tfsdk:"label_local_advertise_explicit_null_to_acl"`
	LabelLocalAdvertiseToNeighbors             []MPLSLDPAddressFamilyLabelLocalAdvertiseToNeighbors    `tfsdk:"label_local_advertise_to_neighbors"`
	LabelLocalAdvertiseInterfaces              []MPLSLDPAddressFamilyLabelLocalAdvertiseInterfaces     `tfsdk:"label_local_advertise_interfaces"`
	LabelLocalAdvertiseDisable                 types.Bool                                              `tfsdk:"label_local_advertise_disable"`
	LabelLocalAdvertiseForAccessLists          []MPLSLDPAddressFamilyLabelLocalAdvertiseForAccessLists `tfsdk:"label_local_advertise_for_access_lists"`
	LabelRemoteAcceptFromNeighbors             []MPLSLDPAddressFamilyLabelRemoteAcceptFromNeighbors    `tfsdk:"label_remote_accept_from_neighbors"`
}
type MPLSLDPAddressFamilyNeighborIpv4Targeted struct {
	NeighborAddress types.String `tfsdk:"neighbor_address"`
}
type MPLSLDPAddressFamilyNeighborIpv6Targeted struct {
	NeighborAddress types.String `tfsdk:"neighbor_address"`
}
type MPLSLDPAddressFamilyNeighborSrPolicies struct {
	PolicyName types.String `tfsdk:"policy_name"`
	Targeted   types.Bool   `tfsdk:"targeted"`
}
type MPLSLDPAddressFamilyTrafficEngAutoTunnelMeshGroups struct {
	GroupId types.Int64 `tfsdk:"group_id"`
}
type MPLSLDPAddressFamilyLabelLocalAdvertiseToNeighbors struct {
	NeighborAddress types.String `tfsdk:"neighbor_address"`
	LabelSpaceId    types.Int64  `tfsdk:"label_space_id"`
	For             types.String `tfsdk:"for"`
}
type MPLSLDPAddressFamilyLabelLocalAdvertiseInterfaces struct {
	InterfaceName types.String `tfsdk:"interface_name"`
}
type MPLSLDPAddressFamilyLabelLocalAdvertiseForAccessLists struct {
	AccessListName types.String `tfsdk:"access_list_name"`
	To             types.String `tfsdk:"to"`
}
type MPLSLDPAddressFamilyLabelRemoteAcceptFromNeighbors struct {
	NeighborAddress types.String `tfsdk:"neighbor_address"`
	LabelSpaceId    types.Int64  `tfsdk:"label_space_id"`
	For             types.String `tfsdk:"for"`
}

// End of section. //template:end types

// Section below is generated&owned by "gen/generator.go". //template:begin getPath

func (data MPLSLDPAddressFamily) getPath() string {
	return fmt.Sprintf("Cisco-IOS-XR-um-mpls-ldp-cfg:/mpls/ldp/address-families/address-family[af-name=%s]", data.AfName.ValueString())
}

func (data MPLSLDPAddressFamilyData) getPath() string {
	return fmt.Sprintf("Cisco-IOS-XR-um-mpls-ldp-cfg:/mpls/ldp/address-families/address-family[af-name=%s]", data.AfName.ValueString())
}

// getXPath returns the XPath for NETCONF operations
func (data MPLSLDPAddressFamily) getXPath() string {
	path := "Cisco-IOS-XR-um-mpls-ldp-cfg:/mpls/ldp/address-families/address-family[af-name=%s]"
	path = fmt.Sprintf(path, fmt.Sprintf("%v", data.AfName.ValueString()))
	return path
}

func (data MPLSLDPAddressFamilyData) getXPath() string {
	path := "Cisco-IOS-XR-um-mpls-ldp-cfg:/mpls/ldp/address-families/address-family[af-name=%s]"
	path = fmt.Sprintf(path, fmt.Sprintf("%v", data.AfName.ValueString()))
	return path
}

// End of section. //template:end getPath

// Section below is generated&owned by "gen/generator.go". //template:begin toBody

func (data MPLSLDPAddressFamily) toBody(ctx context.Context) string {
	body := "{}"
	if !data.AfName.IsNull() && !data.AfName.IsUnknown() {
		body, _ = sjson.Set(body, "af-name", data.AfName.ValueString())
	}
	if !data.DiscoveryTransportAddressIpv4.IsNull() && !data.DiscoveryTransportAddressIpv4.IsUnknown() {
		body, _ = sjson.Set(body, "discovery.transport-address.ipv4-address", data.DiscoveryTransportAddressIpv4.ValueString())
	}
	if !data.DiscoveryTransportAddressIpv6.IsNull() && !data.DiscoveryTransportAddressIpv6.IsUnknown() {
		body, _ = sjson.Set(body, "discovery.transport-address.ipv6-address", data.DiscoveryTransportAddressIpv6.ValueString())
	}
	if !data.DiscoveryTargetedHelloAccept.IsNull() && !data.DiscoveryTargetedHelloAccept.IsUnknown() {
		if data.DiscoveryTargetedHelloAccept.ValueBool() {
			body, _ = sjson.Set(body, "discovery.targeted-hello.accept", map[string]string{})
		}
	}
	if !data.DiscoveryTargetedHelloAcceptFrom.IsNull() && !data.DiscoveryTargetedHelloAcceptFrom.IsUnknown() {
		body, _ = sjson.Set(body, "discovery.targeted-hello.accept.from", data.DiscoveryTargetedHelloAcceptFrom.ValueString())
	}
	if !data.TrafficEngAutoTunnelMeshGroupsAll.IsNull() && !data.TrafficEngAutoTunnelMeshGroupsAll.IsUnknown() {
		if data.TrafficEngAutoTunnelMeshGroupsAll.ValueBool() {
			body, _ = sjson.Set(body, "traffic-eng.auto-tunnel.mesh.groups.all", map[string]string{})
		}
	}
	if !data.RedistributeBgpAs.IsNull() && !data.RedistributeBgpAs.IsUnknown() {
		body, _ = sjson.Set(body, "redistribute.bgp.as", data.RedistributeBgpAs.ValueString())
	}
	if !data.RedistributeBgpAdvertiseTo.IsNull() && !data.RedistributeBgpAdvertiseTo.IsUnknown() {
		body, _ = sjson.Set(body, "redistribute.bgp.advertise-to", data.RedistributeBgpAdvertiseTo.ValueString())
	}
	if !data.LabelLocalAllocateForAccessList.IsNull() && !data.LabelLocalAllocateForAccessList.IsUnknown() {
		body, _ = sjson.Set(body, "label.local.allocate.for.access-list", data.LabelLocalAllocateForAccessList.ValueString())
	}
	if !data.LabelLocalAllocateForHostRoutes.IsNull() && !data.LabelLocalAllocateForHostRoutes.IsUnknown() {
		if data.LabelLocalAllocateForHostRoutes.ValueBool() {
			body, _ = sjson.Set(body, "label.local.allocate.for.host-routes", map[string]string{})
		}
	}
	if !data.LabelLocalDefaultRoute.IsNull() && !data.LabelLocalDefaultRoute.IsUnknown() {
		if data.LabelLocalDefaultRoute.ValueBool() {
			body, _ = sjson.Set(body, "label.local.default-route", map[string]string{})
		}
	}
	if !data.LabelLocalImplicitNullOverrideFor.IsNull() && !data.LabelLocalImplicitNullOverrideFor.IsUnknown() {
		body, _ = sjson.Set(body, "label.local.implicit-null-override.for", data.LabelLocalImplicitNullOverrideFor.ValueString())
	}
	if !data.LabelLocalAdvertiseExplicitNull.IsNull() && !data.LabelLocalAdvertiseExplicitNull.IsUnknown() {
		if data.LabelLocalAdvertiseExplicitNull.ValueBool() {
			body, _ = sjson.Set(body, "label.local.advertise.explicit-null", map[string]string{})
		}
	}
	if !data.LabelLocalAdvertiseExplicitNullForAcl.IsNull() && !data.LabelLocalAdvertiseExplicitNullForAcl.IsUnknown() {
		body, _ = sjson.Set(body, "label.local.advertise.explicit-null.for.access-list", data.LabelLocalAdvertiseExplicitNullForAcl.ValueString())
	}
	if !data.LabelLocalAdvertiseExplicitNullForAclToAcl.IsNull() && !data.LabelLocalAdvertiseExplicitNullForAclToAcl.IsUnknown() {
		body, _ = sjson.Set(body, "label.local.advertise.explicit-null.for.to.access-list", data.LabelLocalAdvertiseExplicitNullForAclToAcl.ValueString())
	}
	if !data.LabelLocalAdvertiseExplicitNullToAcl.IsNull() && !data.LabelLocalAdvertiseExplicitNullToAcl.IsUnknown() {
		body, _ = sjson.Set(body, "label.local.advertise.explicit-null.to.access-list", data.LabelLocalAdvertiseExplicitNullToAcl.ValueString())
	}
	if !data.LabelLocalAdvertiseDisable.IsNull() && !data.LabelLocalAdvertiseDisable.IsUnknown() {
		if data.LabelLocalAdvertiseDisable.ValueBool() {
			body, _ = sjson.Set(body, "label.local.advertise.disable", map[string]string{})
		}
	}
	if len(data.NeighborIpv4Targeted) > 0 {
		body, _ = sjson.Set(body, "neighbor.ipv4-addresses.targeted", []interface{}{})
		for index, item := range data.NeighborIpv4Targeted {
			if !item.NeighborAddress.IsNull() && !item.NeighborAddress.IsUnknown() {
				body, _ = sjson.Set(body, "neighbor.ipv4-addresses.targeted"+"."+strconv.Itoa(index)+"."+"neighbor-address", item.NeighborAddress.ValueString())
			}
		}
	}
	if len(data.NeighborIpv6Targeted) > 0 {
		body, _ = sjson.Set(body, "neighbor.ipv6-addresses.targeted", []interface{}{})
		for index, item := range data.NeighborIpv6Targeted {
			if !item.NeighborAddress.IsNull() && !item.NeighborAddress.IsUnknown() {
				body, _ = sjson.Set(body, "neighbor.ipv6-addresses.targeted"+"."+strconv.Itoa(index)+"."+"neighbor-address", item.NeighborAddress.ValueString())
			}
		}
	}
	if len(data.NeighborSrPolicies) > 0 {
		body, _ = sjson.Set(body, "neighbor.sr-policies.sr-policy", []interface{}{})
		for index, item := range data.NeighborSrPolicies {
			if !item.PolicyName.IsNull() && !item.PolicyName.IsUnknown() {
				body, _ = sjson.Set(body, "neighbor.sr-policies.sr-policy"+"."+strconv.Itoa(index)+"."+"policy-name", item.PolicyName.ValueString())
			}
			if !item.Targeted.IsNull() && !item.Targeted.IsUnknown() {
				if item.Targeted.ValueBool() {
					body, _ = sjson.Set(body, "neighbor.sr-policies.sr-policy"+"."+strconv.Itoa(index)+"."+"targeted", map[string]string{})
				}
			}
		}
	}
	if len(data.TrafficEngAutoTunnelMeshGroups) > 0 {
		body, _ = sjson.Set(body, "traffic-eng.auto-tunnel.mesh.groups.group", []interface{}{})
		for index, item := range data.TrafficEngAutoTunnelMeshGroups {
			if !item.GroupId.IsNull() && !item.GroupId.IsUnknown() {
				body, _ = sjson.Set(body, "traffic-eng.auto-tunnel.mesh.groups.group"+"."+strconv.Itoa(index)+"."+"group-id", strconv.FormatInt(item.GroupId.ValueInt64(), 10))
			}
		}
	}
	if len(data.LabelLocalAdvertiseToNeighbors) > 0 {
		body, _ = sjson.Set(body, "label.local.advertise.to.neighbor", []interface{}{})
		for index, item := range data.LabelLocalAdvertiseToNeighbors {
			if !item.NeighborAddress.IsNull() && !item.NeighborAddress.IsUnknown() {
				body, _ = sjson.Set(body, "label.local.advertise.to.neighbor"+"."+strconv.Itoa(index)+"."+"neighbor-address", item.NeighborAddress.ValueString())
			}
			if !item.LabelSpaceId.IsNull() && !item.LabelSpaceId.IsUnknown() {
				body, _ = sjson.Set(body, "label.local.advertise.to.neighbor"+"."+strconv.Itoa(index)+"."+"label-space-id", strconv.FormatInt(item.LabelSpaceId.ValueInt64(), 10))
			}
			if !item.For.IsNull() && !item.For.IsUnknown() {
				body, _ = sjson.Set(body, "label.local.advertise.to.neighbor"+"."+strconv.Itoa(index)+"."+"for", item.For.ValueString())
			}
		}
	}
	if len(data.LabelLocalAdvertiseInterfaces) > 0 {
		body, _ = sjson.Set(body, "label.local.advertise.interfaces.interface", []interface{}{})
		for index, item := range data.LabelLocalAdvertiseInterfaces {
			if !item.InterfaceName.IsNull() && !item.InterfaceName.IsUnknown() {
				body, _ = sjson.Set(body, "label.local.advertise.interfaces.interface"+"."+strconv.Itoa(index)+"."+"interface-name", item.InterfaceName.ValueString())
			}
		}
	}
	if len(data.LabelLocalAdvertiseForAccessLists) > 0 {
		body, _ = sjson.Set(body, "label.local.advertise.for.access-lists", []interface{}{})
		for index, item := range data.LabelLocalAdvertiseForAccessLists {
			if !item.AccessListName.IsNull() && !item.AccessListName.IsUnknown() {
				body, _ = sjson.Set(body, "label.local.advertise.for.access-lists"+"."+strconv.Itoa(index)+"."+"access-list-name", item.AccessListName.ValueString())
			}
			if !item.To.IsNull() && !item.To.IsUnknown() {
				body, _ = sjson.Set(body, "label.local.advertise.for.access-lists"+"."+strconv.Itoa(index)+"."+"to", item.To.ValueString())
			}
		}
	}
	if len(data.LabelRemoteAcceptFromNeighbors) > 0 {
		body, _ = sjson.Set(body, "label.remote.accept.from.neighbor", []interface{}{})
		for index, item := range data.LabelRemoteAcceptFromNeighbors {
			if !item.NeighborAddress.IsNull() && !item.NeighborAddress.IsUnknown() {
				body, _ = sjson.Set(body, "label.remote.accept.from.neighbor"+"."+strconv.Itoa(index)+"."+"neighbor-address", item.NeighborAddress.ValueString())
			}
			if !item.LabelSpaceId.IsNull() && !item.LabelSpaceId.IsUnknown() {
				body, _ = sjson.Set(body, "label.remote.accept.from.neighbor"+"."+strconv.Itoa(index)+"."+"label-space-id", strconv.FormatInt(item.LabelSpaceId.ValueInt64(), 10))
			}
			if !item.For.IsNull() && !item.For.IsUnknown() {
				body, _ = sjson.Set(body, "label.remote.accept.from.neighbor"+"."+strconv.Itoa(index)+"."+"for", item.For.ValueString())
			}
		}
	}
	return body
}

// End of section. //template:end toBody

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBody

func (data *MPLSLDPAddressFamily) updateFromBody(ctx context.Context, res []byte) {
	if value := gjson.GetBytes(res, "discovery.transport-address.ipv4-address"); value.Exists() && !data.DiscoveryTransportAddressIpv4.IsNull() {
		data.DiscoveryTransportAddressIpv4 = types.StringValue(value.String())
	} else {
		data.DiscoveryTransportAddressIpv4 = types.StringNull()
	}
	if value := gjson.GetBytes(res, "discovery.transport-address.ipv6-address"); value.Exists() && !data.DiscoveryTransportAddressIpv6.IsNull() {
		data.DiscoveryTransportAddressIpv6 = types.StringValue(value.String())
	} else {
		data.DiscoveryTransportAddressIpv6 = types.StringNull()
	}
	if value := gjson.GetBytes(res, "discovery.targeted-hello.accept"); value.Exists() {
		data.DiscoveryTargetedHelloAccept = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.DiscoveryTargetedHelloAccept.IsNull() {
			data.DiscoveryTargetedHelloAccept = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "discovery.targeted-hello.accept.from"); value.Exists() && !data.DiscoveryTargetedHelloAcceptFrom.IsNull() {
		data.DiscoveryTargetedHelloAcceptFrom = types.StringValue(value.String())
	} else {
		data.DiscoveryTargetedHelloAcceptFrom = types.StringNull()
	}
	for i := range data.NeighborIpv4Targeted {
		keys := [...]string{"neighbor-address"}
		keyValues := [...]string{data.NeighborIpv4Targeted[i].NeighborAddress.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "neighbor.ipv4-addresses.targeted").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("neighbor-address"); value.Exists() && !data.NeighborIpv4Targeted[i].NeighborAddress.IsNull() {
			data.NeighborIpv4Targeted[i].NeighborAddress = types.StringValue(value.String())
		} else {
			data.NeighborIpv4Targeted[i].NeighborAddress = types.StringNull()
		}
	}
	for i := range data.NeighborIpv6Targeted {
		keys := [...]string{"neighbor-address"}
		keyValues := [...]string{data.NeighborIpv6Targeted[i].NeighborAddress.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "neighbor.ipv6-addresses.targeted").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("neighbor-address"); value.Exists() && !data.NeighborIpv6Targeted[i].NeighborAddress.IsNull() {
			data.NeighborIpv6Targeted[i].NeighborAddress = types.StringValue(value.String())
		} else {
			data.NeighborIpv6Targeted[i].NeighborAddress = types.StringNull()
		}
	}
	for i := range data.NeighborSrPolicies {
		keys := [...]string{"policy-name"}
		keyValues := [...]string{data.NeighborSrPolicies[i].PolicyName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "neighbor.sr-policies.sr-policy").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("policy-name"); value.Exists() && !data.NeighborSrPolicies[i].PolicyName.IsNull() {
			data.NeighborSrPolicies[i].PolicyName = types.StringValue(value.String())
		} else {
			data.NeighborSrPolicies[i].PolicyName = types.StringNull()
		}
		if value := r.Get("targeted"); value.Exists() {
			data.NeighborSrPolicies[i].Targeted = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.NeighborSrPolicies[i].Targeted.IsNull() {
				data.NeighborSrPolicies[i].Targeted = types.BoolNull()
			}
		}
	}
	for i := range data.TrafficEngAutoTunnelMeshGroups {
		keys := [...]string{"group-id"}
		keyValues := [...]string{strconv.FormatInt(data.TrafficEngAutoTunnelMeshGroups[i].GroupId.ValueInt64(), 10)}

		var r gjson.Result
		gjson.GetBytes(res, "traffic-eng.auto-tunnel.mesh.groups.group").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("group-id"); value.Exists() && !data.TrafficEngAutoTunnelMeshGroups[i].GroupId.IsNull() {
			data.TrafficEngAutoTunnelMeshGroups[i].GroupId = types.Int64Value(value.Int())
		} else {
			data.TrafficEngAutoTunnelMeshGroups[i].GroupId = types.Int64Null()
		}
	}
	if value := gjson.GetBytes(res, "traffic-eng.auto-tunnel.mesh.groups.all"); value.Exists() {
		data.TrafficEngAutoTunnelMeshGroupsAll = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.TrafficEngAutoTunnelMeshGroupsAll.IsNull() {
			data.TrafficEngAutoTunnelMeshGroupsAll = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "redistribute.bgp.as"); value.Exists() && !data.RedistributeBgpAs.IsNull() {
		data.RedistributeBgpAs = types.StringValue(value.String())
	} else {
		data.RedistributeBgpAs = types.StringNull()
	}
	if value := gjson.GetBytes(res, "redistribute.bgp.advertise-to"); value.Exists() && !data.RedistributeBgpAdvertiseTo.IsNull() {
		data.RedistributeBgpAdvertiseTo = types.StringValue(value.String())
	} else {
		data.RedistributeBgpAdvertiseTo = types.StringNull()
	}
	if value := gjson.GetBytes(res, "label.local.allocate.for.access-list"); value.Exists() && !data.LabelLocalAllocateForAccessList.IsNull() {
		data.LabelLocalAllocateForAccessList = types.StringValue(value.String())
	} else {
		data.LabelLocalAllocateForAccessList = types.StringNull()
	}
	if value := gjson.GetBytes(res, "label.local.allocate.for.host-routes"); value.Exists() {
		data.LabelLocalAllocateForHostRoutes = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.LabelLocalAllocateForHostRoutes.IsNull() {
			data.LabelLocalAllocateForHostRoutes = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "label.local.default-route"); value.Exists() {
		data.LabelLocalDefaultRoute = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.LabelLocalDefaultRoute.IsNull() {
			data.LabelLocalDefaultRoute = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "label.local.implicit-null-override.for"); value.Exists() && !data.LabelLocalImplicitNullOverrideFor.IsNull() {
		data.LabelLocalImplicitNullOverrideFor = types.StringValue(value.String())
	} else {
		data.LabelLocalImplicitNullOverrideFor = types.StringNull()
	}
	if value := gjson.GetBytes(res, "label.local.advertise.explicit-null"); value.Exists() {
		data.LabelLocalAdvertiseExplicitNull = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.LabelLocalAdvertiseExplicitNull.IsNull() {
			data.LabelLocalAdvertiseExplicitNull = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "label.local.advertise.explicit-null.for.access-list"); value.Exists() && !data.LabelLocalAdvertiseExplicitNullForAcl.IsNull() {
		data.LabelLocalAdvertiseExplicitNullForAcl = types.StringValue(value.String())
	} else {
		data.LabelLocalAdvertiseExplicitNullForAcl = types.StringNull()
	}
	if value := gjson.GetBytes(res, "label.local.advertise.explicit-null.for.to.access-list"); value.Exists() && !data.LabelLocalAdvertiseExplicitNullForAclToAcl.IsNull() {
		data.LabelLocalAdvertiseExplicitNullForAclToAcl = types.StringValue(value.String())
	} else {
		data.LabelLocalAdvertiseExplicitNullForAclToAcl = types.StringNull()
	}
	if value := gjson.GetBytes(res, "label.local.advertise.explicit-null.to.access-list"); value.Exists() && !data.LabelLocalAdvertiseExplicitNullToAcl.IsNull() {
		data.LabelLocalAdvertiseExplicitNullToAcl = types.StringValue(value.String())
	} else {
		data.LabelLocalAdvertiseExplicitNullToAcl = types.StringNull()
	}
	for i := range data.LabelLocalAdvertiseToNeighbors {
		keys := [...]string{"neighbor-address", "label-space-id"}
		keyValues := [...]string{data.LabelLocalAdvertiseToNeighbors[i].NeighborAddress.ValueString(), strconv.FormatInt(data.LabelLocalAdvertiseToNeighbors[i].LabelSpaceId.ValueInt64(), 10)}

		var r gjson.Result
		gjson.GetBytes(res, "label.local.advertise.to.neighbor").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("neighbor-address"); value.Exists() && !data.LabelLocalAdvertiseToNeighbors[i].NeighborAddress.IsNull() {
			data.LabelLocalAdvertiseToNeighbors[i].NeighborAddress = types.StringValue(value.String())
		} else {
			data.LabelLocalAdvertiseToNeighbors[i].NeighborAddress = types.StringNull()
		}
		if value := r.Get("label-space-id"); value.Exists() && !data.LabelLocalAdvertiseToNeighbors[i].LabelSpaceId.IsNull() {
			data.LabelLocalAdvertiseToNeighbors[i].LabelSpaceId = types.Int64Value(value.Int())
		} else {
			data.LabelLocalAdvertiseToNeighbors[i].LabelSpaceId = types.Int64Null()
		}
		if value := r.Get("for"); value.Exists() && !data.LabelLocalAdvertiseToNeighbors[i].For.IsNull() {
			data.LabelLocalAdvertiseToNeighbors[i].For = types.StringValue(value.String())
		} else {
			data.LabelLocalAdvertiseToNeighbors[i].For = types.StringNull()
		}
	}
	for i := range data.LabelLocalAdvertiseInterfaces {
		keys := [...]string{"interface-name"}
		keyValues := [...]string{data.LabelLocalAdvertiseInterfaces[i].InterfaceName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "label.local.advertise.interfaces.interface").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("interface-name"); value.Exists() && !data.LabelLocalAdvertiseInterfaces[i].InterfaceName.IsNull() {
			data.LabelLocalAdvertiseInterfaces[i].InterfaceName = types.StringValue(value.String())
		} else {
			data.LabelLocalAdvertiseInterfaces[i].InterfaceName = types.StringNull()
		}
	}
	if value := gjson.GetBytes(res, "label.local.advertise.disable"); value.Exists() {
		data.LabelLocalAdvertiseDisable = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.LabelLocalAdvertiseDisable.IsNull() {
			data.LabelLocalAdvertiseDisable = types.BoolNull()
		}
	}
	for i := range data.LabelLocalAdvertiseForAccessLists {
		keys := [...]string{"access-list-name"}
		keyValues := [...]string{data.LabelLocalAdvertiseForAccessLists[i].AccessListName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "label.local.advertise.for.access-lists").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("access-list-name"); value.Exists() && !data.LabelLocalAdvertiseForAccessLists[i].AccessListName.IsNull() {
			data.LabelLocalAdvertiseForAccessLists[i].AccessListName = types.StringValue(value.String())
		} else {
			data.LabelLocalAdvertiseForAccessLists[i].AccessListName = types.StringNull()
		}
		if value := r.Get("to"); value.Exists() && !data.LabelLocalAdvertiseForAccessLists[i].To.IsNull() {
			data.LabelLocalAdvertiseForAccessLists[i].To = types.StringValue(value.String())
		} else {
			data.LabelLocalAdvertiseForAccessLists[i].To = types.StringNull()
		}
	}
	for i := range data.LabelRemoteAcceptFromNeighbors {
		keys := [...]string{"neighbor-address", "label-space-id"}
		keyValues := [...]string{data.LabelRemoteAcceptFromNeighbors[i].NeighborAddress.ValueString(), strconv.FormatInt(data.LabelRemoteAcceptFromNeighbors[i].LabelSpaceId.ValueInt64(), 10)}

		var r gjson.Result
		gjson.GetBytes(res, "label.remote.accept.from.neighbor").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("neighbor-address"); value.Exists() && !data.LabelRemoteAcceptFromNeighbors[i].NeighborAddress.IsNull() {
			data.LabelRemoteAcceptFromNeighbors[i].NeighborAddress = types.StringValue(value.String())
		} else {
			data.LabelRemoteAcceptFromNeighbors[i].NeighborAddress = types.StringNull()
		}
		if value := r.Get("label-space-id"); value.Exists() && !data.LabelRemoteAcceptFromNeighbors[i].LabelSpaceId.IsNull() {
			data.LabelRemoteAcceptFromNeighbors[i].LabelSpaceId = types.Int64Value(value.Int())
		} else {
			data.LabelRemoteAcceptFromNeighbors[i].LabelSpaceId = types.Int64Null()
		}
		if value := r.Get("for"); value.Exists() && !data.LabelRemoteAcceptFromNeighbors[i].For.IsNull() {
			data.LabelRemoteAcceptFromNeighbors[i].For = types.StringValue(value.String())
		} else {
			data.LabelRemoteAcceptFromNeighbors[i].For = types.StringNull()
		}
	}
}

// End of section. //template:end updateFromBody
// Section below is generated&owned by "gen/generator.go". //template:begin toBodyXML

func (data MPLSLDPAddressFamily) toBodyXML(ctx context.Context) string {
	body := netconf.Body{}
	if !data.AfName.IsNull() && !data.AfName.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/af-name", data.AfName.ValueString())
	}
	if !data.DiscoveryTransportAddressIpv4.IsNull() && !data.DiscoveryTransportAddressIpv4.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/discovery/transport-address/ipv4-address", data.DiscoveryTransportAddressIpv4.ValueString())
	}
	if !data.DiscoveryTransportAddressIpv6.IsNull() && !data.DiscoveryTransportAddressIpv6.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/discovery/transport-address/ipv6-address", data.DiscoveryTransportAddressIpv6.ValueString())
	}
	if !data.DiscoveryTargetedHelloAccept.IsNull() && !data.DiscoveryTargetedHelloAccept.IsUnknown() {
		if data.DiscoveryTargetedHelloAccept.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/discovery/targeted-hello/accept", "")
		}
	}
	if !data.DiscoveryTargetedHelloAcceptFrom.IsNull() && !data.DiscoveryTargetedHelloAcceptFrom.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/discovery/targeted-hello/accept/from", data.DiscoveryTargetedHelloAcceptFrom.ValueString())
	}
	if len(data.NeighborIpv4Targeted) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.NeighborIpv4Targeted {
			cBody := netconf.Body{}
			if !item.NeighborAddress.IsNull() && !item.NeighborAddress.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "neighbor-address", item.NeighborAddress.ValueString())
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"neighbor/ipv4-addresses/targeted", cBody.Res())
		}
	}
	if len(data.NeighborIpv6Targeted) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.NeighborIpv6Targeted {
			cBody := netconf.Body{}
			if !item.NeighborAddress.IsNull() && !item.NeighborAddress.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "neighbor-address", item.NeighborAddress.ValueString())
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"neighbor/ipv6-addresses/targeted", cBody.Res())
		}
	}
	if len(data.NeighborSrPolicies) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.NeighborSrPolicies {
			cBody := netconf.Body{}
			if !item.PolicyName.IsNull() && !item.PolicyName.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "policy-name", item.PolicyName.ValueString())
			}
			if !item.Targeted.IsNull() && !item.Targeted.IsUnknown() {
				if item.Targeted.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "targeted", "")
				}
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"neighbor/sr-policies/sr-policy", cBody.Res())
		}
	}
	if len(data.TrafficEngAutoTunnelMeshGroups) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.TrafficEngAutoTunnelMeshGroups {
			cBody := netconf.Body{}
			if !item.GroupId.IsNull() && !item.GroupId.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "group-id", strconv.FormatInt(item.GroupId.ValueInt64(), 10))
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"traffic-eng/auto-tunnel/mesh/groups/group", cBody.Res())
		}
	}
	if !data.TrafficEngAutoTunnelMeshGroupsAll.IsNull() && !data.TrafficEngAutoTunnelMeshGroupsAll.IsUnknown() {
		if data.TrafficEngAutoTunnelMeshGroupsAll.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/traffic-eng/auto-tunnel/mesh/groups/all", "")
		}
	}
	if !data.RedistributeBgpAs.IsNull() && !data.RedistributeBgpAs.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/redistribute/bgp/as", data.RedistributeBgpAs.ValueString())
	}
	if !data.RedistributeBgpAdvertiseTo.IsNull() && !data.RedistributeBgpAdvertiseTo.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/redistribute/bgp/advertise-to", data.RedistributeBgpAdvertiseTo.ValueString())
	}
	if !data.LabelLocalAllocateForAccessList.IsNull() && !data.LabelLocalAllocateForAccessList.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/label/local/allocate/for/access-list", data.LabelLocalAllocateForAccessList.ValueString())
	}
	if !data.LabelLocalAllocateForHostRoutes.IsNull() && !data.LabelLocalAllocateForHostRoutes.IsUnknown() {
		if data.LabelLocalAllocateForHostRoutes.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/label/local/allocate/for/host-routes", "")
		}
	}
	if !data.LabelLocalDefaultRoute.IsNull() && !data.LabelLocalDefaultRoute.IsUnknown() {
		if data.LabelLocalDefaultRoute.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/label/local/default-route", "")
		}
	}
	if !data.LabelLocalImplicitNullOverrideFor.IsNull() && !data.LabelLocalImplicitNullOverrideFor.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/label/local/implicit-null-override/for", data.LabelLocalImplicitNullOverrideFor.ValueString())
	}
	if !data.LabelLocalAdvertiseExplicitNull.IsNull() && !data.LabelLocalAdvertiseExplicitNull.IsUnknown() {
		if data.LabelLocalAdvertiseExplicitNull.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/label/local/advertise/explicit-null", "")
		}
	}
	if !data.LabelLocalAdvertiseExplicitNullForAcl.IsNull() && !data.LabelLocalAdvertiseExplicitNullForAcl.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/label/local/advertise/explicit-null/for/access-list", data.LabelLocalAdvertiseExplicitNullForAcl.ValueString())
	}
	if !data.LabelLocalAdvertiseExplicitNullForAclToAcl.IsNull() && !data.LabelLocalAdvertiseExplicitNullForAclToAcl.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/label/local/advertise/explicit-null/for/to/access-list", data.LabelLocalAdvertiseExplicitNullForAclToAcl.ValueString())
	}
	if !data.LabelLocalAdvertiseExplicitNullToAcl.IsNull() && !data.LabelLocalAdvertiseExplicitNullToAcl.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/label/local/advertise/explicit-null/to/access-list", data.LabelLocalAdvertiseExplicitNullToAcl.ValueString())
	}
	if len(data.LabelLocalAdvertiseToNeighbors) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.LabelLocalAdvertiseToNeighbors {
			cBody := netconf.Body{}
			if !item.NeighborAddress.IsNull() && !item.NeighborAddress.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "neighbor-address", item.NeighborAddress.ValueString())
			}
			if !item.LabelSpaceId.IsNull() && !item.LabelSpaceId.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "label-space-id", strconv.FormatInt(item.LabelSpaceId.ValueInt64(), 10))
			}
			if !item.For.IsNull() && !item.For.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "for", item.For.ValueString())
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"label/local/advertise/to/neighbor", cBody.Res())
		}
	}
	if len(data.LabelLocalAdvertiseInterfaces) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.LabelLocalAdvertiseInterfaces {
			cBody := netconf.Body{}
			if !item.InterfaceName.IsNull() && !item.InterfaceName.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "interface-name", item.InterfaceName.ValueString())
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"label/local/advertise/interfaces/interface", cBody.Res())
		}
	}
	if !data.LabelLocalAdvertiseDisable.IsNull() && !data.LabelLocalAdvertiseDisable.IsUnknown() {
		if data.LabelLocalAdvertiseDisable.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/label/local/advertise/disable", "")
		}
	}
	if len(data.LabelLocalAdvertiseForAccessLists) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.LabelLocalAdvertiseForAccessLists {
			cBody := netconf.Body{}
			if !item.AccessListName.IsNull() && !item.AccessListName.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "access-list-name", item.AccessListName.ValueString())
			}
			if !item.To.IsNull() && !item.To.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "to", item.To.ValueString())
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"label/local/advertise/for/access-lists", cBody.Res())
		}
	}
	if len(data.LabelRemoteAcceptFromNeighbors) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.LabelRemoteAcceptFromNeighbors {
			cBody := netconf.Body{}
			if !item.NeighborAddress.IsNull() && !item.NeighborAddress.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "neighbor-address", item.NeighborAddress.ValueString())
			}
			if !item.LabelSpaceId.IsNull() && !item.LabelSpaceId.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "label-space-id", strconv.FormatInt(item.LabelSpaceId.ValueInt64(), 10))
			}
			if !item.For.IsNull() && !item.For.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "for", item.For.ValueString())
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"label/remote/accept/from/neighbor", cBody.Res())
		}
	}
	bodyString, err := body.String()
	if err != nil {
		tflog.Error(ctx, fmt.Sprintf("Error converting body to string: %s", err))
	}
	return bodyString
}

// End of section. //template:end toBodyXML
// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBodyXML

func (data *MPLSLDPAddressFamily) updateFromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/af-name"); value.Exists() {
		data.AfName = types.StringValue(value.String())
	} else if data.AfName.IsNull() {
		data.AfName = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/discovery/transport-address/ipv4-address"); value.Exists() {
		data.DiscoveryTransportAddressIpv4 = types.StringValue(value.String())
	} else if data.DiscoveryTransportAddressIpv4.IsNull() {
		data.DiscoveryTransportAddressIpv4 = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/discovery/transport-address/ipv6-address"); value.Exists() {
		data.DiscoveryTransportAddressIpv6 = types.StringValue(value.String())
	} else if data.DiscoveryTransportAddressIpv6.IsNull() {
		data.DiscoveryTransportAddressIpv6 = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/discovery/targeted-hello/accept"); value.Exists() {
		data.DiscoveryTargetedHelloAccept = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.DiscoveryTargetedHelloAccept.IsNull() {
			data.DiscoveryTargetedHelloAccept = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/discovery/targeted-hello/accept/from"); value.Exists() {
		data.DiscoveryTargetedHelloAcceptFrom = types.StringValue(value.String())
	} else if data.DiscoveryTargetedHelloAcceptFrom.IsNull() {
		data.DiscoveryTargetedHelloAcceptFrom = types.StringNull()
	}
	for i := range data.NeighborIpv4Targeted {
		keys := [...]string{"neighbor-address"}
		keyValues := [...]string{data.NeighborIpv4Targeted[i].NeighborAddress.ValueString()}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/neighbor/ipv4-addresses/targeted").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "neighbor-address"); value.Exists() {
			data.NeighborIpv4Targeted[i].NeighborAddress = types.StringValue(value.String())
		} else if data.NeighborIpv4Targeted[i].NeighborAddress.IsNull() {
			data.NeighborIpv4Targeted[i].NeighborAddress = types.StringNull()
		}
	}
	for i := range data.NeighborIpv6Targeted {
		keys := [...]string{"neighbor-address"}
		keyValues := [...]string{data.NeighborIpv6Targeted[i].NeighborAddress.ValueString()}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/neighbor/ipv6-addresses/targeted").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "neighbor-address"); value.Exists() {
			data.NeighborIpv6Targeted[i].NeighborAddress = types.StringValue(value.String())
		} else if data.NeighborIpv6Targeted[i].NeighborAddress.IsNull() {
			data.NeighborIpv6Targeted[i].NeighborAddress = types.StringNull()
		}
	}
	for i := range data.NeighborSrPolicies {
		keys := [...]string{"policy-name"}
		keyValues := [...]string{data.NeighborSrPolicies[i].PolicyName.ValueString()}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/neighbor/sr-policies/sr-policy").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "policy-name"); value.Exists() {
			data.NeighborSrPolicies[i].PolicyName = types.StringValue(value.String())
		} else if data.NeighborSrPolicies[i].PolicyName.IsNull() {
			data.NeighborSrPolicies[i].PolicyName = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "targeted"); value.Exists() {
			data.NeighborSrPolicies[i].Targeted = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.NeighborSrPolicies[i].Targeted.IsNull() {
				data.NeighborSrPolicies[i].Targeted = types.BoolNull()
			}
		}
	}
	for i := range data.TrafficEngAutoTunnelMeshGroups {
		keys := [...]string{"group-id"}
		keyValues := [...]string{strconv.FormatInt(data.TrafficEngAutoTunnelMeshGroups[i].GroupId.ValueInt64(), 10)}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/traffic-eng/auto-tunnel/mesh/groups/group").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "group-id"); value.Exists() {
			data.TrafficEngAutoTunnelMeshGroups[i].GroupId = types.Int64Value(value.Int())
		} else if data.TrafficEngAutoTunnelMeshGroups[i].GroupId.IsNull() {
			data.TrafficEngAutoTunnelMeshGroups[i].GroupId = types.Int64Null()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/traffic-eng/auto-tunnel/mesh/groups/all"); value.Exists() {
		data.TrafficEngAutoTunnelMeshGroupsAll = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.TrafficEngAutoTunnelMeshGroupsAll.IsNull() {
			data.TrafficEngAutoTunnelMeshGroupsAll = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/redistribute/bgp/as"); value.Exists() {
		data.RedistributeBgpAs = types.StringValue(value.String())
	} else if data.RedistributeBgpAs.IsNull() {
		data.RedistributeBgpAs = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/redistribute/bgp/advertise-to"); value.Exists() {
		data.RedistributeBgpAdvertiseTo = types.StringValue(value.String())
	} else if data.RedistributeBgpAdvertiseTo.IsNull() {
		data.RedistributeBgpAdvertiseTo = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/allocate/for/access-list"); value.Exists() {
		data.LabelLocalAllocateForAccessList = types.StringValue(value.String())
	} else if data.LabelLocalAllocateForAccessList.IsNull() {
		data.LabelLocalAllocateForAccessList = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/allocate/for/host-routes"); value.Exists() {
		data.LabelLocalAllocateForHostRoutes = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.LabelLocalAllocateForHostRoutes.IsNull() {
			data.LabelLocalAllocateForHostRoutes = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/default-route"); value.Exists() {
		data.LabelLocalDefaultRoute = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.LabelLocalDefaultRoute.IsNull() {
			data.LabelLocalDefaultRoute = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/implicit-null-override/for"); value.Exists() {
		data.LabelLocalImplicitNullOverrideFor = types.StringValue(value.String())
	} else if data.LabelLocalImplicitNullOverrideFor.IsNull() {
		data.LabelLocalImplicitNullOverrideFor = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/explicit-null"); value.Exists() {
		data.LabelLocalAdvertiseExplicitNull = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.LabelLocalAdvertiseExplicitNull.IsNull() {
			data.LabelLocalAdvertiseExplicitNull = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/explicit-null/for/access-list"); value.Exists() {
		data.LabelLocalAdvertiseExplicitNullForAcl = types.StringValue(value.String())
	} else if data.LabelLocalAdvertiseExplicitNullForAcl.IsNull() {
		data.LabelLocalAdvertiseExplicitNullForAcl = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/explicit-null/for/to/access-list"); value.Exists() {
		data.LabelLocalAdvertiseExplicitNullForAclToAcl = types.StringValue(value.String())
	} else if data.LabelLocalAdvertiseExplicitNullForAclToAcl.IsNull() {
		data.LabelLocalAdvertiseExplicitNullForAclToAcl = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/explicit-null/to/access-list"); value.Exists() {
		data.LabelLocalAdvertiseExplicitNullToAcl = types.StringValue(value.String())
	} else if data.LabelLocalAdvertiseExplicitNullToAcl.IsNull() {
		data.LabelLocalAdvertiseExplicitNullToAcl = types.StringNull()
	}
	for i := range data.LabelLocalAdvertiseToNeighbors {
		keys := [...]string{"neighbor-address", "label-space-id"}
		keyValues := [...]string{data.LabelLocalAdvertiseToNeighbors[i].NeighborAddress.ValueString(), strconv.FormatInt(data.LabelLocalAdvertiseToNeighbors[i].LabelSpaceId.ValueInt64(), 10)}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/to/neighbor").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "neighbor-address"); value.Exists() {
			data.LabelLocalAdvertiseToNeighbors[i].NeighborAddress = types.StringValue(value.String())
		} else if data.LabelLocalAdvertiseToNeighbors[i].NeighborAddress.IsNull() {
			data.LabelLocalAdvertiseToNeighbors[i].NeighborAddress = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "label-space-id"); value.Exists() {
			data.LabelLocalAdvertiseToNeighbors[i].LabelSpaceId = types.Int64Value(value.Int())
		} else if data.LabelLocalAdvertiseToNeighbors[i].LabelSpaceId.IsNull() {
			data.LabelLocalAdvertiseToNeighbors[i].LabelSpaceId = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "for"); value.Exists() {
			data.LabelLocalAdvertiseToNeighbors[i].For = types.StringValue(value.String())
		} else if data.LabelLocalAdvertiseToNeighbors[i].For.IsNull() {
			data.LabelLocalAdvertiseToNeighbors[i].For = types.StringNull()
		}
	}
	for i := range data.LabelLocalAdvertiseInterfaces {
		keys := [...]string{"interface-name"}
		keyValues := [...]string{data.LabelLocalAdvertiseInterfaces[i].InterfaceName.ValueString()}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/interfaces/interface").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "interface-name"); value.Exists() {
			data.LabelLocalAdvertiseInterfaces[i].InterfaceName = types.StringValue(value.String())
		} else if data.LabelLocalAdvertiseInterfaces[i].InterfaceName.IsNull() {
			data.LabelLocalAdvertiseInterfaces[i].InterfaceName = types.StringNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/disable"); value.Exists() {
		data.LabelLocalAdvertiseDisable = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.LabelLocalAdvertiseDisable.IsNull() {
			data.LabelLocalAdvertiseDisable = types.BoolNull()
		}
	}
	for i := range data.LabelLocalAdvertiseForAccessLists {
		keys := [...]string{"access-list-name"}
		keyValues := [...]string{data.LabelLocalAdvertiseForAccessLists[i].AccessListName.ValueString()}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/for/access-lists").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "access-list-name"); value.Exists() {
			data.LabelLocalAdvertiseForAccessLists[i].AccessListName = types.StringValue(value.String())
		} else if data.LabelLocalAdvertiseForAccessLists[i].AccessListName.IsNull() {
			data.LabelLocalAdvertiseForAccessLists[i].AccessListName = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "to"); value.Exists() {
			data.LabelLocalAdvertiseForAccessLists[i].To = types.StringValue(value.String())
		} else if data.LabelLocalAdvertiseForAccessLists[i].To.IsNull() {
			data.LabelLocalAdvertiseForAccessLists[i].To = types.StringNull()
		}
	}
	for i := range data.LabelRemoteAcceptFromNeighbors {
		keys := [...]string{"neighbor-address", "label-space-id"}
		keyValues := [...]string{data.LabelRemoteAcceptFromNeighbors[i].NeighborAddress.ValueString(), strconv.FormatInt(data.LabelRemoteAcceptFromNeighbors[i].LabelSpaceId.ValueInt64(), 10)}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/remote/accept/from/neighbor").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "neighbor-address"); value.Exists() {
			data.LabelRemoteAcceptFromNeighbors[i].NeighborAddress = types.StringValue(value.String())
		} else if data.LabelRemoteAcceptFromNeighbors[i].NeighborAddress.IsNull() {
			data.LabelRemoteAcceptFromNeighbors[i].NeighborAddress = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "label-space-id"); value.Exists() {
			data.LabelRemoteAcceptFromNeighbors[i].LabelSpaceId = types.Int64Value(value.Int())
		} else if data.LabelRemoteAcceptFromNeighbors[i].LabelSpaceId.IsNull() {
			data.LabelRemoteAcceptFromNeighbors[i].LabelSpaceId = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "for"); value.Exists() {
			data.LabelRemoteAcceptFromNeighbors[i].For = types.StringValue(value.String())
		} else if data.LabelRemoteAcceptFromNeighbors[i].For.IsNull() {
			data.LabelRemoteAcceptFromNeighbors[i].For = types.StringNull()
		}
	}
}

// End of section. //template:end updateFromBodyXML
// Section below is generated&owned by "gen/generator.go". //template:begin fromBody

func (data *MPLSLDPAddressFamily) fromBody(ctx context.Context, res gjson.Result) {
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	if value := res.Get(prefix + "discovery.transport-address.ipv4-address"); value.Exists() {
		data.DiscoveryTransportAddressIpv4 = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "discovery.transport-address.ipv6-address"); value.Exists() {
		data.DiscoveryTransportAddressIpv6 = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "discovery.targeted-hello.accept"); value.Exists() {
		data.DiscoveryTargetedHelloAccept = types.BoolValue(true)
	} else {
		data.DiscoveryTargetedHelloAccept = types.BoolValue(false)
	}
	if value := res.Get(prefix + "discovery.targeted-hello.accept.from"); value.Exists() {
		data.DiscoveryTargetedHelloAcceptFrom = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "neighbor.ipv4-addresses.targeted"); value.Exists() {
		data.NeighborIpv4Targeted = make([]MPLSLDPAddressFamilyNeighborIpv4Targeted, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := MPLSLDPAddressFamilyNeighborIpv4Targeted{}
			if cValue := v.Get("neighbor-address"); cValue.Exists() {
				item.NeighborAddress = types.StringValue(cValue.String())
			}
			data.NeighborIpv4Targeted = append(data.NeighborIpv4Targeted, item)
			return true
		})
	}
	if value := res.Get(prefix + "neighbor.ipv6-addresses.targeted"); value.Exists() {
		data.NeighborIpv6Targeted = make([]MPLSLDPAddressFamilyNeighborIpv6Targeted, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := MPLSLDPAddressFamilyNeighborIpv6Targeted{}
			if cValue := v.Get("neighbor-address"); cValue.Exists() {
				item.NeighborAddress = types.StringValue(cValue.String())
			}
			data.NeighborIpv6Targeted = append(data.NeighborIpv6Targeted, item)
			return true
		})
	}
	if value := res.Get(prefix + "neighbor.sr-policies.sr-policy"); value.Exists() {
		data.NeighborSrPolicies = make([]MPLSLDPAddressFamilyNeighborSrPolicies, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := MPLSLDPAddressFamilyNeighborSrPolicies{}
			if cValue := v.Get("policy-name"); cValue.Exists() {
				item.PolicyName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("targeted"); cValue.Exists() {
				item.Targeted = types.BoolValue(true)
			} else {
				item.Targeted = types.BoolValue(false)
			}
			data.NeighborSrPolicies = append(data.NeighborSrPolicies, item)
			return true
		})
	}
	if value := res.Get(prefix + "traffic-eng.auto-tunnel.mesh.groups.group"); value.Exists() {
		data.TrafficEngAutoTunnelMeshGroups = make([]MPLSLDPAddressFamilyTrafficEngAutoTunnelMeshGroups, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := MPLSLDPAddressFamilyTrafficEngAutoTunnelMeshGroups{}
			if cValue := v.Get("group-id"); cValue.Exists() {
				item.GroupId = types.Int64Value(cValue.Int())
			}
			data.TrafficEngAutoTunnelMeshGroups = append(data.TrafficEngAutoTunnelMeshGroups, item)
			return true
		})
	}
	if value := res.Get(prefix + "traffic-eng.auto-tunnel.mesh.groups.all"); value.Exists() {
		data.TrafficEngAutoTunnelMeshGroupsAll = types.BoolValue(true)
	} else {
		data.TrafficEngAutoTunnelMeshGroupsAll = types.BoolValue(false)
	}
	if value := res.Get(prefix + "redistribute.bgp.as"); value.Exists() {
		data.RedistributeBgpAs = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "redistribute.bgp.advertise-to"); value.Exists() {
		data.RedistributeBgpAdvertiseTo = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "label.local.allocate.for.access-list"); value.Exists() {
		data.LabelLocalAllocateForAccessList = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "label.local.allocate.for.host-routes"); value.Exists() {
		data.LabelLocalAllocateForHostRoutes = types.BoolValue(true)
	} else {
		data.LabelLocalAllocateForHostRoutes = types.BoolValue(false)
	}
	if value := res.Get(prefix + "label.local.default-route"); value.Exists() {
		data.LabelLocalDefaultRoute = types.BoolValue(true)
	} else {
		data.LabelLocalDefaultRoute = types.BoolValue(false)
	}
	if value := res.Get(prefix + "label.local.implicit-null-override.for"); value.Exists() {
		data.LabelLocalImplicitNullOverrideFor = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "label.local.advertise.explicit-null"); value.Exists() {
		data.LabelLocalAdvertiseExplicitNull = types.BoolValue(true)
	} else {
		data.LabelLocalAdvertiseExplicitNull = types.BoolValue(false)
	}
	if value := res.Get(prefix + "label.local.advertise.explicit-null.for.access-list"); value.Exists() {
		data.LabelLocalAdvertiseExplicitNullForAcl = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "label.local.advertise.explicit-null.for.to.access-list"); value.Exists() {
		data.LabelLocalAdvertiseExplicitNullForAclToAcl = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "label.local.advertise.explicit-null.to.access-list"); value.Exists() {
		data.LabelLocalAdvertiseExplicitNullToAcl = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "label.local.advertise.to.neighbor"); value.Exists() {
		data.LabelLocalAdvertiseToNeighbors = make([]MPLSLDPAddressFamilyLabelLocalAdvertiseToNeighbors, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := MPLSLDPAddressFamilyLabelLocalAdvertiseToNeighbors{}
			if cValue := v.Get("neighbor-address"); cValue.Exists() {
				item.NeighborAddress = types.StringValue(cValue.String())
			}
			if cValue := v.Get("label-space-id"); cValue.Exists() {
				item.LabelSpaceId = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("for"); cValue.Exists() {
				item.For = types.StringValue(cValue.String())
			}
			data.LabelLocalAdvertiseToNeighbors = append(data.LabelLocalAdvertiseToNeighbors, item)
			return true
		})
	}
	if value := res.Get(prefix + "label.local.advertise.interfaces.interface"); value.Exists() {
		data.LabelLocalAdvertiseInterfaces = make([]MPLSLDPAddressFamilyLabelLocalAdvertiseInterfaces, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := MPLSLDPAddressFamilyLabelLocalAdvertiseInterfaces{}
			if cValue := v.Get("interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			data.LabelLocalAdvertiseInterfaces = append(data.LabelLocalAdvertiseInterfaces, item)
			return true
		})
	}
	if value := res.Get(prefix + "label.local.advertise.disable"); value.Exists() {
		data.LabelLocalAdvertiseDisable = types.BoolValue(true)
	} else {
		data.LabelLocalAdvertiseDisable = types.BoolValue(false)
	}
	if value := res.Get(prefix + "label.local.advertise.for.access-lists"); value.Exists() {
		data.LabelLocalAdvertiseForAccessLists = make([]MPLSLDPAddressFamilyLabelLocalAdvertiseForAccessLists, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := MPLSLDPAddressFamilyLabelLocalAdvertiseForAccessLists{}
			if cValue := v.Get("access-list-name"); cValue.Exists() {
				item.AccessListName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("to"); cValue.Exists() {
				item.To = types.StringValue(cValue.String())
			}
			data.LabelLocalAdvertiseForAccessLists = append(data.LabelLocalAdvertiseForAccessLists, item)
			return true
		})
	}
	if value := res.Get(prefix + "label.remote.accept.from.neighbor"); value.Exists() {
		data.LabelRemoteAcceptFromNeighbors = make([]MPLSLDPAddressFamilyLabelRemoteAcceptFromNeighbors, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := MPLSLDPAddressFamilyLabelRemoteAcceptFromNeighbors{}
			if cValue := v.Get("neighbor-address"); cValue.Exists() {
				item.NeighborAddress = types.StringValue(cValue.String())
			}
			if cValue := v.Get("label-space-id"); cValue.Exists() {
				item.LabelSpaceId = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("for"); cValue.Exists() {
				item.For = types.StringValue(cValue.String())
			}
			data.LabelRemoteAcceptFromNeighbors = append(data.LabelRemoteAcceptFromNeighbors, item)
			return true
		})
	}
}

// End of section. //template:end fromBody
// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyData

func (data *MPLSLDPAddressFamilyData) fromBody(ctx context.Context, res gjson.Result) {
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	if value := res.Get(prefix + "discovery.transport-address.ipv4-address"); value.Exists() {
		data.DiscoveryTransportAddressIpv4 = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "discovery.transport-address.ipv6-address"); value.Exists() {
		data.DiscoveryTransportAddressIpv6 = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "discovery.targeted-hello.accept"); value.Exists() {
		data.DiscoveryTargetedHelloAccept = types.BoolValue(true)
	} else {
		data.DiscoveryTargetedHelloAccept = types.BoolNull()
	}
	if value := res.Get(prefix + "discovery.targeted-hello.accept.from"); value.Exists() {
		data.DiscoveryTargetedHelloAcceptFrom = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "neighbor.ipv4-addresses.targeted"); value.Exists() {
		data.NeighborIpv4Targeted = make([]MPLSLDPAddressFamilyNeighborIpv4Targeted, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := MPLSLDPAddressFamilyNeighborIpv4Targeted{}
			if cValue := v.Get("neighbor-address"); cValue.Exists() {
				item.NeighborAddress = types.StringValue(cValue.String())
			}
			data.NeighborIpv4Targeted = append(data.NeighborIpv4Targeted, item)
			return true
		})
	}
	if value := res.Get(prefix + "neighbor.ipv6-addresses.targeted"); value.Exists() {
		data.NeighborIpv6Targeted = make([]MPLSLDPAddressFamilyNeighborIpv6Targeted, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := MPLSLDPAddressFamilyNeighborIpv6Targeted{}
			if cValue := v.Get("neighbor-address"); cValue.Exists() {
				item.NeighborAddress = types.StringValue(cValue.String())
			}
			data.NeighborIpv6Targeted = append(data.NeighborIpv6Targeted, item)
			return true
		})
	}
	if value := res.Get(prefix + "neighbor.sr-policies.sr-policy"); value.Exists() {
		data.NeighborSrPolicies = make([]MPLSLDPAddressFamilyNeighborSrPolicies, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := MPLSLDPAddressFamilyNeighborSrPolicies{}
			if cValue := v.Get("policy-name"); cValue.Exists() {
				item.PolicyName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("targeted"); cValue.Exists() {
				item.Targeted = types.BoolValue(true)
			} else {
				item.Targeted = types.BoolNull()
			}
			data.NeighborSrPolicies = append(data.NeighborSrPolicies, item)
			return true
		})
	}
	if value := res.Get(prefix + "traffic-eng.auto-tunnel.mesh.groups.group"); value.Exists() {
		data.TrafficEngAutoTunnelMeshGroups = make([]MPLSLDPAddressFamilyTrafficEngAutoTunnelMeshGroups, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := MPLSLDPAddressFamilyTrafficEngAutoTunnelMeshGroups{}
			if cValue := v.Get("group-id"); cValue.Exists() {
				item.GroupId = types.Int64Value(cValue.Int())
			}
			data.TrafficEngAutoTunnelMeshGroups = append(data.TrafficEngAutoTunnelMeshGroups, item)
			return true
		})
	}
	if value := res.Get(prefix + "traffic-eng.auto-tunnel.mesh.groups.all"); value.Exists() {
		data.TrafficEngAutoTunnelMeshGroupsAll = types.BoolValue(true)
	} else {
		data.TrafficEngAutoTunnelMeshGroupsAll = types.BoolNull()
	}
	if value := res.Get(prefix + "redistribute.bgp.as"); value.Exists() {
		data.RedistributeBgpAs = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "redistribute.bgp.advertise-to"); value.Exists() {
		data.RedistributeBgpAdvertiseTo = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "label.local.allocate.for.access-list"); value.Exists() {
		data.LabelLocalAllocateForAccessList = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "label.local.allocate.for.host-routes"); value.Exists() {
		data.LabelLocalAllocateForHostRoutes = types.BoolValue(true)
	} else {
		data.LabelLocalAllocateForHostRoutes = types.BoolNull()
	}
	if value := res.Get(prefix + "label.local.default-route"); value.Exists() {
		data.LabelLocalDefaultRoute = types.BoolValue(true)
	} else {
		data.LabelLocalDefaultRoute = types.BoolNull()
	}
	if value := res.Get(prefix + "label.local.implicit-null-override.for"); value.Exists() {
		data.LabelLocalImplicitNullOverrideFor = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "label.local.advertise.explicit-null"); value.Exists() {
		data.LabelLocalAdvertiseExplicitNull = types.BoolValue(true)
	} else {
		data.LabelLocalAdvertiseExplicitNull = types.BoolNull()
	}
	if value := res.Get(prefix + "label.local.advertise.explicit-null.for.access-list"); value.Exists() {
		data.LabelLocalAdvertiseExplicitNullForAcl = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "label.local.advertise.explicit-null.for.to.access-list"); value.Exists() {
		data.LabelLocalAdvertiseExplicitNullForAclToAcl = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "label.local.advertise.explicit-null.to.access-list"); value.Exists() {
		data.LabelLocalAdvertiseExplicitNullToAcl = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "label.local.advertise.to.neighbor"); value.Exists() {
		data.LabelLocalAdvertiseToNeighbors = make([]MPLSLDPAddressFamilyLabelLocalAdvertiseToNeighbors, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := MPLSLDPAddressFamilyLabelLocalAdvertiseToNeighbors{}
			if cValue := v.Get("neighbor-address"); cValue.Exists() {
				item.NeighborAddress = types.StringValue(cValue.String())
			}
			if cValue := v.Get("label-space-id"); cValue.Exists() {
				item.LabelSpaceId = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("for"); cValue.Exists() {
				item.For = types.StringValue(cValue.String())
			}
			data.LabelLocalAdvertiseToNeighbors = append(data.LabelLocalAdvertiseToNeighbors, item)
			return true
		})
	}
	if value := res.Get(prefix + "label.local.advertise.interfaces.interface"); value.Exists() {
		data.LabelLocalAdvertiseInterfaces = make([]MPLSLDPAddressFamilyLabelLocalAdvertiseInterfaces, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := MPLSLDPAddressFamilyLabelLocalAdvertiseInterfaces{}
			if cValue := v.Get("interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			data.LabelLocalAdvertiseInterfaces = append(data.LabelLocalAdvertiseInterfaces, item)
			return true
		})
	}
	if value := res.Get(prefix + "label.local.advertise.disable"); value.Exists() {
		data.LabelLocalAdvertiseDisable = types.BoolValue(true)
	} else {
		data.LabelLocalAdvertiseDisable = types.BoolNull()
	}
	if value := res.Get(prefix + "label.local.advertise.for.access-lists"); value.Exists() {
		data.LabelLocalAdvertiseForAccessLists = make([]MPLSLDPAddressFamilyLabelLocalAdvertiseForAccessLists, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := MPLSLDPAddressFamilyLabelLocalAdvertiseForAccessLists{}
			if cValue := v.Get("access-list-name"); cValue.Exists() {
				item.AccessListName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("to"); cValue.Exists() {
				item.To = types.StringValue(cValue.String())
			}
			data.LabelLocalAdvertiseForAccessLists = append(data.LabelLocalAdvertiseForAccessLists, item)
			return true
		})
	}
	if value := res.Get(prefix + "label.remote.accept.from.neighbor"); value.Exists() {
		data.LabelRemoteAcceptFromNeighbors = make([]MPLSLDPAddressFamilyLabelRemoteAcceptFromNeighbors, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := MPLSLDPAddressFamilyLabelRemoteAcceptFromNeighbors{}
			if cValue := v.Get("neighbor-address"); cValue.Exists() {
				item.NeighborAddress = types.StringValue(cValue.String())
			}
			if cValue := v.Get("label-space-id"); cValue.Exists() {
				item.LabelSpaceId = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("for"); cValue.Exists() {
				item.For = types.StringValue(cValue.String())
			}
			data.LabelRemoteAcceptFromNeighbors = append(data.LabelRemoteAcceptFromNeighbors, item)
			return true
		})
	}
}

// End of section. //template:end fromBodyData
// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyXML

func (data *MPLSLDPAddressFamily) fromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/discovery/transport-address/ipv4-address"); value.Exists() {
		data.DiscoveryTransportAddressIpv4 = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/discovery/transport-address/ipv6-address"); value.Exists() {
		data.DiscoveryTransportAddressIpv6 = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/discovery/targeted-hello/accept"); value.Exists() {
		data.DiscoveryTargetedHelloAccept = types.BoolValue(true)
	} else {
		data.DiscoveryTargetedHelloAccept = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/discovery/targeted-hello/accept/from"); value.Exists() {
		data.DiscoveryTargetedHelloAcceptFrom = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/neighbor/ipv4-addresses/targeted"); value.Exists() {
		data.NeighborIpv4Targeted = make([]MPLSLDPAddressFamilyNeighborIpv4Targeted, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := MPLSLDPAddressFamilyNeighborIpv4Targeted{}
			if cValue := helpers.GetFromXPath(v, "neighbor-address"); cValue.Exists() {
				item.NeighborAddress = types.StringValue(cValue.String())
			}
			data.NeighborIpv4Targeted = append(data.NeighborIpv4Targeted, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/neighbor/ipv6-addresses/targeted"); value.Exists() {
		data.NeighborIpv6Targeted = make([]MPLSLDPAddressFamilyNeighborIpv6Targeted, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := MPLSLDPAddressFamilyNeighborIpv6Targeted{}
			if cValue := helpers.GetFromXPath(v, "neighbor-address"); cValue.Exists() {
				item.NeighborAddress = types.StringValue(cValue.String())
			}
			data.NeighborIpv6Targeted = append(data.NeighborIpv6Targeted, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/neighbor/sr-policies/sr-policy"); value.Exists() {
		data.NeighborSrPolicies = make([]MPLSLDPAddressFamilyNeighborSrPolicies, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := MPLSLDPAddressFamilyNeighborSrPolicies{}
			if cValue := helpers.GetFromXPath(v, "policy-name"); cValue.Exists() {
				item.PolicyName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "targeted"); cValue.Exists() {
				item.Targeted = types.BoolValue(true)
			} else {
				item.Targeted = types.BoolValue(false)
			}
			data.NeighborSrPolicies = append(data.NeighborSrPolicies, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/traffic-eng/auto-tunnel/mesh/groups/group"); value.Exists() {
		data.TrafficEngAutoTunnelMeshGroups = make([]MPLSLDPAddressFamilyTrafficEngAutoTunnelMeshGroups, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := MPLSLDPAddressFamilyTrafficEngAutoTunnelMeshGroups{}
			if cValue := helpers.GetFromXPath(v, "group-id"); cValue.Exists() {
				item.GroupId = types.Int64Value(cValue.Int())
			}
			data.TrafficEngAutoTunnelMeshGroups = append(data.TrafficEngAutoTunnelMeshGroups, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/traffic-eng/auto-tunnel/mesh/groups/all"); value.Exists() {
		data.TrafficEngAutoTunnelMeshGroupsAll = types.BoolValue(true)
	} else {
		data.TrafficEngAutoTunnelMeshGroupsAll = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/redistribute/bgp/as"); value.Exists() {
		data.RedistributeBgpAs = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/redistribute/bgp/advertise-to"); value.Exists() {
		data.RedistributeBgpAdvertiseTo = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/allocate/for/access-list"); value.Exists() {
		data.LabelLocalAllocateForAccessList = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/allocate/for/host-routes"); value.Exists() {
		data.LabelLocalAllocateForHostRoutes = types.BoolValue(true)
	} else {
		data.LabelLocalAllocateForHostRoutes = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/default-route"); value.Exists() {
		data.LabelLocalDefaultRoute = types.BoolValue(true)
	} else {
		data.LabelLocalDefaultRoute = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/implicit-null-override/for"); value.Exists() {
		data.LabelLocalImplicitNullOverrideFor = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/explicit-null"); value.Exists() {
		data.LabelLocalAdvertiseExplicitNull = types.BoolValue(true)
	} else {
		data.LabelLocalAdvertiseExplicitNull = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/explicit-null/for/access-list"); value.Exists() {
		data.LabelLocalAdvertiseExplicitNullForAcl = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/explicit-null/for/to/access-list"); value.Exists() {
		data.LabelLocalAdvertiseExplicitNullForAclToAcl = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/explicit-null/to/access-list"); value.Exists() {
		data.LabelLocalAdvertiseExplicitNullToAcl = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/to/neighbor"); value.Exists() {
		data.LabelLocalAdvertiseToNeighbors = make([]MPLSLDPAddressFamilyLabelLocalAdvertiseToNeighbors, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := MPLSLDPAddressFamilyLabelLocalAdvertiseToNeighbors{}
			if cValue := helpers.GetFromXPath(v, "neighbor-address"); cValue.Exists() {
				item.NeighborAddress = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "label-space-id"); cValue.Exists() {
				item.LabelSpaceId = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "for"); cValue.Exists() {
				item.For = types.StringValue(cValue.String())
			}
			data.LabelLocalAdvertiseToNeighbors = append(data.LabelLocalAdvertiseToNeighbors, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/interfaces/interface"); value.Exists() {
		data.LabelLocalAdvertiseInterfaces = make([]MPLSLDPAddressFamilyLabelLocalAdvertiseInterfaces, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := MPLSLDPAddressFamilyLabelLocalAdvertiseInterfaces{}
			if cValue := helpers.GetFromXPath(v, "interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			data.LabelLocalAdvertiseInterfaces = append(data.LabelLocalAdvertiseInterfaces, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/disable"); value.Exists() {
		data.LabelLocalAdvertiseDisable = types.BoolValue(true)
	} else {
		data.LabelLocalAdvertiseDisable = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/for/access-lists"); value.Exists() {
		data.LabelLocalAdvertiseForAccessLists = make([]MPLSLDPAddressFamilyLabelLocalAdvertiseForAccessLists, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := MPLSLDPAddressFamilyLabelLocalAdvertiseForAccessLists{}
			if cValue := helpers.GetFromXPath(v, "access-list-name"); cValue.Exists() {
				item.AccessListName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "to"); cValue.Exists() {
				item.To = types.StringValue(cValue.String())
			}
			data.LabelLocalAdvertiseForAccessLists = append(data.LabelLocalAdvertiseForAccessLists, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/remote/accept/from/neighbor"); value.Exists() {
		data.LabelRemoteAcceptFromNeighbors = make([]MPLSLDPAddressFamilyLabelRemoteAcceptFromNeighbors, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := MPLSLDPAddressFamilyLabelRemoteAcceptFromNeighbors{}
			if cValue := helpers.GetFromXPath(v, "neighbor-address"); cValue.Exists() {
				item.NeighborAddress = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "label-space-id"); cValue.Exists() {
				item.LabelSpaceId = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "for"); cValue.Exists() {
				item.For = types.StringValue(cValue.String())
			}
			data.LabelRemoteAcceptFromNeighbors = append(data.LabelRemoteAcceptFromNeighbors, item)
			return true
		})
	}
}

// End of section. //template:end fromBodyXML
// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyDataXML

func (data *MPLSLDPAddressFamilyData) fromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/discovery/transport-address/ipv4-address"); value.Exists() {
		data.DiscoveryTransportAddressIpv4 = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/discovery/transport-address/ipv6-address"); value.Exists() {
		data.DiscoveryTransportAddressIpv6 = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/discovery/targeted-hello/accept"); value.Exists() {
		data.DiscoveryTargetedHelloAccept = types.BoolValue(true)
	} else {
		data.DiscoveryTargetedHelloAccept = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/discovery/targeted-hello/accept/from"); value.Exists() {
		data.DiscoveryTargetedHelloAcceptFrom = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/neighbor/ipv4-addresses/targeted"); value.Exists() {
		data.NeighborIpv4Targeted = make([]MPLSLDPAddressFamilyNeighborIpv4Targeted, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := MPLSLDPAddressFamilyNeighborIpv4Targeted{}
			if cValue := helpers.GetFromXPath(v, "neighbor-address"); cValue.Exists() {
				item.NeighborAddress = types.StringValue(cValue.String())
			}
			data.NeighborIpv4Targeted = append(data.NeighborIpv4Targeted, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/neighbor/ipv6-addresses/targeted"); value.Exists() {
		data.NeighborIpv6Targeted = make([]MPLSLDPAddressFamilyNeighborIpv6Targeted, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := MPLSLDPAddressFamilyNeighborIpv6Targeted{}
			if cValue := helpers.GetFromXPath(v, "neighbor-address"); cValue.Exists() {
				item.NeighborAddress = types.StringValue(cValue.String())
			}
			data.NeighborIpv6Targeted = append(data.NeighborIpv6Targeted, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/neighbor/sr-policies/sr-policy"); value.Exists() {
		data.NeighborSrPolicies = make([]MPLSLDPAddressFamilyNeighborSrPolicies, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := MPLSLDPAddressFamilyNeighborSrPolicies{}
			if cValue := helpers.GetFromXPath(v, "policy-name"); cValue.Exists() {
				item.PolicyName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "targeted"); cValue.Exists() {
				item.Targeted = types.BoolValue(true)
			} else {
				item.Targeted = types.BoolValue(false)
			}
			data.NeighborSrPolicies = append(data.NeighborSrPolicies, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/traffic-eng/auto-tunnel/mesh/groups/group"); value.Exists() {
		data.TrafficEngAutoTunnelMeshGroups = make([]MPLSLDPAddressFamilyTrafficEngAutoTunnelMeshGroups, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := MPLSLDPAddressFamilyTrafficEngAutoTunnelMeshGroups{}
			if cValue := helpers.GetFromXPath(v, "group-id"); cValue.Exists() {
				item.GroupId = types.Int64Value(cValue.Int())
			}
			data.TrafficEngAutoTunnelMeshGroups = append(data.TrafficEngAutoTunnelMeshGroups, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/traffic-eng/auto-tunnel/mesh/groups/all"); value.Exists() {
		data.TrafficEngAutoTunnelMeshGroupsAll = types.BoolValue(true)
	} else {
		data.TrafficEngAutoTunnelMeshGroupsAll = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/redistribute/bgp/as"); value.Exists() {
		data.RedistributeBgpAs = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/redistribute/bgp/advertise-to"); value.Exists() {
		data.RedistributeBgpAdvertiseTo = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/allocate/for/access-list"); value.Exists() {
		data.LabelLocalAllocateForAccessList = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/allocate/for/host-routes"); value.Exists() {
		data.LabelLocalAllocateForHostRoutes = types.BoolValue(true)
	} else {
		data.LabelLocalAllocateForHostRoutes = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/default-route"); value.Exists() {
		data.LabelLocalDefaultRoute = types.BoolValue(true)
	} else {
		data.LabelLocalDefaultRoute = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/implicit-null-override/for"); value.Exists() {
		data.LabelLocalImplicitNullOverrideFor = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/explicit-null"); value.Exists() {
		data.LabelLocalAdvertiseExplicitNull = types.BoolValue(true)
	} else {
		data.LabelLocalAdvertiseExplicitNull = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/explicit-null/for/access-list"); value.Exists() {
		data.LabelLocalAdvertiseExplicitNullForAcl = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/explicit-null/for/to/access-list"); value.Exists() {
		data.LabelLocalAdvertiseExplicitNullForAclToAcl = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/explicit-null/to/access-list"); value.Exists() {
		data.LabelLocalAdvertiseExplicitNullToAcl = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/to/neighbor"); value.Exists() {
		data.LabelLocalAdvertiseToNeighbors = make([]MPLSLDPAddressFamilyLabelLocalAdvertiseToNeighbors, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := MPLSLDPAddressFamilyLabelLocalAdvertiseToNeighbors{}
			if cValue := helpers.GetFromXPath(v, "neighbor-address"); cValue.Exists() {
				item.NeighborAddress = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "label-space-id"); cValue.Exists() {
				item.LabelSpaceId = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "for"); cValue.Exists() {
				item.For = types.StringValue(cValue.String())
			}
			data.LabelLocalAdvertiseToNeighbors = append(data.LabelLocalAdvertiseToNeighbors, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/interfaces/interface"); value.Exists() {
		data.LabelLocalAdvertiseInterfaces = make([]MPLSLDPAddressFamilyLabelLocalAdvertiseInterfaces, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := MPLSLDPAddressFamilyLabelLocalAdvertiseInterfaces{}
			if cValue := helpers.GetFromXPath(v, "interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			data.LabelLocalAdvertiseInterfaces = append(data.LabelLocalAdvertiseInterfaces, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/disable"); value.Exists() {
		data.LabelLocalAdvertiseDisable = types.BoolValue(true)
	} else {
		data.LabelLocalAdvertiseDisable = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/local/advertise/for/access-lists"); value.Exists() {
		data.LabelLocalAdvertiseForAccessLists = make([]MPLSLDPAddressFamilyLabelLocalAdvertiseForAccessLists, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := MPLSLDPAddressFamilyLabelLocalAdvertiseForAccessLists{}
			if cValue := helpers.GetFromXPath(v, "access-list-name"); cValue.Exists() {
				item.AccessListName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "to"); cValue.Exists() {
				item.To = types.StringValue(cValue.String())
			}
			data.LabelLocalAdvertiseForAccessLists = append(data.LabelLocalAdvertiseForAccessLists, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/label/remote/accept/from/neighbor"); value.Exists() {
		data.LabelRemoteAcceptFromNeighbors = make([]MPLSLDPAddressFamilyLabelRemoteAcceptFromNeighbors, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := MPLSLDPAddressFamilyLabelRemoteAcceptFromNeighbors{}
			if cValue := helpers.GetFromXPath(v, "neighbor-address"); cValue.Exists() {
				item.NeighborAddress = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "label-space-id"); cValue.Exists() {
				item.LabelSpaceId = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "for"); cValue.Exists() {
				item.For = types.StringValue(cValue.String())
			}
			data.LabelRemoteAcceptFromNeighbors = append(data.LabelRemoteAcceptFromNeighbors, item)
			return true
		})
	}
}

// End of section. //template:end fromBodyDataXML
// Section below is generated&owned by "gen/generator.go". //template:begin getDeletedItems

func (data *MPLSLDPAddressFamily) getDeletedItems(ctx context.Context, state MPLSLDPAddressFamily) []string {
	deletedItems := make([]string, 0)
	for i := range state.LabelRemoteAcceptFromNeighbors {
		keys := [...]string{"neighbor-address", "label-space-id"}
		stateKeyValues := [...]string{state.LabelRemoteAcceptFromNeighbors[i].NeighborAddress.ValueString(), strconv.FormatInt(state.LabelRemoteAcceptFromNeighbors[i].LabelSpaceId.ValueInt64(), 10)}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.LabelRemoteAcceptFromNeighbors[i].NeighborAddress.ValueString()).IsZero() {
			emptyKeys = false
		}
		if !reflect.ValueOf(state.LabelRemoteAcceptFromNeighbors[i].LabelSpaceId.ValueInt64()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.LabelRemoteAcceptFromNeighbors {
			found = true
			if state.LabelRemoteAcceptFromNeighbors[i].NeighborAddress.ValueString() != data.LabelRemoteAcceptFromNeighbors[j].NeighborAddress.ValueString() {
				found = false
			}
			if state.LabelRemoteAcceptFromNeighbors[i].LabelSpaceId.ValueInt64() != data.LabelRemoteAcceptFromNeighbors[j].LabelSpaceId.ValueInt64() {
				found = false
			}
			if found {
				if !state.LabelRemoteAcceptFromNeighbors[i].For.IsNull() && data.LabelRemoteAcceptFromNeighbors[j].For.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/label/remote/accept/from/neighbor%v/for", state.getPath(), keyString))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/label/remote/accept/from/neighbor%v", state.getPath(), keyString))
		}
	}
	for i := range state.LabelLocalAdvertiseForAccessLists {
		keys := [...]string{"access-list-name"}
		stateKeyValues := [...]string{state.LabelLocalAdvertiseForAccessLists[i].AccessListName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.LabelLocalAdvertiseForAccessLists[i].AccessListName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.LabelLocalAdvertiseForAccessLists {
			found = true
			if state.LabelLocalAdvertiseForAccessLists[i].AccessListName.ValueString() != data.LabelLocalAdvertiseForAccessLists[j].AccessListName.ValueString() {
				found = false
			}
			if found {
				if !state.LabelLocalAdvertiseForAccessLists[i].To.IsNull() && data.LabelLocalAdvertiseForAccessLists[j].To.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/label/local/advertise/for/access-lists%v/to", state.getPath(), keyString))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/label/local/advertise/for/access-lists%v", state.getPath(), keyString))
		}
	}
	if !state.LabelLocalAdvertiseDisable.IsNull() && data.LabelLocalAdvertiseDisable.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/label/local/advertise/disable", state.getPath()))
	}
	for i := range state.LabelLocalAdvertiseInterfaces {
		keys := [...]string{"interface-name"}
		stateKeyValues := [...]string{state.LabelLocalAdvertiseInterfaces[i].InterfaceName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.LabelLocalAdvertiseInterfaces[i].InterfaceName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.LabelLocalAdvertiseInterfaces {
			found = true
			if state.LabelLocalAdvertiseInterfaces[i].InterfaceName.ValueString() != data.LabelLocalAdvertiseInterfaces[j].InterfaceName.ValueString() {
				found = false
			}
			if found {
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/label/local/advertise/interfaces/interface%v", state.getPath(), keyString))
		}
	}
	for i := range state.LabelLocalAdvertiseToNeighbors {
		keys := [...]string{"neighbor-address", "label-space-id"}
		stateKeyValues := [...]string{state.LabelLocalAdvertiseToNeighbors[i].NeighborAddress.ValueString(), strconv.FormatInt(state.LabelLocalAdvertiseToNeighbors[i].LabelSpaceId.ValueInt64(), 10)}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.LabelLocalAdvertiseToNeighbors[i].NeighborAddress.ValueString()).IsZero() {
			emptyKeys = false
		}
		if !reflect.ValueOf(state.LabelLocalAdvertiseToNeighbors[i].LabelSpaceId.ValueInt64()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.LabelLocalAdvertiseToNeighbors {
			found = true
			if state.LabelLocalAdvertiseToNeighbors[i].NeighborAddress.ValueString() != data.LabelLocalAdvertiseToNeighbors[j].NeighborAddress.ValueString() {
				found = false
			}
			if state.LabelLocalAdvertiseToNeighbors[i].LabelSpaceId.ValueInt64() != data.LabelLocalAdvertiseToNeighbors[j].LabelSpaceId.ValueInt64() {
				found = false
			}
			if found {
				if !state.LabelLocalAdvertiseToNeighbors[i].For.IsNull() && data.LabelLocalAdvertiseToNeighbors[j].For.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/label/local/advertise/to/neighbor%v/for", state.getPath(), keyString))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/label/local/advertise/to/neighbor%v", state.getPath(), keyString))
		}
	}
	if !state.LabelLocalAdvertiseExplicitNullToAcl.IsNull() && data.LabelLocalAdvertiseExplicitNullToAcl.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/label/local/advertise/explicit-null/to", state.getPath()))
	}
	if !state.LabelLocalAdvertiseExplicitNullForAclToAcl.IsNull() && data.LabelLocalAdvertiseExplicitNullForAclToAcl.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/label/local/advertise/explicit-null/for", state.getPath()))
	}
	if !state.LabelLocalAdvertiseExplicitNullForAcl.IsNull() && data.LabelLocalAdvertiseExplicitNullForAcl.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/label/local/advertise/explicit-null", state.getPath()))
	}
	if !state.LabelLocalAdvertiseExplicitNull.IsNull() && data.LabelLocalAdvertiseExplicitNull.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/label/local/advertise/explicit-null", state.getPath()))
	}
	if !state.LabelLocalImplicitNullOverrideFor.IsNull() && data.LabelLocalImplicitNullOverrideFor.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/label/local/implicit-null-override/for", state.getPath()))
	}
	if !state.LabelLocalDefaultRoute.IsNull() && data.LabelLocalDefaultRoute.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/label/local/default-route", state.getPath()))
	}
	if !state.LabelLocalAllocateForHostRoutes.IsNull() && data.LabelLocalAllocateForHostRoutes.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/label/local/allocate/for/host-routes", state.getPath()))
	}
	if !state.LabelLocalAllocateForAccessList.IsNull() && data.LabelLocalAllocateForAccessList.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/label/local/allocate/for/access-list", state.getPath()))
	}
	if !state.RedistributeBgpAdvertiseTo.IsNull() && data.RedistributeBgpAdvertiseTo.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/redistribute/bgp/advertise-to", state.getPath()))
	}
	if !state.RedistributeBgpAs.IsNull() && data.RedistributeBgpAs.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/redistribute/bgp/as", state.getPath()))
	}
	if !state.TrafficEngAutoTunnelMeshGroupsAll.IsNull() && data.TrafficEngAutoTunnelMeshGroupsAll.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/traffic-eng/auto-tunnel/mesh/groups/all", state.getPath()))
	}
	for i := range state.TrafficEngAutoTunnelMeshGroups {
		keys := [...]string{"group-id"}
		stateKeyValues := [...]string{strconv.FormatInt(state.TrafficEngAutoTunnelMeshGroups[i].GroupId.ValueInt64(), 10)}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.TrafficEngAutoTunnelMeshGroups[i].GroupId.ValueInt64()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.TrafficEngAutoTunnelMeshGroups {
			found = true
			if state.TrafficEngAutoTunnelMeshGroups[i].GroupId.ValueInt64() != data.TrafficEngAutoTunnelMeshGroups[j].GroupId.ValueInt64() {
				found = false
			}
			if found {
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/traffic-eng/auto-tunnel/mesh/groups/group%v", state.getPath(), keyString))
		}
	}
	for i := range state.NeighborSrPolicies {
		keys := [...]string{"policy-name"}
		stateKeyValues := [...]string{state.NeighborSrPolicies[i].PolicyName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.NeighborSrPolicies[i].PolicyName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.NeighborSrPolicies {
			found = true
			if state.NeighborSrPolicies[i].PolicyName.ValueString() != data.NeighborSrPolicies[j].PolicyName.ValueString() {
				found = false
			}
			if found {
				if !state.NeighborSrPolicies[i].Targeted.IsNull() && data.NeighborSrPolicies[j].Targeted.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/neighbor/sr-policies/sr-policy%v/targeted", state.getPath(), keyString))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/neighbor/sr-policies/sr-policy%v", state.getPath(), keyString))
		}
	}
	for i := range state.NeighborIpv6Targeted {
		keys := [...]string{"neighbor-address"}
		stateKeyValues := [...]string{state.NeighborIpv6Targeted[i].NeighborAddress.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.NeighborIpv6Targeted[i].NeighborAddress.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.NeighborIpv6Targeted {
			found = true
			if state.NeighborIpv6Targeted[i].NeighborAddress.ValueString() != data.NeighborIpv6Targeted[j].NeighborAddress.ValueString() {
				found = false
			}
			if found {
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/neighbor/ipv6-addresses/targeted%v", state.getPath(), keyString))
		}
	}
	for i := range state.NeighborIpv4Targeted {
		keys := [...]string{"neighbor-address"}
		stateKeyValues := [...]string{state.NeighborIpv4Targeted[i].NeighborAddress.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.NeighborIpv4Targeted[i].NeighborAddress.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.NeighborIpv4Targeted {
			found = true
			if state.NeighborIpv4Targeted[i].NeighborAddress.ValueString() != data.NeighborIpv4Targeted[j].NeighborAddress.ValueString() {
				found = false
			}
			if found {
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/neighbor/ipv4-addresses/targeted%v", state.getPath(), keyString))
		}
	}
	if !state.DiscoveryTargetedHelloAcceptFrom.IsNull() && data.DiscoveryTargetedHelloAcceptFrom.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/discovery/targeted-hello/accept/from", state.getPath()))
	}
	if !state.DiscoveryTargetedHelloAccept.IsNull() && data.DiscoveryTargetedHelloAccept.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/discovery/targeted-hello/accept", state.getPath()))
	}
	if !state.DiscoveryTransportAddressIpv6.IsNull() && data.DiscoveryTransportAddressIpv6.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/discovery/transport-address/ipv6-address", state.getPath()))
	}
	if !state.DiscoveryTransportAddressIpv4.IsNull() && data.DiscoveryTransportAddressIpv4.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/discovery/transport-address/ipv4-address", state.getPath()))
	}
	return deletedItems
}

// End of section. //template:end getDeletedItems
// Section below is generated&owned by "gen/generator.go". //template:begin getEmptyLeafsDelete

func (data *MPLSLDPAddressFamily) getEmptyLeafsDelete(ctx context.Context, state *MPLSLDPAddressFamily) []string {
	emptyLeafsDelete := make([]string, 0)
	for i := range data.LabelRemoteAcceptFromNeighbors {
		keys := [...]string{"neighbor-address", "label-space-id"}
		keyValues := [...]string{data.LabelRemoteAcceptFromNeighbors[i].NeighborAddress.ValueString(), strconv.FormatInt(data.LabelRemoteAcceptFromNeighbors[i].LabelSpaceId.ValueInt64(), 10)}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
	}
	for i := range data.LabelLocalAdvertiseForAccessLists {
		keys := [...]string{"access-list-name"}
		keyValues := [...]string{data.LabelLocalAdvertiseForAccessLists[i].AccessListName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
	}
	// Only delete if state has true and plan has false
	if !data.LabelLocalAdvertiseDisable.IsNull() && !data.LabelLocalAdvertiseDisable.ValueBool() {
		if state != nil && !state.LabelLocalAdvertiseDisable.IsNull() && state.LabelLocalAdvertiseDisable.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/label/local/advertise/disable", data.getXPath()))
		}
	}
	for i := range data.LabelLocalAdvertiseInterfaces {
		keys := [...]string{"interface-name"}
		keyValues := [...]string{data.LabelLocalAdvertiseInterfaces[i].InterfaceName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
	}
	for i := range data.LabelLocalAdvertiseToNeighbors {
		keys := [...]string{"neighbor-address", "label-space-id"}
		keyValues := [...]string{data.LabelLocalAdvertiseToNeighbors[i].NeighborAddress.ValueString(), strconv.FormatInt(data.LabelLocalAdvertiseToNeighbors[i].LabelSpaceId.ValueInt64(), 10)}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
	}
	// Only delete if state has true and plan has false
	if !data.LabelLocalAdvertiseExplicitNull.IsNull() && !data.LabelLocalAdvertiseExplicitNull.ValueBool() {
		if state != nil && !state.LabelLocalAdvertiseExplicitNull.IsNull() && state.LabelLocalAdvertiseExplicitNull.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/label/local/advertise/explicit-null", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.LabelLocalDefaultRoute.IsNull() && !data.LabelLocalDefaultRoute.ValueBool() {
		if state != nil && !state.LabelLocalDefaultRoute.IsNull() && state.LabelLocalDefaultRoute.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/label/local/default-route", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.LabelLocalAllocateForHostRoutes.IsNull() && !data.LabelLocalAllocateForHostRoutes.ValueBool() {
		if state != nil && !state.LabelLocalAllocateForHostRoutes.IsNull() && state.LabelLocalAllocateForHostRoutes.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/label/local/allocate/for/host-routes", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.TrafficEngAutoTunnelMeshGroupsAll.IsNull() && !data.TrafficEngAutoTunnelMeshGroupsAll.ValueBool() {
		if state != nil && !state.TrafficEngAutoTunnelMeshGroupsAll.IsNull() && state.TrafficEngAutoTunnelMeshGroupsAll.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/traffic-eng/auto-tunnel/mesh/groups/all", data.getXPath()))
		}
	}
	for i := range data.TrafficEngAutoTunnelMeshGroups {
		keys := [...]string{"group-id"}
		keyValues := [...]string{strconv.FormatInt(data.TrafficEngAutoTunnelMeshGroups[i].GroupId.ValueInt64(), 10)}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
	}
	for i := range data.NeighborSrPolicies {
		keys := [...]string{"policy-name"}
		keyValues := [...]string{data.NeighborSrPolicies[i].PolicyName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		// Only delete if state has true and plan has false
		if !data.NeighborSrPolicies[i].Targeted.IsNull() && !data.NeighborSrPolicies[i].Targeted.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.NeighborSrPolicies) && !state.NeighborSrPolicies[i].Targeted.IsNull() && state.NeighborSrPolicies[i].Targeted.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/neighbor/sr-policies/sr-policy%v/targeted", data.getXPath(), keyString))
			}
		}
	}
	for i := range data.NeighborIpv6Targeted {
		keys := [...]string{"neighbor-address"}
		keyValues := [...]string{data.NeighborIpv6Targeted[i].NeighborAddress.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
	}
	for i := range data.NeighborIpv4Targeted {
		keys := [...]string{"neighbor-address"}
		keyValues := [...]string{data.NeighborIpv4Targeted[i].NeighborAddress.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
	}
	// Only delete if state has true and plan has false
	if !data.DiscoveryTargetedHelloAccept.IsNull() && !data.DiscoveryTargetedHelloAccept.ValueBool() {
		if state != nil && !state.DiscoveryTargetedHelloAccept.IsNull() && state.DiscoveryTargetedHelloAccept.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/discovery/targeted-hello/accept", data.getXPath()))
		}
	}
	return emptyLeafsDelete
}

// End of section. //template:end getEmptyLeafsDelete
// Section below is generated&owned by "gen/generator.go". //template:begin getDeletePaths

func (data *MPLSLDPAddressFamily) getDeletePaths(ctx context.Context) []string {
	var deletePaths []string
	for i := range data.LabelRemoteAcceptFromNeighbors {
		keyValues := [...]string{data.LabelRemoteAcceptFromNeighbors[i].NeighborAddress.ValueString(), strconv.FormatInt(data.LabelRemoteAcceptFromNeighbors[i].LabelSpaceId.ValueInt64(), 10)}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/label/remote/accept/from/neighbor=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	for i := range data.LabelLocalAdvertiseForAccessLists {
		keyValues := [...]string{data.LabelLocalAdvertiseForAccessLists[i].AccessListName.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/label/local/advertise/for/access-lists=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	if !data.LabelLocalAdvertiseDisable.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/label/local/advertise/disable", data.getPath()))
	}
	for i := range data.LabelLocalAdvertiseInterfaces {
		keyValues := [...]string{data.LabelLocalAdvertiseInterfaces[i].InterfaceName.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/label/local/advertise/interfaces/interface=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	for i := range data.LabelLocalAdvertiseToNeighbors {
		keyValues := [...]string{data.LabelLocalAdvertiseToNeighbors[i].NeighborAddress.ValueString(), strconv.FormatInt(data.LabelLocalAdvertiseToNeighbors[i].LabelSpaceId.ValueInt64(), 10)}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/label/local/advertise/to/neighbor=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	if !data.LabelLocalAdvertiseExplicitNullToAcl.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/label/local/advertise/explicit-null/to", data.getPath()))
	}
	if !data.LabelLocalAdvertiseExplicitNullForAclToAcl.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/label/local/advertise/explicit-null/for", data.getPath()))
	}
	if !data.LabelLocalAdvertiseExplicitNullForAcl.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/label/local/advertise/explicit-null", data.getPath()))
	}
	if !data.LabelLocalAdvertiseExplicitNull.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/label/local/advertise/explicit-null", data.getPath()))
	}
	if !data.LabelLocalImplicitNullOverrideFor.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/label/local/implicit-null-override/for", data.getPath()))
	}
	if !data.LabelLocalDefaultRoute.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/label/local/default-route", data.getPath()))
	}
	if !data.LabelLocalAllocateForHostRoutes.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/label/local/allocate/for/host-routes", data.getPath()))
	}
	if !data.LabelLocalAllocateForAccessList.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/label/local/allocate/for/access-list", data.getPath()))
	}
	if !data.RedistributeBgpAdvertiseTo.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/redistribute/bgp/advertise-to", data.getPath()))
	}
	if !data.RedistributeBgpAs.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/redistribute/bgp/as", data.getPath()))
	}
	if !data.TrafficEngAutoTunnelMeshGroupsAll.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/traffic-eng/auto-tunnel/mesh/groups/all", data.getPath()))
	}
	for i := range data.TrafficEngAutoTunnelMeshGroups {
		keyValues := [...]string{strconv.FormatInt(data.TrafficEngAutoTunnelMeshGroups[i].GroupId.ValueInt64(), 10)}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/traffic-eng/auto-tunnel/mesh/groups/group=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	for i := range data.NeighborSrPolicies {
		keyValues := [...]string{data.NeighborSrPolicies[i].PolicyName.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/neighbor/sr-policies/sr-policy=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	for i := range data.NeighborIpv6Targeted {
		keyValues := [...]string{data.NeighborIpv6Targeted[i].NeighborAddress.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/neighbor/ipv6-addresses/targeted=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	for i := range data.NeighborIpv4Targeted {
		keyValues := [...]string{data.NeighborIpv4Targeted[i].NeighborAddress.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/neighbor/ipv4-addresses/targeted=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	if !data.DiscoveryTargetedHelloAcceptFrom.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/discovery/targeted-hello/accept/from", data.getPath()))
	}
	if !data.DiscoveryTargetedHelloAccept.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/discovery/targeted-hello/accept", data.getPath()))
	}
	if !data.DiscoveryTransportAddressIpv6.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/discovery/transport-address/ipv6-address", data.getPath()))
	}
	if !data.DiscoveryTransportAddressIpv4.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/discovery/transport-address/ipv4-address", data.getPath()))
	}

	return deletePaths
}

// End of section. //template:end getDeletePaths
// Section below is generated&owned by "gen/generator.go". //template:begin addDeletedItemsXML

func (data *MPLSLDPAddressFamily) addDeletedItemsXML(ctx context.Context, state MPLSLDPAddressFamily, body string) string {
	deleteXml := ""
	deletedPaths := make(map[string]bool)
	_ = deletedPaths // Avoid unused variable error when no delete_parent attributes exist
	for i := range state.LabelRemoteAcceptFromNeighbors {
		stateKeys := [...]string{"neighbor-address", "label-space-id"}
		stateKeyValues := [...]string{state.LabelRemoteAcceptFromNeighbors[i].NeighborAddress.ValueString(), strconv.FormatInt(state.LabelRemoteAcceptFromNeighbors[i].LabelSpaceId.ValueInt64(), 10)}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.LabelRemoteAcceptFromNeighbors[i].NeighborAddress.ValueString()).IsZero() {
			emptyKeys = false
		}
		if !reflect.ValueOf(state.LabelRemoteAcceptFromNeighbors[i].LabelSpaceId.ValueInt64()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.LabelRemoteAcceptFromNeighbors {
			found = true
			if state.LabelRemoteAcceptFromNeighbors[i].NeighborAddress.ValueString() != data.LabelRemoteAcceptFromNeighbors[j].NeighborAddress.ValueString() {
				found = false
			}
			if state.LabelRemoteAcceptFromNeighbors[i].LabelSpaceId.ValueInt64() != data.LabelRemoteAcceptFromNeighbors[j].LabelSpaceId.ValueInt64() {
				found = false
			}
			if found {
				if !state.LabelRemoteAcceptFromNeighbors[i].For.IsNull() && data.LabelRemoteAcceptFromNeighbors[j].For.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/label/remote/accept/from/neighbor%v/for", predicates))
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/label/remote/accept/from/neighbor%v", predicates))
		}
	}
	for i := range state.LabelLocalAdvertiseForAccessLists {
		stateKeys := [...]string{"access-list-name"}
		stateKeyValues := [...]string{state.LabelLocalAdvertiseForAccessLists[i].AccessListName.ValueString()}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.LabelLocalAdvertiseForAccessLists[i].AccessListName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.LabelLocalAdvertiseForAccessLists {
			found = true
			if state.LabelLocalAdvertiseForAccessLists[i].AccessListName.ValueString() != data.LabelLocalAdvertiseForAccessLists[j].AccessListName.ValueString() {
				found = false
			}
			if found {
				if !state.LabelLocalAdvertiseForAccessLists[i].To.IsNull() && data.LabelLocalAdvertiseForAccessLists[j].To.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/label/local/advertise/for/access-lists%v/to", predicates))
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/label/local/advertise/for/access-lists%v", predicates))
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.LabelLocalAdvertiseDisable.IsNull() && state.LabelLocalAdvertiseDisable.ValueBool() && data.LabelLocalAdvertiseDisable.IsNull() {
		deletePath := state.getXPath() + "/label/local/advertise/disable"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	for i := range state.LabelLocalAdvertiseInterfaces {
		stateKeys := [...]string{"interface-name"}
		stateKeyValues := [...]string{state.LabelLocalAdvertiseInterfaces[i].InterfaceName.ValueString()}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.LabelLocalAdvertiseInterfaces[i].InterfaceName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.LabelLocalAdvertiseInterfaces {
			found = true
			if state.LabelLocalAdvertiseInterfaces[i].InterfaceName.ValueString() != data.LabelLocalAdvertiseInterfaces[j].InterfaceName.ValueString() {
				found = false
			}
			if found {
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/label/local/advertise/interfaces/interface%v", predicates))
		}
	}
	for i := range state.LabelLocalAdvertiseToNeighbors {
		stateKeys := [...]string{"neighbor-address", "label-space-id"}
		stateKeyValues := [...]string{state.LabelLocalAdvertiseToNeighbors[i].NeighborAddress.ValueString(), strconv.FormatInt(state.LabelLocalAdvertiseToNeighbors[i].LabelSpaceId.ValueInt64(), 10)}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.LabelLocalAdvertiseToNeighbors[i].NeighborAddress.ValueString()).IsZero() {
			emptyKeys = false
		}
		if !reflect.ValueOf(state.LabelLocalAdvertiseToNeighbors[i].LabelSpaceId.ValueInt64()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.LabelLocalAdvertiseToNeighbors {
			found = true
			if state.LabelLocalAdvertiseToNeighbors[i].NeighborAddress.ValueString() != data.LabelLocalAdvertiseToNeighbors[j].NeighborAddress.ValueString() {
				found = false
			}
			if state.LabelLocalAdvertiseToNeighbors[i].LabelSpaceId.ValueInt64() != data.LabelLocalAdvertiseToNeighbors[j].LabelSpaceId.ValueInt64() {
				found = false
			}
			if found {
				if !state.LabelLocalAdvertiseToNeighbors[i].For.IsNull() && data.LabelLocalAdvertiseToNeighbors[j].For.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/label/local/advertise/to/neighbor%v/for", predicates))
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/label/local/advertise/to/neighbor%v", predicates))
		}
	}
	if !state.LabelLocalAdvertiseExplicitNullToAcl.IsNull() && data.LabelLocalAdvertiseExplicitNullToAcl.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/label/local/advertise/explicit-null/to"
		predicates := make(map[string]string)
		predicates["access-list"] = fmt.Sprintf("%v", state.LabelLocalAdvertiseExplicitNullToAcl.ValueString())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.LabelLocalAdvertiseExplicitNullForAclToAcl.IsNull() && data.LabelLocalAdvertiseExplicitNullForAclToAcl.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/label/local/advertise/explicit-null/for"
		predicates := make(map[string]string)
		predicates["access-list"] = fmt.Sprintf("%v", state.LabelLocalAdvertiseExplicitNullForAclToAcl.ValueString())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.LabelLocalAdvertiseExplicitNullForAcl.IsNull() && data.LabelLocalAdvertiseExplicitNullForAcl.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/label/local/advertise/explicit-null"
		predicates := make(map[string]string)
		predicates["access-list"] = fmt.Sprintf("%v", state.LabelLocalAdvertiseExplicitNullForAcl.ValueString())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.LabelLocalAdvertiseExplicitNull.IsNull() && state.LabelLocalAdvertiseExplicitNull.ValueBool() && data.LabelLocalAdvertiseExplicitNull.IsNull() {
		deletePath := state.getXPath() + "/label/local/advertise/explicit-null"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.LabelLocalImplicitNullOverrideFor.IsNull() && data.LabelLocalImplicitNullOverrideFor.IsNull() {
		deletePath := state.getXPath() + "/label/local/implicit-null-override/for"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.LabelLocalDefaultRoute.IsNull() && state.LabelLocalDefaultRoute.ValueBool() && data.LabelLocalDefaultRoute.IsNull() {
		deletePath := state.getXPath() + "/label/local/default-route"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.LabelLocalAllocateForHostRoutes.IsNull() && state.LabelLocalAllocateForHostRoutes.ValueBool() && data.LabelLocalAllocateForHostRoutes.IsNull() {
		deletePath := state.getXPath() + "/label/local/allocate/for/host-routes"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.LabelLocalAllocateForAccessList.IsNull() && data.LabelLocalAllocateForAccessList.IsNull() {
		deletePath := state.getXPath() + "/label/local/allocate/for/access-list"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.RedistributeBgpAdvertiseTo.IsNull() && data.RedistributeBgpAdvertiseTo.IsNull() {
		deletePath := state.getXPath() + "/redistribute/bgp/advertise-to"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.RedistributeBgpAs.IsNull() && data.RedistributeBgpAs.IsNull() {
		deletePath := state.getXPath() + "/redistribute/bgp/as"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.TrafficEngAutoTunnelMeshGroupsAll.IsNull() && state.TrafficEngAutoTunnelMeshGroupsAll.ValueBool() && data.TrafficEngAutoTunnelMeshGroupsAll.IsNull() {
		deletePath := state.getXPath() + "/traffic-eng/auto-tunnel/mesh/groups/all"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	for i := range state.TrafficEngAutoTunnelMeshGroups {
		stateKeys := [...]string{"group-id"}
		stateKeyValues := [...]string{strconv.FormatInt(state.TrafficEngAutoTunnelMeshGroups[i].GroupId.ValueInt64(), 10)}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.TrafficEngAutoTunnelMeshGroups[i].GroupId.ValueInt64()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.TrafficEngAutoTunnelMeshGroups {
			found = true
			if state.TrafficEngAutoTunnelMeshGroups[i].GroupId.ValueInt64() != data.TrafficEngAutoTunnelMeshGroups[j].GroupId.ValueInt64() {
				found = false
			}
			if found {
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/traffic-eng/auto-tunnel/mesh/groups/group%v", predicates))
		}
	}
	for i := range state.NeighborSrPolicies {
		stateKeys := [...]string{"policy-name"}
		stateKeyValues := [...]string{state.NeighborSrPolicies[i].PolicyName.ValueString()}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.NeighborSrPolicies[i].PolicyName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.NeighborSrPolicies {
			found = true
			if state.NeighborSrPolicies[i].PolicyName.ValueString() != data.NeighborSrPolicies[j].PolicyName.ValueString() {
				found = false
			}
			if found {
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.NeighborSrPolicies[i].Targeted.IsNull() && state.NeighborSrPolicies[i].Targeted.ValueBool() && data.NeighborSrPolicies[j].Targeted.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/neighbor/sr-policies/sr-policy%v/targeted", predicates))
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/neighbor/sr-policies/sr-policy%v", predicates))
		}
	}
	for i := range state.NeighborIpv6Targeted {
		stateKeys := [...]string{"neighbor-address"}
		stateKeyValues := [...]string{state.NeighborIpv6Targeted[i].NeighborAddress.ValueString()}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.NeighborIpv6Targeted[i].NeighborAddress.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.NeighborIpv6Targeted {
			found = true
			if state.NeighborIpv6Targeted[i].NeighborAddress.ValueString() != data.NeighborIpv6Targeted[j].NeighborAddress.ValueString() {
				found = false
			}
			if found {
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/neighbor/ipv6-addresses/targeted%v", predicates))
		}
	}
	for i := range state.NeighborIpv4Targeted {
		stateKeys := [...]string{"neighbor-address"}
		stateKeyValues := [...]string{state.NeighborIpv4Targeted[i].NeighborAddress.ValueString()}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.NeighborIpv4Targeted[i].NeighborAddress.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.NeighborIpv4Targeted {
			found = true
			if state.NeighborIpv4Targeted[i].NeighborAddress.ValueString() != data.NeighborIpv4Targeted[j].NeighborAddress.ValueString() {
				found = false
			}
			if found {
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/neighbor/ipv4-addresses/targeted%v", predicates))
		}
	}
	if !state.DiscoveryTargetedHelloAcceptFrom.IsNull() && data.DiscoveryTargetedHelloAcceptFrom.IsNull() {
		deletePath := state.getXPath() + "/discovery/targeted-hello/accept/from"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.DiscoveryTargetedHelloAccept.IsNull() && state.DiscoveryTargetedHelloAccept.ValueBool() && data.DiscoveryTargetedHelloAccept.IsNull() {
		deletePath := state.getXPath() + "/discovery/targeted-hello/accept"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.DiscoveryTransportAddressIpv6.IsNull() && data.DiscoveryTransportAddressIpv6.IsNull() {
		deletePath := state.getXPath() + "/discovery/transport-address/ipv6-address"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.DiscoveryTransportAddressIpv4.IsNull() && data.DiscoveryTransportAddressIpv4.IsNull() {
		deletePath := state.getXPath() + "/discovery/transport-address/ipv4-address"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}

	b := netconf.NewBody(deleteXml)
	b = helpers.CleanupRedundantRemoveOperations(b)
	return b.Res()
}

// End of section. //template:end addDeletedItemsXML
// Section below is generated&owned by "gen/generator.go". //template:begin addDeletePathsXML

func (data *MPLSLDPAddressFamily) addDeletePathsXML(ctx context.Context, body string) string {
	b := netconf.NewBody(body)
	for i := range data.LabelRemoteAcceptFromNeighbors {
		keys := [...]string{"neighbor-address", "label-space-id"}
		keyValues := [...]string{data.LabelRemoteAcceptFromNeighbors[i].NeighborAddress.ValueString(), strconv.FormatInt(data.LabelRemoteAcceptFromNeighbors[i].LabelSpaceId.ValueInt64(), 10)}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/label/remote/accept/from/neighbor%v", predicates))
	}
	for i := range data.LabelLocalAdvertiseForAccessLists {
		keys := [...]string{"access-list-name"}
		keyValues := [...]string{data.LabelLocalAdvertiseForAccessLists[i].AccessListName.ValueString()}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/label/local/advertise/for/access-lists%v", predicates))
	}
	if !data.LabelLocalAdvertiseDisable.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/label/local/advertise/disable")
	}
	for i := range data.LabelLocalAdvertiseInterfaces {
		keys := [...]string{"interface-name"}
		keyValues := [...]string{data.LabelLocalAdvertiseInterfaces[i].InterfaceName.ValueString()}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/label/local/advertise/interfaces/interface%v", predicates))
	}
	for i := range data.LabelLocalAdvertiseToNeighbors {
		keys := [...]string{"neighbor-address", "label-space-id"}
		keyValues := [...]string{data.LabelLocalAdvertiseToNeighbors[i].NeighborAddress.ValueString(), strconv.FormatInt(data.LabelLocalAdvertiseToNeighbors[i].LabelSpaceId.ValueInt64(), 10)}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/label/local/advertise/to/neighbor%v", predicates))
	}
	if !data.LabelLocalAdvertiseExplicitNullToAcl.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/label/local/advertise/explicit-null/to")
	}
	if !data.LabelLocalAdvertiseExplicitNullForAclToAcl.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/label/local/advertise/explicit-null/for")
	}
	if !data.LabelLocalAdvertiseExplicitNullForAcl.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/label/local/advertise/explicit-null")
	}
	if !data.LabelLocalAdvertiseExplicitNull.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/label/local/advertise/explicit-null")
	}
	if !data.LabelLocalImplicitNullOverrideFor.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/label/local/implicit-null-override/for")
	}
	if !data.LabelLocalDefaultRoute.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/label/local/default-route")
	}
	if !data.LabelLocalAllocateForHostRoutes.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/label/local/allocate/for/host-routes")
	}
	if !data.LabelLocalAllocateForAccessList.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/label/local/allocate/for/access-list")
	}
	if !data.RedistributeBgpAdvertiseTo.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/redistribute/bgp/advertise-to")
	}
	if !data.RedistributeBgpAs.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/redistribute/bgp/as")
	}
	if !data.TrafficEngAutoTunnelMeshGroupsAll.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/traffic-eng/auto-tunnel/mesh/groups/all")
	}
	for i := range data.TrafficEngAutoTunnelMeshGroups {
		keys := [...]string{"group-id"}
		keyValues := [...]string{strconv.FormatInt(data.TrafficEngAutoTunnelMeshGroups[i].GroupId.ValueInt64(), 10)}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/traffic-eng/auto-tunnel/mesh/groups/group%v", predicates))
	}
	for i := range data.NeighborSrPolicies {
		keys := [...]string{"policy-name"}
		keyValues := [...]string{data.NeighborSrPolicies[i].PolicyName.ValueString()}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/neighbor/sr-policies/sr-policy%v", predicates))
	}
	for i := range data.NeighborIpv6Targeted {
		keys := [...]string{"neighbor-address"}
		keyValues := [...]string{data.NeighborIpv6Targeted[i].NeighborAddress.ValueString()}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/neighbor/ipv6-addresses/targeted%v", predicates))
	}
	for i := range data.NeighborIpv4Targeted {
		keys := [...]string{"neighbor-address"}
		keyValues := [...]string{data.NeighborIpv4Targeted[i].NeighborAddress.ValueString()}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/neighbor/ipv4-addresses/targeted%v", predicates))
	}
	if !data.DiscoveryTargetedHelloAcceptFrom.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/discovery/targeted-hello/accept/from")
	}
	if !data.DiscoveryTargetedHelloAccept.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/discovery/targeted-hello/accept")
	}
	if !data.DiscoveryTransportAddressIpv6.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/discovery/transport-address/ipv6-address")
	}
	if !data.DiscoveryTransportAddressIpv4.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/discovery/transport-address/ipv4-address")
	}

	b = helpers.CleanupRedundantRemoveOperations(b)
	return b.Res()
}

// End of section. //template:end addDeletePathsXML
