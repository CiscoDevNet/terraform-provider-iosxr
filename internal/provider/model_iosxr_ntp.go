// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"reflect"
	"strconv"

	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

type NTP struct {
	Device                   types.String     `tfsdk:"device"`
	Id                       types.String     `tfsdk:"id"`
	DeleteMode               types.String     `tfsdk:"delete_mode"`
	Ipv4Dscp                 types.String     `tfsdk:"ipv4_dscp"`
	Ipv4Precedence           types.String     `tfsdk:"ipv4_precedence"`
	Ipv6Dscp                 types.String     `tfsdk:"ipv6_dscp"`
	Ipv6Precedence           types.String     `tfsdk:"ipv6_precedence"`
	AccessGroupIpv6Peer      types.String     `tfsdk:"access_group_ipv6_peer"`
	AccessGroupIpv6QueryOnly types.String     `tfsdk:"access_group_ipv6_query_only"`
	AccessGroupIpv6Serve     types.String     `tfsdk:"access_group_ipv6_serve"`
	AccessGroupIpv6ServeOnly types.String     `tfsdk:"access_group_ipv6_serve_only"`
	AccessGroupIpv4Peer      types.String     `tfsdk:"access_group_ipv4_peer"`
	AccessGroupIpv4QueryOnly types.String     `tfsdk:"access_group_ipv4_query_only"`
	AccessGroupIpv4Serve     types.String     `tfsdk:"access_group_ipv4_serve"`
	AccessGroupIpv4ServeOnly types.String     `tfsdk:"access_group_ipv4_serve_only"`
	Vrfs                     []NTPVrfs        `tfsdk:"vrfs"`
	Authenticate             types.Bool       `tfsdk:"authenticate"`
	AuthKeys                 []NTPAuthKeys    `tfsdk:"auth_keys"`
	Broadcastdelay           types.Int64      `tfsdk:"broadcastdelay"`
	MaxAssociations          types.Int64      `tfsdk:"max_associations"`
	TrustedKeys              []NTPTrustedKeys `tfsdk:"trusted_keys"`
	UpdateCalendar           types.Bool       `tfsdk:"update_calendar"`
	LogInternalSync          types.Bool       `tfsdk:"log_internal_sync"`
	SourceInterfaceName      types.String     `tfsdk:"source_interface_name"`
	SourceVrfs               []NTPSourceVrfs  `tfsdk:"source_vrfs"`
	Passive                  types.Bool       `tfsdk:"passive"`
}

type NTPData struct {
	Device                   types.String     `tfsdk:"device"`
	Id                       types.String     `tfsdk:"id"`
	Ipv4Dscp                 types.String     `tfsdk:"ipv4_dscp"`
	Ipv4Precedence           types.String     `tfsdk:"ipv4_precedence"`
	Ipv6Dscp                 types.String     `tfsdk:"ipv6_dscp"`
	Ipv6Precedence           types.String     `tfsdk:"ipv6_precedence"`
	AccessGroupIpv6Peer      types.String     `tfsdk:"access_group_ipv6_peer"`
	AccessGroupIpv6QueryOnly types.String     `tfsdk:"access_group_ipv6_query_only"`
	AccessGroupIpv6Serve     types.String     `tfsdk:"access_group_ipv6_serve"`
	AccessGroupIpv6ServeOnly types.String     `tfsdk:"access_group_ipv6_serve_only"`
	AccessGroupIpv4Peer      types.String     `tfsdk:"access_group_ipv4_peer"`
	AccessGroupIpv4QueryOnly types.String     `tfsdk:"access_group_ipv4_query_only"`
	AccessGroupIpv4Serve     types.String     `tfsdk:"access_group_ipv4_serve"`
	AccessGroupIpv4ServeOnly types.String     `tfsdk:"access_group_ipv4_serve_only"`
	Vrfs                     []NTPVrfs        `tfsdk:"vrfs"`
	Authenticate             types.Bool       `tfsdk:"authenticate"`
	AuthKeys                 []NTPAuthKeys    `tfsdk:"auth_keys"`
	Broadcastdelay           types.Int64      `tfsdk:"broadcastdelay"`
	MaxAssociations          types.Int64      `tfsdk:"max_associations"`
	TrustedKeys              []NTPTrustedKeys `tfsdk:"trusted_keys"`
	UpdateCalendar           types.Bool       `tfsdk:"update_calendar"`
	LogInternalSync          types.Bool       `tfsdk:"log_internal_sync"`
	SourceInterfaceName      types.String     `tfsdk:"source_interface_name"`
	SourceVrfs               []NTPSourceVrfs  `tfsdk:"source_vrfs"`
	Passive                  types.Bool       `tfsdk:"passive"`
}
type NTPVrfs struct {
	VrfName       types.String `tfsdk:"vrf_name"`
	Ipv6Peer      types.String `tfsdk:"ipv6_peer"`
	Ipv6QueryOnly types.String `tfsdk:"ipv6_query_only"`
	Ipv6Serve     types.String `tfsdk:"ipv6_serve"`
	Ipv6ServeOnly types.String `tfsdk:"ipv6_serve_only"`
	Ipv4Peer      types.String `tfsdk:"ipv4_peer"`
	Ipv4QueryOnly types.String `tfsdk:"ipv4_query_only"`
	Ipv4Serve     types.String `tfsdk:"ipv4_serve"`
	Ipv4ServeOnly types.String `tfsdk:"ipv4_serve_only"`
}
type NTPAuthKeys struct {
	KeyNumber    types.Int64  `tfsdk:"key_number"`
	Md5Encrypted types.String `tfsdk:"md5_encrypted"`
}
type NTPTrustedKeys struct {
	KeyNumber types.Int64 `tfsdk:"key_number"`
}
type NTPSourceVrfs struct {
	VrfName       types.String `tfsdk:"vrf_name"`
	InterfaceName types.String `tfsdk:"interface_name"`
}

func (data NTP) getPath() string {
	return "Cisco-IOS-XR-um-ntp-cfg:/ntp"
}

func (data NTPData) getPath() string {
	return "Cisco-IOS-XR-um-ntp-cfg:/ntp"
}

func (data NTP) toBody(ctx context.Context) string {
	body := "{}"
	if !data.Ipv4Dscp.IsNull() && !data.Ipv4Dscp.IsUnknown() {
		body, _ = sjson.Set(body, "ipv4.dscp", data.Ipv4Dscp.ValueString())
	}
	if !data.Ipv4Precedence.IsNull() && !data.Ipv4Precedence.IsUnknown() {
		body, _ = sjson.Set(body, "ipv4.precedence", data.Ipv4Precedence.ValueString())
	}
	if !data.Ipv6Dscp.IsNull() && !data.Ipv6Dscp.IsUnknown() {
		body, _ = sjson.Set(body, "ipv6.dscp", data.Ipv6Dscp.ValueString())
	}
	if !data.Ipv6Precedence.IsNull() && !data.Ipv6Precedence.IsUnknown() {
		body, _ = sjson.Set(body, "ipv6.precedence", data.Ipv6Precedence.ValueString())
	}
	if !data.AccessGroupIpv6Peer.IsNull() && !data.AccessGroupIpv6Peer.IsUnknown() {
		body, _ = sjson.Set(body, "access-group.ipv6.peer", data.AccessGroupIpv6Peer.ValueString())
	}
	if !data.AccessGroupIpv6QueryOnly.IsNull() && !data.AccessGroupIpv6QueryOnly.IsUnknown() {
		body, _ = sjson.Set(body, "access-group.ipv6.query-only", data.AccessGroupIpv6QueryOnly.ValueString())
	}
	if !data.AccessGroupIpv6Serve.IsNull() && !data.AccessGroupIpv6Serve.IsUnknown() {
		body, _ = sjson.Set(body, "access-group.ipv6.serve", data.AccessGroupIpv6Serve.ValueString())
	}
	if !data.AccessGroupIpv6ServeOnly.IsNull() && !data.AccessGroupIpv6ServeOnly.IsUnknown() {
		body, _ = sjson.Set(body, "access-group.ipv6.serve-only", data.AccessGroupIpv6ServeOnly.ValueString())
	}
	if !data.AccessGroupIpv4Peer.IsNull() && !data.AccessGroupIpv4Peer.IsUnknown() {
		body, _ = sjson.Set(body, "access-group.ipv4.peer", data.AccessGroupIpv4Peer.ValueString())
	}
	if !data.AccessGroupIpv4QueryOnly.IsNull() && !data.AccessGroupIpv4QueryOnly.IsUnknown() {
		body, _ = sjson.Set(body, "access-group.ipv4.query-only", data.AccessGroupIpv4QueryOnly.ValueString())
	}
	if !data.AccessGroupIpv4Serve.IsNull() && !data.AccessGroupIpv4Serve.IsUnknown() {
		body, _ = sjson.Set(body, "access-group.ipv4.serve", data.AccessGroupIpv4Serve.ValueString())
	}
	if !data.AccessGroupIpv4ServeOnly.IsNull() && !data.AccessGroupIpv4ServeOnly.IsUnknown() {
		body, _ = sjson.Set(body, "access-group.ipv4.serve-only", data.AccessGroupIpv4ServeOnly.ValueString())
	}
	if !data.Authenticate.IsNull() && !data.Authenticate.IsUnknown() {
		if data.Authenticate.ValueBool() {
			body, _ = sjson.Set(body, "authenticate", map[string]string{})
		}
	}
	if !data.Broadcastdelay.IsNull() && !data.Broadcastdelay.IsUnknown() {
		body, _ = sjson.Set(body, "broadcastdelay", strconv.FormatInt(data.Broadcastdelay.ValueInt64(), 10))
	}
	if !data.MaxAssociations.IsNull() && !data.MaxAssociations.IsUnknown() {
		body, _ = sjson.Set(body, "max-associations", strconv.FormatInt(data.MaxAssociations.ValueInt64(), 10))
	}
	if !data.UpdateCalendar.IsNull() && !data.UpdateCalendar.IsUnknown() {
		if data.UpdateCalendar.ValueBool() {
			body, _ = sjson.Set(body, "update-calendar", map[string]string{})
		}
	}
	if !data.LogInternalSync.IsNull() && !data.LogInternalSync.IsUnknown() {
		if data.LogInternalSync.ValueBool() {
			body, _ = sjson.Set(body, "log-internal-sync", map[string]string{})
		}
	}
	if !data.SourceInterfaceName.IsNull() && !data.SourceInterfaceName.IsUnknown() {
		body, _ = sjson.Set(body, "source.interface-name", data.SourceInterfaceName.ValueString())
	}
	if !data.Passive.IsNull() && !data.Passive.IsUnknown() {
		if data.Passive.ValueBool() {
			body, _ = sjson.Set(body, "passive", map[string]string{})
		}
	}
	if len(data.Vrfs) > 0 {
		body, _ = sjson.Set(body, "access-group.vrfs.vrf", []interface{}{})
		for index, item := range data.Vrfs {
			if !item.VrfName.IsNull() && !item.VrfName.IsUnknown() {
				body, _ = sjson.Set(body, "access-group.vrfs.vrf"+"."+strconv.Itoa(index)+"."+"vrf-name", item.VrfName.ValueString())
			}
			if !item.Ipv6Peer.IsNull() && !item.Ipv6Peer.IsUnknown() {
				body, _ = sjson.Set(body, "access-group.vrfs.vrf"+"."+strconv.Itoa(index)+"."+"ipv6.peer", item.Ipv6Peer.ValueString())
			}
			if !item.Ipv6QueryOnly.IsNull() && !item.Ipv6QueryOnly.IsUnknown() {
				body, _ = sjson.Set(body, "access-group.vrfs.vrf"+"."+strconv.Itoa(index)+"."+"ipv6.query-only", item.Ipv6QueryOnly.ValueString())
			}
			if !item.Ipv6Serve.IsNull() && !item.Ipv6Serve.IsUnknown() {
				body, _ = sjson.Set(body, "access-group.vrfs.vrf"+"."+strconv.Itoa(index)+"."+"ipv6.serve", item.Ipv6Serve.ValueString())
			}
			if !item.Ipv6ServeOnly.IsNull() && !item.Ipv6ServeOnly.IsUnknown() {
				body, _ = sjson.Set(body, "access-group.vrfs.vrf"+"."+strconv.Itoa(index)+"."+"ipv6.serve-only", item.Ipv6ServeOnly.ValueString())
			}
			if !item.Ipv4Peer.IsNull() && !item.Ipv4Peer.IsUnknown() {
				body, _ = sjson.Set(body, "access-group.vrfs.vrf"+"."+strconv.Itoa(index)+"."+"ipv4.peer", item.Ipv4Peer.ValueString())
			}
			if !item.Ipv4QueryOnly.IsNull() && !item.Ipv4QueryOnly.IsUnknown() {
				body, _ = sjson.Set(body, "access-group.vrfs.vrf"+"."+strconv.Itoa(index)+"."+"ipv4.query-only", item.Ipv4QueryOnly.ValueString())
			}
			if !item.Ipv4Serve.IsNull() && !item.Ipv4Serve.IsUnknown() {
				body, _ = sjson.Set(body, "access-group.vrfs.vrf"+"."+strconv.Itoa(index)+"."+"ipv4.serve", item.Ipv4Serve.ValueString())
			}
			if !item.Ipv4ServeOnly.IsNull() && !item.Ipv4ServeOnly.IsUnknown() {
				body, _ = sjson.Set(body, "access-group.vrfs.vrf"+"."+strconv.Itoa(index)+"."+"ipv4.serve-only", item.Ipv4ServeOnly.ValueString())
			}
		}
	}
	if len(data.AuthKeys) > 0 {
		body, _ = sjson.Set(body, "authentication-keys.authentication-key", []interface{}{})
		for index, item := range data.AuthKeys {
			if !item.KeyNumber.IsNull() && !item.KeyNumber.IsUnknown() {
				body, _ = sjson.Set(body, "authentication-keys.authentication-key"+"."+strconv.Itoa(index)+"."+"key-number", strconv.FormatInt(item.KeyNumber.ValueInt64(), 10))
			}
			if !item.Md5Encrypted.IsNull() && !item.Md5Encrypted.IsUnknown() {
				body, _ = sjson.Set(body, "authentication-keys.authentication-key"+"."+strconv.Itoa(index)+"."+"md5.encrypted", item.Md5Encrypted.ValueString())
			}
		}
	}
	if len(data.TrustedKeys) > 0 {
		body, _ = sjson.Set(body, "trusted-keys.trusted-key", []interface{}{})
		for index, item := range data.TrustedKeys {
			if !item.KeyNumber.IsNull() && !item.KeyNumber.IsUnknown() {
				body, _ = sjson.Set(body, "trusted-keys.trusted-key"+"."+strconv.Itoa(index)+"."+"key-number", strconv.FormatInt(item.KeyNumber.ValueInt64(), 10))
			}
		}
	}
	if len(data.SourceVrfs) > 0 {
		body, _ = sjson.Set(body, "source.vrfs.vrf", []interface{}{})
		for index, item := range data.SourceVrfs {
			if !item.VrfName.IsNull() && !item.VrfName.IsUnknown() {
				body, _ = sjson.Set(body, "source.vrfs.vrf"+"."+strconv.Itoa(index)+"."+"vrf-name", item.VrfName.ValueString())
			}
			if !item.InterfaceName.IsNull() && !item.InterfaceName.IsUnknown() {
				body, _ = sjson.Set(body, "source.vrfs.vrf"+"."+strconv.Itoa(index)+"."+"interface-name", item.InterfaceName.ValueString())
			}
		}
	}
	return body
}

func (data *NTP) updateFromBody(ctx context.Context, res []byte) {
	if value := gjson.GetBytes(res, "ipv4.dscp"); value.Exists() && !data.Ipv4Dscp.IsNull() {
		data.Ipv4Dscp = types.StringValue(value.String())
	} else {
		data.Ipv4Dscp = types.StringNull()
	}
	if value := gjson.GetBytes(res, "ipv4.precedence"); value.Exists() && !data.Ipv4Precedence.IsNull() {
		data.Ipv4Precedence = types.StringValue(value.String())
	} else {
		data.Ipv4Precedence = types.StringNull()
	}
	if value := gjson.GetBytes(res, "ipv6.dscp"); value.Exists() && !data.Ipv6Dscp.IsNull() {
		data.Ipv6Dscp = types.StringValue(value.String())
	} else {
		data.Ipv6Dscp = types.StringNull()
	}
	if value := gjson.GetBytes(res, "ipv6.precedence"); value.Exists() && !data.Ipv6Precedence.IsNull() {
		data.Ipv6Precedence = types.StringValue(value.String())
	} else {
		data.Ipv6Precedence = types.StringNull()
	}
	if value := gjson.GetBytes(res, "access-group.ipv6.peer"); value.Exists() && !data.AccessGroupIpv6Peer.IsNull() {
		data.AccessGroupIpv6Peer = types.StringValue(value.String())
	} else {
		data.AccessGroupIpv6Peer = types.StringNull()
	}
	if value := gjson.GetBytes(res, "access-group.ipv6.query-only"); value.Exists() && !data.AccessGroupIpv6QueryOnly.IsNull() {
		data.AccessGroupIpv6QueryOnly = types.StringValue(value.String())
	} else {
		data.AccessGroupIpv6QueryOnly = types.StringNull()
	}
	if value := gjson.GetBytes(res, "access-group.ipv6.serve"); value.Exists() && !data.AccessGroupIpv6Serve.IsNull() {
		data.AccessGroupIpv6Serve = types.StringValue(value.String())
	} else {
		data.AccessGroupIpv6Serve = types.StringNull()
	}
	if value := gjson.GetBytes(res, "access-group.ipv6.serve-only"); value.Exists() && !data.AccessGroupIpv6ServeOnly.IsNull() {
		data.AccessGroupIpv6ServeOnly = types.StringValue(value.String())
	} else {
		data.AccessGroupIpv6ServeOnly = types.StringNull()
	}
	if value := gjson.GetBytes(res, "access-group.ipv4.peer"); value.Exists() && !data.AccessGroupIpv4Peer.IsNull() {
		data.AccessGroupIpv4Peer = types.StringValue(value.String())
	} else {
		data.AccessGroupIpv4Peer = types.StringNull()
	}
	if value := gjson.GetBytes(res, "access-group.ipv4.query-only"); value.Exists() && !data.AccessGroupIpv4QueryOnly.IsNull() {
		data.AccessGroupIpv4QueryOnly = types.StringValue(value.String())
	} else {
		data.AccessGroupIpv4QueryOnly = types.StringNull()
	}
	if value := gjson.GetBytes(res, "access-group.ipv4.serve"); value.Exists() && !data.AccessGroupIpv4Serve.IsNull() {
		data.AccessGroupIpv4Serve = types.StringValue(value.String())
	} else {
		data.AccessGroupIpv4Serve = types.StringNull()
	}
	if value := gjson.GetBytes(res, "access-group.ipv4.serve-only"); value.Exists() && !data.AccessGroupIpv4ServeOnly.IsNull() {
		data.AccessGroupIpv4ServeOnly = types.StringValue(value.String())
	} else {
		data.AccessGroupIpv4ServeOnly = types.StringNull()
	}
	for i := range data.Vrfs {
		keys := [...]string{"vrf-name"}
		keyValues := [...]string{data.Vrfs[i].VrfName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "access-group.vrfs.vrf").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("vrf-name"); value.Exists() && !data.Vrfs[i].VrfName.IsNull() {
			data.Vrfs[i].VrfName = types.StringValue(value.String())
		} else {
			data.Vrfs[i].VrfName = types.StringNull()
		}
		if value := r.Get("ipv6.peer"); value.Exists() && !data.Vrfs[i].Ipv6Peer.IsNull() {
			data.Vrfs[i].Ipv6Peer = types.StringValue(value.String())
		} else {
			data.Vrfs[i].Ipv6Peer = types.StringNull()
		}
		if value := r.Get("ipv6.query-only"); value.Exists() && !data.Vrfs[i].Ipv6QueryOnly.IsNull() {
			data.Vrfs[i].Ipv6QueryOnly = types.StringValue(value.String())
		} else {
			data.Vrfs[i].Ipv6QueryOnly = types.StringNull()
		}
		if value := r.Get("ipv6.serve"); value.Exists() && !data.Vrfs[i].Ipv6Serve.IsNull() {
			data.Vrfs[i].Ipv6Serve = types.StringValue(value.String())
		} else {
			data.Vrfs[i].Ipv6Serve = types.StringNull()
		}
		if value := r.Get("ipv6.serve-only"); value.Exists() && !data.Vrfs[i].Ipv6ServeOnly.IsNull() {
			data.Vrfs[i].Ipv6ServeOnly = types.StringValue(value.String())
		} else {
			data.Vrfs[i].Ipv6ServeOnly = types.StringNull()
		}
		if value := r.Get("ipv4.peer"); value.Exists() && !data.Vrfs[i].Ipv4Peer.IsNull() {
			data.Vrfs[i].Ipv4Peer = types.StringValue(value.String())
		} else {
			data.Vrfs[i].Ipv4Peer = types.StringNull()
		}
		if value := r.Get("ipv4.query-only"); value.Exists() && !data.Vrfs[i].Ipv4QueryOnly.IsNull() {
			data.Vrfs[i].Ipv4QueryOnly = types.StringValue(value.String())
		} else {
			data.Vrfs[i].Ipv4QueryOnly = types.StringNull()
		}
		if value := r.Get("ipv4.serve"); value.Exists() && !data.Vrfs[i].Ipv4Serve.IsNull() {
			data.Vrfs[i].Ipv4Serve = types.StringValue(value.String())
		} else {
			data.Vrfs[i].Ipv4Serve = types.StringNull()
		}
		if value := r.Get("ipv4.serve-only"); value.Exists() && !data.Vrfs[i].Ipv4ServeOnly.IsNull() {
			data.Vrfs[i].Ipv4ServeOnly = types.StringValue(value.String())
		} else {
			data.Vrfs[i].Ipv4ServeOnly = types.StringNull()
		}
	}
	if value := gjson.GetBytes(res, "authenticate"); !data.Authenticate.IsNull() {
		if value.Exists() {
			data.Authenticate = types.BoolValue(true)
		} else {
			data.Authenticate = types.BoolValue(false)
		}
	} else {
		data.Authenticate = types.BoolNull()
	}
	for i := range data.AuthKeys {
		keys := [...]string{"key-number"}
		keyValues := [...]string{strconv.FormatInt(data.AuthKeys[i].KeyNumber.ValueInt64(), 10)}

		var r gjson.Result
		gjson.GetBytes(res, "authentication-keys.authentication-key").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("key-number"); value.Exists() && !data.AuthKeys[i].KeyNumber.IsNull() {
			data.AuthKeys[i].KeyNumber = types.Int64Value(value.Int())
		} else {
			data.AuthKeys[i].KeyNumber = types.Int64Null()
		}
		if value := r.Get("md5.encrypted"); value.Exists() && !data.AuthKeys[i].Md5Encrypted.IsNull() {
			data.AuthKeys[i].Md5Encrypted = types.StringValue(value.String())
		} else {
			data.AuthKeys[i].Md5Encrypted = types.StringNull()
		}
	}
	if value := gjson.GetBytes(res, "broadcastdelay"); value.Exists() && !data.Broadcastdelay.IsNull() {
		data.Broadcastdelay = types.Int64Value(value.Int())
	} else {
		data.Broadcastdelay = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "max-associations"); value.Exists() && !data.MaxAssociations.IsNull() {
		data.MaxAssociations = types.Int64Value(value.Int())
	} else {
		data.MaxAssociations = types.Int64Null()
	}
	for i := range data.TrustedKeys {
		keys := [...]string{"key-number"}
		keyValues := [...]string{strconv.FormatInt(data.TrustedKeys[i].KeyNumber.ValueInt64(), 10)}

		var r gjson.Result
		gjson.GetBytes(res, "trusted-keys.trusted-key").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("key-number"); value.Exists() && !data.TrustedKeys[i].KeyNumber.IsNull() {
			data.TrustedKeys[i].KeyNumber = types.Int64Value(value.Int())
		} else {
			data.TrustedKeys[i].KeyNumber = types.Int64Null()
		}
	}
	if value := gjson.GetBytes(res, "update-calendar"); !data.UpdateCalendar.IsNull() {
		if value.Exists() {
			data.UpdateCalendar = types.BoolValue(true)
		} else {
			data.UpdateCalendar = types.BoolValue(false)
		}
	} else {
		data.UpdateCalendar = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "log-internal-sync"); !data.LogInternalSync.IsNull() {
		if value.Exists() {
			data.LogInternalSync = types.BoolValue(true)
		} else {
			data.LogInternalSync = types.BoolValue(false)
		}
	} else {
		data.LogInternalSync = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "source.interface-name"); value.Exists() && !data.SourceInterfaceName.IsNull() {
		data.SourceInterfaceName = types.StringValue(value.String())
	} else {
		data.SourceInterfaceName = types.StringNull()
	}
	for i := range data.SourceVrfs {
		keys := [...]string{"vrf-name"}
		keyValues := [...]string{data.SourceVrfs[i].VrfName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "source.vrfs.vrf").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("vrf-name"); value.Exists() && !data.SourceVrfs[i].VrfName.IsNull() {
			data.SourceVrfs[i].VrfName = types.StringValue(value.String())
		} else {
			data.SourceVrfs[i].VrfName = types.StringNull()
		}
		if value := r.Get("interface-name"); value.Exists() && !data.SourceVrfs[i].InterfaceName.IsNull() {
			data.SourceVrfs[i].InterfaceName = types.StringValue(value.String())
		} else {
			data.SourceVrfs[i].InterfaceName = types.StringNull()
		}
	}
	if value := gjson.GetBytes(res, "passive"); !data.Passive.IsNull() {
		if value.Exists() {
			data.Passive = types.BoolValue(true)
		} else {
			data.Passive = types.BoolValue(false)
		}
	} else {
		data.Passive = types.BoolNull()
	}
}

func (data *NTPData) fromBody(ctx context.Context, res []byte) {
	if value := gjson.GetBytes(res, "ipv4.dscp"); value.Exists() {
		data.Ipv4Dscp = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "ipv4.precedence"); value.Exists() {
		data.Ipv4Precedence = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "ipv6.dscp"); value.Exists() {
		data.Ipv6Dscp = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "ipv6.precedence"); value.Exists() {
		data.Ipv6Precedence = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "access-group.ipv6.peer"); value.Exists() {
		data.AccessGroupIpv6Peer = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "access-group.ipv6.query-only"); value.Exists() {
		data.AccessGroupIpv6QueryOnly = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "access-group.ipv6.serve"); value.Exists() {
		data.AccessGroupIpv6Serve = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "access-group.ipv6.serve-only"); value.Exists() {
		data.AccessGroupIpv6ServeOnly = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "access-group.ipv4.peer"); value.Exists() {
		data.AccessGroupIpv4Peer = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "access-group.ipv4.query-only"); value.Exists() {
		data.AccessGroupIpv4QueryOnly = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "access-group.ipv4.serve"); value.Exists() {
		data.AccessGroupIpv4Serve = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "access-group.ipv4.serve-only"); value.Exists() {
		data.AccessGroupIpv4ServeOnly = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "access-group.vrfs.vrf"); value.Exists() {
		data.Vrfs = make([]NTPVrfs, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := NTPVrfs{}
			if cValue := v.Get("vrf-name"); cValue.Exists() {
				item.VrfName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("ipv6.peer"); cValue.Exists() {
				item.Ipv6Peer = types.StringValue(cValue.String())
			}
			if cValue := v.Get("ipv6.query-only"); cValue.Exists() {
				item.Ipv6QueryOnly = types.StringValue(cValue.String())
			}
			if cValue := v.Get("ipv6.serve"); cValue.Exists() {
				item.Ipv6Serve = types.StringValue(cValue.String())
			}
			if cValue := v.Get("ipv6.serve-only"); cValue.Exists() {
				item.Ipv6ServeOnly = types.StringValue(cValue.String())
			}
			if cValue := v.Get("ipv4.peer"); cValue.Exists() {
				item.Ipv4Peer = types.StringValue(cValue.String())
			}
			if cValue := v.Get("ipv4.query-only"); cValue.Exists() {
				item.Ipv4QueryOnly = types.StringValue(cValue.String())
			}
			if cValue := v.Get("ipv4.serve"); cValue.Exists() {
				item.Ipv4Serve = types.StringValue(cValue.String())
			}
			if cValue := v.Get("ipv4.serve-only"); cValue.Exists() {
				item.Ipv4ServeOnly = types.StringValue(cValue.String())
			}
			data.Vrfs = append(data.Vrfs, item)
			return true
		})
	}
	if value := gjson.GetBytes(res, "authenticate"); value.Exists() {
		data.Authenticate = types.BoolValue(true)
	} else {
		data.Authenticate = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "authentication-keys.authentication-key"); value.Exists() {
		data.AuthKeys = make([]NTPAuthKeys, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := NTPAuthKeys{}
			if cValue := v.Get("key-number"); cValue.Exists() {
				item.KeyNumber = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("md5.encrypted"); cValue.Exists() {
				item.Md5Encrypted = types.StringValue(cValue.String())
			}
			data.AuthKeys = append(data.AuthKeys, item)
			return true
		})
	}
	if value := gjson.GetBytes(res, "broadcastdelay"); value.Exists() {
		data.Broadcastdelay = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "max-associations"); value.Exists() {
		data.MaxAssociations = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "trusted-keys.trusted-key"); value.Exists() {
		data.TrustedKeys = make([]NTPTrustedKeys, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := NTPTrustedKeys{}
			if cValue := v.Get("key-number"); cValue.Exists() {
				item.KeyNumber = types.Int64Value(cValue.Int())
			}
			data.TrustedKeys = append(data.TrustedKeys, item)
			return true
		})
	}
	if value := gjson.GetBytes(res, "update-calendar"); value.Exists() {
		data.UpdateCalendar = types.BoolValue(true)
	} else {
		data.UpdateCalendar = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "log-internal-sync"); value.Exists() {
		data.LogInternalSync = types.BoolValue(true)
	} else {
		data.LogInternalSync = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "source.interface-name"); value.Exists() {
		data.SourceInterfaceName = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "source.vrfs.vrf"); value.Exists() {
		data.SourceVrfs = make([]NTPSourceVrfs, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := NTPSourceVrfs{}
			if cValue := v.Get("vrf-name"); cValue.Exists() {
				item.VrfName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			data.SourceVrfs = append(data.SourceVrfs, item)
			return true
		})
	}
	if value := gjson.GetBytes(res, "passive"); value.Exists() {
		data.Passive = types.BoolValue(true)
	} else {
		data.Passive = types.BoolValue(false)
	}
}

func (data *NTP) getDeletedListItems(ctx context.Context, state NTP) []string {
	deletedListItems := make([]string, 0)
	for i := range state.Vrfs {
		keys := [...]string{"vrf-name"}
		stateKeyValues := [...]string{state.Vrfs[i].VrfName.ValueString()}

		emptyKeys := true
		if !reflect.ValueOf(state.Vrfs[i].VrfName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Vrfs {
			found = true
			if state.Vrfs[i].VrfName.ValueString() != data.Vrfs[j].VrfName.ValueString() {
				found = false
			}
			if found {
				break
			}
		}
		if !found {
			keyString := ""
			for ki := range keys {
				keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
			}
			deletedListItems = append(deletedListItems, fmt.Sprintf("%v/access-group/vrfs/vrf%v", state.getPath(), keyString))
		}
	}
	for i := range state.AuthKeys {
		keys := [...]string{"key-number"}
		stateKeyValues := [...]string{strconv.FormatInt(state.AuthKeys[i].KeyNumber.ValueInt64(), 10)}

		emptyKeys := true
		if !reflect.ValueOf(state.AuthKeys[i].KeyNumber.ValueInt64()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.AuthKeys {
			found = true
			if state.AuthKeys[i].KeyNumber.ValueInt64() != data.AuthKeys[j].KeyNumber.ValueInt64() {
				found = false
			}
			if found {
				break
			}
		}
		if !found {
			keyString := ""
			for ki := range keys {
				keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
			}
			deletedListItems = append(deletedListItems, fmt.Sprintf("%v/authentication-keys/authentication-key%v", state.getPath(), keyString))
		}
	}
	for i := range state.TrustedKeys {
		keys := [...]string{"key-number"}
		stateKeyValues := [...]string{strconv.FormatInt(state.TrustedKeys[i].KeyNumber.ValueInt64(), 10)}

		emptyKeys := true
		if !reflect.ValueOf(state.TrustedKeys[i].KeyNumber.ValueInt64()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.TrustedKeys {
			found = true
			if state.TrustedKeys[i].KeyNumber.ValueInt64() != data.TrustedKeys[j].KeyNumber.ValueInt64() {
				found = false
			}
			if found {
				break
			}
		}
		if !found {
			keyString := ""
			for ki := range keys {
				keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
			}
			deletedListItems = append(deletedListItems, fmt.Sprintf("%v/trusted-keys/trusted-key%v", state.getPath(), keyString))
		}
	}
	for i := range state.SourceVrfs {
		keys := [...]string{"vrf-name"}
		stateKeyValues := [...]string{state.SourceVrfs[i].VrfName.ValueString()}

		emptyKeys := true
		if !reflect.ValueOf(state.SourceVrfs[i].VrfName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.SourceVrfs {
			found = true
			if state.SourceVrfs[i].VrfName.ValueString() != data.SourceVrfs[j].VrfName.ValueString() {
				found = false
			}
			if found {
				break
			}
		}
		if !found {
			keyString := ""
			for ki := range keys {
				keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
			}
			deletedListItems = append(deletedListItems, fmt.Sprintf("%v/source/vrfs/vrf%v", state.getPath(), keyString))
		}
	}
	return deletedListItems
}

func (data *NTP) getEmptyLeafsDelete(ctx context.Context) []string {
	emptyLeafsDelete := make([]string, 0)
	for i := range data.Vrfs {
		keys := [...]string{"vrf-name"}
		keyValues := [...]string{data.Vrfs[i].VrfName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
	}
	if !data.Authenticate.IsNull() && !data.Authenticate.ValueBool() {
		emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/authenticate", data.getPath()))
	}
	for i := range data.AuthKeys {
		keys := [...]string{"key-number"}
		keyValues := [...]string{strconv.FormatInt(data.AuthKeys[i].KeyNumber.ValueInt64(), 10)}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
	}
	for i := range data.TrustedKeys {
		keys := [...]string{"key-number"}
		keyValues := [...]string{strconv.FormatInt(data.TrustedKeys[i].KeyNumber.ValueInt64(), 10)}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
	}
	if !data.UpdateCalendar.IsNull() && !data.UpdateCalendar.ValueBool() {
		emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/update-calendar", data.getPath()))
	}
	if !data.LogInternalSync.IsNull() && !data.LogInternalSync.ValueBool() {
		emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/log-internal-sync", data.getPath()))
	}
	for i := range data.SourceVrfs {
		keys := [...]string{"vrf-name"}
		keyValues := [...]string{data.SourceVrfs[i].VrfName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
	}
	if !data.Passive.IsNull() && !data.Passive.ValueBool() {
		emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/passive", data.getPath()))
	}
	return emptyLeafsDelete
}

func (data *NTP) getDeletePaths(ctx context.Context) []string {
	var deletePaths []string
	if !data.Ipv4Dscp.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/ipv4/dscp", data.getPath()))
	}
	if !data.Ipv4Precedence.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/ipv4/precedence", data.getPath()))
	}
	if !data.Ipv6Dscp.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/ipv6/dscp", data.getPath()))
	}
	if !data.Ipv6Precedence.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/ipv6/precedence", data.getPath()))
	}
	if !data.AccessGroupIpv6Peer.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/access-group/ipv6/peer", data.getPath()))
	}
	if !data.AccessGroupIpv6QueryOnly.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/access-group/ipv6/query-only", data.getPath()))
	}
	if !data.AccessGroupIpv6Serve.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/access-group/ipv6/serve", data.getPath()))
	}
	if !data.AccessGroupIpv6ServeOnly.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/access-group/ipv6/serve-only", data.getPath()))
	}
	if !data.AccessGroupIpv4Peer.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/access-group/ipv4/peer", data.getPath()))
	}
	if !data.AccessGroupIpv4QueryOnly.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/access-group/ipv4/query-only", data.getPath()))
	}
	if !data.AccessGroupIpv4Serve.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/access-group/ipv4/serve", data.getPath()))
	}
	if !data.AccessGroupIpv4ServeOnly.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/access-group/ipv4/serve-only", data.getPath()))
	}
	for i := range data.Vrfs {
		keys := [...]string{"vrf-name"}
		keyValues := [...]string{data.Vrfs[i].VrfName.ValueString()}

		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		deletePaths = append(deletePaths, fmt.Sprintf("%v/access-group/vrfs/vrf%v", data.getPath(), keyString))
	}
	if !data.Authenticate.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/authenticate", data.getPath()))
	}
	for i := range data.AuthKeys {
		keys := [...]string{"key-number"}
		keyValues := [...]string{strconv.FormatInt(data.AuthKeys[i].KeyNumber.ValueInt64(), 10)}

		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		deletePaths = append(deletePaths, fmt.Sprintf("%v/authentication-keys/authentication-key%v", data.getPath(), keyString))
	}
	if !data.Broadcastdelay.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/broadcastdelay", data.getPath()))
	}
	if !data.MaxAssociations.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/max-associations", data.getPath()))
	}
	for i := range data.TrustedKeys {
		keys := [...]string{"key-number"}
		keyValues := [...]string{strconv.FormatInt(data.TrustedKeys[i].KeyNumber.ValueInt64(), 10)}

		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		deletePaths = append(deletePaths, fmt.Sprintf("%v/trusted-keys/trusted-key%v", data.getPath(), keyString))
	}
	if !data.UpdateCalendar.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/update-calendar", data.getPath()))
	}
	if !data.LogInternalSync.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/log-internal-sync", data.getPath()))
	}
	if !data.SourceInterfaceName.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/source/interface-name", data.getPath()))
	}
	for i := range data.SourceVrfs {
		keys := [...]string{"vrf-name"}
		keyValues := [...]string{data.SourceVrfs[i].VrfName.ValueString()}

		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		deletePaths = append(deletePaths, fmt.Sprintf("%v/source/vrfs/vrf%v", data.getPath(), keyString))
	}
	if !data.Passive.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/passive", data.getPath()))
	}
	return deletePaths
}
