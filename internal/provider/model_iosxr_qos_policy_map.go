// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"reflect"
	"strconv"

	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

type QoSPolicyMap struct {
	Device                     types.String              `tfsdk:"device"`
	Id                         types.String              `tfsdk:"id"`
	PolicyMapName              types.String              `tfsdk:"policy_map_name"`
	Name                       types.String              `tfsdk:"name"`
	Type                       types.String              `tfsdk:"type"`
	SetMplsExperimentalTopmost types.Int64               `tfsdk:"set_mpls_experimental_topmost"`
	SetDscp                    types.String              `tfsdk:"set_dscp"`
	PriorityLevel              types.Int64               `tfsdk:"priority_level"`
	QueueLimits                []QoSPolicyMapQueueLimits `tfsdk:"queue_limits"`
	ServicePolicyName          types.String              `tfsdk:"service_policy_name"`
	PoliceRateValue            types.String              `tfsdk:"police_rate_value"`
	PoliceRateUnit             types.String              `tfsdk:"police_rate_unit"`
	ShapeAverageRateValue      types.String              `tfsdk:"shape_average_rate_value"`
	ShapeAverageRateUnit       types.String              `tfsdk:"shape_average_rate_unit"`
	BandwidthRemainingUnit     types.String              `tfsdk:"bandwidth_remaining_unit"`
	BandwidthRemainingValue    types.String              `tfsdk:"bandwidth_remaining_value"`
}
type QoSPolicyMapQueueLimits struct {
	Value types.String `tfsdk:"value"`
	Unit  types.String `tfsdk:"unit"`
}

func (data QoSPolicyMap) getPath() string {
	return fmt.Sprintf("Cisco-IOS-XR-um-policymap-classmap-cfg:/policy-map/type/qos[policy-map-name=%s]/class[name=%s][type=%s]", data.PolicyMapName.ValueString(), data.Name.ValueString(), data.Type.ValueString())
}

func (data QoSPolicyMap) toBody(ctx context.Context) string {
	body := "{}"
	if !data.Name.IsNull() && !data.Name.IsUnknown() {
		body, _ = sjson.Set(body, "name", data.Name.ValueString())
	}
	if !data.Type.IsNull() && !data.Type.IsUnknown() {
		body, _ = sjson.Set(body, "type", data.Type.ValueString())
	}
	if !data.SetMplsExperimentalTopmost.IsNull() && !data.SetMplsExperimentalTopmost.IsUnknown() {
		body, _ = sjson.Set(body, "set.mpls.experimental.topmost", strconv.FormatInt(data.SetMplsExperimentalTopmost.ValueInt64(), 10))
	}
	if !data.SetDscp.IsNull() && !data.SetDscp.IsUnknown() {
		body, _ = sjson.Set(body, "set.dscp", data.SetDscp.ValueString())
	}
	if !data.PriorityLevel.IsNull() && !data.PriorityLevel.IsUnknown() {
		body, _ = sjson.Set(body, "priority.level", strconv.FormatInt(data.PriorityLevel.ValueInt64(), 10))
	}
	if !data.ServicePolicyName.IsNull() && !data.ServicePolicyName.IsUnknown() {
		body, _ = sjson.Set(body, "service-policy.name", data.ServicePolicyName.ValueString())
	}
	if !data.PoliceRateValue.IsNull() && !data.PoliceRateValue.IsUnknown() {
		body, _ = sjson.Set(body, "police.rate.value", data.PoliceRateValue.ValueString())
	}
	if !data.PoliceRateUnit.IsNull() && !data.PoliceRateUnit.IsUnknown() {
		body, _ = sjson.Set(body, "police.rate.unit", data.PoliceRateUnit.ValueString())
	}
	if !data.ShapeAverageRateValue.IsNull() && !data.ShapeAverageRateValue.IsUnknown() {
		body, _ = sjson.Set(body, "shape.average.rate.value", data.ShapeAverageRateValue.ValueString())
	}
	if !data.ShapeAverageRateUnit.IsNull() && !data.ShapeAverageRateUnit.IsUnknown() {
		body, _ = sjson.Set(body, "shape.average.rate.unit", data.ShapeAverageRateUnit.ValueString())
	}
	if !data.BandwidthRemainingUnit.IsNull() && !data.BandwidthRemainingUnit.IsUnknown() {
		body, _ = sjson.Set(body, "bandwidth-remaining.unit", data.BandwidthRemainingUnit.ValueString())
	}
	if !data.BandwidthRemainingValue.IsNull() && !data.BandwidthRemainingValue.IsUnknown() {
		body, _ = sjson.Set(body, "bandwidth-remaining.value", data.BandwidthRemainingValue.ValueString())
	}
	if len(data.QueueLimits) > 0 {
		body, _ = sjson.Set(body, "queue-limits.queue-limit", []interface{}{})
		for index, item := range data.QueueLimits {
			if !item.Value.IsNull() && !item.Value.IsUnknown() {
				body, _ = sjson.Set(body, "queue-limits.queue-limit"+"."+strconv.Itoa(index)+"."+"value", item.Value.ValueString())
			}
			if !item.Unit.IsNull() && !item.Unit.IsUnknown() {
				body, _ = sjson.Set(body, "queue-limits.queue-limit"+"."+strconv.Itoa(index)+"."+"unit", item.Unit.ValueString())
			}
		}
	}
	return body
}

func (data *QoSPolicyMap) updateFromBody(ctx context.Context, res []byte) {
	if value := gjson.GetBytes(res, "set.mpls.experimental.topmost"); value.Exists() && !data.SetMplsExperimentalTopmost.IsNull() {
		data.SetMplsExperimentalTopmost = types.Int64Value(value.Int())
	} else {
		data.SetMplsExperimentalTopmost = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "set.dscp"); value.Exists() && !data.SetDscp.IsNull() {
		data.SetDscp = types.StringValue(value.String())
	} else {
		data.SetDscp = types.StringNull()
	}
	if value := gjson.GetBytes(res, "priority.level"); value.Exists() && !data.PriorityLevel.IsNull() {
		data.PriorityLevel = types.Int64Value(value.Int())
	} else {
		data.PriorityLevel = types.Int64Null()
	}
	for i := range data.QueueLimits {
		keys := [...]string{"value", "unit"}
		keyValues := [...]string{data.QueueLimits[i].Value.ValueString(), data.QueueLimits[i].Unit.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "queue-limits.queue-limit").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("value"); value.Exists() && !data.QueueLimits[i].Value.IsNull() {
			data.QueueLimits[i].Value = types.StringValue(value.String())
		} else {
			data.QueueLimits[i].Value = types.StringNull()
		}
		if value := r.Get("unit"); value.Exists() && !data.QueueLimits[i].Unit.IsNull() {
			data.QueueLimits[i].Unit = types.StringValue(value.String())
		} else {
			data.QueueLimits[i].Unit = types.StringNull()
		}
	}
	if value := gjson.GetBytes(res, "service-policy.name"); value.Exists() && !data.ServicePolicyName.IsNull() {
		data.ServicePolicyName = types.StringValue(value.String())
	} else {
		data.ServicePolicyName = types.StringNull()
	}
	if value := gjson.GetBytes(res, "police.rate.value"); value.Exists() && !data.PoliceRateValue.IsNull() {
		data.PoliceRateValue = types.StringValue(value.String())
	} else {
		data.PoliceRateValue = types.StringNull()
	}
	if value := gjson.GetBytes(res, "police.rate.unit"); value.Exists() && !data.PoliceRateUnit.IsNull() {
		data.PoliceRateUnit = types.StringValue(value.String())
	} else {
		data.PoliceRateUnit = types.StringNull()
	}
	if value := gjson.GetBytes(res, "shape.average.rate.value"); value.Exists() && !data.ShapeAverageRateValue.IsNull() {
		data.ShapeAverageRateValue = types.StringValue(value.String())
	} else {
		data.ShapeAverageRateValue = types.StringNull()
	}
	if value := gjson.GetBytes(res, "shape.average.rate.unit"); value.Exists() && !data.ShapeAverageRateUnit.IsNull() {
		data.ShapeAverageRateUnit = types.StringValue(value.String())
	} else {
		data.ShapeAverageRateUnit = types.StringNull()
	}
	if value := gjson.GetBytes(res, "bandwidth-remaining.unit"); value.Exists() && !data.BandwidthRemainingUnit.IsNull() {
		data.BandwidthRemainingUnit = types.StringValue(value.String())
	} else {
		data.BandwidthRemainingUnit = types.StringNull()
	}
	if value := gjson.GetBytes(res, "bandwidth-remaining.value"); value.Exists() && !data.BandwidthRemainingValue.IsNull() {
		data.BandwidthRemainingValue = types.StringValue(value.String())
	} else {
		data.BandwidthRemainingValue = types.StringNull()
	}
}

func (data *QoSPolicyMap) fromBody(ctx context.Context, res []byte) {
	if value := gjson.GetBytes(res, "set.mpls.experimental.topmost"); value.Exists() {
		data.SetMplsExperimentalTopmost = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "set.dscp"); value.Exists() {
		data.SetDscp = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "priority.level"); value.Exists() {
		data.PriorityLevel = types.Int64Value(value.Int())
	}
	if value := gjson.GetBytes(res, "queue-limits.queue-limit"); value.Exists() {
		data.QueueLimits = make([]QoSPolicyMapQueueLimits, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := QoSPolicyMapQueueLimits{}
			if cValue := v.Get("value"); cValue.Exists() {
				item.Value = types.StringValue(cValue.String())
			}
			if cValue := v.Get("unit"); cValue.Exists() {
				item.Unit = types.StringValue(cValue.String())
			}
			data.QueueLimits = append(data.QueueLimits, item)
			return true
		})
	}
	if value := gjson.GetBytes(res, "service-policy.name"); value.Exists() {
		data.ServicePolicyName = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "police.rate.value"); value.Exists() {
		data.PoliceRateValue = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "police.rate.unit"); value.Exists() {
		data.PoliceRateUnit = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "shape.average.rate.value"); value.Exists() {
		data.ShapeAverageRateValue = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "shape.average.rate.unit"); value.Exists() {
		data.ShapeAverageRateUnit = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "bandwidth-remaining.unit"); value.Exists() {
		data.BandwidthRemainingUnit = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "bandwidth-remaining.value"); value.Exists() {
		data.BandwidthRemainingValue = types.StringValue(value.String())
	}
}

func (data *QoSPolicyMap) getDeletedListItems(ctx context.Context, state QoSPolicyMap) []string {
	deletedListItems := make([]string, 0)
	for i := range state.QueueLimits {
		keys := [...]string{"value", "unit"}
		stateKeyValues := [...]string{state.QueueLimits[i].Value.ValueString(), state.QueueLimits[i].Unit.ValueString()}

		emptyKeys := true
		if !reflect.ValueOf(state.QueueLimits[i].Value.ValueString()).IsZero() {
			emptyKeys = false
		}
		if !reflect.ValueOf(state.QueueLimits[i].Unit.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.QueueLimits {
			found = true
			if state.QueueLimits[i].Value.ValueString() != data.QueueLimits[j].Value.ValueString() {
				found = false
			}
			if state.QueueLimits[i].Unit.ValueString() != data.QueueLimits[j].Unit.ValueString() {
				found = false
			}
			if found {
				break
			}
		}
		if found {
		} else {
			keyString := ""
			for ki := range keys {
				keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
			}
			deletedListItems = append(deletedListItems, fmt.Sprintf("%v/queue-limits/queue-limit%v", state.getPath(), keyString))
		}
	}
	return deletedListItems
}

func (data *QoSPolicyMap) getEmptyLeafsDelete(ctx context.Context) []string {
	emptyLeafsDelete := make([]string, 0)
	for i := range data.QueueLimits {
		keys := [...]string{"value", "unit"}
		keyValues := [...]string{data.QueueLimits[i].Value.ValueString(), data.QueueLimits[i].Unit.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
	}
	return emptyLeafsDelete
}
