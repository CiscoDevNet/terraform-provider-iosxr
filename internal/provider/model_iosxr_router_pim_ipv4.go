// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports
import (
	"context"
	"fmt"
	"reflect"
	"sort"
	"strconv"
	"strings"

	"github.com/CiscoDevNet/terraform-provider-iosxr/internal/provider/helpers"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/netascode/go-netconf"
	"github.com/netascode/xmldot"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin types
type RouterPIMIPv4 struct {
	Device                                    types.String                            `tfsdk:"device"`
	Id                                        types.String                            `tfsdk:"id"`
	DeleteMode                                types.String                            `tfsdk:"delete_mode"`
	RpAddresses                               []RouterPIMIPv4RpAddresses              `tfsdk:"rp_addresses"`
	RpAddressesBidir                          []RouterPIMIPv4RpAddressesBidir         `tfsdk:"rp_addresses_bidir"`
	RpStaticDeny                              types.String                            `tfsdk:"rp_static_deny"`
	AcceptRegister                            types.String                            `tfsdk:"accept_register"`
	SuppressDataRegisters                     types.Bool                              `tfsdk:"suppress_data_registers"`
	RegisterSource                            types.String                            `tfsdk:"register_source"`
	SuppressRpfChangePrunes                   types.Bool                              `tfsdk:"suppress_rpf_change_prunes"`
	NeighborFilter                            types.String                            `tfsdk:"neighbor_filter"`
	ConvergenceRpfConflictJoinDelay           types.Int64                             `tfsdk:"convergence_rpf_conflict_join_delay"`
	ConvergenceLinkDownPruneDelay             types.Int64                             `tfsdk:"convergence_link_down_prune_delay"`
	SptThresholdInfinity                      types.Bool                              `tfsdk:"spt_threshold_infinity"`
	SptThresholdInfinityGroupList             types.String                            `tfsdk:"spt_threshold_infinity_group_list"`
	OldRegisterChecksum                       types.Bool                              `tfsdk:"old_register_checksum"`
	NsfLifetime                               types.Int64                             `tfsdk:"nsf_lifetime"`
	NeighborCheckOnSend                       types.Bool                              `tfsdk:"neighbor_check_on_send"`
	NeighborCheckOnRecv                       types.Bool                              `tfsdk:"neighbor_check_on_recv"`
	HelloInterval                             types.Int64                             `tfsdk:"hello_interval"`
	MdtHelloInterval                          types.Int64                             `tfsdk:"mdt_hello_interval"`
	DrPriority                                types.Int64                             `tfsdk:"dr_priority"`
	JoinPruneInterval                         types.Int64                             `tfsdk:"join_prune_interval"`
	JoinPruneMtu                              types.Int64                             `tfsdk:"join_prune_mtu"`
	PropagationDelay                          types.Int64                             `tfsdk:"propagation_delay"`
	OverrideInterval                          types.Int64                             `tfsdk:"override_interval"`
	GlobalMaximumRoutes                       types.Int64                             `tfsdk:"global_maximum_routes"`
	GlobalMaximumRoutesThreshold              types.Int64                             `tfsdk:"global_maximum_routes_threshold"`
	GlobalMaximumRouteInterfaces              types.Int64                             `tfsdk:"global_maximum_route_interfaces"`
	GlobalMaximumRouteInterfacesThreshold     types.Int64                             `tfsdk:"global_maximum_route_interfaces_threshold"`
	GlobalMaximumRegisterStates               types.Int64                             `tfsdk:"global_maximum_register_states"`
	GlobalMaximumRegisterStatesThreshold      types.Int64                             `tfsdk:"global_maximum_register_states_threshold"`
	GlobalMaximumPacketQueueHighPriority      types.Int64                             `tfsdk:"global_maximum_packet_queue_high_priority"`
	GlobalMaximumPacketQueueLowPriority       types.Int64                             `tfsdk:"global_maximum_packet_queue_low_priority"`
	GlobalMaximumGroupMappingsBsr             types.Int64                             `tfsdk:"global_maximum_group_mappings_bsr"`
	GlobalMaximumGroupMappingsBsrThreshold    types.Int64                             `tfsdk:"global_maximum_group_mappings_bsr_threshold"`
	GlobalMaximumGroupMappingsAutorp          types.Int64                             `tfsdk:"global_maximum_group_mappings_autorp"`
	GlobalMaximumGroupMappingsAutorpThreshold types.Int64                             `tfsdk:"global_maximum_group_mappings_autorp_threshold"`
	GlobalMaximumBsrCrpCacheMaximum           types.Int64                             `tfsdk:"global_maximum_bsr_crp_cache_maximum"`
	GlobalMaximumBsrCrpCacheThreshold         types.Int64                             `tfsdk:"global_maximum_bsr_crp_cache_threshold"`
	MaximumRoutes                             types.Int64                             `tfsdk:"maximum_routes"`
	MaximumRoutesThreshold                    types.Int64                             `tfsdk:"maximum_routes_threshold"`
	MaximumRouteInterfaces                    types.Int64                             `tfsdk:"maximum_route_interfaces"`
	MaximumRouteInterfacesThreshold           types.Int64                             `tfsdk:"maximum_route_interfaces_threshold"`
	MaximumRegisterStates                     types.Int64                             `tfsdk:"maximum_register_states"`
	MaximumRegisterStatesThreshold            types.Int64                             `tfsdk:"maximum_register_states_threshold"`
	MaximumGroupMappingsBsr                   types.Int64                             `tfsdk:"maximum_group_mappings_bsr"`
	MaximumGroupMappingsBsrThreshold          types.Int64                             `tfsdk:"maximum_group_mappings_bsr_threshold"`
	MaximumGroupMappingsAutorp                types.Int64                             `tfsdk:"maximum_group_mappings_autorp"`
	MaximumGroupMappingsAutorpThreshold       types.Int64                             `tfsdk:"maximum_group_mappings_autorp_threshold"`
	MaximumBsrCrpCacheMaximum                 types.Int64                             `tfsdk:"maximum_bsr_crp_cache_maximum"`
	MaximumBsrCrpCacheThreshold               types.Int64                             `tfsdk:"maximum_bsr_crp_cache_threshold"`
	LogNeighborChanges                        types.Bool                              `tfsdk:"log_neighbor_changes"`
	RpfVectorAllowEbgp                        types.Bool                              `tfsdk:"rpf_vector_allow_ebgp"`
	RpfVectorDisableIbgp                      types.Bool                              `tfsdk:"rpf_vector_disable_ibgp"`
	RpfVectorStandardEncoding                 types.Bool                              `tfsdk:"rpf_vector_standard_encoding"`
	RpfVectorInjects                          []RouterPIMIPv4RpfVectorInjects         `tfsdk:"rpf_vector_injects"`
	ExplicitRpfVectorInjects                  []RouterPIMIPv4ExplicitRpfVectorInjects `tfsdk:"explicit_rpf_vector_injects"`
	RpfTopologyRoutePolicy                    types.String                            `tfsdk:"rpf_topology_route_policy"`
	MdtNeighborFilter                         types.String                            `tfsdk:"mdt_neighbor_filter"`
	MdtDataSwitchoverInterval                 types.Int64                             `tfsdk:"mdt_data_switchover_interval"`
	MdtDataAnnounceInterval                   types.Int64                             `tfsdk:"mdt_data_announce_interval"`
	MdtCMulticastType                         types.String                            `tfsdk:"mdt_c_multicast_type"`
	MdtCMulticastAnnouncePimJoinTlv           types.Bool                              `tfsdk:"mdt_c_multicast_announce_pim_join_tlv"`
	MdtCMulticastSharedTreePrune              types.Bool                              `tfsdk:"mdt_c_multicast_shared_tree_prune"`
	MdtCMulticastSuppressSharedTreeJoin       types.Bool                              `tfsdk:"mdt_c_multicast_suppress_shared_tree_join"`
	MdtCMulticastSuppressPimDataSignaling     types.Bool                              `tfsdk:"mdt_c_multicast_suppress_pim_data_signaling"`
	MdtCMulticastHelloEnable                  types.Bool                              `tfsdk:"mdt_c_multicast_hello_enable"`
	MdtCMulticastSharedTreePruneDelay         types.Int64                             `tfsdk:"mdt_c_multicast_shared_tree_prune_delay"`
	MdtCMulticastSourceTreePruneDelay         types.Int64                             `tfsdk:"mdt_c_multicast_source_tree_prune_delay"`
	MdtCMulticastMigrationRoutePolicy         types.String                            `tfsdk:"mdt_c_multicast_migration_route_policy"`
	AllowRp                                   types.Bool                              `tfsdk:"allow_rp"`
	AllowRpList                               types.String                            `tfsdk:"allow_rp_list"`
	AllowRpGroupList                          types.String                            `tfsdk:"allow_rp_group_list"`
	SgExpiryTimer                             types.Int64                             `tfsdk:"sg_expiry_timer"`
	SgList                                    types.String                            `tfsdk:"sg_list"`
	SsmRange                                  types.String                            `tfsdk:"ssm_range"`
	SsmDisable                                types.Bool                              `tfsdk:"ssm_disable"`
	SsmAllowOverride                          types.Bool                              `tfsdk:"ssm_allow_override"`
	RpfRedirectRoutePolicy                    types.String                            `tfsdk:"rpf_redirect_route_policy"`
	Multipath                                 types.Bool                              `tfsdk:"multipath"`
	MultipathHashSource                       types.Bool                              `tfsdk:"multipath_hash_source"`
	MultipathHashSourceNexthop                types.Bool                              `tfsdk:"multipath_hash_source_nexthop"`
	MultipathHashSourceGroup                  types.Bool                              `tfsdk:"multipath_hash_source_group"`
	AutoRpMappingAgentInterface               types.String                            `tfsdk:"auto_rp_mapping_agent_interface"`
	AutoRpMappingAgentScope                   types.Int64                             `tfsdk:"auto_rp_mapping_agent_scope"`
	AutoRpMappingAgentInterval                types.Int64                             `tfsdk:"auto_rp_mapping_agent_interval"`
	AutoRpCandidateRps                        []RouterPIMIPv4AutoRpCandidateRps       `tfsdk:"auto_rp_candidate_rps"`
	AutoRpListenDisable                       types.Bool                              `tfsdk:"auto_rp_listen_disable"`
	AutoRpRelayVrfs                           []RouterPIMIPv4AutoRpRelayVrfs          `tfsdk:"auto_rp_relay_vrfs"`
	BsrCandidateBsrAddress                    types.String                            `tfsdk:"bsr_candidate_bsr_address"`
	BsrCandidateBsrHashMaskLen                types.Int64                             `tfsdk:"bsr_candidate_bsr_hash_mask_len"`
	BsrCandidateBsrPriority                   types.Int64                             `tfsdk:"bsr_candidate_bsr_priority"`
	BsrCandidateRps                           []RouterPIMIPv4BsrCandidateRps          `tfsdk:"bsr_candidate_rps"`
	BsrRelayVrfs                              []RouterPIMIPv4BsrRelayVrfs             `tfsdk:"bsr_relay_vrfs"`
	Mofrr                                     types.Bool                              `tfsdk:"mofrr"`
	MofrrFlow                                 types.String                            `tfsdk:"mofrr_flow"`
	MofrrRib                                  types.String                            `tfsdk:"mofrr_rib"`
	MofrrProtect                              types.String                            `tfsdk:"mofrr_protect"`
	MofrrProtectLocalFaultOnly                types.Bool                              `tfsdk:"mofrr_protect_local_fault_only"`
	MofrrNonRevertive                         types.Bool                              `tfsdk:"mofrr_non_revertive"`
	MofrrCloneJoins                           []RouterPIMIPv4MofrrCloneJoins          `tfsdk:"mofrr_clone_joins"`
	MofrrCloneSources                         []RouterPIMIPv4MofrrCloneSources        `tfsdk:"mofrr_clone_sources"`
	SrP2mpPolicies                            []RouterPIMIPv4SrP2mpPolicies           `tfsdk:"sr_p2mp_policies"`
	Interfaces                                []RouterPIMIPv4Interfaces               `tfsdk:"interfaces"`
}

type RouterPIMIPv4Data struct {
	Device                                    types.String                            `tfsdk:"device"`
	Id                                        types.String                            `tfsdk:"id"`
	RpAddresses                               []RouterPIMIPv4RpAddresses              `tfsdk:"rp_addresses"`
	RpAddressesBidir                          []RouterPIMIPv4RpAddressesBidir         `tfsdk:"rp_addresses_bidir"`
	RpStaticDeny                              types.String                            `tfsdk:"rp_static_deny"`
	AcceptRegister                            types.String                            `tfsdk:"accept_register"`
	SuppressDataRegisters                     types.Bool                              `tfsdk:"suppress_data_registers"`
	RegisterSource                            types.String                            `tfsdk:"register_source"`
	SuppressRpfChangePrunes                   types.Bool                              `tfsdk:"suppress_rpf_change_prunes"`
	NeighborFilter                            types.String                            `tfsdk:"neighbor_filter"`
	ConvergenceRpfConflictJoinDelay           types.Int64                             `tfsdk:"convergence_rpf_conflict_join_delay"`
	ConvergenceLinkDownPruneDelay             types.Int64                             `tfsdk:"convergence_link_down_prune_delay"`
	SptThresholdInfinity                      types.Bool                              `tfsdk:"spt_threshold_infinity"`
	SptThresholdInfinityGroupList             types.String                            `tfsdk:"spt_threshold_infinity_group_list"`
	OldRegisterChecksum                       types.Bool                              `tfsdk:"old_register_checksum"`
	NsfLifetime                               types.Int64                             `tfsdk:"nsf_lifetime"`
	NeighborCheckOnSend                       types.Bool                              `tfsdk:"neighbor_check_on_send"`
	NeighborCheckOnRecv                       types.Bool                              `tfsdk:"neighbor_check_on_recv"`
	HelloInterval                             types.Int64                             `tfsdk:"hello_interval"`
	MdtHelloInterval                          types.Int64                             `tfsdk:"mdt_hello_interval"`
	DrPriority                                types.Int64                             `tfsdk:"dr_priority"`
	JoinPruneInterval                         types.Int64                             `tfsdk:"join_prune_interval"`
	JoinPruneMtu                              types.Int64                             `tfsdk:"join_prune_mtu"`
	PropagationDelay                          types.Int64                             `tfsdk:"propagation_delay"`
	OverrideInterval                          types.Int64                             `tfsdk:"override_interval"`
	GlobalMaximumRoutes                       types.Int64                             `tfsdk:"global_maximum_routes"`
	GlobalMaximumRoutesThreshold              types.Int64                             `tfsdk:"global_maximum_routes_threshold"`
	GlobalMaximumRouteInterfaces              types.Int64                             `tfsdk:"global_maximum_route_interfaces"`
	GlobalMaximumRouteInterfacesThreshold     types.Int64                             `tfsdk:"global_maximum_route_interfaces_threshold"`
	GlobalMaximumRegisterStates               types.Int64                             `tfsdk:"global_maximum_register_states"`
	GlobalMaximumRegisterStatesThreshold      types.Int64                             `tfsdk:"global_maximum_register_states_threshold"`
	GlobalMaximumPacketQueueHighPriority      types.Int64                             `tfsdk:"global_maximum_packet_queue_high_priority"`
	GlobalMaximumPacketQueueLowPriority       types.Int64                             `tfsdk:"global_maximum_packet_queue_low_priority"`
	GlobalMaximumGroupMappingsBsr             types.Int64                             `tfsdk:"global_maximum_group_mappings_bsr"`
	GlobalMaximumGroupMappingsBsrThreshold    types.Int64                             `tfsdk:"global_maximum_group_mappings_bsr_threshold"`
	GlobalMaximumGroupMappingsAutorp          types.Int64                             `tfsdk:"global_maximum_group_mappings_autorp"`
	GlobalMaximumGroupMappingsAutorpThreshold types.Int64                             `tfsdk:"global_maximum_group_mappings_autorp_threshold"`
	GlobalMaximumBsrCrpCacheMaximum           types.Int64                             `tfsdk:"global_maximum_bsr_crp_cache_maximum"`
	GlobalMaximumBsrCrpCacheThreshold         types.Int64                             `tfsdk:"global_maximum_bsr_crp_cache_threshold"`
	MaximumRoutes                             types.Int64                             `tfsdk:"maximum_routes"`
	MaximumRoutesThreshold                    types.Int64                             `tfsdk:"maximum_routes_threshold"`
	MaximumRouteInterfaces                    types.Int64                             `tfsdk:"maximum_route_interfaces"`
	MaximumRouteInterfacesThreshold           types.Int64                             `tfsdk:"maximum_route_interfaces_threshold"`
	MaximumRegisterStates                     types.Int64                             `tfsdk:"maximum_register_states"`
	MaximumRegisterStatesThreshold            types.Int64                             `tfsdk:"maximum_register_states_threshold"`
	MaximumGroupMappingsBsr                   types.Int64                             `tfsdk:"maximum_group_mappings_bsr"`
	MaximumGroupMappingsBsrThreshold          types.Int64                             `tfsdk:"maximum_group_mappings_bsr_threshold"`
	MaximumGroupMappingsAutorp                types.Int64                             `tfsdk:"maximum_group_mappings_autorp"`
	MaximumGroupMappingsAutorpThreshold       types.Int64                             `tfsdk:"maximum_group_mappings_autorp_threshold"`
	MaximumBsrCrpCacheMaximum                 types.Int64                             `tfsdk:"maximum_bsr_crp_cache_maximum"`
	MaximumBsrCrpCacheThreshold               types.Int64                             `tfsdk:"maximum_bsr_crp_cache_threshold"`
	LogNeighborChanges                        types.Bool                              `tfsdk:"log_neighbor_changes"`
	RpfVectorAllowEbgp                        types.Bool                              `tfsdk:"rpf_vector_allow_ebgp"`
	RpfVectorDisableIbgp                      types.Bool                              `tfsdk:"rpf_vector_disable_ibgp"`
	RpfVectorStandardEncoding                 types.Bool                              `tfsdk:"rpf_vector_standard_encoding"`
	RpfVectorInjects                          []RouterPIMIPv4RpfVectorInjects         `tfsdk:"rpf_vector_injects"`
	ExplicitRpfVectorInjects                  []RouterPIMIPv4ExplicitRpfVectorInjects `tfsdk:"explicit_rpf_vector_injects"`
	RpfTopologyRoutePolicy                    types.String                            `tfsdk:"rpf_topology_route_policy"`
	MdtNeighborFilter                         types.String                            `tfsdk:"mdt_neighbor_filter"`
	MdtDataSwitchoverInterval                 types.Int64                             `tfsdk:"mdt_data_switchover_interval"`
	MdtDataAnnounceInterval                   types.Int64                             `tfsdk:"mdt_data_announce_interval"`
	MdtCMulticastType                         types.String                            `tfsdk:"mdt_c_multicast_type"`
	MdtCMulticastAnnouncePimJoinTlv           types.Bool                              `tfsdk:"mdt_c_multicast_announce_pim_join_tlv"`
	MdtCMulticastSharedTreePrune              types.Bool                              `tfsdk:"mdt_c_multicast_shared_tree_prune"`
	MdtCMulticastSuppressSharedTreeJoin       types.Bool                              `tfsdk:"mdt_c_multicast_suppress_shared_tree_join"`
	MdtCMulticastSuppressPimDataSignaling     types.Bool                              `tfsdk:"mdt_c_multicast_suppress_pim_data_signaling"`
	MdtCMulticastHelloEnable                  types.Bool                              `tfsdk:"mdt_c_multicast_hello_enable"`
	MdtCMulticastSharedTreePruneDelay         types.Int64                             `tfsdk:"mdt_c_multicast_shared_tree_prune_delay"`
	MdtCMulticastSourceTreePruneDelay         types.Int64                             `tfsdk:"mdt_c_multicast_source_tree_prune_delay"`
	MdtCMulticastMigrationRoutePolicy         types.String                            `tfsdk:"mdt_c_multicast_migration_route_policy"`
	AllowRp                                   types.Bool                              `tfsdk:"allow_rp"`
	AllowRpList                               types.String                            `tfsdk:"allow_rp_list"`
	AllowRpGroupList                          types.String                            `tfsdk:"allow_rp_group_list"`
	SgExpiryTimer                             types.Int64                             `tfsdk:"sg_expiry_timer"`
	SgList                                    types.String                            `tfsdk:"sg_list"`
	SsmRange                                  types.String                            `tfsdk:"ssm_range"`
	SsmDisable                                types.Bool                              `tfsdk:"ssm_disable"`
	SsmAllowOverride                          types.Bool                              `tfsdk:"ssm_allow_override"`
	RpfRedirectRoutePolicy                    types.String                            `tfsdk:"rpf_redirect_route_policy"`
	Multipath                                 types.Bool                              `tfsdk:"multipath"`
	MultipathHashSource                       types.Bool                              `tfsdk:"multipath_hash_source"`
	MultipathHashSourceNexthop                types.Bool                              `tfsdk:"multipath_hash_source_nexthop"`
	MultipathHashSourceGroup                  types.Bool                              `tfsdk:"multipath_hash_source_group"`
	AutoRpMappingAgentInterface               types.String                            `tfsdk:"auto_rp_mapping_agent_interface"`
	AutoRpMappingAgentScope                   types.Int64                             `tfsdk:"auto_rp_mapping_agent_scope"`
	AutoRpMappingAgentInterval                types.Int64                             `tfsdk:"auto_rp_mapping_agent_interval"`
	AutoRpCandidateRps                        []RouterPIMIPv4AutoRpCandidateRps       `tfsdk:"auto_rp_candidate_rps"`
	AutoRpListenDisable                       types.Bool                              `tfsdk:"auto_rp_listen_disable"`
	AutoRpRelayVrfs                           []RouterPIMIPv4AutoRpRelayVrfs          `tfsdk:"auto_rp_relay_vrfs"`
	BsrCandidateBsrAddress                    types.String                            `tfsdk:"bsr_candidate_bsr_address"`
	BsrCandidateBsrHashMaskLen                types.Int64                             `tfsdk:"bsr_candidate_bsr_hash_mask_len"`
	BsrCandidateBsrPriority                   types.Int64                             `tfsdk:"bsr_candidate_bsr_priority"`
	BsrCandidateRps                           []RouterPIMIPv4BsrCandidateRps          `tfsdk:"bsr_candidate_rps"`
	BsrRelayVrfs                              []RouterPIMIPv4BsrRelayVrfs             `tfsdk:"bsr_relay_vrfs"`
	Mofrr                                     types.Bool                              `tfsdk:"mofrr"`
	MofrrFlow                                 types.String                            `tfsdk:"mofrr_flow"`
	MofrrRib                                  types.String                            `tfsdk:"mofrr_rib"`
	MofrrProtect                              types.String                            `tfsdk:"mofrr_protect"`
	MofrrProtectLocalFaultOnly                types.Bool                              `tfsdk:"mofrr_protect_local_fault_only"`
	MofrrNonRevertive                         types.Bool                              `tfsdk:"mofrr_non_revertive"`
	MofrrCloneJoins                           []RouterPIMIPv4MofrrCloneJoins          `tfsdk:"mofrr_clone_joins"`
	MofrrCloneSources                         []RouterPIMIPv4MofrrCloneSources        `tfsdk:"mofrr_clone_sources"`
	SrP2mpPolicies                            []RouterPIMIPv4SrP2mpPolicies           `tfsdk:"sr_p2mp_policies"`
	Interfaces                                []RouterPIMIPv4Interfaces               `tfsdk:"interfaces"`
}
type RouterPIMIPv4RpAddresses struct {
	Address    types.String `tfsdk:"address"`
	AccessList types.String `tfsdk:"access_list"`
	Override   types.Bool   `tfsdk:"override"`
}
type RouterPIMIPv4RpAddressesBidir struct {
	Address    types.String `tfsdk:"address"`
	AccessList types.String `tfsdk:"access_list"`
	Override   types.Bool   `tfsdk:"override"`
}
type RouterPIMIPv4RpfVectorInjects struct {
	SourceAddress types.String `tfsdk:"source_address"`
	SourceMask    types.Int64  `tfsdk:"source_mask"`
	RpfVectors    types.List   `tfsdk:"rpf_vectors"`
}
type RouterPIMIPv4ExplicitRpfVectorInjects struct {
	SourceAddress types.String `tfsdk:"source_address"`
	SourceMask    types.Int64  `tfsdk:"source_mask"`
	RpfVectors    types.List   `tfsdk:"rpf_vectors"`
}
type RouterPIMIPv4AutoRpCandidateRps struct {
	InterfaceName  types.String `tfsdk:"interface_name"`
	Scope          types.Int64  `tfsdk:"scope"`
	GroupList      types.String `tfsdk:"group_list"`
	Interval       types.Int64  `tfsdk:"interval"`
	BidirScope     types.Int64  `tfsdk:"bidir_scope"`
	BidirGroupList types.String `tfsdk:"bidir_group_list"`
	BidirInterval  types.Int64  `tfsdk:"bidir_interval"`
}
type RouterPIMIPv4AutoRpRelayVrfs struct {
	VrfName types.String `tfsdk:"vrf_name"`
	Listen  types.Bool   `tfsdk:"listen"`
}
type RouterPIMIPv4BsrCandidateRps struct {
	Address        types.String `tfsdk:"address"`
	GroupList      types.String `tfsdk:"group_list"`
	Priority       types.Int64  `tfsdk:"priority"`
	Interval       types.Int64  `tfsdk:"interval"`
	BidirGroupList types.String `tfsdk:"bidir_group_list"`
	BidirPriority  types.Int64  `tfsdk:"bidir_priority"`
	BidirInterval  types.Int64  `tfsdk:"bidir_interval"`
}
type RouterPIMIPv4BsrRelayVrfs struct {
	VrfName types.String `tfsdk:"vrf_name"`
	Listen  types.Bool   `tfsdk:"listen"`
}
type RouterPIMIPv4MofrrCloneJoins struct {
	SourceAddress types.String                     `tfsdk:"source_address"`
	To            []RouterPIMIPv4MofrrCloneJoinsTo `tfsdk:"to"`
}
type RouterPIMIPv4MofrrCloneSources struct {
	SourceAddress types.String                       `tfsdk:"source_address"`
	To            []RouterPIMIPv4MofrrCloneSourcesTo `tfsdk:"to"`
}
type RouterPIMIPv4SrP2mpPolicies struct {
	PolicyName   types.String                              `tfsdk:"policy_name"`
	StaticGroups []RouterPIMIPv4SrP2mpPoliciesStaticGroups `tfsdk:"static_groups"`
}
type RouterPIMIPv4Interfaces struct {
	InterfaceName                    types.String `tfsdk:"interface_name"`
	Enable                           types.Bool   `tfsdk:"enable"`
	Disable                          types.Bool   `tfsdk:"disable"`
	DrPriority                       types.Int64  `tfsdk:"dr_priority"`
	HelloInterval                    types.Int64  `tfsdk:"hello_interval"`
	JoinPruneInterval                types.Int64  `tfsdk:"join_prune_interval"`
	JoinPruneMtu                     types.Int64  `tfsdk:"join_prune_mtu"`
	PropagationDelay                 types.Int64  `tfsdk:"propagation_delay"`
	OverrideInterval                 types.Int64  `tfsdk:"override_interval"`
	NeighborFilter                   types.String `tfsdk:"neighbor_filter"`
	MaximumRouteInterfaces           types.Int64  `tfsdk:"maximum_route_interfaces"`
	MaximumRouteInterfacesThreshold  types.Int64  `tfsdk:"maximum_route_interfaces_threshold"`
	MaximumRouteInterfacesAccessList types.String `tfsdk:"maximum_route_interfaces_access_list"`
	BfdMultiplier                    types.Int64  `tfsdk:"bfd_multiplier"`
	BfdMinimumInterval               types.Int64  `tfsdk:"bfd_minimum_interval"`
	BfdFastDetect                    types.Bool   `tfsdk:"bfd_fast_detect"`
	BsrBorder                        types.Bool   `tfsdk:"bsr_border"`
}
type RouterPIMIPv4MofrrCloneJoinsTo struct {
	PrimaryAddress types.String                        `tfsdk:"primary_address"`
	And            []RouterPIMIPv4MofrrCloneJoinsToAnd `tfsdk:"and"`
}
type RouterPIMIPv4MofrrCloneSourcesTo struct {
	PrimaryAddress types.String                          `tfsdk:"primary_address"`
	And            []RouterPIMIPv4MofrrCloneSourcesToAnd `tfsdk:"and"`
}
type RouterPIMIPv4SrP2mpPoliciesStaticGroups struct {
	GroupAddress              types.String                                                       `tfsdk:"group_address"`
	GroupAddressOnly          types.Bool                                                         `tfsdk:"group_address_only"`
	GroupMasks                []RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasks                `tfsdk:"group_masks"`
	GroupMasksSourceAddresses []RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasksSourceAddresses `tfsdk:"group_masks_source_addresses"`
	SourceMasks               []RouterPIMIPv4SrP2mpPoliciesStaticGroupsSourceMasks               `tfsdk:"source_masks"`
	GroupMasksSourceMasks     []RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasksSourceMasks     `tfsdk:"group_masks_source_masks"`
}
type RouterPIMIPv4MofrrCloneJoinsToAnd struct {
	BackupAddress types.String                               `tfsdk:"backup_address"`
	Masklen       []RouterPIMIPv4MofrrCloneJoinsToAndMasklen `tfsdk:"masklen"`
}
type RouterPIMIPv4MofrrCloneSourcesToAnd struct {
	BackupAddress types.String                                 `tfsdk:"backup_address"`
	Masklen       []RouterPIMIPv4MofrrCloneSourcesToAndMasklen `tfsdk:"masklen"`
}
type RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasks struct {
	GroupIncMask types.String `tfsdk:"group_inc_mask"`
	GroupCount   types.Int64  `tfsdk:"group_count"`
}
type RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasksSourceAddresses struct {
	GroupIncMask types.String `tfsdk:"group_inc_mask"`
	SourceIp     types.String `tfsdk:"source_ip"`
	GroupCount   types.Int64  `tfsdk:"group_count"`
}
type RouterPIMIPv4SrP2mpPoliciesStaticGroupsSourceMasks struct {
	SourceIp      types.String `tfsdk:"source_ip"`
	SourceIncMask types.String `tfsdk:"source_inc_mask"`
	SourceCount   types.Int64  `tfsdk:"source_count"`
}
type RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasksSourceMasks struct {
	GroupIncMask  types.String `tfsdk:"group_inc_mask"`
	SourceIp      types.String `tfsdk:"source_ip"`
	SourceIncMask types.String `tfsdk:"source_inc_mask"`
	GroupCount    types.Int64  `tfsdk:"group_count"`
	SourceCount   types.Int64  `tfsdk:"source_count"`
}
type RouterPIMIPv4MofrrCloneJoinsToAndMasklen struct {
	MaskLength types.Int64 `tfsdk:"mask_length"`
}
type RouterPIMIPv4MofrrCloneSourcesToAndMasklen struct {
	MaskLength types.Int64 `tfsdk:"mask_length"`
}

// End of section. //template:end types

// Section below is generated&owned by "gen/generator.go". //template:begin getPath

func (data RouterPIMIPv4) getPath() string {
	return "Cisco-IOS-XR-um-router-pim-cfg:/router/pim/address-family/ipv4"
}

func (data RouterPIMIPv4Data) getPath() string {
	return "Cisco-IOS-XR-um-router-pim-cfg:/router/pim/address-family/ipv4"
}

// getXPath returns the XPath for NETCONF operations
func (data RouterPIMIPv4) getXPath() string {
	path := "Cisco-IOS-XR-um-router-pim-cfg:/router/pim/address-family/ipv4"
	return path
}

func (data RouterPIMIPv4Data) getXPath() string {
	path := "Cisco-IOS-XR-um-router-pim-cfg:/router/pim/address-family/ipv4"
	return path
}

// End of section. //template:end getPath

// Section below is generated&owned by "gen/generator.go". //template:begin toBody

func (data RouterPIMIPv4) toBody(ctx context.Context) string {
	body := "{}"
	if !data.RpStaticDeny.IsNull() && !data.RpStaticDeny.IsUnknown() {
		body, _ = sjson.Set(body, "rp-static-deny", data.RpStaticDeny.ValueString())
	}
	if !data.AcceptRegister.IsNull() && !data.AcceptRegister.IsUnknown() {
		body, _ = sjson.Set(body, "accept-register", data.AcceptRegister.ValueString())
	}
	if !data.SuppressDataRegisters.IsNull() && !data.SuppressDataRegisters.IsUnknown() {
		if data.SuppressDataRegisters.ValueBool() {
			body, _ = sjson.Set(body, "suppress-data-registers", map[string]string{})
		}
	}
	if !data.RegisterSource.IsNull() && !data.RegisterSource.IsUnknown() {
		body, _ = sjson.Set(body, "register-source", data.RegisterSource.ValueString())
	}
	if !data.SuppressRpfChangePrunes.IsNull() && !data.SuppressRpfChangePrunes.IsUnknown() {
		if data.SuppressRpfChangePrunes.ValueBool() {
			body, _ = sjson.Set(body, "suppress-rpf-change-prunes", map[string]string{})
		}
	}
	if !data.NeighborFilter.IsNull() && !data.NeighborFilter.IsUnknown() {
		body, _ = sjson.Set(body, "neighbor-filter", data.NeighborFilter.ValueString())
	}
	if !data.ConvergenceRpfConflictJoinDelay.IsNull() && !data.ConvergenceRpfConflictJoinDelay.IsUnknown() {
		body, _ = sjson.Set(body, "convergence.rpf-conflict-join-delay", strconv.FormatInt(data.ConvergenceRpfConflictJoinDelay.ValueInt64(), 10))
	}
	if !data.ConvergenceLinkDownPruneDelay.IsNull() && !data.ConvergenceLinkDownPruneDelay.IsUnknown() {
		body, _ = sjson.Set(body, "convergence.link-down-prune-delay", strconv.FormatInt(data.ConvergenceLinkDownPruneDelay.ValueInt64(), 10))
	}
	if !data.SptThresholdInfinity.IsNull() && !data.SptThresholdInfinity.IsUnknown() {
		if data.SptThresholdInfinity.ValueBool() {
			body, _ = sjson.Set(body, "spt-threshold.infinity", map[string]string{})
		}
	}
	if !data.SptThresholdInfinityGroupList.IsNull() && !data.SptThresholdInfinityGroupList.IsUnknown() {
		body, _ = sjson.Set(body, "spt-threshold.infinity.group-list", data.SptThresholdInfinityGroupList.ValueString())
	}
	if !data.OldRegisterChecksum.IsNull() && !data.OldRegisterChecksum.IsUnknown() {
		if data.OldRegisterChecksum.ValueBool() {
			body, _ = sjson.Set(body, "old-register-checksum", map[string]string{})
		}
	}
	if !data.NsfLifetime.IsNull() && !data.NsfLifetime.IsUnknown() {
		body, _ = sjson.Set(body, "nsf.lifetime", strconv.FormatInt(data.NsfLifetime.ValueInt64(), 10))
	}
	if !data.NeighborCheckOnSend.IsNull() && !data.NeighborCheckOnSend.IsUnknown() {
		if data.NeighborCheckOnSend.ValueBool() {
			body, _ = sjson.Set(body, "neighbor-check-on-send.enable", map[string]string{})
		}
	}
	if !data.NeighborCheckOnRecv.IsNull() && !data.NeighborCheckOnRecv.IsUnknown() {
		if data.NeighborCheckOnRecv.ValueBool() {
			body, _ = sjson.Set(body, "neighbor-check-on-recv.enable", map[string]string{})
		}
	}
	if !data.HelloInterval.IsNull() && !data.HelloInterval.IsUnknown() {
		body, _ = sjson.Set(body, "hello-interval", strconv.FormatInt(data.HelloInterval.ValueInt64(), 10))
	}
	if !data.MdtHelloInterval.IsNull() && !data.MdtHelloInterval.IsUnknown() {
		body, _ = sjson.Set(body, "mdt-hello-interval", strconv.FormatInt(data.MdtHelloInterval.ValueInt64(), 10))
	}
	if !data.DrPriority.IsNull() && !data.DrPriority.IsUnknown() {
		body, _ = sjson.Set(body, "dr-priority", strconv.FormatInt(data.DrPriority.ValueInt64(), 10))
	}
	if !data.JoinPruneInterval.IsNull() && !data.JoinPruneInterval.IsUnknown() {
		body, _ = sjson.Set(body, "join-prune-interval", strconv.FormatInt(data.JoinPruneInterval.ValueInt64(), 10))
	}
	if !data.JoinPruneMtu.IsNull() && !data.JoinPruneMtu.IsUnknown() {
		body, _ = sjson.Set(body, "join-prune-mtu", strconv.FormatInt(data.JoinPruneMtu.ValueInt64(), 10))
	}
	if !data.PropagationDelay.IsNull() && !data.PropagationDelay.IsUnknown() {
		body, _ = sjson.Set(body, "propagation-delay", strconv.FormatInt(data.PropagationDelay.ValueInt64(), 10))
	}
	if !data.OverrideInterval.IsNull() && !data.OverrideInterval.IsUnknown() {
		body, _ = sjson.Set(body, "override-interval", strconv.FormatInt(data.OverrideInterval.ValueInt64(), 10))
	}
	if !data.GlobalMaximumRoutes.IsNull() && !data.GlobalMaximumRoutes.IsUnknown() {
		body, _ = sjson.Set(body, "global.maximum.routes.maximum-routes", strconv.FormatInt(data.GlobalMaximumRoutes.ValueInt64(), 10))
	}
	if !data.GlobalMaximumRoutesThreshold.IsNull() && !data.GlobalMaximumRoutesThreshold.IsUnknown() {
		body, _ = sjson.Set(body, "global.maximum.routes.threshold", strconv.FormatInt(data.GlobalMaximumRoutesThreshold.ValueInt64(), 10))
	}
	if !data.GlobalMaximumRouteInterfaces.IsNull() && !data.GlobalMaximumRouteInterfaces.IsUnknown() {
		body, _ = sjson.Set(body, "global.maximum.route-interfaces.maximum-route-interfaces", strconv.FormatInt(data.GlobalMaximumRouteInterfaces.ValueInt64(), 10))
	}
	if !data.GlobalMaximumRouteInterfacesThreshold.IsNull() && !data.GlobalMaximumRouteInterfacesThreshold.IsUnknown() {
		body, _ = sjson.Set(body, "global.maximum.route-interfaces.threshold", strconv.FormatInt(data.GlobalMaximumRouteInterfacesThreshold.ValueInt64(), 10))
	}
	if !data.GlobalMaximumRegisterStates.IsNull() && !data.GlobalMaximumRegisterStates.IsUnknown() {
		body, _ = sjson.Set(body, "global.maximum.register-states.maximum-register-states", strconv.FormatInt(data.GlobalMaximumRegisterStates.ValueInt64(), 10))
	}
	if !data.GlobalMaximumRegisterStatesThreshold.IsNull() && !data.GlobalMaximumRegisterStatesThreshold.IsUnknown() {
		body, _ = sjson.Set(body, "global.maximum.register-states.threshold", strconv.FormatInt(data.GlobalMaximumRegisterStatesThreshold.ValueInt64(), 10))
	}
	if !data.GlobalMaximumPacketQueueHighPriority.IsNull() && !data.GlobalMaximumPacketQueueHighPriority.IsUnknown() {
		body, _ = sjson.Set(body, "global.maximum.packet-queue.high-priority", strconv.FormatInt(data.GlobalMaximumPacketQueueHighPriority.ValueInt64(), 10))
	}
	if !data.GlobalMaximumPacketQueueLowPriority.IsNull() && !data.GlobalMaximumPacketQueueLowPriority.IsUnknown() {
		body, _ = sjson.Set(body, "global.maximum.packet-queue.low-priority", strconv.FormatInt(data.GlobalMaximumPacketQueueLowPriority.ValueInt64(), 10))
	}
	if !data.GlobalMaximumGroupMappingsBsr.IsNull() && !data.GlobalMaximumGroupMappingsBsr.IsUnknown() {
		body, _ = sjson.Set(body, "global.maximum.group-mappings.bsr.maximum-bsr", strconv.FormatInt(data.GlobalMaximumGroupMappingsBsr.ValueInt64(), 10))
	}
	if !data.GlobalMaximumGroupMappingsBsrThreshold.IsNull() && !data.GlobalMaximumGroupMappingsBsrThreshold.IsUnknown() {
		body, _ = sjson.Set(body, "global.maximum.group-mappings.bsr.threshold", strconv.FormatInt(data.GlobalMaximumGroupMappingsBsrThreshold.ValueInt64(), 10))
	}
	if !data.GlobalMaximumGroupMappingsAutorp.IsNull() && !data.GlobalMaximumGroupMappingsAutorp.IsUnknown() {
		body, _ = sjson.Set(body, "global.maximum.group-mappings.autorp.maximum-autorp", strconv.FormatInt(data.GlobalMaximumGroupMappingsAutorp.ValueInt64(), 10))
	}
	if !data.GlobalMaximumGroupMappingsAutorpThreshold.IsNull() && !data.GlobalMaximumGroupMappingsAutorpThreshold.IsUnknown() {
		body, _ = sjson.Set(body, "global.maximum.group-mappings.autorp.threshold", strconv.FormatInt(data.GlobalMaximumGroupMappingsAutorpThreshold.ValueInt64(), 10))
	}
	if !data.GlobalMaximumBsrCrpCacheMaximum.IsNull() && !data.GlobalMaximumBsrCrpCacheMaximum.IsUnknown() {
		body, _ = sjson.Set(body, "global.maximum.bsr.crp-cache.maximum-crp-cache", strconv.FormatInt(data.GlobalMaximumBsrCrpCacheMaximum.ValueInt64(), 10))
	}
	if !data.GlobalMaximumBsrCrpCacheThreshold.IsNull() && !data.GlobalMaximumBsrCrpCacheThreshold.IsUnknown() {
		body, _ = sjson.Set(body, "global.maximum.bsr.crp-cache.threshold", strconv.FormatInt(data.GlobalMaximumBsrCrpCacheThreshold.ValueInt64(), 10))
	}
	if !data.MaximumRoutes.IsNull() && !data.MaximumRoutes.IsUnknown() {
		body, _ = sjson.Set(body, "maximum.routes.maximum-routes", strconv.FormatInt(data.MaximumRoutes.ValueInt64(), 10))
	}
	if !data.MaximumRoutesThreshold.IsNull() && !data.MaximumRoutesThreshold.IsUnknown() {
		body, _ = sjson.Set(body, "maximum.routes.threshold", strconv.FormatInt(data.MaximumRoutesThreshold.ValueInt64(), 10))
	}
	if !data.MaximumRouteInterfaces.IsNull() && !data.MaximumRouteInterfaces.IsUnknown() {
		body, _ = sjson.Set(body, "maximum.route-interfaces.maximum-route-interfaces", strconv.FormatInt(data.MaximumRouteInterfaces.ValueInt64(), 10))
	}
	if !data.MaximumRouteInterfacesThreshold.IsNull() && !data.MaximumRouteInterfacesThreshold.IsUnknown() {
		body, _ = sjson.Set(body, "maximum.route-interfaces.threshold", strconv.FormatInt(data.MaximumRouteInterfacesThreshold.ValueInt64(), 10))
	}
	if !data.MaximumRegisterStates.IsNull() && !data.MaximumRegisterStates.IsUnknown() {
		body, _ = sjson.Set(body, "maximum.register-states.maximum-register-states", strconv.FormatInt(data.MaximumRegisterStates.ValueInt64(), 10))
	}
	if !data.MaximumRegisterStatesThreshold.IsNull() && !data.MaximumRegisterStatesThreshold.IsUnknown() {
		body, _ = sjson.Set(body, "maximum.register-states.threshold", strconv.FormatInt(data.MaximumRegisterStatesThreshold.ValueInt64(), 10))
	}
	if !data.MaximumGroupMappingsBsr.IsNull() && !data.MaximumGroupMappingsBsr.IsUnknown() {
		body, _ = sjson.Set(body, "maximum.group-mappings.bsr.maximum-bsr", strconv.FormatInt(data.MaximumGroupMappingsBsr.ValueInt64(), 10))
	}
	if !data.MaximumGroupMappingsBsrThreshold.IsNull() && !data.MaximumGroupMappingsBsrThreshold.IsUnknown() {
		body, _ = sjson.Set(body, "maximum.group-mappings.bsr.threshold", strconv.FormatInt(data.MaximumGroupMappingsBsrThreshold.ValueInt64(), 10))
	}
	if !data.MaximumGroupMappingsAutorp.IsNull() && !data.MaximumGroupMappingsAutorp.IsUnknown() {
		body, _ = sjson.Set(body, "maximum.group-mappings.autorp.maximum-autorp", strconv.FormatInt(data.MaximumGroupMappingsAutorp.ValueInt64(), 10))
	}
	if !data.MaximumGroupMappingsAutorpThreshold.IsNull() && !data.MaximumGroupMappingsAutorpThreshold.IsUnknown() {
		body, _ = sjson.Set(body, "maximum.group-mappings.autorp.threshold", strconv.FormatInt(data.MaximumGroupMappingsAutorpThreshold.ValueInt64(), 10))
	}
	if !data.MaximumBsrCrpCacheMaximum.IsNull() && !data.MaximumBsrCrpCacheMaximum.IsUnknown() {
		body, _ = sjson.Set(body, "maximum.bsr.crp-cache.maximum-crp-cache", strconv.FormatInt(data.MaximumBsrCrpCacheMaximum.ValueInt64(), 10))
	}
	if !data.MaximumBsrCrpCacheThreshold.IsNull() && !data.MaximumBsrCrpCacheThreshold.IsUnknown() {
		body, _ = sjson.Set(body, "maximum.bsr.crp-cache.threshold", strconv.FormatInt(data.MaximumBsrCrpCacheThreshold.ValueInt64(), 10))
	}
	if !data.LogNeighborChanges.IsNull() && !data.LogNeighborChanges.IsUnknown() {
		if data.LogNeighborChanges.ValueBool() {
			body, _ = sjson.Set(body, "log.neighbor.changes", map[string]string{})
		}
	}
	if !data.RpfVectorAllowEbgp.IsNull() && !data.RpfVectorAllowEbgp.IsUnknown() {
		if data.RpfVectorAllowEbgp.ValueBool() {
			body, _ = sjson.Set(body, "rpf-vector.allow-ebgp", map[string]string{})
		}
	}
	if !data.RpfVectorDisableIbgp.IsNull() && !data.RpfVectorDisableIbgp.IsUnknown() {
		if data.RpfVectorDisableIbgp.ValueBool() {
			body, _ = sjson.Set(body, "rpf-vector.disable-ibgp", map[string]string{})
		}
	}
	if !data.RpfVectorStandardEncoding.IsNull() && !data.RpfVectorStandardEncoding.IsUnknown() {
		if data.RpfVectorStandardEncoding.ValueBool() {
			body, _ = sjson.Set(body, "rpf-vector.use-standard-encoding", map[string]string{})
		}
	}
	if !data.RpfTopologyRoutePolicy.IsNull() && !data.RpfTopologyRoutePolicy.IsUnknown() {
		body, _ = sjson.Set(body, "rpf.topology.route-policy", data.RpfTopologyRoutePolicy.ValueString())
	}
	if !data.MdtNeighborFilter.IsNull() && !data.MdtNeighborFilter.IsUnknown() {
		body, _ = sjson.Set(body, "mdt.neighbor-filter", data.MdtNeighborFilter.ValueString())
	}
	if !data.MdtDataSwitchoverInterval.IsNull() && !data.MdtDataSwitchoverInterval.IsUnknown() {
		body, _ = sjson.Set(body, "mdt.data.switchover-interval", strconv.FormatInt(data.MdtDataSwitchoverInterval.ValueInt64(), 10))
	}
	if !data.MdtDataAnnounceInterval.IsNull() && !data.MdtDataAnnounceInterval.IsUnknown() {
		body, _ = sjson.Set(body, "mdt.data.announce-interval", strconv.FormatInt(data.MdtDataAnnounceInterval.ValueInt64(), 10))
	}
	if !data.MdtCMulticastType.IsNull() && !data.MdtCMulticastType.IsUnknown() {
		body, _ = sjson.Set(body, "mdt.c-multicast-routing.type", data.MdtCMulticastType.ValueString())
	}
	if !data.MdtCMulticastAnnouncePimJoinTlv.IsNull() && !data.MdtCMulticastAnnouncePimJoinTlv.IsUnknown() {
		if data.MdtCMulticastAnnouncePimJoinTlv.ValueBool() {
			body, _ = sjson.Set(body, "mdt.c-multicast-routing.announce-pim-join-tlv", map[string]string{})
		}
	}
	if !data.MdtCMulticastSharedTreePrune.IsNull() && !data.MdtCMulticastSharedTreePrune.IsUnknown() {
		if data.MdtCMulticastSharedTreePrune.ValueBool() {
			body, _ = sjson.Set(body, "mdt.c-multicast-routing.shared-tree-prune", map[string]string{})
		}
	}
	if !data.MdtCMulticastSuppressSharedTreeJoin.IsNull() && !data.MdtCMulticastSuppressSharedTreeJoin.IsUnknown() {
		if data.MdtCMulticastSuppressSharedTreeJoin.ValueBool() {
			body, _ = sjson.Set(body, "mdt.c-multicast-routing.suppress-shared-tree-join", map[string]string{})
		}
	}
	if !data.MdtCMulticastSuppressPimDataSignaling.IsNull() && !data.MdtCMulticastSuppressPimDataSignaling.IsUnknown() {
		if data.MdtCMulticastSuppressPimDataSignaling.ValueBool() {
			body, _ = sjson.Set(body, "mdt.c-multicast-routing.suppress-pim-data-signaling", map[string]string{})
		}
	}
	if !data.MdtCMulticastHelloEnable.IsNull() && !data.MdtCMulticastHelloEnable.IsUnknown() {
		if data.MdtCMulticastHelloEnable.ValueBool() {
			body, _ = sjson.Set(body, "mdt.c-multicast-routing.mdt-hello.enable", map[string]string{})
		}
	}
	if !data.MdtCMulticastSharedTreePruneDelay.IsNull() && !data.MdtCMulticastSharedTreePruneDelay.IsUnknown() {
		body, _ = sjson.Set(body, "mdt.c-multicast-routing.shared-tree-prune-delay", strconv.FormatInt(data.MdtCMulticastSharedTreePruneDelay.ValueInt64(), 10))
	}
	if !data.MdtCMulticastSourceTreePruneDelay.IsNull() && !data.MdtCMulticastSourceTreePruneDelay.IsUnknown() {
		body, _ = sjson.Set(body, "mdt.c-multicast-routing.source-tree-prune-delay", strconv.FormatInt(data.MdtCMulticastSourceTreePruneDelay.ValueInt64(), 10))
	}
	if !data.MdtCMulticastMigrationRoutePolicy.IsNull() && !data.MdtCMulticastMigrationRoutePolicy.IsUnknown() {
		body, _ = sjson.Set(body, "mdt.c-multicast-routing.migration.route-policy", data.MdtCMulticastMigrationRoutePolicy.ValueString())
	}
	if !data.AllowRp.IsNull() && !data.AllowRp.IsUnknown() {
		if data.AllowRp.ValueBool() {
			body, _ = sjson.Set(body, "allow-rp", map[string]string{})
		}
	}
	if !data.AllowRpList.IsNull() && !data.AllowRpList.IsUnknown() {
		body, _ = sjson.Set(body, "allow-rp.rp-list", data.AllowRpList.ValueString())
	}
	if !data.AllowRpGroupList.IsNull() && !data.AllowRpGroupList.IsUnknown() {
		body, _ = sjson.Set(body, "allow-rp.group-list", data.AllowRpGroupList.ValueString())
	}
	if !data.SgExpiryTimer.IsNull() && !data.SgExpiryTimer.IsUnknown() {
		body, _ = sjson.Set(body, "sg-expiry-timer.sg-expiry-timer-value", strconv.FormatInt(data.SgExpiryTimer.ValueInt64(), 10))
	}
	if !data.SgList.IsNull() && !data.SgList.IsUnknown() {
		body, _ = sjson.Set(body, "sg-expiry-timer.sg-list", data.SgList.ValueString())
	}
	if !data.SsmRange.IsNull() && !data.SsmRange.IsUnknown() {
		body, _ = sjson.Set(body, "ssm.range", data.SsmRange.ValueString())
	}
	if !data.SsmDisable.IsNull() && !data.SsmDisable.IsUnknown() {
		if data.SsmDisable.ValueBool() {
			body, _ = sjson.Set(body, "ssm.disable", map[string]string{})
		}
	}
	if !data.SsmAllowOverride.IsNull() && !data.SsmAllowOverride.IsUnknown() {
		if data.SsmAllowOverride.ValueBool() {
			body, _ = sjson.Set(body, "ssm.allow-override", map[string]string{})
		}
	}
	if !data.RpfRedirectRoutePolicy.IsNull() && !data.RpfRedirectRoutePolicy.IsUnknown() {
		body, _ = sjson.Set(body, "rpf-redirect.route-policy", data.RpfRedirectRoutePolicy.ValueString())
	}
	if !data.Multipath.IsNull() && !data.Multipath.IsUnknown() {
		if data.Multipath.ValueBool() {
			body, _ = sjson.Set(body, "multipath", map[string]string{})
		}
	}
	if !data.MultipathHashSource.IsNull() && !data.MultipathHashSource.IsUnknown() {
		if data.MultipathHashSource.ValueBool() {
			body, _ = sjson.Set(body, "multipath.hash.source", map[string]string{})
		}
	}
	if !data.MultipathHashSourceNexthop.IsNull() && !data.MultipathHashSourceNexthop.IsUnknown() {
		if data.MultipathHashSourceNexthop.ValueBool() {
			body, _ = sjson.Set(body, "multipath.hash.source-nexthop", map[string]string{})
		}
	}
	if !data.MultipathHashSourceGroup.IsNull() && !data.MultipathHashSourceGroup.IsUnknown() {
		if data.MultipathHashSourceGroup.ValueBool() {
			body, _ = sjson.Set(body, "multipath.hash.source-group", map[string]string{})
		}
	}
	if !data.AutoRpMappingAgentInterface.IsNull() && !data.AutoRpMappingAgentInterface.IsUnknown() {
		body, _ = sjson.Set(body, "auto-rp.mapping-agent.interface-name", data.AutoRpMappingAgentInterface.ValueString())
	}
	if !data.AutoRpMappingAgentScope.IsNull() && !data.AutoRpMappingAgentScope.IsUnknown() {
		body, _ = sjson.Set(body, "auto-rp.mapping-agent.scope", strconv.FormatInt(data.AutoRpMappingAgentScope.ValueInt64(), 10))
	}
	if !data.AutoRpMappingAgentInterval.IsNull() && !data.AutoRpMappingAgentInterval.IsUnknown() {
		body, _ = sjson.Set(body, "auto-rp.mapping-agent.interval", strconv.FormatInt(data.AutoRpMappingAgentInterval.ValueInt64(), 10))
	}
	if !data.AutoRpListenDisable.IsNull() && !data.AutoRpListenDisable.IsUnknown() {
		if data.AutoRpListenDisable.ValueBool() {
			body, _ = sjson.Set(body, "auto-rp.listen.disable", map[string]string{})
		}
	}
	if !data.BsrCandidateBsrAddress.IsNull() && !data.BsrCandidateBsrAddress.IsUnknown() {
		body, _ = sjson.Set(body, "bsr.candidate-bsr.address", data.BsrCandidateBsrAddress.ValueString())
	}
	if !data.BsrCandidateBsrHashMaskLen.IsNull() && !data.BsrCandidateBsrHashMaskLen.IsUnknown() {
		body, _ = sjson.Set(body, "bsr.candidate-bsr.hash-mask-len", strconv.FormatInt(data.BsrCandidateBsrHashMaskLen.ValueInt64(), 10))
	}
	if !data.BsrCandidateBsrPriority.IsNull() && !data.BsrCandidateBsrPriority.IsUnknown() {
		body, _ = sjson.Set(body, "bsr.candidate-bsr.priority", strconv.FormatInt(data.BsrCandidateBsrPriority.ValueInt64(), 10))
	}
	if !data.Mofrr.IsNull() && !data.Mofrr.IsUnknown() {
		if data.Mofrr.ValueBool() {
			body, _ = sjson.Set(body, "mofrr", map[string]string{})
		}
	}
	if !data.MofrrFlow.IsNull() && !data.MofrrFlow.IsUnknown() {
		body, _ = sjson.Set(body, "mofrr.flow", data.MofrrFlow.ValueString())
	}
	if !data.MofrrRib.IsNull() && !data.MofrrRib.IsUnknown() {
		body, _ = sjson.Set(body, "mofrr.rib", data.MofrrRib.ValueString())
	}
	if !data.MofrrProtect.IsNull() && !data.MofrrProtect.IsUnknown() {
		body, _ = sjson.Set(body, "mofrr.protect", data.MofrrProtect.ValueString())
	}
	if !data.MofrrProtectLocalFaultOnly.IsNull() && !data.MofrrProtectLocalFaultOnly.IsUnknown() {
		if data.MofrrProtectLocalFaultOnly.ValueBool() {
			body, _ = sjson.Set(body, "mofrr.local-fault-only", map[string]string{})
		}
	}
	if !data.MofrrNonRevertive.IsNull() && !data.MofrrNonRevertive.IsUnknown() {
		if data.MofrrNonRevertive.ValueBool() {
			body, _ = sjson.Set(body, "mofrr.non-revertive", map[string]string{})
		}
	}
	if len(data.RpAddresses) > 0 {
		body, _ = sjson.Set(body, "rp-addresses.rp-address", []interface{}{})
		for index, item := range data.RpAddresses {
			if !item.Address.IsNull() && !item.Address.IsUnknown() {
				body, _ = sjson.Set(body, "rp-addresses.rp-address"+"."+strconv.Itoa(index)+"."+"address", item.Address.ValueString())
			}
			if !item.AccessList.IsNull() && !item.AccessList.IsUnknown() {
				body, _ = sjson.Set(body, "rp-addresses.rp-address"+"."+strconv.Itoa(index)+"."+"access-list", item.AccessList.ValueString())
			}
			if !item.Override.IsNull() && !item.Override.IsUnknown() {
				if item.Override.ValueBool() {
					body, _ = sjson.Set(body, "rp-addresses.rp-address"+"."+strconv.Itoa(index)+"."+"override", map[string]string{})
				}
			}
		}
	}
	if len(data.RpAddressesBidir) > 0 {
		body, _ = sjson.Set(body, "rp-addresses.bidir.rp-address", []interface{}{})
		for index, item := range data.RpAddressesBidir {
			if !item.Address.IsNull() && !item.Address.IsUnknown() {
				body, _ = sjson.Set(body, "rp-addresses.bidir.rp-address"+"."+strconv.Itoa(index)+"."+"address", item.Address.ValueString())
			}
			if !item.AccessList.IsNull() && !item.AccessList.IsUnknown() {
				body, _ = sjson.Set(body, "rp-addresses.bidir.rp-address"+"."+strconv.Itoa(index)+"."+"access-list", item.AccessList.ValueString())
			}
			if !item.Override.IsNull() && !item.Override.IsUnknown() {
				if item.Override.ValueBool() {
					body, _ = sjson.Set(body, "rp-addresses.bidir.rp-address"+"."+strconv.Itoa(index)+"."+"override", map[string]string{})
				}
			}
		}
	}
	if len(data.RpfVectorInjects) > 0 {
		body, _ = sjson.Set(body, "rpf-vector-injects.inject", []interface{}{})
		for index, item := range data.RpfVectorInjects {
			if !item.SourceAddress.IsNull() && !item.SourceAddress.IsUnknown() {
				body, _ = sjson.Set(body, "rpf-vector-injects.inject"+"."+strconv.Itoa(index)+"."+"source-address", item.SourceAddress.ValueString())
			}
			if !item.SourceMask.IsNull() && !item.SourceMask.IsUnknown() {
				body, _ = sjson.Set(body, "rpf-vector-injects.inject"+"."+strconv.Itoa(index)+"."+"masklen", strconv.FormatInt(item.SourceMask.ValueInt64(), 10))
			}
			if !item.RpfVectors.IsNull() && !item.RpfVectors.IsUnknown() {
				var values []string
				item.RpfVectors.ElementsAs(ctx, &values, false)
				body, _ = sjson.Set(body, "rpf-vector-injects.inject"+"."+strconv.Itoa(index)+"."+"rpf-vector", values)
			}
		}
	}
	if len(data.ExplicitRpfVectorInjects) > 0 {
		body, _ = sjson.Set(body, "explicit-rpf-vector.injects.inject", []interface{}{})
		for index, item := range data.ExplicitRpfVectorInjects {
			if !item.SourceAddress.IsNull() && !item.SourceAddress.IsUnknown() {
				body, _ = sjson.Set(body, "explicit-rpf-vector.injects.inject"+"."+strconv.Itoa(index)+"."+"source-address", item.SourceAddress.ValueString())
			}
			if !item.SourceMask.IsNull() && !item.SourceMask.IsUnknown() {
				body, _ = sjson.Set(body, "explicit-rpf-vector.injects.inject"+"."+strconv.Itoa(index)+"."+"masklen", strconv.FormatInt(item.SourceMask.ValueInt64(), 10))
			}
			if !item.RpfVectors.IsNull() && !item.RpfVectors.IsUnknown() {
				var values []string
				item.RpfVectors.ElementsAs(ctx, &values, false)
				body, _ = sjson.Set(body, "explicit-rpf-vector.injects.inject"+"."+strconv.Itoa(index)+"."+"rpf-vector", values)
			}
		}
	}
	if len(data.AutoRpCandidateRps) > 0 {
		body, _ = sjson.Set(body, "auto-rp.candidate-rps.candidate-rp", []interface{}{})
		for index, item := range data.AutoRpCandidateRps {
			if !item.InterfaceName.IsNull() && !item.InterfaceName.IsUnknown() {
				body, _ = sjson.Set(body, "auto-rp.candidate-rps.candidate-rp"+"."+strconv.Itoa(index)+"."+"interface-name", item.InterfaceName.ValueString())
			}
			if !item.Scope.IsNull() && !item.Scope.IsUnknown() {
				body, _ = sjson.Set(body, "auto-rp.candidate-rps.candidate-rp"+"."+strconv.Itoa(index)+"."+"scope", strconv.FormatInt(item.Scope.ValueInt64(), 10))
			}
			if !item.GroupList.IsNull() && !item.GroupList.IsUnknown() {
				body, _ = sjson.Set(body, "auto-rp.candidate-rps.candidate-rp"+"."+strconv.Itoa(index)+"."+"group-list", item.GroupList.ValueString())
			}
			if !item.Interval.IsNull() && !item.Interval.IsUnknown() {
				body, _ = sjson.Set(body, "auto-rp.candidate-rps.candidate-rp"+"."+strconv.Itoa(index)+"."+"interval", strconv.FormatInt(item.Interval.ValueInt64(), 10))
			}
			if !item.BidirScope.IsNull() && !item.BidirScope.IsUnknown() {
				body, _ = sjson.Set(body, "auto-rp.candidate-rps.candidate-rp"+"."+strconv.Itoa(index)+"."+"bidir.scope", strconv.FormatInt(item.BidirScope.ValueInt64(), 10))
			}
			if !item.BidirGroupList.IsNull() && !item.BidirGroupList.IsUnknown() {
				body, _ = sjson.Set(body, "auto-rp.candidate-rps.candidate-rp"+"."+strconv.Itoa(index)+"."+"bidir.group-list", item.BidirGroupList.ValueString())
			}
			if !item.BidirInterval.IsNull() && !item.BidirInterval.IsUnknown() {
				body, _ = sjson.Set(body, "auto-rp.candidate-rps.candidate-rp"+"."+strconv.Itoa(index)+"."+"bidir.interval", strconv.FormatInt(item.BidirInterval.ValueInt64(), 10))
			}
		}
	}
	if len(data.AutoRpRelayVrfs) > 0 {
		body, _ = sjson.Set(body, "auto-rp.relay.vrfs.vrf", []interface{}{})
		for index, item := range data.AutoRpRelayVrfs {
			if !item.VrfName.IsNull() && !item.VrfName.IsUnknown() {
				body, _ = sjson.Set(body, "auto-rp.relay.vrfs.vrf"+"."+strconv.Itoa(index)+"."+"vrf-name", item.VrfName.ValueString())
			}
			if !item.Listen.IsNull() && !item.Listen.IsUnknown() {
				if item.Listen.ValueBool() {
					body, _ = sjson.Set(body, "auto-rp.relay.vrfs.vrf"+"."+strconv.Itoa(index)+"."+"listen", map[string]string{})
				}
			}
		}
	}
	if len(data.BsrCandidateRps) > 0 {
		body, _ = sjson.Set(body, "bsr.candidate-rps.candidate-rp", []interface{}{})
		for index, item := range data.BsrCandidateRps {
			if !item.Address.IsNull() && !item.Address.IsUnknown() {
				body, _ = sjson.Set(body, "bsr.candidate-rps.candidate-rp"+"."+strconv.Itoa(index)+"."+"address", item.Address.ValueString())
			}
			if !item.GroupList.IsNull() && !item.GroupList.IsUnknown() {
				body, _ = sjson.Set(body, "bsr.candidate-rps.candidate-rp"+"."+strconv.Itoa(index)+"."+"group-list", item.GroupList.ValueString())
			}
			if !item.Priority.IsNull() && !item.Priority.IsUnknown() {
				body, _ = sjson.Set(body, "bsr.candidate-rps.candidate-rp"+"."+strconv.Itoa(index)+"."+"priority", strconv.FormatInt(item.Priority.ValueInt64(), 10))
			}
			if !item.Interval.IsNull() && !item.Interval.IsUnknown() {
				body, _ = sjson.Set(body, "bsr.candidate-rps.candidate-rp"+"."+strconv.Itoa(index)+"."+"interval", strconv.FormatInt(item.Interval.ValueInt64(), 10))
			}
			if !item.BidirGroupList.IsNull() && !item.BidirGroupList.IsUnknown() {
				body, _ = sjson.Set(body, "bsr.candidate-rps.candidate-rp"+"."+strconv.Itoa(index)+"."+"bidir.group-list", item.BidirGroupList.ValueString())
			}
			if !item.BidirPriority.IsNull() && !item.BidirPriority.IsUnknown() {
				body, _ = sjson.Set(body, "bsr.candidate-rps.candidate-rp"+"."+strconv.Itoa(index)+"."+"bidir.priority", strconv.FormatInt(item.BidirPriority.ValueInt64(), 10))
			}
			if !item.BidirInterval.IsNull() && !item.BidirInterval.IsUnknown() {
				body, _ = sjson.Set(body, "bsr.candidate-rps.candidate-rp"+"."+strconv.Itoa(index)+"."+"bidir.interval", strconv.FormatInt(item.BidirInterval.ValueInt64(), 10))
			}
		}
	}
	if len(data.BsrRelayVrfs) > 0 {
		body, _ = sjson.Set(body, "bsr.relay.vrfs.vrf", []interface{}{})
		for index, item := range data.BsrRelayVrfs {
			if !item.VrfName.IsNull() && !item.VrfName.IsUnknown() {
				body, _ = sjson.Set(body, "bsr.relay.vrfs.vrf"+"."+strconv.Itoa(index)+"."+"vrf-name", item.VrfName.ValueString())
			}
			if !item.Listen.IsNull() && !item.Listen.IsUnknown() {
				if item.Listen.ValueBool() {
					body, _ = sjson.Set(body, "bsr.relay.vrfs.vrf"+"."+strconv.Itoa(index)+"."+"listen", map[string]string{})
				}
			}
		}
	}
	if len(data.MofrrCloneJoins) > 0 {
		body, _ = sjson.Set(body, "mofrr.clone.joins.join", []interface{}{})
		for index, item := range data.MofrrCloneJoins {
			if !item.SourceAddress.IsNull() && !item.SourceAddress.IsUnknown() {
				body, _ = sjson.Set(body, "mofrr.clone.joins.join"+"."+strconv.Itoa(index)+"."+"address", item.SourceAddress.ValueString())
			}
			if len(item.To) > 0 {
				body, _ = sjson.Set(body, "mofrr.clone.joins.join"+"."+strconv.Itoa(index)+"."+"to", []interface{}{})
				for cindex, citem := range item.To {
					if !citem.PrimaryAddress.IsNull() && !citem.PrimaryAddress.IsUnknown() {
						body, _ = sjson.Set(body, "mofrr.clone.joins.join"+"."+strconv.Itoa(index)+"."+"to"+"."+strconv.Itoa(cindex)+"."+"address", citem.PrimaryAddress.ValueString())
					}
					if len(citem.And) > 0 {
						body, _ = sjson.Set(body, "mofrr.clone.joins.join"+"."+strconv.Itoa(index)+"."+"to"+"."+strconv.Itoa(cindex)+"."+"and", []interface{}{})
						for ccindex, ccitem := range citem.And {
							if !ccitem.BackupAddress.IsNull() && !ccitem.BackupAddress.IsUnknown() {
								body, _ = sjson.Set(body, "mofrr.clone.joins.join"+"."+strconv.Itoa(index)+"."+"to"+"."+strconv.Itoa(cindex)+"."+"and"+"."+strconv.Itoa(ccindex)+"."+"address", ccitem.BackupAddress.ValueString())
							}
							if len(ccitem.Masklen) > 0 {
								body, _ = sjson.Set(body, "mofrr.clone.joins.join"+"."+strconv.Itoa(index)+"."+"to"+"."+strconv.Itoa(cindex)+"."+"and"+"."+strconv.Itoa(ccindex)+"."+"", []interface{}{})
								for cccindex, cccitem := range ccitem.Masklen {
									if !cccitem.MaskLength.IsNull() && !cccitem.MaskLength.IsUnknown() {
										body, _ = sjson.Set(body, "mofrr.clone.joins.join"+"."+strconv.Itoa(index)+"."+"to"+"."+strconv.Itoa(cindex)+"."+"and"+"."+strconv.Itoa(ccindex)+"."+""+"."+strconv.Itoa(cccindex)+"."+"", strconv.FormatInt(cccitem.MaskLength.ValueInt64(), 10))
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if len(data.MofrrCloneSources) > 0 {
		body, _ = sjson.Set(body, "mofrr.clone.sources.source", []interface{}{})
		for index, item := range data.MofrrCloneSources {
			if !item.SourceAddress.IsNull() && !item.SourceAddress.IsUnknown() {
				body, _ = sjson.Set(body, "mofrr.clone.sources.source"+"."+strconv.Itoa(index)+"."+"address", item.SourceAddress.ValueString())
			}
			if len(item.To) > 0 {
				body, _ = sjson.Set(body, "mofrr.clone.sources.source"+"."+strconv.Itoa(index)+"."+"to", []interface{}{})
				for cindex, citem := range item.To {
					if !citem.PrimaryAddress.IsNull() && !citem.PrimaryAddress.IsUnknown() {
						body, _ = sjson.Set(body, "mofrr.clone.sources.source"+"."+strconv.Itoa(index)+"."+"to"+"."+strconv.Itoa(cindex)+"."+"address", citem.PrimaryAddress.ValueString())
					}
					if len(citem.And) > 0 {
						body, _ = sjson.Set(body, "mofrr.clone.sources.source"+"."+strconv.Itoa(index)+"."+"to"+"."+strconv.Itoa(cindex)+"."+"and", []interface{}{})
						for ccindex, ccitem := range citem.And {
							if !ccitem.BackupAddress.IsNull() && !ccitem.BackupAddress.IsUnknown() {
								body, _ = sjson.Set(body, "mofrr.clone.sources.source"+"."+strconv.Itoa(index)+"."+"to"+"."+strconv.Itoa(cindex)+"."+"and"+"."+strconv.Itoa(ccindex)+"."+"address", ccitem.BackupAddress.ValueString())
							}
							if len(ccitem.Masklen) > 0 {
								body, _ = sjson.Set(body, "mofrr.clone.sources.source"+"."+strconv.Itoa(index)+"."+"to"+"."+strconv.Itoa(cindex)+"."+"and"+"."+strconv.Itoa(ccindex)+"."+"", []interface{}{})
								for cccindex, cccitem := range ccitem.Masklen {
									if !cccitem.MaskLength.IsNull() && !cccitem.MaskLength.IsUnknown() {
										body, _ = sjson.Set(body, "mofrr.clone.sources.source"+"."+strconv.Itoa(index)+"."+"to"+"."+strconv.Itoa(cindex)+"."+"and"+"."+strconv.Itoa(ccindex)+"."+""+"."+strconv.Itoa(cccindex)+"."+"", strconv.FormatInt(cccitem.MaskLength.ValueInt64(), 10))
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if len(data.SrP2mpPolicies) > 0 {
		body, _ = sjson.Set(body, "sr-p2mp-policies.sr-p2mp-policy", []interface{}{})
		for index, item := range data.SrP2mpPolicies {
			if !item.PolicyName.IsNull() && !item.PolicyName.IsUnknown() {
				body, _ = sjson.Set(body, "sr-p2mp-policies.sr-p2mp-policy"+"."+strconv.Itoa(index)+"."+"sr-p2mp-policy-id", item.PolicyName.ValueString())
			}
			if len(item.StaticGroups) > 0 {
				body, _ = sjson.Set(body, "sr-p2mp-policies.sr-p2mp-policy"+"."+strconv.Itoa(index)+"."+"static-group.group-address", []interface{}{})
				for cindex, citem := range item.StaticGroups {
					if !citem.GroupAddress.IsNull() && !citem.GroupAddress.IsUnknown() {
						body, _ = sjson.Set(body, "sr-p2mp-policies.sr-p2mp-policy"+"."+strconv.Itoa(index)+"."+"static-group.group-address"+"."+strconv.Itoa(cindex)+"."+"group-address", citem.GroupAddress.ValueString())
					}
					if !citem.GroupAddressOnly.IsNull() && !citem.GroupAddressOnly.IsUnknown() {
						if citem.GroupAddressOnly.ValueBool() {
							body, _ = sjson.Set(body, "sr-p2mp-policies.sr-p2mp-policy"+"."+strconv.Itoa(index)+"."+"static-group.group-address"+"."+strconv.Itoa(cindex)+"."+"group-address-only", map[string]string{})
						}
					}
					if len(citem.GroupMasks) > 0 {
						body, _ = sjson.Set(body, "sr-p2mp-policies.sr-p2mp-policy"+"."+strconv.Itoa(index)+"."+"static-group.group-address"+"."+strconv.Itoa(cindex)+"."+"group-address-inc-mask", []interface{}{})
						for ccindex, ccitem := range citem.GroupMasks {
							if !ccitem.GroupIncMask.IsNull() && !ccitem.GroupIncMask.IsUnknown() {
								body, _ = sjson.Set(body, "sr-p2mp-policies.sr-p2mp-policy"+"."+strconv.Itoa(index)+"."+"static-group.group-address"+"."+strconv.Itoa(cindex)+"."+"group-address-inc-mask"+"."+strconv.Itoa(ccindex)+"."+"group-mask-address", ccitem.GroupIncMask.ValueString())
							}
							if !ccitem.GroupCount.IsNull() && !ccitem.GroupCount.IsUnknown() {
								body, _ = sjson.Set(body, "sr-p2mp-policies.sr-p2mp-policy"+"."+strconv.Itoa(index)+"."+"static-group.group-address"+"."+strconv.Itoa(cindex)+"."+"group-address-inc-mask"+"."+strconv.Itoa(ccindex)+"."+"group-address-count", strconv.FormatInt(ccitem.GroupCount.ValueInt64(), 10))
							}
						}
					}
					if len(citem.GroupMasksSourceAddresses) > 0 {
						body, _ = sjson.Set(body, "sr-p2mp-policies.sr-p2mp-policy"+"."+strconv.Itoa(index)+"."+"static-group.group-address"+"."+strconv.Itoa(cindex)+"."+"group-mask-address-source-address-inc-mask", []interface{}{})
						for ccindex, ccitem := range citem.GroupMasksSourceAddresses {
							if !ccitem.GroupIncMask.IsNull() && !ccitem.GroupIncMask.IsUnknown() {
								body, _ = sjson.Set(body, "sr-p2mp-policies.sr-p2mp-policy"+"."+strconv.Itoa(index)+"."+"static-group.group-address"+"."+strconv.Itoa(cindex)+"."+"group-mask-address-source-address-inc-mask"+"."+strconv.Itoa(ccindex)+"."+"group-mask-address", ccitem.GroupIncMask.ValueString())
							}
							if !ccitem.SourceIp.IsNull() && !ccitem.SourceIp.IsUnknown() {
								body, _ = sjson.Set(body, "sr-p2mp-policies.sr-p2mp-policy"+"."+strconv.Itoa(index)+"."+"static-group.group-address"+"."+strconv.Itoa(cindex)+"."+"group-mask-address-source-address-inc-mask"+"."+strconv.Itoa(ccindex)+"."+"source-address", ccitem.SourceIp.ValueString())
							}
							if !ccitem.GroupCount.IsNull() && !ccitem.GroupCount.IsUnknown() {
								body, _ = sjson.Set(body, "sr-p2mp-policies.sr-p2mp-policy"+"."+strconv.Itoa(index)+"."+"static-group.group-address"+"."+strconv.Itoa(cindex)+"."+"group-mask-address-source-address-inc-mask"+"."+strconv.Itoa(ccindex)+"."+"group-address-count", strconv.FormatInt(ccitem.GroupCount.ValueInt64(), 10))
							}
						}
					}
					if len(citem.SourceMasks) > 0 {
						body, _ = sjson.Set(body, "sr-p2mp-policies.sr-p2mp-policy"+"."+strconv.Itoa(index)+"."+"static-group.group-address"+"."+strconv.Itoa(cindex)+"."+"source-address-source-mask-address-inc-mask", []interface{}{})
						for ccindex, ccitem := range citem.SourceMasks {
							if !ccitem.SourceIp.IsNull() && !ccitem.SourceIp.IsUnknown() {
								body, _ = sjson.Set(body, "sr-p2mp-policies.sr-p2mp-policy"+"."+strconv.Itoa(index)+"."+"static-group.group-address"+"."+strconv.Itoa(cindex)+"."+"source-address-source-mask-address-inc-mask"+"."+strconv.Itoa(ccindex)+"."+"source-address", ccitem.SourceIp.ValueString())
							}
							if !ccitem.SourceIncMask.IsNull() && !ccitem.SourceIncMask.IsUnknown() {
								body, _ = sjson.Set(body, "sr-p2mp-policies.sr-p2mp-policy"+"."+strconv.Itoa(index)+"."+"static-group.group-address"+"."+strconv.Itoa(cindex)+"."+"source-address-source-mask-address-inc-mask"+"."+strconv.Itoa(ccindex)+"."+"source-mask-address", ccitem.SourceIncMask.ValueString())
							}
							if !ccitem.SourceCount.IsNull() && !ccitem.SourceCount.IsUnknown() {
								body, _ = sjson.Set(body, "sr-p2mp-policies.sr-p2mp-policy"+"."+strconv.Itoa(index)+"."+"static-group.group-address"+"."+strconv.Itoa(cindex)+"."+"source-address-source-mask-address-inc-mask"+"."+strconv.Itoa(ccindex)+"."+"source-address-count", strconv.FormatInt(ccitem.SourceCount.ValueInt64(), 10))
							}
						}
					}
					if len(citem.GroupMasksSourceMasks) > 0 {
						body, _ = sjson.Set(body, "sr-p2mp-policies.sr-p2mp-policy"+"."+strconv.Itoa(index)+"."+"static-group.group-address"+"."+strconv.Itoa(cindex)+"."+"group-mask-address-source-address-source-mask-address-inc-mask", []interface{}{})
						for ccindex, ccitem := range citem.GroupMasksSourceMasks {
							if !ccitem.GroupIncMask.IsNull() && !ccitem.GroupIncMask.IsUnknown() {
								body, _ = sjson.Set(body, "sr-p2mp-policies.sr-p2mp-policy"+"."+strconv.Itoa(index)+"."+"static-group.group-address"+"."+strconv.Itoa(cindex)+"."+"group-mask-address-source-address-source-mask-address-inc-mask"+"."+strconv.Itoa(ccindex)+"."+"group-mask-address", ccitem.GroupIncMask.ValueString())
							}
							if !ccitem.SourceIp.IsNull() && !ccitem.SourceIp.IsUnknown() {
								body, _ = sjson.Set(body, "sr-p2mp-policies.sr-p2mp-policy"+"."+strconv.Itoa(index)+"."+"static-group.group-address"+"."+strconv.Itoa(cindex)+"."+"group-mask-address-source-address-source-mask-address-inc-mask"+"."+strconv.Itoa(ccindex)+"."+"source-address", ccitem.SourceIp.ValueString())
							}
							if !ccitem.SourceIncMask.IsNull() && !ccitem.SourceIncMask.IsUnknown() {
								body, _ = sjson.Set(body, "sr-p2mp-policies.sr-p2mp-policy"+"."+strconv.Itoa(index)+"."+"static-group.group-address"+"."+strconv.Itoa(cindex)+"."+"group-mask-address-source-address-source-mask-address-inc-mask"+"."+strconv.Itoa(ccindex)+"."+"source-mask-address", ccitem.SourceIncMask.ValueString())
							}
							if !ccitem.GroupCount.IsNull() && !ccitem.GroupCount.IsUnknown() {
								body, _ = sjson.Set(body, "sr-p2mp-policies.sr-p2mp-policy"+"."+strconv.Itoa(index)+"."+"static-group.group-address"+"."+strconv.Itoa(cindex)+"."+"group-mask-address-source-address-source-mask-address-inc-mask"+"."+strconv.Itoa(ccindex)+"."+"group-address-count", strconv.FormatInt(ccitem.GroupCount.ValueInt64(), 10))
							}
							if !ccitem.SourceCount.IsNull() && !ccitem.SourceCount.IsUnknown() {
								body, _ = sjson.Set(body, "sr-p2mp-policies.sr-p2mp-policy"+"."+strconv.Itoa(index)+"."+"static-group.group-address"+"."+strconv.Itoa(cindex)+"."+"group-mask-address-source-address-source-mask-address-inc-mask"+"."+strconv.Itoa(ccindex)+"."+"source-address-count", strconv.FormatInt(ccitem.SourceCount.ValueInt64(), 10))
							}
						}
					}
				}
			}
		}
	}
	if len(data.Interfaces) > 0 {
		body, _ = sjson.Set(body, "interfaces.interface", []interface{}{})
		for index, item := range data.Interfaces {
			if !item.InterfaceName.IsNull() && !item.InterfaceName.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"interface-name", item.InterfaceName.ValueString())
			}
			if !item.Enable.IsNull() && !item.Enable.IsUnknown() {
				if item.Enable.ValueBool() {
					body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"enable", map[string]string{})
				}
			}
			if !item.Disable.IsNull() && !item.Disable.IsUnknown() {
				if item.Disable.ValueBool() {
					body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"disable", map[string]string{})
				}
			}
			if !item.DrPriority.IsNull() && !item.DrPriority.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"dr-priority", strconv.FormatInt(item.DrPriority.ValueInt64(), 10))
			}
			if !item.HelloInterval.IsNull() && !item.HelloInterval.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"hello-interval", strconv.FormatInt(item.HelloInterval.ValueInt64(), 10))
			}
			if !item.JoinPruneInterval.IsNull() && !item.JoinPruneInterval.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"join-prune-interval", strconv.FormatInt(item.JoinPruneInterval.ValueInt64(), 10))
			}
			if !item.JoinPruneMtu.IsNull() && !item.JoinPruneMtu.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"join-prune-mtu", strconv.FormatInt(item.JoinPruneMtu.ValueInt64(), 10))
			}
			if !item.PropagationDelay.IsNull() && !item.PropagationDelay.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"propagation-delay", strconv.FormatInt(item.PropagationDelay.ValueInt64(), 10))
			}
			if !item.OverrideInterval.IsNull() && !item.OverrideInterval.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"override-interval", strconv.FormatInt(item.OverrideInterval.ValueInt64(), 10))
			}
			if !item.NeighborFilter.IsNull() && !item.NeighborFilter.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"neighbor-filter", item.NeighborFilter.ValueString())
			}
			if !item.MaximumRouteInterfaces.IsNull() && !item.MaximumRouteInterfaces.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"maximum.route-interfaces.maximum-route-interfaces", strconv.FormatInt(item.MaximumRouteInterfaces.ValueInt64(), 10))
			}
			if !item.MaximumRouteInterfacesThreshold.IsNull() && !item.MaximumRouteInterfacesThreshold.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"maximum.route-interfaces.threshold", strconv.FormatInt(item.MaximumRouteInterfacesThreshold.ValueInt64(), 10))
			}
			if !item.MaximumRouteInterfacesAccessList.IsNull() && !item.MaximumRouteInterfacesAccessList.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"maximum.route-interfaces.access-list", item.MaximumRouteInterfacesAccessList.ValueString())
			}
			if !item.BfdMultiplier.IsNull() && !item.BfdMultiplier.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"bfd.multiplier", strconv.FormatInt(item.BfdMultiplier.ValueInt64(), 10))
			}
			if !item.BfdMinimumInterval.IsNull() && !item.BfdMinimumInterval.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"bfd.minimum-interval", strconv.FormatInt(item.BfdMinimumInterval.ValueInt64(), 10))
			}
			if !item.BfdFastDetect.IsNull() && !item.BfdFastDetect.IsUnknown() {
				if item.BfdFastDetect.ValueBool() {
					body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"bfd.fast-detect", map[string]string{})
				}
			}
			if !item.BsrBorder.IsNull() && !item.BsrBorder.IsUnknown() {
				if item.BsrBorder.ValueBool() {
					body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"bsr-border", map[string]string{})
				}
			}
		}
	}
	return body
}

// End of section. //template:end toBody

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBody

func (data *RouterPIMIPv4) updateFromBody(ctx context.Context, res []byte) {
	for i := range data.RpAddresses {
		keys := [...]string{"address"}
		keyValues := [...]string{data.RpAddresses[i].Address.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "rp-addresses.rp-address").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("address"); value.Exists() && !data.RpAddresses[i].Address.IsNull() {
			data.RpAddresses[i].Address = types.StringValue(value.String())
		} else {
			data.RpAddresses[i].Address = types.StringNull()
		}
		if value := r.Get("access-list"); value.Exists() && !data.RpAddresses[i].AccessList.IsNull() {
			data.RpAddresses[i].AccessList = types.StringValue(value.String())
		} else {
			data.RpAddresses[i].AccessList = types.StringNull()
		}
		if value := r.Get("override"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.RpAddresses[i].Override.IsNull() && !data.RpAddresses[i].Override.ValueBool() {
				// Keep false value from state even though element exists on device
				data.RpAddresses[i].Override = types.BoolValue(false)
			} else if !data.RpAddresses[i].Override.IsNull() {
				data.RpAddresses[i].Override = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.RpAddresses[i].Override.IsNull() {
				data.RpAddresses[i].Override = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.RpAddresses[i].Override = types.BoolValue(false)
			}
		}
	}
	for i := range data.RpAddressesBidir {
		keys := [...]string{"address"}
		keyValues := [...]string{data.RpAddressesBidir[i].Address.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "rp-addresses.bidir.rp-address").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("address"); value.Exists() && !data.RpAddressesBidir[i].Address.IsNull() {
			data.RpAddressesBidir[i].Address = types.StringValue(value.String())
		} else {
			data.RpAddressesBidir[i].Address = types.StringNull()
		}
		if value := r.Get("access-list"); value.Exists() && !data.RpAddressesBidir[i].AccessList.IsNull() {
			data.RpAddressesBidir[i].AccessList = types.StringValue(value.String())
		} else {
			data.RpAddressesBidir[i].AccessList = types.StringNull()
		}
		if value := r.Get("override"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.RpAddressesBidir[i].Override.IsNull() && !data.RpAddressesBidir[i].Override.ValueBool() {
				// Keep false value from state even though element exists on device
				data.RpAddressesBidir[i].Override = types.BoolValue(false)
			} else if !data.RpAddressesBidir[i].Override.IsNull() {
				data.RpAddressesBidir[i].Override = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.RpAddressesBidir[i].Override.IsNull() {
				data.RpAddressesBidir[i].Override = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.RpAddressesBidir[i].Override = types.BoolValue(false)
			}
		}
	}
	if value := gjson.GetBytes(res, "rp-static-deny"); value.Exists() && !data.RpStaticDeny.IsNull() {
		data.RpStaticDeny = types.StringValue(value.String())
	} else {
		data.RpStaticDeny = types.StringNull()
	}
	if value := gjson.GetBytes(res, "accept-register"); value.Exists() && !data.AcceptRegister.IsNull() {
		data.AcceptRegister = types.StringValue(value.String())
	} else {
		data.AcceptRegister = types.StringNull()
	}
	if value := gjson.GetBytes(res, "suppress-data-registers"); value.Exists() {
		if !data.SuppressDataRegisters.IsNull() {
			data.SuppressDataRegisters = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.SuppressDataRegisters.IsNull() {
			data.SuppressDataRegisters = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "register-source"); value.Exists() && !data.RegisterSource.IsNull() {
		data.RegisterSource = types.StringValue(value.String())
	} else {
		data.RegisterSource = types.StringNull()
	}
	if value := gjson.GetBytes(res, "suppress-rpf-change-prunes"); value.Exists() {
		if !data.SuppressRpfChangePrunes.IsNull() {
			data.SuppressRpfChangePrunes = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.SuppressRpfChangePrunes.IsNull() {
			data.SuppressRpfChangePrunes = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "neighbor-filter"); value.Exists() && !data.NeighborFilter.IsNull() {
		data.NeighborFilter = types.StringValue(value.String())
	} else {
		data.NeighborFilter = types.StringNull()
	}
	if value := gjson.GetBytes(res, "convergence.rpf-conflict-join-delay"); value.Exists() && !data.ConvergenceRpfConflictJoinDelay.IsNull() {
		data.ConvergenceRpfConflictJoinDelay = types.Int64Value(value.Int())
	} else {
		data.ConvergenceRpfConflictJoinDelay = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "convergence.link-down-prune-delay"); value.Exists() && !data.ConvergenceLinkDownPruneDelay.IsNull() {
		data.ConvergenceLinkDownPruneDelay = types.Int64Value(value.Int())
	} else {
		data.ConvergenceLinkDownPruneDelay = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "spt-threshold.infinity"); value.Exists() {
		if !data.SptThresholdInfinity.IsNull() {
			data.SptThresholdInfinity = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.SptThresholdInfinity.IsNull() {
			data.SptThresholdInfinity = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "spt-threshold.infinity.group-list"); value.Exists() && !data.SptThresholdInfinityGroupList.IsNull() {
		data.SptThresholdInfinityGroupList = types.StringValue(value.String())
	} else {
		data.SptThresholdInfinityGroupList = types.StringNull()
	}
	if value := gjson.GetBytes(res, "old-register-checksum"); value.Exists() {
		if !data.OldRegisterChecksum.IsNull() {
			data.OldRegisterChecksum = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.OldRegisterChecksum.IsNull() {
			data.OldRegisterChecksum = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "nsf.lifetime"); value.Exists() && !data.NsfLifetime.IsNull() {
		data.NsfLifetime = types.Int64Value(value.Int())
	} else {
		data.NsfLifetime = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "neighbor-check-on-send.enable"); value.Exists() {
		if !data.NeighborCheckOnSend.IsNull() {
			data.NeighborCheckOnSend = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.NeighborCheckOnSend.IsNull() {
			data.NeighborCheckOnSend = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "neighbor-check-on-recv.enable"); value.Exists() {
		if !data.NeighborCheckOnRecv.IsNull() {
			data.NeighborCheckOnRecv = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.NeighborCheckOnRecv.IsNull() {
			data.NeighborCheckOnRecv = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "hello-interval"); value.Exists() && !data.HelloInterval.IsNull() {
		data.HelloInterval = types.Int64Value(value.Int())
	} else {
		data.HelloInterval = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "mdt-hello-interval"); value.Exists() && !data.MdtHelloInterval.IsNull() {
		data.MdtHelloInterval = types.Int64Value(value.Int())
	} else {
		data.MdtHelloInterval = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "dr-priority"); value.Exists() && !data.DrPriority.IsNull() {
		data.DrPriority = types.Int64Value(value.Int())
	} else {
		data.DrPriority = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "join-prune-interval"); value.Exists() && !data.JoinPruneInterval.IsNull() {
		data.JoinPruneInterval = types.Int64Value(value.Int())
	} else {
		data.JoinPruneInterval = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "join-prune-mtu"); value.Exists() && !data.JoinPruneMtu.IsNull() {
		data.JoinPruneMtu = types.Int64Value(value.Int())
	} else {
		data.JoinPruneMtu = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "propagation-delay"); value.Exists() && !data.PropagationDelay.IsNull() {
		data.PropagationDelay = types.Int64Value(value.Int())
	} else {
		data.PropagationDelay = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "override-interval"); value.Exists() && !data.OverrideInterval.IsNull() {
		data.OverrideInterval = types.Int64Value(value.Int())
	} else {
		data.OverrideInterval = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "global.maximum.routes.maximum-routes"); value.Exists() && !data.GlobalMaximumRoutes.IsNull() {
		data.GlobalMaximumRoutes = types.Int64Value(value.Int())
	} else {
		data.GlobalMaximumRoutes = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "global.maximum.routes.threshold"); value.Exists() && !data.GlobalMaximumRoutesThreshold.IsNull() {
		data.GlobalMaximumRoutesThreshold = types.Int64Value(value.Int())
	} else {
		data.GlobalMaximumRoutesThreshold = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "global.maximum.route-interfaces.maximum-route-interfaces"); value.Exists() && !data.GlobalMaximumRouteInterfaces.IsNull() {
		data.GlobalMaximumRouteInterfaces = types.Int64Value(value.Int())
	} else {
		data.GlobalMaximumRouteInterfaces = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "global.maximum.route-interfaces.threshold"); value.Exists() && !data.GlobalMaximumRouteInterfacesThreshold.IsNull() {
		data.GlobalMaximumRouteInterfacesThreshold = types.Int64Value(value.Int())
	} else {
		data.GlobalMaximumRouteInterfacesThreshold = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "global.maximum.register-states.maximum-register-states"); value.Exists() && !data.GlobalMaximumRegisterStates.IsNull() {
		data.GlobalMaximumRegisterStates = types.Int64Value(value.Int())
	} else {
		data.GlobalMaximumRegisterStates = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "global.maximum.register-states.threshold"); value.Exists() && !data.GlobalMaximumRegisterStatesThreshold.IsNull() {
		data.GlobalMaximumRegisterStatesThreshold = types.Int64Value(value.Int())
	} else {
		data.GlobalMaximumRegisterStatesThreshold = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "global.maximum.packet-queue.high-priority"); value.Exists() && !data.GlobalMaximumPacketQueueHighPriority.IsNull() {
		data.GlobalMaximumPacketQueueHighPriority = types.Int64Value(value.Int())
	} else {
		data.GlobalMaximumPacketQueueHighPriority = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "global.maximum.packet-queue.low-priority"); value.Exists() && !data.GlobalMaximumPacketQueueLowPriority.IsNull() {
		data.GlobalMaximumPacketQueueLowPriority = types.Int64Value(value.Int())
	} else {
		data.GlobalMaximumPacketQueueLowPriority = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "global.maximum.group-mappings.bsr.maximum-bsr"); value.Exists() && !data.GlobalMaximumGroupMappingsBsr.IsNull() {
		data.GlobalMaximumGroupMappingsBsr = types.Int64Value(value.Int())
	} else {
		data.GlobalMaximumGroupMappingsBsr = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "global.maximum.group-mappings.bsr.threshold"); value.Exists() && !data.GlobalMaximumGroupMappingsBsrThreshold.IsNull() {
		data.GlobalMaximumGroupMappingsBsrThreshold = types.Int64Value(value.Int())
	} else {
		data.GlobalMaximumGroupMappingsBsrThreshold = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "global.maximum.group-mappings.autorp.maximum-autorp"); value.Exists() && !data.GlobalMaximumGroupMappingsAutorp.IsNull() {
		data.GlobalMaximumGroupMappingsAutorp = types.Int64Value(value.Int())
	} else {
		data.GlobalMaximumGroupMappingsAutorp = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "global.maximum.group-mappings.autorp.threshold"); value.Exists() && !data.GlobalMaximumGroupMappingsAutorpThreshold.IsNull() {
		data.GlobalMaximumGroupMappingsAutorpThreshold = types.Int64Value(value.Int())
	} else {
		data.GlobalMaximumGroupMappingsAutorpThreshold = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "global.maximum.bsr.crp-cache.maximum-crp-cache"); value.Exists() && !data.GlobalMaximumBsrCrpCacheMaximum.IsNull() {
		data.GlobalMaximumBsrCrpCacheMaximum = types.Int64Value(value.Int())
	} else {
		data.GlobalMaximumBsrCrpCacheMaximum = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "global.maximum.bsr.crp-cache.threshold"); value.Exists() && !data.GlobalMaximumBsrCrpCacheThreshold.IsNull() {
		data.GlobalMaximumBsrCrpCacheThreshold = types.Int64Value(value.Int())
	} else {
		data.GlobalMaximumBsrCrpCacheThreshold = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "maximum.routes.maximum-routes"); value.Exists() && !data.MaximumRoutes.IsNull() {
		data.MaximumRoutes = types.Int64Value(value.Int())
	} else {
		data.MaximumRoutes = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "maximum.routes.threshold"); value.Exists() && !data.MaximumRoutesThreshold.IsNull() {
		data.MaximumRoutesThreshold = types.Int64Value(value.Int())
	} else {
		data.MaximumRoutesThreshold = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "maximum.route-interfaces.maximum-route-interfaces"); value.Exists() && !data.MaximumRouteInterfaces.IsNull() {
		data.MaximumRouteInterfaces = types.Int64Value(value.Int())
	} else {
		data.MaximumRouteInterfaces = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "maximum.route-interfaces.threshold"); value.Exists() && !data.MaximumRouteInterfacesThreshold.IsNull() {
		data.MaximumRouteInterfacesThreshold = types.Int64Value(value.Int())
	} else {
		data.MaximumRouteInterfacesThreshold = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "maximum.register-states.maximum-register-states"); value.Exists() && !data.MaximumRegisterStates.IsNull() {
		data.MaximumRegisterStates = types.Int64Value(value.Int())
	} else {
		data.MaximumRegisterStates = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "maximum.register-states.threshold"); value.Exists() && !data.MaximumRegisterStatesThreshold.IsNull() {
		data.MaximumRegisterStatesThreshold = types.Int64Value(value.Int())
	} else {
		data.MaximumRegisterStatesThreshold = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "maximum.group-mappings.bsr.maximum-bsr"); value.Exists() && !data.MaximumGroupMappingsBsr.IsNull() {
		data.MaximumGroupMappingsBsr = types.Int64Value(value.Int())
	} else {
		data.MaximumGroupMappingsBsr = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "maximum.group-mappings.bsr.threshold"); value.Exists() && !data.MaximumGroupMappingsBsrThreshold.IsNull() {
		data.MaximumGroupMappingsBsrThreshold = types.Int64Value(value.Int())
	} else {
		data.MaximumGroupMappingsBsrThreshold = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "maximum.group-mappings.autorp.maximum-autorp"); value.Exists() && !data.MaximumGroupMappingsAutorp.IsNull() {
		data.MaximumGroupMappingsAutorp = types.Int64Value(value.Int())
	} else {
		data.MaximumGroupMappingsAutorp = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "maximum.group-mappings.autorp.threshold"); value.Exists() && !data.MaximumGroupMappingsAutorpThreshold.IsNull() {
		data.MaximumGroupMappingsAutorpThreshold = types.Int64Value(value.Int())
	} else {
		data.MaximumGroupMappingsAutorpThreshold = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "maximum.bsr.crp-cache.maximum-crp-cache"); value.Exists() && !data.MaximumBsrCrpCacheMaximum.IsNull() {
		data.MaximumBsrCrpCacheMaximum = types.Int64Value(value.Int())
	} else {
		data.MaximumBsrCrpCacheMaximum = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "maximum.bsr.crp-cache.threshold"); value.Exists() && !data.MaximumBsrCrpCacheThreshold.IsNull() {
		data.MaximumBsrCrpCacheThreshold = types.Int64Value(value.Int())
	} else {
		data.MaximumBsrCrpCacheThreshold = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "log.neighbor.changes"); value.Exists() {
		if !data.LogNeighborChanges.IsNull() {
			data.LogNeighborChanges = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.LogNeighborChanges.IsNull() {
			data.LogNeighborChanges = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "rpf-vector.allow-ebgp"); value.Exists() {
		if !data.RpfVectorAllowEbgp.IsNull() {
			data.RpfVectorAllowEbgp = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RpfVectorAllowEbgp.IsNull() {
			data.RpfVectorAllowEbgp = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "rpf-vector.disable-ibgp"); value.Exists() {
		if !data.RpfVectorDisableIbgp.IsNull() {
			data.RpfVectorDisableIbgp = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RpfVectorDisableIbgp.IsNull() {
			data.RpfVectorDisableIbgp = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "rpf-vector.use-standard-encoding"); value.Exists() {
		if !data.RpfVectorStandardEncoding.IsNull() {
			data.RpfVectorStandardEncoding = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.RpfVectorStandardEncoding.IsNull() {
			data.RpfVectorStandardEncoding = types.BoolNull()
		}
	}
	for i := range data.RpfVectorInjects {
		keys := [...]string{"source-address", "masklen"}
		keyValues := [...]string{data.RpfVectorInjects[i].SourceAddress.ValueString(), strconv.FormatInt(data.RpfVectorInjects[i].SourceMask.ValueInt64(), 10)}

		var r gjson.Result
		gjson.GetBytes(res, "rpf-vector-injects.inject").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("source-address"); value.Exists() && !data.RpfVectorInjects[i].SourceAddress.IsNull() {
			data.RpfVectorInjects[i].SourceAddress = types.StringValue(value.String())
		} else {
			data.RpfVectorInjects[i].SourceAddress = types.StringNull()
		}
		if value := r.Get("masklen"); value.Exists() && !data.RpfVectorInjects[i].SourceMask.IsNull() {
			data.RpfVectorInjects[i].SourceMask = types.Int64Value(value.Int())
		} else {
			data.RpfVectorInjects[i].SourceMask = types.Int64Null()
		}
		if value := r.Get("rpf-vector"); value.Exists() && !data.RpfVectorInjects[i].RpfVectors.IsNull() {
			data.RpfVectorInjects[i].RpfVectors = helpers.GetStringList(value.Array())
		} else {
			data.RpfVectorInjects[i].RpfVectors = types.ListNull(types.StringType)
		}
	}
	for i := range data.ExplicitRpfVectorInjects {
		keys := [...]string{"source-address", "masklen"}
		keyValues := [...]string{data.ExplicitRpfVectorInjects[i].SourceAddress.ValueString(), strconv.FormatInt(data.ExplicitRpfVectorInjects[i].SourceMask.ValueInt64(), 10)}

		var r gjson.Result
		gjson.GetBytes(res, "explicit-rpf-vector.injects.inject").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("source-address"); value.Exists() && !data.ExplicitRpfVectorInjects[i].SourceAddress.IsNull() {
			data.ExplicitRpfVectorInjects[i].SourceAddress = types.StringValue(value.String())
		} else {
			data.ExplicitRpfVectorInjects[i].SourceAddress = types.StringNull()
		}
		if value := r.Get("masklen"); value.Exists() && !data.ExplicitRpfVectorInjects[i].SourceMask.IsNull() {
			data.ExplicitRpfVectorInjects[i].SourceMask = types.Int64Value(value.Int())
		} else {
			data.ExplicitRpfVectorInjects[i].SourceMask = types.Int64Null()
		}
		if value := r.Get("rpf-vector"); value.Exists() && !data.ExplicitRpfVectorInjects[i].RpfVectors.IsNull() {
			data.ExplicitRpfVectorInjects[i].RpfVectors = helpers.GetStringList(value.Array())
		} else {
			data.ExplicitRpfVectorInjects[i].RpfVectors = types.ListNull(types.StringType)
		}
	}
	if value := gjson.GetBytes(res, "rpf.topology.route-policy"); value.Exists() && !data.RpfTopologyRoutePolicy.IsNull() {
		data.RpfTopologyRoutePolicy = types.StringValue(value.String())
	} else {
		data.RpfTopologyRoutePolicy = types.StringNull()
	}
	if value := gjson.GetBytes(res, "mdt.neighbor-filter"); value.Exists() && !data.MdtNeighborFilter.IsNull() {
		data.MdtNeighborFilter = types.StringValue(value.String())
	} else {
		data.MdtNeighborFilter = types.StringNull()
	}
	if value := gjson.GetBytes(res, "mdt.data.switchover-interval"); value.Exists() && !data.MdtDataSwitchoverInterval.IsNull() {
		data.MdtDataSwitchoverInterval = types.Int64Value(value.Int())
	} else {
		data.MdtDataSwitchoverInterval = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "mdt.data.announce-interval"); value.Exists() && !data.MdtDataAnnounceInterval.IsNull() {
		data.MdtDataAnnounceInterval = types.Int64Value(value.Int())
	} else {
		data.MdtDataAnnounceInterval = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "mdt.c-multicast-routing.type"); value.Exists() && !data.MdtCMulticastType.IsNull() {
		data.MdtCMulticastType = types.StringValue(value.String())
	} else {
		data.MdtCMulticastType = types.StringNull()
	}
	if value := gjson.GetBytes(res, "mdt.c-multicast-routing.announce-pim-join-tlv"); value.Exists() {
		if !data.MdtCMulticastAnnouncePimJoinTlv.IsNull() {
			data.MdtCMulticastAnnouncePimJoinTlv = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.MdtCMulticastAnnouncePimJoinTlv.IsNull() {
			data.MdtCMulticastAnnouncePimJoinTlv = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "mdt.c-multicast-routing.shared-tree-prune"); value.Exists() {
		if !data.MdtCMulticastSharedTreePrune.IsNull() {
			data.MdtCMulticastSharedTreePrune = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.MdtCMulticastSharedTreePrune.IsNull() {
			data.MdtCMulticastSharedTreePrune = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "mdt.c-multicast-routing.suppress-shared-tree-join"); value.Exists() {
		if !data.MdtCMulticastSuppressSharedTreeJoin.IsNull() {
			data.MdtCMulticastSuppressSharedTreeJoin = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.MdtCMulticastSuppressSharedTreeJoin.IsNull() {
			data.MdtCMulticastSuppressSharedTreeJoin = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "mdt.c-multicast-routing.suppress-pim-data-signaling"); value.Exists() {
		if !data.MdtCMulticastSuppressPimDataSignaling.IsNull() {
			data.MdtCMulticastSuppressPimDataSignaling = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.MdtCMulticastSuppressPimDataSignaling.IsNull() {
			data.MdtCMulticastSuppressPimDataSignaling = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "mdt.c-multicast-routing.mdt-hello.enable"); value.Exists() {
		if !data.MdtCMulticastHelloEnable.IsNull() {
			data.MdtCMulticastHelloEnable = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.MdtCMulticastHelloEnable.IsNull() {
			data.MdtCMulticastHelloEnable = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "mdt.c-multicast-routing.shared-tree-prune-delay"); value.Exists() && !data.MdtCMulticastSharedTreePruneDelay.IsNull() {
		data.MdtCMulticastSharedTreePruneDelay = types.Int64Value(value.Int())
	} else {
		data.MdtCMulticastSharedTreePruneDelay = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "mdt.c-multicast-routing.source-tree-prune-delay"); value.Exists() && !data.MdtCMulticastSourceTreePruneDelay.IsNull() {
		data.MdtCMulticastSourceTreePruneDelay = types.Int64Value(value.Int())
	} else {
		data.MdtCMulticastSourceTreePruneDelay = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "mdt.c-multicast-routing.migration.route-policy"); value.Exists() && !data.MdtCMulticastMigrationRoutePolicy.IsNull() {
		data.MdtCMulticastMigrationRoutePolicy = types.StringValue(value.String())
	} else {
		data.MdtCMulticastMigrationRoutePolicy = types.StringNull()
	}
	if value := gjson.GetBytes(res, "allow-rp"); value.Exists() {
		if !data.AllowRp.IsNull() {
			data.AllowRp = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.AllowRp.IsNull() {
			data.AllowRp = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "allow-rp.rp-list"); value.Exists() && !data.AllowRpList.IsNull() {
		data.AllowRpList = types.StringValue(value.String())
	} else {
		data.AllowRpList = types.StringNull()
	}
	if value := gjson.GetBytes(res, "allow-rp.group-list"); value.Exists() && !data.AllowRpGroupList.IsNull() {
		data.AllowRpGroupList = types.StringValue(value.String())
	} else {
		data.AllowRpGroupList = types.StringNull()
	}
	if value := gjson.GetBytes(res, "sg-expiry-timer.sg-expiry-timer-value"); value.Exists() && !data.SgExpiryTimer.IsNull() {
		data.SgExpiryTimer = types.Int64Value(value.Int())
	} else {
		data.SgExpiryTimer = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "sg-expiry-timer.sg-list"); value.Exists() && !data.SgList.IsNull() {
		data.SgList = types.StringValue(value.String())
	} else {
		data.SgList = types.StringNull()
	}
	if value := gjson.GetBytes(res, "ssm.range"); value.Exists() && !data.SsmRange.IsNull() {
		data.SsmRange = types.StringValue(value.String())
	} else {
		data.SsmRange = types.StringNull()
	}
	if value := gjson.GetBytes(res, "ssm.disable"); value.Exists() {
		if !data.SsmDisable.IsNull() {
			data.SsmDisable = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.SsmDisable.IsNull() {
			data.SsmDisable = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "ssm.allow-override"); value.Exists() {
		if !data.SsmAllowOverride.IsNull() {
			data.SsmAllowOverride = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.SsmAllowOverride.IsNull() {
			data.SsmAllowOverride = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "rpf-redirect.route-policy"); value.Exists() && !data.RpfRedirectRoutePolicy.IsNull() {
		data.RpfRedirectRoutePolicy = types.StringValue(value.String())
	} else {
		data.RpfRedirectRoutePolicy = types.StringNull()
	}
	if value := gjson.GetBytes(res, "multipath"); value.Exists() {
		if !data.Multipath.IsNull() {
			data.Multipath = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.Multipath.IsNull() {
			data.Multipath = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "multipath.hash.source"); value.Exists() {
		if !data.MultipathHashSource.IsNull() {
			data.MultipathHashSource = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.MultipathHashSource.IsNull() {
			data.MultipathHashSource = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "multipath.hash.source-nexthop"); value.Exists() {
		if !data.MultipathHashSourceNexthop.IsNull() {
			data.MultipathHashSourceNexthop = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.MultipathHashSourceNexthop.IsNull() {
			data.MultipathHashSourceNexthop = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "multipath.hash.source-group"); value.Exists() {
		if !data.MultipathHashSourceGroup.IsNull() {
			data.MultipathHashSourceGroup = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.MultipathHashSourceGroup.IsNull() {
			data.MultipathHashSourceGroup = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "auto-rp.mapping-agent.interface-name"); value.Exists() && !data.AutoRpMappingAgentInterface.IsNull() {
		data.AutoRpMappingAgentInterface = types.StringValue(value.String())
	} else {
		data.AutoRpMappingAgentInterface = types.StringNull()
	}
	if value := gjson.GetBytes(res, "auto-rp.mapping-agent.scope"); value.Exists() && !data.AutoRpMappingAgentScope.IsNull() {
		data.AutoRpMappingAgentScope = types.Int64Value(value.Int())
	} else {
		data.AutoRpMappingAgentScope = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "auto-rp.mapping-agent.interval"); value.Exists() && !data.AutoRpMappingAgentInterval.IsNull() {
		data.AutoRpMappingAgentInterval = types.Int64Value(value.Int())
	} else {
		data.AutoRpMappingAgentInterval = types.Int64Null()
	}
	for i := range data.AutoRpCandidateRps {
		keys := [...]string{"interface-name"}
		keyValues := [...]string{data.AutoRpCandidateRps[i].InterfaceName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "auto-rp.candidate-rps.candidate-rp").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("interface-name"); value.Exists() && !data.AutoRpCandidateRps[i].InterfaceName.IsNull() {
			data.AutoRpCandidateRps[i].InterfaceName = types.StringValue(value.String())
		} else {
			data.AutoRpCandidateRps[i].InterfaceName = types.StringNull()
		}
		if value := r.Get("scope"); value.Exists() && !data.AutoRpCandidateRps[i].Scope.IsNull() {
			data.AutoRpCandidateRps[i].Scope = types.Int64Value(value.Int())
		} else {
			data.AutoRpCandidateRps[i].Scope = types.Int64Null()
		}
		if value := r.Get("group-list"); value.Exists() && !data.AutoRpCandidateRps[i].GroupList.IsNull() {
			data.AutoRpCandidateRps[i].GroupList = types.StringValue(value.String())
		} else {
			data.AutoRpCandidateRps[i].GroupList = types.StringNull()
		}
		if value := r.Get("interval"); value.Exists() && !data.AutoRpCandidateRps[i].Interval.IsNull() {
			data.AutoRpCandidateRps[i].Interval = types.Int64Value(value.Int())
		} else {
			data.AutoRpCandidateRps[i].Interval = types.Int64Null()
		}
		if value := r.Get("bidir.scope"); value.Exists() && !data.AutoRpCandidateRps[i].BidirScope.IsNull() {
			data.AutoRpCandidateRps[i].BidirScope = types.Int64Value(value.Int())
		} else {
			data.AutoRpCandidateRps[i].BidirScope = types.Int64Null()
		}
		if value := r.Get("bidir.group-list"); value.Exists() && !data.AutoRpCandidateRps[i].BidirGroupList.IsNull() {
			data.AutoRpCandidateRps[i].BidirGroupList = types.StringValue(value.String())
		} else {
			data.AutoRpCandidateRps[i].BidirGroupList = types.StringNull()
		}
		if value := r.Get("bidir.interval"); value.Exists() && !data.AutoRpCandidateRps[i].BidirInterval.IsNull() {
			data.AutoRpCandidateRps[i].BidirInterval = types.Int64Value(value.Int())
		} else {
			data.AutoRpCandidateRps[i].BidirInterval = types.Int64Null()
		}
	}
	if value := gjson.GetBytes(res, "auto-rp.listen.disable"); value.Exists() {
		if !data.AutoRpListenDisable.IsNull() {
			data.AutoRpListenDisable = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.AutoRpListenDisable.IsNull() {
			data.AutoRpListenDisable = types.BoolNull()
		}
	}
	for i := range data.AutoRpRelayVrfs {
		keys := [...]string{"vrf-name"}
		keyValues := [...]string{data.AutoRpRelayVrfs[i].VrfName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "auto-rp.relay.vrfs.vrf").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("vrf-name"); value.Exists() && !data.AutoRpRelayVrfs[i].VrfName.IsNull() {
			data.AutoRpRelayVrfs[i].VrfName = types.StringValue(value.String())
		} else {
			data.AutoRpRelayVrfs[i].VrfName = types.StringNull()
		}
		if value := r.Get("listen"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.AutoRpRelayVrfs[i].Listen.IsNull() && !data.AutoRpRelayVrfs[i].Listen.ValueBool() {
				// Keep false value from state even though element exists on device
				data.AutoRpRelayVrfs[i].Listen = types.BoolValue(false)
			} else if !data.AutoRpRelayVrfs[i].Listen.IsNull() {
				data.AutoRpRelayVrfs[i].Listen = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.AutoRpRelayVrfs[i].Listen.IsNull() {
				data.AutoRpRelayVrfs[i].Listen = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.AutoRpRelayVrfs[i].Listen = types.BoolValue(false)
			}
		}
	}
	if value := gjson.GetBytes(res, "bsr.candidate-bsr.address"); value.Exists() && !data.BsrCandidateBsrAddress.IsNull() {
		data.BsrCandidateBsrAddress = types.StringValue(value.String())
	} else {
		data.BsrCandidateBsrAddress = types.StringNull()
	}
	if value := gjson.GetBytes(res, "bsr.candidate-bsr.hash-mask-len"); value.Exists() && !data.BsrCandidateBsrHashMaskLen.IsNull() {
		data.BsrCandidateBsrHashMaskLen = types.Int64Value(value.Int())
	} else {
		data.BsrCandidateBsrHashMaskLen = types.Int64Null()
	}
	if value := gjson.GetBytes(res, "bsr.candidate-bsr.priority"); value.Exists() && !data.BsrCandidateBsrPriority.IsNull() {
		data.BsrCandidateBsrPriority = types.Int64Value(value.Int())
	} else {
		data.BsrCandidateBsrPriority = types.Int64Null()
	}
	for i := range data.BsrCandidateRps {
		keys := [...]string{"address"}
		keyValues := [...]string{data.BsrCandidateRps[i].Address.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "bsr.candidate-rps.candidate-rp").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("address"); value.Exists() && !data.BsrCandidateRps[i].Address.IsNull() {
			data.BsrCandidateRps[i].Address = types.StringValue(value.String())
		} else {
			data.BsrCandidateRps[i].Address = types.StringNull()
		}
		if value := r.Get("group-list"); value.Exists() && !data.BsrCandidateRps[i].GroupList.IsNull() {
			data.BsrCandidateRps[i].GroupList = types.StringValue(value.String())
		} else {
			data.BsrCandidateRps[i].GroupList = types.StringNull()
		}
		if value := r.Get("priority"); value.Exists() && !data.BsrCandidateRps[i].Priority.IsNull() {
			data.BsrCandidateRps[i].Priority = types.Int64Value(value.Int())
		} else {
			data.BsrCandidateRps[i].Priority = types.Int64Null()
		}
		if value := r.Get("interval"); value.Exists() && !data.BsrCandidateRps[i].Interval.IsNull() {
			data.BsrCandidateRps[i].Interval = types.Int64Value(value.Int())
		} else {
			data.BsrCandidateRps[i].Interval = types.Int64Null()
		}
		if value := r.Get("bidir.group-list"); value.Exists() && !data.BsrCandidateRps[i].BidirGroupList.IsNull() {
			data.BsrCandidateRps[i].BidirGroupList = types.StringValue(value.String())
		} else {
			data.BsrCandidateRps[i].BidirGroupList = types.StringNull()
		}
		if value := r.Get("bidir.priority"); value.Exists() && !data.BsrCandidateRps[i].BidirPriority.IsNull() {
			data.BsrCandidateRps[i].BidirPriority = types.Int64Value(value.Int())
		} else {
			data.BsrCandidateRps[i].BidirPriority = types.Int64Null()
		}
		if value := r.Get("bidir.interval"); value.Exists() && !data.BsrCandidateRps[i].BidirInterval.IsNull() {
			data.BsrCandidateRps[i].BidirInterval = types.Int64Value(value.Int())
		} else {
			data.BsrCandidateRps[i].BidirInterval = types.Int64Null()
		}
	}
	for i := range data.BsrRelayVrfs {
		keys := [...]string{"vrf-name"}
		keyValues := [...]string{data.BsrRelayVrfs[i].VrfName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "bsr.relay.vrfs.vrf").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("vrf-name"); value.Exists() && !data.BsrRelayVrfs[i].VrfName.IsNull() {
			data.BsrRelayVrfs[i].VrfName = types.StringValue(value.String())
		} else {
			data.BsrRelayVrfs[i].VrfName = types.StringNull()
		}
		if value := r.Get("listen"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.BsrRelayVrfs[i].Listen.IsNull() && !data.BsrRelayVrfs[i].Listen.ValueBool() {
				// Keep false value from state even though element exists on device
				data.BsrRelayVrfs[i].Listen = types.BoolValue(false)
			} else if !data.BsrRelayVrfs[i].Listen.IsNull() {
				data.BsrRelayVrfs[i].Listen = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.BsrRelayVrfs[i].Listen.IsNull() {
				data.BsrRelayVrfs[i].Listen = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.BsrRelayVrfs[i].Listen = types.BoolValue(false)
			}
		}
	}
	if value := gjson.GetBytes(res, "mofrr"); value.Exists() {
		if !data.Mofrr.IsNull() {
			data.Mofrr = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.Mofrr.IsNull() {
			data.Mofrr = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "mofrr.flow"); value.Exists() && !data.MofrrFlow.IsNull() {
		data.MofrrFlow = types.StringValue(value.String())
	} else {
		data.MofrrFlow = types.StringNull()
	}
	if value := gjson.GetBytes(res, "mofrr.rib"); value.Exists() && !data.MofrrRib.IsNull() {
		data.MofrrRib = types.StringValue(value.String())
	} else {
		data.MofrrRib = types.StringNull()
	}
	if value := gjson.GetBytes(res, "mofrr.protect"); value.Exists() && !data.MofrrProtect.IsNull() {
		data.MofrrProtect = types.StringValue(value.String())
	} else {
		data.MofrrProtect = types.StringNull()
	}
	if value := gjson.GetBytes(res, "mofrr.local-fault-only"); value.Exists() {
		if !data.MofrrProtectLocalFaultOnly.IsNull() {
			data.MofrrProtectLocalFaultOnly = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.MofrrProtectLocalFaultOnly.IsNull() {
			data.MofrrProtectLocalFaultOnly = types.BoolNull()
		}
	}
	if value := gjson.GetBytes(res, "mofrr.non-revertive"); value.Exists() {
		if !data.MofrrNonRevertive.IsNull() {
			data.MofrrNonRevertive = types.BoolValue(true)
		}
	} else {
		// For presence-based booleans, only set to null if the attribute is null in state
		if data.MofrrNonRevertive.IsNull() {
			data.MofrrNonRevertive = types.BoolNull()
		}
	}
	for i := range data.MofrrCloneJoins {
		keys := [...]string{"address"}
		keyValues := [...]string{data.MofrrCloneJoins[i].SourceAddress.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "mofrr.clone.joins.join").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("address"); value.Exists() && !data.MofrrCloneJoins[i].SourceAddress.IsNull() {
			data.MofrrCloneJoins[i].SourceAddress = types.StringValue(value.String())
		} else {
			data.MofrrCloneJoins[i].SourceAddress = types.StringNull()
		}
		for ci := range data.MofrrCloneJoins[i].To {
			keys := [...]string{"address"}
			keyValues := [...]string{data.MofrrCloneJoins[i].To[ci].PrimaryAddress.ValueString()}

			var cr gjson.Result
			r.Get("to").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("address"); value.Exists() && !data.MofrrCloneJoins[i].To[ci].PrimaryAddress.IsNull() {
				data.MofrrCloneJoins[i].To[ci].PrimaryAddress = types.StringValue(value.String())
			} else {
				data.MofrrCloneJoins[i].To[ci].PrimaryAddress = types.StringNull()
			}
			for cci := range data.MofrrCloneJoins[i].To[ci].And {
				keys := [...]string{"address"}
				keyValues := [...]string{data.MofrrCloneJoins[i].To[ci].And[cci].BackupAddress.ValueString()}

				var ccr gjson.Result
				cr.Get("and").ForEach(
					func(_, v gjson.Result) bool {
						found := false
						for ik := range keys {
							if v.Get(keys[ik]).String() == keyValues[ik] {
								found = true
								continue
							}
							found = false
							break
						}
						if found {
							ccr = v
							return false
						}
						return true
					},
				)
				if value := ccr.Get("address"); value.Exists() && !data.MofrrCloneJoins[i].To[ci].And[cci].BackupAddress.IsNull() {
					data.MofrrCloneJoins[i].To[ci].And[cci].BackupAddress = types.StringValue(value.String())
				} else {
					data.MofrrCloneJoins[i].To[ci].And[cci].BackupAddress = types.StringNull()
				}
				for ccci := range data.MofrrCloneJoins[i].To[ci].And[cci].Masklen {
					keys := [...]string{"mask-length"}
					keyValues := [...]string{strconv.FormatInt(data.MofrrCloneJoins[i].To[ci].And[cci].Masklen[ccci].MaskLength.ValueInt64(), 10)}

					var cccr gjson.Result
					ccr.Get("").ForEach(
						func(_, v gjson.Result) bool {
							found := false
							for ik := range keys {
								if v.Get(keys[ik]).String() == keyValues[ik] {
									found = true
									continue
								}
								found = false
								break
							}
							if found {
								cccr = v
								return false
							}
							return true
						},
					)
					if value := cccr.Get(""); value.Exists() && !data.MofrrCloneJoins[i].To[ci].And[cci].Masklen[ccci].MaskLength.IsNull() {
						data.MofrrCloneJoins[i].To[ci].And[cci].Masklen[ccci].MaskLength = types.Int64Value(value.Int())
					} else {
						data.MofrrCloneJoins[i].To[ci].And[cci].Masklen[ccci].MaskLength = types.Int64Null()
					}
				}
			}
		}
	}
	for i := range data.MofrrCloneSources {
		keys := [...]string{"address"}
		keyValues := [...]string{data.MofrrCloneSources[i].SourceAddress.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "mofrr.clone.sources.source").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("address"); value.Exists() && !data.MofrrCloneSources[i].SourceAddress.IsNull() {
			data.MofrrCloneSources[i].SourceAddress = types.StringValue(value.String())
		} else {
			data.MofrrCloneSources[i].SourceAddress = types.StringNull()
		}
		for ci := range data.MofrrCloneSources[i].To {
			keys := [...]string{"address"}
			keyValues := [...]string{data.MofrrCloneSources[i].To[ci].PrimaryAddress.ValueString()}

			var cr gjson.Result
			r.Get("to").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("address"); value.Exists() && !data.MofrrCloneSources[i].To[ci].PrimaryAddress.IsNull() {
				data.MofrrCloneSources[i].To[ci].PrimaryAddress = types.StringValue(value.String())
			} else {
				data.MofrrCloneSources[i].To[ci].PrimaryAddress = types.StringNull()
			}
			for cci := range data.MofrrCloneSources[i].To[ci].And {
				keys := [...]string{"address"}
				keyValues := [...]string{data.MofrrCloneSources[i].To[ci].And[cci].BackupAddress.ValueString()}

				var ccr gjson.Result
				cr.Get("and").ForEach(
					func(_, v gjson.Result) bool {
						found := false
						for ik := range keys {
							if v.Get(keys[ik]).String() == keyValues[ik] {
								found = true
								continue
							}
							found = false
							break
						}
						if found {
							ccr = v
							return false
						}
						return true
					},
				)
				if value := ccr.Get("address"); value.Exists() && !data.MofrrCloneSources[i].To[ci].And[cci].BackupAddress.IsNull() {
					data.MofrrCloneSources[i].To[ci].And[cci].BackupAddress = types.StringValue(value.String())
				} else {
					data.MofrrCloneSources[i].To[ci].And[cci].BackupAddress = types.StringNull()
				}
				for ccci := range data.MofrrCloneSources[i].To[ci].And[cci].Masklen {
					keys := [...]string{"mask-length"}
					keyValues := [...]string{strconv.FormatInt(data.MofrrCloneSources[i].To[ci].And[cci].Masklen[ccci].MaskLength.ValueInt64(), 10)}

					var cccr gjson.Result
					ccr.Get("").ForEach(
						func(_, v gjson.Result) bool {
							found := false
							for ik := range keys {
								if v.Get(keys[ik]).String() == keyValues[ik] {
									found = true
									continue
								}
								found = false
								break
							}
							if found {
								cccr = v
								return false
							}
							return true
						},
					)
					if value := cccr.Get(""); value.Exists() && !data.MofrrCloneSources[i].To[ci].And[cci].Masklen[ccci].MaskLength.IsNull() {
						data.MofrrCloneSources[i].To[ci].And[cci].Masklen[ccci].MaskLength = types.Int64Value(value.Int())
					} else {
						data.MofrrCloneSources[i].To[ci].And[cci].Masklen[ccci].MaskLength = types.Int64Null()
					}
				}
			}
		}
	}
	for i := range data.SrP2mpPolicies {
		keys := [...]string{"sr-p2mp-policy-id"}
		keyValues := [...]string{data.SrP2mpPolicies[i].PolicyName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "sr-p2mp-policies.sr-p2mp-policy").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("sr-p2mp-policy-id"); value.Exists() && !data.SrP2mpPolicies[i].PolicyName.IsNull() {
			data.SrP2mpPolicies[i].PolicyName = types.StringValue(value.String())
		} else {
			data.SrP2mpPolicies[i].PolicyName = types.StringNull()
		}
		for ci := range data.SrP2mpPolicies[i].StaticGroups {
			keys := [...]string{"group-address"}
			keyValues := [...]string{data.SrP2mpPolicies[i].StaticGroups[ci].GroupAddress.ValueString()}

			var cr gjson.Result
			r.Get("static-group.group-address").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("group-address"); value.Exists() && !data.SrP2mpPolicies[i].StaticGroups[ci].GroupAddress.IsNull() {
				data.SrP2mpPolicies[i].StaticGroups[ci].GroupAddress = types.StringValue(value.String())
			} else {
				data.SrP2mpPolicies[i].StaticGroups[ci].GroupAddress = types.StringNull()
			}
			if value := cr.Get("group-address-only"); value.Exists() {
				// For presence-based booleans: if state has explicit false, preserve it
				if !data.SrP2mpPolicies[i].StaticGroups[ci].GroupAddressOnly.IsNull() && !data.SrP2mpPolicies[i].StaticGroups[ci].GroupAddressOnly.ValueBool() {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupAddressOnly = types.BoolValue(false)
				} else if !data.SrP2mpPolicies[i].StaticGroups[ci].GroupAddressOnly.IsNull() {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupAddressOnly = types.BoolValue(true)
				}
			} else {
				// Element doesn't exist on device
				if data.SrP2mpPolicies[i].StaticGroups[ci].GroupAddressOnly.IsNull() {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupAddressOnly = types.BoolNull()
				} else {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupAddressOnly = types.BoolValue(false)
				}
			}
			for cci := range data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasks {
				keys := [...]string{"group-mask-address"}
				keyValues := [...]string{data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasks[cci].GroupIncMask.ValueString()}

				var ccr gjson.Result
				cr.Get("group-address-inc-mask").ForEach(
					func(_, v gjson.Result) bool {
						found := false
						for ik := range keys {
							if v.Get(keys[ik]).String() == keyValues[ik] {
								found = true
								continue
							}
							found = false
							break
						}
						if found {
							ccr = v
							return false
						}
						return true
					},
				)
				if value := ccr.Get("group-mask-address"); value.Exists() && !data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasks[cci].GroupIncMask.IsNull() {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasks[cci].GroupIncMask = types.StringValue(value.String())
				} else {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasks[cci].GroupIncMask = types.StringNull()
				}
				if value := ccr.Get("group-address-count"); value.Exists() && !data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasks[cci].GroupCount.IsNull() {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasks[cci].GroupCount = types.Int64Value(value.Int())
				} else {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasks[cci].GroupCount = types.Int64Null()
				}
			}
			for cci := range data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses {
				keys := [...]string{"group-mask-address", "source-address"}
				keyValues := [...]string{data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses[cci].GroupIncMask.ValueString(), data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses[cci].SourceIp.ValueString()}

				var ccr gjson.Result
				cr.Get("group-mask-address-source-address-inc-mask").ForEach(
					func(_, v gjson.Result) bool {
						found := false
						for ik := range keys {
							if v.Get(keys[ik]).String() == keyValues[ik] {
								found = true
								continue
							}
							found = false
							break
						}
						if found {
							ccr = v
							return false
						}
						return true
					},
				)
				if value := ccr.Get("group-mask-address"); value.Exists() && !data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses[cci].GroupIncMask.IsNull() {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses[cci].GroupIncMask = types.StringValue(value.String())
				} else {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses[cci].GroupIncMask = types.StringNull()
				}
				if value := ccr.Get("source-address"); value.Exists() && !data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses[cci].SourceIp.IsNull() {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses[cci].SourceIp = types.StringValue(value.String())
				} else {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses[cci].SourceIp = types.StringNull()
				}
				if value := ccr.Get("group-address-count"); value.Exists() && !data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses[cci].GroupCount.IsNull() {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses[cci].GroupCount = types.Int64Value(value.Int())
				} else {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses[cci].GroupCount = types.Int64Null()
				}
			}
			for cci := range data.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks {
				keys := [...]string{"source-address", "source-mask-address"}
				keyValues := [...]string{data.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks[cci].SourceIp.ValueString(), data.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks[cci].SourceIncMask.ValueString()}

				var ccr gjson.Result
				cr.Get("source-address-source-mask-address-inc-mask").ForEach(
					func(_, v gjson.Result) bool {
						found := false
						for ik := range keys {
							if v.Get(keys[ik]).String() == keyValues[ik] {
								found = true
								continue
							}
							found = false
							break
						}
						if found {
							ccr = v
							return false
						}
						return true
					},
				)
				if value := ccr.Get("source-address"); value.Exists() && !data.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks[cci].SourceIp.IsNull() {
					data.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks[cci].SourceIp = types.StringValue(value.String())
				} else {
					data.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks[cci].SourceIp = types.StringNull()
				}
				if value := ccr.Get("source-mask-address"); value.Exists() && !data.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks[cci].SourceIncMask.IsNull() {
					data.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks[cci].SourceIncMask = types.StringValue(value.String())
				} else {
					data.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks[cci].SourceIncMask = types.StringNull()
				}
				if value := ccr.Get("source-address-count"); value.Exists() && !data.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks[cci].SourceCount.IsNull() {
					data.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks[cci].SourceCount = types.Int64Value(value.Int())
				} else {
					data.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks[cci].SourceCount = types.Int64Null()
				}
			}
			for cci := range data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks {
				keys := [...]string{"group-mask-address", "source-address", "source-mask-address"}
				keyValues := [...]string{data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].GroupIncMask.ValueString(), data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].SourceIp.ValueString(), data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].SourceIncMask.ValueString()}

				var ccr gjson.Result
				cr.Get("group-mask-address-source-address-source-mask-address-inc-mask").ForEach(
					func(_, v gjson.Result) bool {
						found := false
						for ik := range keys {
							if v.Get(keys[ik]).String() == keyValues[ik] {
								found = true
								continue
							}
							found = false
							break
						}
						if found {
							ccr = v
							return false
						}
						return true
					},
				)
				if value := ccr.Get("group-mask-address"); value.Exists() && !data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].GroupIncMask.IsNull() {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].GroupIncMask = types.StringValue(value.String())
				} else {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].GroupIncMask = types.StringNull()
				}
				if value := ccr.Get("source-address"); value.Exists() && !data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].SourceIp.IsNull() {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].SourceIp = types.StringValue(value.String())
				} else {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].SourceIp = types.StringNull()
				}
				if value := ccr.Get("source-mask-address"); value.Exists() && !data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].SourceIncMask.IsNull() {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].SourceIncMask = types.StringValue(value.String())
				} else {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].SourceIncMask = types.StringNull()
				}
				if value := ccr.Get("group-address-count"); value.Exists() && !data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].GroupCount.IsNull() {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].GroupCount = types.Int64Value(value.Int())
				} else {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].GroupCount = types.Int64Null()
				}
				if value := ccr.Get("source-address-count"); value.Exists() && !data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].SourceCount.IsNull() {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].SourceCount = types.Int64Value(value.Int())
				} else {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].SourceCount = types.Int64Null()
				}
			}
		}
	}
	for i := range data.Interfaces {
		keys := [...]string{"interface-name"}
		keyValues := [...]string{data.Interfaces[i].InterfaceName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "interfaces.interface").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("interface-name"); value.Exists() && !data.Interfaces[i].InterfaceName.IsNull() {
			data.Interfaces[i].InterfaceName = types.StringValue(value.String())
		} else {
			data.Interfaces[i].InterfaceName = types.StringNull()
		}
		if value := r.Get("enable"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Interfaces[i].Enable.IsNull() && !data.Interfaces[i].Enable.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Interfaces[i].Enable = types.BoolValue(false)
			} else if !data.Interfaces[i].Enable.IsNull() {
				data.Interfaces[i].Enable = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Interfaces[i].Enable.IsNull() {
				data.Interfaces[i].Enable = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Interfaces[i].Enable = types.BoolValue(false)
			}
		}
		if value := r.Get("disable"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Interfaces[i].Disable.IsNull() && !data.Interfaces[i].Disable.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Interfaces[i].Disable = types.BoolValue(false)
			} else if !data.Interfaces[i].Disable.IsNull() {
				data.Interfaces[i].Disable = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Interfaces[i].Disable.IsNull() {
				data.Interfaces[i].Disable = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Interfaces[i].Disable = types.BoolValue(false)
			}
		}
		if value := r.Get("dr-priority"); value.Exists() && !data.Interfaces[i].DrPriority.IsNull() {
			data.Interfaces[i].DrPriority = types.Int64Value(value.Int())
		} else {
			data.Interfaces[i].DrPriority = types.Int64Null()
		}
		if value := r.Get("hello-interval"); value.Exists() && !data.Interfaces[i].HelloInterval.IsNull() {
			data.Interfaces[i].HelloInterval = types.Int64Value(value.Int())
		} else {
			data.Interfaces[i].HelloInterval = types.Int64Null()
		}
		if value := r.Get("join-prune-interval"); value.Exists() && !data.Interfaces[i].JoinPruneInterval.IsNull() {
			data.Interfaces[i].JoinPruneInterval = types.Int64Value(value.Int())
		} else {
			data.Interfaces[i].JoinPruneInterval = types.Int64Null()
		}
		if value := r.Get("join-prune-mtu"); value.Exists() && !data.Interfaces[i].JoinPruneMtu.IsNull() {
			data.Interfaces[i].JoinPruneMtu = types.Int64Value(value.Int())
		} else {
			data.Interfaces[i].JoinPruneMtu = types.Int64Null()
		}
		if value := r.Get("propagation-delay"); value.Exists() && !data.Interfaces[i].PropagationDelay.IsNull() {
			data.Interfaces[i].PropagationDelay = types.Int64Value(value.Int())
		} else {
			data.Interfaces[i].PropagationDelay = types.Int64Null()
		}
		if value := r.Get("override-interval"); value.Exists() && !data.Interfaces[i].OverrideInterval.IsNull() {
			data.Interfaces[i].OverrideInterval = types.Int64Value(value.Int())
		} else {
			data.Interfaces[i].OverrideInterval = types.Int64Null()
		}
		if value := r.Get("neighbor-filter"); value.Exists() && !data.Interfaces[i].NeighborFilter.IsNull() {
			data.Interfaces[i].NeighborFilter = types.StringValue(value.String())
		} else {
			data.Interfaces[i].NeighborFilter = types.StringNull()
		}
		if value := r.Get("maximum.route-interfaces.maximum-route-interfaces"); value.Exists() && !data.Interfaces[i].MaximumRouteInterfaces.IsNull() {
			data.Interfaces[i].MaximumRouteInterfaces = types.Int64Value(value.Int())
		} else {
			data.Interfaces[i].MaximumRouteInterfaces = types.Int64Null()
		}
		if value := r.Get("maximum.route-interfaces.threshold"); value.Exists() && !data.Interfaces[i].MaximumRouteInterfacesThreshold.IsNull() {
			data.Interfaces[i].MaximumRouteInterfacesThreshold = types.Int64Value(value.Int())
		} else {
			data.Interfaces[i].MaximumRouteInterfacesThreshold = types.Int64Null()
		}
		if value := r.Get("maximum.route-interfaces.access-list"); value.Exists() && !data.Interfaces[i].MaximumRouteInterfacesAccessList.IsNull() {
			data.Interfaces[i].MaximumRouteInterfacesAccessList = types.StringValue(value.String())
		} else {
			data.Interfaces[i].MaximumRouteInterfacesAccessList = types.StringNull()
		}
		if value := r.Get("bfd.multiplier"); value.Exists() && !data.Interfaces[i].BfdMultiplier.IsNull() {
			data.Interfaces[i].BfdMultiplier = types.Int64Value(value.Int())
		} else {
			data.Interfaces[i].BfdMultiplier = types.Int64Null()
		}
		if value := r.Get("bfd.minimum-interval"); value.Exists() && !data.Interfaces[i].BfdMinimumInterval.IsNull() {
			data.Interfaces[i].BfdMinimumInterval = types.Int64Value(value.Int())
		} else {
			data.Interfaces[i].BfdMinimumInterval = types.Int64Null()
		}
		if value := r.Get("bfd.fast-detect"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Interfaces[i].BfdFastDetect.IsNull() && !data.Interfaces[i].BfdFastDetect.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Interfaces[i].BfdFastDetect = types.BoolValue(false)
			} else if !data.Interfaces[i].BfdFastDetect.IsNull() {
				data.Interfaces[i].BfdFastDetect = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Interfaces[i].BfdFastDetect.IsNull() {
				data.Interfaces[i].BfdFastDetect = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Interfaces[i].BfdFastDetect = types.BoolValue(false)
			}
		}
		if value := r.Get("bsr-border"); value.Exists() {
			// For presence-based booleans: if state has explicit false, preserve it
			// Otherwise set to true since element exists on device
			if !data.Interfaces[i].BsrBorder.IsNull() && !data.Interfaces[i].BsrBorder.ValueBool() {
				// Keep false value from state even though element exists on device
				data.Interfaces[i].BsrBorder = types.BoolValue(false)
			} else if !data.Interfaces[i].BsrBorder.IsNull() {
				data.Interfaces[i].BsrBorder = types.BoolValue(true)
			}
		} else {
			// Element doesn't exist on device
			if data.Interfaces[i].BsrBorder.IsNull() {
				data.Interfaces[i].BsrBorder = types.BoolNull()
			} else {
				// Preserve false value from state when element doesn't exist
				data.Interfaces[i].BsrBorder = types.BoolValue(false)
			}
		}
	}
}

// End of section. //template:end updateFromBody
// Section below is generated&owned by "gen/generator.go". //template:begin toBodyXML

func (data RouterPIMIPv4) toBodyXML(ctx context.Context) string {
	body := netconf.Body{}
	if len(data.RpAddresses) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.RpAddresses {
			cBody := netconf.Body{}
			if !item.Address.IsNull() && !item.Address.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "address", item.Address.ValueString())
			}
			if !item.AccessList.IsNull() && !item.AccessList.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "access-list", item.AccessList.ValueString())
			}
			if !item.Override.IsNull() && !item.Override.IsUnknown() {
				if item.Override.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "override", "")
				}
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"rp-addresses/rp-address", cBody.Res())
		}
	}
	if len(data.RpAddressesBidir) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.RpAddressesBidir {
			cBody := netconf.Body{}
			if !item.Address.IsNull() && !item.Address.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "address", item.Address.ValueString())
			}
			if !item.AccessList.IsNull() && !item.AccessList.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "access-list", item.AccessList.ValueString())
			}
			if !item.Override.IsNull() && !item.Override.IsUnknown() {
				if item.Override.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "override", "")
				}
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"rp-addresses/bidir/rp-address", cBody.Res())
		}
	}
	if !data.RpStaticDeny.IsNull() && !data.RpStaticDeny.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/rp-static-deny", data.RpStaticDeny.ValueString())
	}
	if !data.AcceptRegister.IsNull() && !data.AcceptRegister.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/accept-register", data.AcceptRegister.ValueString())
	}
	if !data.SuppressDataRegisters.IsNull() && !data.SuppressDataRegisters.IsUnknown() {
		if data.SuppressDataRegisters.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/suppress-data-registers", "")
		}
	}
	if !data.RegisterSource.IsNull() && !data.RegisterSource.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/register-source", data.RegisterSource.ValueString())
	}
	if !data.SuppressRpfChangePrunes.IsNull() && !data.SuppressRpfChangePrunes.IsUnknown() {
		if data.SuppressRpfChangePrunes.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/suppress-rpf-change-prunes", "")
		}
	}
	if !data.NeighborFilter.IsNull() && !data.NeighborFilter.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/neighbor-filter", data.NeighborFilter.ValueString())
	}
	if !data.ConvergenceRpfConflictJoinDelay.IsNull() && !data.ConvergenceRpfConflictJoinDelay.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/convergence/rpf-conflict-join-delay", strconv.FormatInt(data.ConvergenceRpfConflictJoinDelay.ValueInt64(), 10))
	}
	if !data.ConvergenceLinkDownPruneDelay.IsNull() && !data.ConvergenceLinkDownPruneDelay.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/convergence/link-down-prune-delay", strconv.FormatInt(data.ConvergenceLinkDownPruneDelay.ValueInt64(), 10))
	}
	if !data.SptThresholdInfinity.IsNull() && !data.SptThresholdInfinity.IsUnknown() {
		if data.SptThresholdInfinity.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/spt-threshold/infinity", "")
		}
	}
	if !data.SptThresholdInfinityGroupList.IsNull() && !data.SptThresholdInfinityGroupList.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/spt-threshold/infinity/group-list", data.SptThresholdInfinityGroupList.ValueString())
	}
	if !data.OldRegisterChecksum.IsNull() && !data.OldRegisterChecksum.IsUnknown() {
		if data.OldRegisterChecksum.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/old-register-checksum", "")
		}
	}
	if !data.NsfLifetime.IsNull() && !data.NsfLifetime.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/nsf/lifetime", strconv.FormatInt(data.NsfLifetime.ValueInt64(), 10))
	}
	if !data.NeighborCheckOnSend.IsNull() && !data.NeighborCheckOnSend.IsUnknown() {
		if data.NeighborCheckOnSend.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/neighbor-check-on-send/enable", "")
		}
	}
	if !data.NeighborCheckOnRecv.IsNull() && !data.NeighborCheckOnRecv.IsUnknown() {
		if data.NeighborCheckOnRecv.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/neighbor-check-on-recv/enable", "")
		}
	}
	if !data.HelloInterval.IsNull() && !data.HelloInterval.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/hello-interval", strconv.FormatInt(data.HelloInterval.ValueInt64(), 10))
	}
	if !data.MdtHelloInterval.IsNull() && !data.MdtHelloInterval.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/mdt-hello-interval", strconv.FormatInt(data.MdtHelloInterval.ValueInt64(), 10))
	}
	if !data.DrPriority.IsNull() && !data.DrPriority.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/dr-priority", strconv.FormatInt(data.DrPriority.ValueInt64(), 10))
	}
	if !data.JoinPruneInterval.IsNull() && !data.JoinPruneInterval.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/join-prune-interval", strconv.FormatInt(data.JoinPruneInterval.ValueInt64(), 10))
	}
	if !data.JoinPruneMtu.IsNull() && !data.JoinPruneMtu.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/join-prune-mtu", strconv.FormatInt(data.JoinPruneMtu.ValueInt64(), 10))
	}
	if !data.PropagationDelay.IsNull() && !data.PropagationDelay.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/propagation-delay", strconv.FormatInt(data.PropagationDelay.ValueInt64(), 10))
	}
	if !data.OverrideInterval.IsNull() && !data.OverrideInterval.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/override-interval", strconv.FormatInt(data.OverrideInterval.ValueInt64(), 10))
	}
	if !data.GlobalMaximumRoutes.IsNull() && !data.GlobalMaximumRoutes.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/global/maximum/routes/maximum-routes", strconv.FormatInt(data.GlobalMaximumRoutes.ValueInt64(), 10))
	}
	if !data.GlobalMaximumRoutesThreshold.IsNull() && !data.GlobalMaximumRoutesThreshold.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/global/maximum/routes/threshold", strconv.FormatInt(data.GlobalMaximumRoutesThreshold.ValueInt64(), 10))
	}
	if !data.GlobalMaximumRouteInterfaces.IsNull() && !data.GlobalMaximumRouteInterfaces.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/global/maximum/route-interfaces/maximum-route-interfaces", strconv.FormatInt(data.GlobalMaximumRouteInterfaces.ValueInt64(), 10))
	}
	if !data.GlobalMaximumRouteInterfacesThreshold.IsNull() && !data.GlobalMaximumRouteInterfacesThreshold.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/global/maximum/route-interfaces/threshold", strconv.FormatInt(data.GlobalMaximumRouteInterfacesThreshold.ValueInt64(), 10))
	}
	if !data.GlobalMaximumRegisterStates.IsNull() && !data.GlobalMaximumRegisterStates.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/global/maximum/register-states/maximum-register-states", strconv.FormatInt(data.GlobalMaximumRegisterStates.ValueInt64(), 10))
	}
	if !data.GlobalMaximumRegisterStatesThreshold.IsNull() && !data.GlobalMaximumRegisterStatesThreshold.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/global/maximum/register-states/threshold", strconv.FormatInt(data.GlobalMaximumRegisterStatesThreshold.ValueInt64(), 10))
	}
	if !data.GlobalMaximumPacketQueueHighPriority.IsNull() && !data.GlobalMaximumPacketQueueHighPriority.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/global/maximum/packet-queue/high-priority", strconv.FormatInt(data.GlobalMaximumPacketQueueHighPriority.ValueInt64(), 10))
	}
	if !data.GlobalMaximumPacketQueueLowPriority.IsNull() && !data.GlobalMaximumPacketQueueLowPriority.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/global/maximum/packet-queue/low-priority", strconv.FormatInt(data.GlobalMaximumPacketQueueLowPriority.ValueInt64(), 10))
	}
	if !data.GlobalMaximumGroupMappingsBsr.IsNull() && !data.GlobalMaximumGroupMappingsBsr.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/global/maximum/group-mappings/bsr/maximum-bsr", strconv.FormatInt(data.GlobalMaximumGroupMappingsBsr.ValueInt64(), 10))
	}
	if !data.GlobalMaximumGroupMappingsBsrThreshold.IsNull() && !data.GlobalMaximumGroupMappingsBsrThreshold.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/global/maximum/group-mappings/bsr/threshold", strconv.FormatInt(data.GlobalMaximumGroupMappingsBsrThreshold.ValueInt64(), 10))
	}
	if !data.GlobalMaximumGroupMappingsAutorp.IsNull() && !data.GlobalMaximumGroupMappingsAutorp.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/global/maximum/group-mappings/autorp/maximum-autorp", strconv.FormatInt(data.GlobalMaximumGroupMappingsAutorp.ValueInt64(), 10))
	}
	if !data.GlobalMaximumGroupMappingsAutorpThreshold.IsNull() && !data.GlobalMaximumGroupMappingsAutorpThreshold.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/global/maximum/group-mappings/autorp/threshold", strconv.FormatInt(data.GlobalMaximumGroupMappingsAutorpThreshold.ValueInt64(), 10))
	}
	if !data.GlobalMaximumBsrCrpCacheMaximum.IsNull() && !data.GlobalMaximumBsrCrpCacheMaximum.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/global/maximum/bsr/crp-cache/maximum-crp-cache", strconv.FormatInt(data.GlobalMaximumBsrCrpCacheMaximum.ValueInt64(), 10))
	}
	if !data.GlobalMaximumBsrCrpCacheThreshold.IsNull() && !data.GlobalMaximumBsrCrpCacheThreshold.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/global/maximum/bsr/crp-cache/threshold", strconv.FormatInt(data.GlobalMaximumBsrCrpCacheThreshold.ValueInt64(), 10))
	}
	if !data.MaximumRoutes.IsNull() && !data.MaximumRoutes.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/maximum/routes/maximum-routes", strconv.FormatInt(data.MaximumRoutes.ValueInt64(), 10))
	}
	if !data.MaximumRoutesThreshold.IsNull() && !data.MaximumRoutesThreshold.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/maximum/routes/threshold", strconv.FormatInt(data.MaximumRoutesThreshold.ValueInt64(), 10))
	}
	if !data.MaximumRouteInterfaces.IsNull() && !data.MaximumRouteInterfaces.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/maximum/route-interfaces/maximum-route-interfaces", strconv.FormatInt(data.MaximumRouteInterfaces.ValueInt64(), 10))
	}
	if !data.MaximumRouteInterfacesThreshold.IsNull() && !data.MaximumRouteInterfacesThreshold.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/maximum/route-interfaces/threshold", strconv.FormatInt(data.MaximumRouteInterfacesThreshold.ValueInt64(), 10))
	}
	if !data.MaximumRegisterStates.IsNull() && !data.MaximumRegisterStates.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/maximum/register-states/maximum-register-states", strconv.FormatInt(data.MaximumRegisterStates.ValueInt64(), 10))
	}
	if !data.MaximumRegisterStatesThreshold.IsNull() && !data.MaximumRegisterStatesThreshold.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/maximum/register-states/threshold", strconv.FormatInt(data.MaximumRegisterStatesThreshold.ValueInt64(), 10))
	}
	if !data.MaximumGroupMappingsBsr.IsNull() && !data.MaximumGroupMappingsBsr.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/maximum/group-mappings/bsr/maximum-bsr", strconv.FormatInt(data.MaximumGroupMappingsBsr.ValueInt64(), 10))
	}
	if !data.MaximumGroupMappingsBsrThreshold.IsNull() && !data.MaximumGroupMappingsBsrThreshold.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/maximum/group-mappings/bsr/threshold", strconv.FormatInt(data.MaximumGroupMappingsBsrThreshold.ValueInt64(), 10))
	}
	if !data.MaximumGroupMappingsAutorp.IsNull() && !data.MaximumGroupMappingsAutorp.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/maximum/group-mappings/autorp/maximum-autorp", strconv.FormatInt(data.MaximumGroupMappingsAutorp.ValueInt64(), 10))
	}
	if !data.MaximumGroupMappingsAutorpThreshold.IsNull() && !data.MaximumGroupMappingsAutorpThreshold.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/maximum/group-mappings/autorp/threshold", strconv.FormatInt(data.MaximumGroupMappingsAutorpThreshold.ValueInt64(), 10))
	}
	if !data.MaximumBsrCrpCacheMaximum.IsNull() && !data.MaximumBsrCrpCacheMaximum.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/maximum/bsr/crp-cache/maximum-crp-cache", strconv.FormatInt(data.MaximumBsrCrpCacheMaximum.ValueInt64(), 10))
	}
	if !data.MaximumBsrCrpCacheThreshold.IsNull() && !data.MaximumBsrCrpCacheThreshold.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/maximum/bsr/crp-cache/threshold", strconv.FormatInt(data.MaximumBsrCrpCacheThreshold.ValueInt64(), 10))
	}
	if !data.LogNeighborChanges.IsNull() && !data.LogNeighborChanges.IsUnknown() {
		if data.LogNeighborChanges.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/log/neighbor/changes", "")
		}
	}
	if !data.RpfVectorAllowEbgp.IsNull() && !data.RpfVectorAllowEbgp.IsUnknown() {
		if data.RpfVectorAllowEbgp.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/rpf-vector/allow-ebgp", "")
		}
	}
	if !data.RpfVectorDisableIbgp.IsNull() && !data.RpfVectorDisableIbgp.IsUnknown() {
		if data.RpfVectorDisableIbgp.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/rpf-vector/disable-ibgp", "")
		}
	}
	if !data.RpfVectorStandardEncoding.IsNull() && !data.RpfVectorStandardEncoding.IsUnknown() {
		if data.RpfVectorStandardEncoding.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/rpf-vector/use-standard-encoding", "")
		}
	}
	if len(data.RpfVectorInjects) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.RpfVectorInjects {
			cBody := netconf.Body{}
			if !item.SourceAddress.IsNull() && !item.SourceAddress.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "source-address", item.SourceAddress.ValueString())
			}
			if !item.SourceMask.IsNull() && !item.SourceMask.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "masklen", strconv.FormatInt(item.SourceMask.ValueInt64(), 10))
			}
			if !item.RpfVectors.IsNull() && !item.RpfVectors.IsUnknown() {
				var values []string
				item.RpfVectors.ElementsAs(ctx, &values, false)
				for _, v := range values {
					cBody = helpers.AppendFromXPath(cBody, "rpf-vector", v)
				}
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"rpf-vector-injects/inject", cBody.Res())
		}
	}
	if len(data.ExplicitRpfVectorInjects) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.ExplicitRpfVectorInjects {
			cBody := netconf.Body{}
			if !item.SourceAddress.IsNull() && !item.SourceAddress.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "source-address", item.SourceAddress.ValueString())
			}
			if !item.SourceMask.IsNull() && !item.SourceMask.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "masklen", strconv.FormatInt(item.SourceMask.ValueInt64(), 10))
			}
			if !item.RpfVectors.IsNull() && !item.RpfVectors.IsUnknown() {
				var values []string
				item.RpfVectors.ElementsAs(ctx, &values, false)
				for _, v := range values {
					cBody = helpers.AppendFromXPath(cBody, "rpf-vector", v)
				}
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"explicit-rpf-vector/injects/inject", cBody.Res())
		}
	}
	if !data.RpfTopologyRoutePolicy.IsNull() && !data.RpfTopologyRoutePolicy.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/rpf/topology/route-policy", data.RpfTopologyRoutePolicy.ValueString())
	}
	if !data.MdtNeighborFilter.IsNull() && !data.MdtNeighborFilter.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/mdt/neighbor-filter", data.MdtNeighborFilter.ValueString())
	}
	if !data.MdtDataSwitchoverInterval.IsNull() && !data.MdtDataSwitchoverInterval.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/mdt/data/switchover-interval", strconv.FormatInt(data.MdtDataSwitchoverInterval.ValueInt64(), 10))
	}
	if !data.MdtDataAnnounceInterval.IsNull() && !data.MdtDataAnnounceInterval.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/mdt/data/announce-interval", strconv.FormatInt(data.MdtDataAnnounceInterval.ValueInt64(), 10))
	}
	if !data.MdtCMulticastType.IsNull() && !data.MdtCMulticastType.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/mdt/c-multicast-routing/type", data.MdtCMulticastType.ValueString())
	}
	if !data.MdtCMulticastAnnouncePimJoinTlv.IsNull() && !data.MdtCMulticastAnnouncePimJoinTlv.IsUnknown() {
		if data.MdtCMulticastAnnouncePimJoinTlv.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/mdt/c-multicast-routing/announce-pim-join-tlv", "")
		}
	}
	if !data.MdtCMulticastSharedTreePrune.IsNull() && !data.MdtCMulticastSharedTreePrune.IsUnknown() {
		if data.MdtCMulticastSharedTreePrune.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/mdt/c-multicast-routing/shared-tree-prune", "")
		}
	}
	if !data.MdtCMulticastSuppressSharedTreeJoin.IsNull() && !data.MdtCMulticastSuppressSharedTreeJoin.IsUnknown() {
		if data.MdtCMulticastSuppressSharedTreeJoin.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/mdt/c-multicast-routing/suppress-shared-tree-join", "")
		}
	}
	if !data.MdtCMulticastSuppressPimDataSignaling.IsNull() && !data.MdtCMulticastSuppressPimDataSignaling.IsUnknown() {
		if data.MdtCMulticastSuppressPimDataSignaling.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/mdt/c-multicast-routing/suppress-pim-data-signaling", "")
		}
	}
	if !data.MdtCMulticastHelloEnable.IsNull() && !data.MdtCMulticastHelloEnable.IsUnknown() {
		if data.MdtCMulticastHelloEnable.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/mdt/c-multicast-routing/mdt-hello/enable", "")
		}
	}
	if !data.MdtCMulticastSharedTreePruneDelay.IsNull() && !data.MdtCMulticastSharedTreePruneDelay.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/mdt/c-multicast-routing/shared-tree-prune-delay", strconv.FormatInt(data.MdtCMulticastSharedTreePruneDelay.ValueInt64(), 10))
	}
	if !data.MdtCMulticastSourceTreePruneDelay.IsNull() && !data.MdtCMulticastSourceTreePruneDelay.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/mdt/c-multicast-routing/source-tree-prune-delay", strconv.FormatInt(data.MdtCMulticastSourceTreePruneDelay.ValueInt64(), 10))
	}
	if !data.MdtCMulticastMigrationRoutePolicy.IsNull() && !data.MdtCMulticastMigrationRoutePolicy.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/mdt/c-multicast-routing/migration/route-policy", data.MdtCMulticastMigrationRoutePolicy.ValueString())
	}
	if !data.AllowRp.IsNull() && !data.AllowRp.IsUnknown() {
		if data.AllowRp.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/allow-rp", "")
		}
	}
	if !data.AllowRpList.IsNull() && !data.AllowRpList.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/allow-rp/rp-list", data.AllowRpList.ValueString())
	}
	if !data.AllowRpGroupList.IsNull() && !data.AllowRpGroupList.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/allow-rp/group-list", data.AllowRpGroupList.ValueString())
	}
	if !data.SgExpiryTimer.IsNull() && !data.SgExpiryTimer.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/sg-expiry-timer/sg-expiry-timer-value", strconv.FormatInt(data.SgExpiryTimer.ValueInt64(), 10))
	}
	if !data.SgList.IsNull() && !data.SgList.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/sg-expiry-timer/sg-list", data.SgList.ValueString())
	}
	if !data.SsmRange.IsNull() && !data.SsmRange.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/ssm/range", data.SsmRange.ValueString())
	}
	if !data.SsmDisable.IsNull() && !data.SsmDisable.IsUnknown() {
		if data.SsmDisable.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/ssm/disable", "")
		}
	}
	if !data.SsmAllowOverride.IsNull() && !data.SsmAllowOverride.IsUnknown() {
		if data.SsmAllowOverride.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/ssm/allow-override", "")
		}
	}
	if !data.RpfRedirectRoutePolicy.IsNull() && !data.RpfRedirectRoutePolicy.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/rpf-redirect/route-policy", data.RpfRedirectRoutePolicy.ValueString())
	}
	if !data.Multipath.IsNull() && !data.Multipath.IsUnknown() {
		if data.Multipath.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/multipath", "")
		}
	}
	if !data.MultipathHashSource.IsNull() && !data.MultipathHashSource.IsUnknown() {
		if data.MultipathHashSource.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/multipath/hash/source", "")
		}
	}
	if !data.MultipathHashSourceNexthop.IsNull() && !data.MultipathHashSourceNexthop.IsUnknown() {
		if data.MultipathHashSourceNexthop.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/multipath/hash/source-nexthop", "")
		}
	}
	if !data.MultipathHashSourceGroup.IsNull() && !data.MultipathHashSourceGroup.IsUnknown() {
		if data.MultipathHashSourceGroup.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/multipath/hash/source-group", "")
		}
	}
	if !data.AutoRpMappingAgentInterface.IsNull() && !data.AutoRpMappingAgentInterface.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/auto-rp/mapping-agent/interface-name", data.AutoRpMappingAgentInterface.ValueString())
	}
	if !data.AutoRpMappingAgentScope.IsNull() && !data.AutoRpMappingAgentScope.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/auto-rp/mapping-agent/scope", strconv.FormatInt(data.AutoRpMappingAgentScope.ValueInt64(), 10))
	}
	if !data.AutoRpMappingAgentInterval.IsNull() && !data.AutoRpMappingAgentInterval.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/auto-rp/mapping-agent/interval", strconv.FormatInt(data.AutoRpMappingAgentInterval.ValueInt64(), 10))
	}
	if len(data.AutoRpCandidateRps) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.AutoRpCandidateRps {
			cBody := netconf.Body{}
			if !item.InterfaceName.IsNull() && !item.InterfaceName.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "interface-name", item.InterfaceName.ValueString())
			}
			if !item.Scope.IsNull() && !item.Scope.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "scope", strconv.FormatInt(item.Scope.ValueInt64(), 10))
			}
			if !item.GroupList.IsNull() && !item.GroupList.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "group-list", item.GroupList.ValueString())
			}
			if !item.Interval.IsNull() && !item.Interval.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "interval", strconv.FormatInt(item.Interval.ValueInt64(), 10))
			}
			if !item.BidirScope.IsNull() && !item.BidirScope.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "bidir/scope", strconv.FormatInt(item.BidirScope.ValueInt64(), 10))
			}
			if !item.BidirGroupList.IsNull() && !item.BidirGroupList.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "bidir/group-list", item.BidirGroupList.ValueString())
			}
			if !item.BidirInterval.IsNull() && !item.BidirInterval.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "bidir/interval", strconv.FormatInt(item.BidirInterval.ValueInt64(), 10))
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"auto-rp/candidate-rps/candidate-rp", cBody.Res())
		}
	}
	if !data.AutoRpListenDisable.IsNull() && !data.AutoRpListenDisable.IsUnknown() {
		if data.AutoRpListenDisable.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/auto-rp/listen/disable", "")
		}
	}
	if len(data.AutoRpRelayVrfs) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.AutoRpRelayVrfs {
			cBody := netconf.Body{}
			if !item.VrfName.IsNull() && !item.VrfName.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "vrf-name", item.VrfName.ValueString())
			}
			if !item.Listen.IsNull() && !item.Listen.IsUnknown() {
				if item.Listen.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "listen", "")
				}
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"auto-rp/relay/vrfs/vrf", cBody.Res())
		}
	}
	if !data.BsrCandidateBsrAddress.IsNull() && !data.BsrCandidateBsrAddress.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/bsr/candidate-bsr/address", data.BsrCandidateBsrAddress.ValueString())
	}
	if !data.BsrCandidateBsrHashMaskLen.IsNull() && !data.BsrCandidateBsrHashMaskLen.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/bsr/candidate-bsr/hash-mask-len", strconv.FormatInt(data.BsrCandidateBsrHashMaskLen.ValueInt64(), 10))
	}
	if !data.BsrCandidateBsrPriority.IsNull() && !data.BsrCandidateBsrPriority.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/bsr/candidate-bsr/priority", strconv.FormatInt(data.BsrCandidateBsrPriority.ValueInt64(), 10))
	}
	if len(data.BsrCandidateRps) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.BsrCandidateRps {
			cBody := netconf.Body{}
			if !item.Address.IsNull() && !item.Address.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "address", item.Address.ValueString())
			}
			if !item.GroupList.IsNull() && !item.GroupList.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "group-list", item.GroupList.ValueString())
			}
			if !item.Priority.IsNull() && !item.Priority.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "priority", strconv.FormatInt(item.Priority.ValueInt64(), 10))
			}
			if !item.Interval.IsNull() && !item.Interval.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "interval", strconv.FormatInt(item.Interval.ValueInt64(), 10))
			}
			if !item.BidirGroupList.IsNull() && !item.BidirGroupList.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "bidir/group-list", item.BidirGroupList.ValueString())
			}
			if !item.BidirPriority.IsNull() && !item.BidirPriority.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "bidir/priority", strconv.FormatInt(item.BidirPriority.ValueInt64(), 10))
			}
			if !item.BidirInterval.IsNull() && !item.BidirInterval.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "bidir/interval", strconv.FormatInt(item.BidirInterval.ValueInt64(), 10))
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"bsr/candidate-rps/candidate-rp", cBody.Res())
		}
	}
	if len(data.BsrRelayVrfs) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.BsrRelayVrfs {
			cBody := netconf.Body{}
			if !item.VrfName.IsNull() && !item.VrfName.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "vrf-name", item.VrfName.ValueString())
			}
			if !item.Listen.IsNull() && !item.Listen.IsUnknown() {
				if item.Listen.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "listen", "")
				}
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"bsr/relay/vrfs/vrf", cBody.Res())
		}
	}
	if !data.Mofrr.IsNull() && !data.Mofrr.IsUnknown() {
		if data.Mofrr.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/mofrr", "")
		}
	}
	if !data.MofrrFlow.IsNull() && !data.MofrrFlow.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/mofrr/flow", data.MofrrFlow.ValueString())
	}
	if !data.MofrrRib.IsNull() && !data.MofrrRib.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/mofrr/rib", data.MofrrRib.ValueString())
	}
	if !data.MofrrProtect.IsNull() && !data.MofrrProtect.IsUnknown() {
		body = helpers.SetFromXPath(body, data.getXPath()+"/mofrr/protect", data.MofrrProtect.ValueString())
	}
	if !data.MofrrProtectLocalFaultOnly.IsNull() && !data.MofrrProtectLocalFaultOnly.IsUnknown() {
		if data.MofrrProtectLocalFaultOnly.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/mofrr/local-fault-only", "")
		}
	}
	if !data.MofrrNonRevertive.IsNull() && !data.MofrrNonRevertive.IsUnknown() {
		if data.MofrrNonRevertive.ValueBool() {
			body = helpers.SetFromXPath(body, data.getXPath()+"/mofrr/non-revertive", "")
		}
	}
	if len(data.MofrrCloneJoins) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.MofrrCloneJoins {
			cBody := netconf.Body{}
			if !item.SourceAddress.IsNull() && !item.SourceAddress.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "address", item.SourceAddress.ValueString())
			}
			if len(item.To) > 0 {
				for _, citem := range item.To {
					ccBody := netconf.Body{}
					_ = citem // Suppress unused variable warning when all attributes are IDs
					if len(citem.And) > 0 {
						for _, ccitem := range citem.And {
							cccBody := netconf.Body{}
							_ = ccitem // Suppress unused variable warning
							ccBody = helpers.AppendRawFromXPath(ccBody, "and", cccBody.Res())
						}
					}
					cBody = helpers.SetRawFromXPath(cBody, "to", ccBody.Res())
				}
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"mofrr/clone/joins/join", cBody.Res())
		}
	}
	if len(data.MofrrCloneSources) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.MofrrCloneSources {
			cBody := netconf.Body{}
			if !item.SourceAddress.IsNull() && !item.SourceAddress.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "address", item.SourceAddress.ValueString())
			}
			if len(item.To) > 0 {
				for _, citem := range item.To {
					ccBody := netconf.Body{}
					_ = citem // Suppress unused variable warning when all attributes are IDs
					if len(citem.And) > 0 {
						for _, ccitem := range citem.And {
							cccBody := netconf.Body{}
							_ = ccitem // Suppress unused variable warning
							ccBody = helpers.AppendRawFromXPath(ccBody, "and", cccBody.Res())
						}
					}
					cBody = helpers.SetRawFromXPath(cBody, "to", ccBody.Res())
				}
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"mofrr/clone/sources/source", cBody.Res())
		}
	}
	if len(data.SrP2mpPolicies) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.SrP2mpPolicies {
			cBody := netconf.Body{}
			if !item.PolicyName.IsNull() && !item.PolicyName.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "sr-p2mp-policy-id", item.PolicyName.ValueString())
			}
			if len(item.StaticGroups) > 0 {
				for _, citem := range item.StaticGroups {
					ccBody := netconf.Body{}
					_ = citem // Suppress unused variable warning when all attributes are IDs
					if !citem.GroupAddressOnly.IsNull() && !citem.GroupAddressOnly.IsUnknown() {
						if citem.GroupAddressOnly.ValueBool() {
							ccBody = helpers.SetFromXPath(ccBody, "group-address-only", "")
						}
					}
					if len(citem.GroupMasks) > 0 {
						for _, ccitem := range citem.GroupMasks {
							cccBody := netconf.Body{}
							_ = ccitem // Suppress unused variable warning
							if !ccitem.GroupCount.IsNull() && !ccitem.GroupCount.IsUnknown() {
								cccBody = helpers.SetFromXPath(cccBody, "group-address-count", strconv.FormatInt(ccitem.GroupCount.ValueInt64(), 10))
							}
							ccBody = helpers.AppendRawFromXPath(ccBody, "group-address-inc-mask", cccBody.Res())
						}
					}
					if len(citem.GroupMasksSourceAddresses) > 0 {
						for _, ccitem := range citem.GroupMasksSourceAddresses {
							cccBody := netconf.Body{}
							_ = ccitem // Suppress unused variable warning
							if !ccitem.GroupCount.IsNull() && !ccitem.GroupCount.IsUnknown() {
								cccBody = helpers.SetFromXPath(cccBody, "group-address-count", strconv.FormatInt(ccitem.GroupCount.ValueInt64(), 10))
							}
							ccBody = helpers.AppendRawFromXPath(ccBody, "group-mask-address-source-address-inc-mask", cccBody.Res())
						}
					}
					if len(citem.SourceMasks) > 0 {
						for _, ccitem := range citem.SourceMasks {
							cccBody := netconf.Body{}
							_ = ccitem // Suppress unused variable warning
							if !ccitem.SourceCount.IsNull() && !ccitem.SourceCount.IsUnknown() {
								cccBody = helpers.SetFromXPath(cccBody, "source-address-count", strconv.FormatInt(ccitem.SourceCount.ValueInt64(), 10))
							}
							ccBody = helpers.AppendRawFromXPath(ccBody, "source-address-source-mask-address-inc-mask", cccBody.Res())
						}
					}
					if len(citem.GroupMasksSourceMasks) > 0 {
						for _, ccitem := range citem.GroupMasksSourceMasks {
							cccBody := netconf.Body{}
							_ = ccitem // Suppress unused variable warning
							if !ccitem.GroupCount.IsNull() && !ccitem.GroupCount.IsUnknown() {
								cccBody = helpers.SetFromXPath(cccBody, "group-address-count", strconv.FormatInt(ccitem.GroupCount.ValueInt64(), 10))
							}
							if !ccitem.SourceCount.IsNull() && !ccitem.SourceCount.IsUnknown() {
								cccBody = helpers.SetFromXPath(cccBody, "source-address-count", strconv.FormatInt(ccitem.SourceCount.ValueInt64(), 10))
							}
							ccBody = helpers.AppendRawFromXPath(ccBody, "group-mask-address-source-address-source-mask-address-inc-mask", cccBody.Res())
						}
					}
					cBody = helpers.SetRawFromXPath(cBody, "static-group/group-address", ccBody.Res())
				}
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"sr-p2mp-policies/sr-p2mp-policy", cBody.Res())
		}
	}
	if len(data.Interfaces) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.Interfaces {
			cBody := netconf.Body{}
			if !item.InterfaceName.IsNull() && !item.InterfaceName.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "interface-name", item.InterfaceName.ValueString())
			}
			if !item.Enable.IsNull() && !item.Enable.IsUnknown() {
				if item.Enable.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "enable", "")
				}
			}
			if !item.Disable.IsNull() && !item.Disable.IsUnknown() {
				if item.Disable.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "disable", "")
				}
			}
			if !item.DrPriority.IsNull() && !item.DrPriority.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "dr-priority", strconv.FormatInt(item.DrPriority.ValueInt64(), 10))
			}
			if !item.HelloInterval.IsNull() && !item.HelloInterval.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "hello-interval", strconv.FormatInt(item.HelloInterval.ValueInt64(), 10))
			}
			if !item.JoinPruneInterval.IsNull() && !item.JoinPruneInterval.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "join-prune-interval", strconv.FormatInt(item.JoinPruneInterval.ValueInt64(), 10))
			}
			if !item.JoinPruneMtu.IsNull() && !item.JoinPruneMtu.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "join-prune-mtu", strconv.FormatInt(item.JoinPruneMtu.ValueInt64(), 10))
			}
			if !item.PropagationDelay.IsNull() && !item.PropagationDelay.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "propagation-delay", strconv.FormatInt(item.PropagationDelay.ValueInt64(), 10))
			}
			if !item.OverrideInterval.IsNull() && !item.OverrideInterval.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "override-interval", strconv.FormatInt(item.OverrideInterval.ValueInt64(), 10))
			}
			if !item.NeighborFilter.IsNull() && !item.NeighborFilter.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "neighbor-filter", item.NeighborFilter.ValueString())
			}
			if !item.MaximumRouteInterfaces.IsNull() && !item.MaximumRouteInterfaces.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "maximum/route-interfaces/maximum-route-interfaces", strconv.FormatInt(item.MaximumRouteInterfaces.ValueInt64(), 10))
			}
			if !item.MaximumRouteInterfacesThreshold.IsNull() && !item.MaximumRouteInterfacesThreshold.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "maximum/route-interfaces/threshold", strconv.FormatInt(item.MaximumRouteInterfacesThreshold.ValueInt64(), 10))
			}
			if !item.MaximumRouteInterfacesAccessList.IsNull() && !item.MaximumRouteInterfacesAccessList.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "maximum/route-interfaces/access-list", item.MaximumRouteInterfacesAccessList.ValueString())
			}
			if !item.BfdMultiplier.IsNull() && !item.BfdMultiplier.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "bfd/multiplier", strconv.FormatInt(item.BfdMultiplier.ValueInt64(), 10))
			}
			if !item.BfdMinimumInterval.IsNull() && !item.BfdMinimumInterval.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "bfd/minimum-interval", strconv.FormatInt(item.BfdMinimumInterval.ValueInt64(), 10))
			}
			if !item.BfdFastDetect.IsNull() && !item.BfdFastDetect.IsUnknown() {
				if item.BfdFastDetect.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "bfd/fast-detect", "")
				}
			}
			if !item.BsrBorder.IsNull() && !item.BsrBorder.IsUnknown() {
				if item.BsrBorder.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "bsr-border", "")
				}
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"interfaces/interface", cBody.Res())
		}
	}
	bodyString, err := body.String()
	if err != nil {
		tflog.Error(ctx, fmt.Sprintf("Error converting body to string: %s", err))
	}
	return bodyString
}

// End of section. //template:end toBodyXML
// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBodyXML

func (data *RouterPIMIPv4) updateFromBodyXML(ctx context.Context, res xmldot.Result) {
	for i := range data.RpAddresses {
		keys := [...]string{"address"}
		keyValues := [...]string{data.RpAddresses[i].Address.ValueString()}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/rp-addresses/rp-address").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "address"); value.Exists() {
			data.RpAddresses[i].Address = types.StringValue(value.String())
		} else if data.RpAddresses[i].Address.IsNull() {
			data.RpAddresses[i].Address = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "access-list"); value.Exists() {
			data.RpAddresses[i].AccessList = types.StringValue(value.String())
		} else if data.RpAddresses[i].AccessList.IsNull() {
			data.RpAddresses[i].AccessList = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "override"); value.Exists() {
			data.RpAddresses[i].Override = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.RpAddresses[i].Override.IsNull() {
				data.RpAddresses[i].Override = types.BoolNull()
			}
		}
	}
	for i := range data.RpAddressesBidir {
		keys := [...]string{"address"}
		keyValues := [...]string{data.RpAddressesBidir[i].Address.ValueString()}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/rp-addresses/bidir/rp-address").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "address"); value.Exists() {
			data.RpAddressesBidir[i].Address = types.StringValue(value.String())
		} else if data.RpAddressesBidir[i].Address.IsNull() {
			data.RpAddressesBidir[i].Address = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "access-list"); value.Exists() {
			data.RpAddressesBidir[i].AccessList = types.StringValue(value.String())
		} else if data.RpAddressesBidir[i].AccessList.IsNull() {
			data.RpAddressesBidir[i].AccessList = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "override"); value.Exists() {
			data.RpAddressesBidir[i].Override = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.RpAddressesBidir[i].Override.IsNull() {
				data.RpAddressesBidir[i].Override = types.BoolNull()
			}
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rp-static-deny"); value.Exists() {
		data.RpStaticDeny = types.StringValue(value.String())
	} else if data.RpStaticDeny.IsNull() {
		data.RpStaticDeny = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/accept-register"); value.Exists() {
		data.AcceptRegister = types.StringValue(value.String())
	} else if data.AcceptRegister.IsNull() {
		data.AcceptRegister = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/suppress-data-registers"); value.Exists() {
		data.SuppressDataRegisters = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.SuppressDataRegisters.IsNull() {
			data.SuppressDataRegisters = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/register-source"); value.Exists() {
		data.RegisterSource = types.StringValue(value.String())
	} else if data.RegisterSource.IsNull() {
		data.RegisterSource = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/suppress-rpf-change-prunes"); value.Exists() {
		data.SuppressRpfChangePrunes = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.SuppressRpfChangePrunes.IsNull() {
			data.SuppressRpfChangePrunes = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/neighbor-filter"); value.Exists() {
		data.NeighborFilter = types.StringValue(value.String())
	} else if data.NeighborFilter.IsNull() {
		data.NeighborFilter = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/convergence/rpf-conflict-join-delay"); value.Exists() {
		data.ConvergenceRpfConflictJoinDelay = types.Int64Value(value.Int())
	} else if data.ConvergenceRpfConflictJoinDelay.IsNull() {
		data.ConvergenceRpfConflictJoinDelay = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/convergence/link-down-prune-delay"); value.Exists() {
		data.ConvergenceLinkDownPruneDelay = types.Int64Value(value.Int())
	} else if data.ConvergenceLinkDownPruneDelay.IsNull() {
		data.ConvergenceLinkDownPruneDelay = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/spt-threshold/infinity"); value.Exists() {
		data.SptThresholdInfinity = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.SptThresholdInfinity.IsNull() {
			data.SptThresholdInfinity = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/spt-threshold/infinity/group-list"); value.Exists() {
		data.SptThresholdInfinityGroupList = types.StringValue(value.String())
	} else if data.SptThresholdInfinityGroupList.IsNull() {
		data.SptThresholdInfinityGroupList = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/old-register-checksum"); value.Exists() {
		data.OldRegisterChecksum = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.OldRegisterChecksum.IsNull() {
			data.OldRegisterChecksum = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/nsf/lifetime"); value.Exists() {
		data.NsfLifetime = types.Int64Value(value.Int())
	} else if data.NsfLifetime.IsNull() {
		data.NsfLifetime = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/neighbor-check-on-send/enable"); value.Exists() {
		data.NeighborCheckOnSend = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.NeighborCheckOnSend.IsNull() {
			data.NeighborCheckOnSend = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/neighbor-check-on-recv/enable"); value.Exists() {
		data.NeighborCheckOnRecv = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.NeighborCheckOnRecv.IsNull() {
			data.NeighborCheckOnRecv = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/hello-interval"); value.Exists() {
		data.HelloInterval = types.Int64Value(value.Int())
	} else if data.HelloInterval.IsNull() {
		data.HelloInterval = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt-hello-interval"); value.Exists() {
		data.MdtHelloInterval = types.Int64Value(value.Int())
	} else if data.MdtHelloInterval.IsNull() {
		data.MdtHelloInterval = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dr-priority"); value.Exists() {
		data.DrPriority = types.Int64Value(value.Int())
	} else if data.DrPriority.IsNull() {
		data.DrPriority = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/join-prune-interval"); value.Exists() {
		data.JoinPruneInterval = types.Int64Value(value.Int())
	} else if data.JoinPruneInterval.IsNull() {
		data.JoinPruneInterval = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/join-prune-mtu"); value.Exists() {
		data.JoinPruneMtu = types.Int64Value(value.Int())
	} else if data.JoinPruneMtu.IsNull() {
		data.JoinPruneMtu = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/propagation-delay"); value.Exists() {
		data.PropagationDelay = types.Int64Value(value.Int())
	} else if data.PropagationDelay.IsNull() {
		data.PropagationDelay = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/override-interval"); value.Exists() {
		data.OverrideInterval = types.Int64Value(value.Int())
	} else if data.OverrideInterval.IsNull() {
		data.OverrideInterval = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/routes/maximum-routes"); value.Exists() {
		data.GlobalMaximumRoutes = types.Int64Value(value.Int())
	} else if data.GlobalMaximumRoutes.IsNull() {
		data.GlobalMaximumRoutes = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/routes/threshold"); value.Exists() {
		data.GlobalMaximumRoutesThreshold = types.Int64Value(value.Int())
	} else if data.GlobalMaximumRoutesThreshold.IsNull() {
		data.GlobalMaximumRoutesThreshold = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/route-interfaces/maximum-route-interfaces"); value.Exists() {
		data.GlobalMaximumRouteInterfaces = types.Int64Value(value.Int())
	} else if data.GlobalMaximumRouteInterfaces.IsNull() {
		data.GlobalMaximumRouteInterfaces = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/route-interfaces/threshold"); value.Exists() {
		data.GlobalMaximumRouteInterfacesThreshold = types.Int64Value(value.Int())
	} else if data.GlobalMaximumRouteInterfacesThreshold.IsNull() {
		data.GlobalMaximumRouteInterfacesThreshold = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/register-states/maximum-register-states"); value.Exists() {
		data.GlobalMaximumRegisterStates = types.Int64Value(value.Int())
	} else if data.GlobalMaximumRegisterStates.IsNull() {
		data.GlobalMaximumRegisterStates = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/register-states/threshold"); value.Exists() {
		data.GlobalMaximumRegisterStatesThreshold = types.Int64Value(value.Int())
	} else if data.GlobalMaximumRegisterStatesThreshold.IsNull() {
		data.GlobalMaximumRegisterStatesThreshold = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/packet-queue/high-priority"); value.Exists() {
		data.GlobalMaximumPacketQueueHighPriority = types.Int64Value(value.Int())
	} else if data.GlobalMaximumPacketQueueHighPriority.IsNull() {
		data.GlobalMaximumPacketQueueHighPriority = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/packet-queue/low-priority"); value.Exists() {
		data.GlobalMaximumPacketQueueLowPriority = types.Int64Value(value.Int())
	} else if data.GlobalMaximumPacketQueueLowPriority.IsNull() {
		data.GlobalMaximumPacketQueueLowPriority = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/group-mappings/bsr/maximum-bsr"); value.Exists() {
		data.GlobalMaximumGroupMappingsBsr = types.Int64Value(value.Int())
	} else if data.GlobalMaximumGroupMappingsBsr.IsNull() {
		data.GlobalMaximumGroupMappingsBsr = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/group-mappings/bsr/threshold"); value.Exists() {
		data.GlobalMaximumGroupMappingsBsrThreshold = types.Int64Value(value.Int())
	} else if data.GlobalMaximumGroupMappingsBsrThreshold.IsNull() {
		data.GlobalMaximumGroupMappingsBsrThreshold = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/group-mappings/autorp/maximum-autorp"); value.Exists() {
		data.GlobalMaximumGroupMappingsAutorp = types.Int64Value(value.Int())
	} else if data.GlobalMaximumGroupMappingsAutorp.IsNull() {
		data.GlobalMaximumGroupMappingsAutorp = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/group-mappings/autorp/threshold"); value.Exists() {
		data.GlobalMaximumGroupMappingsAutorpThreshold = types.Int64Value(value.Int())
	} else if data.GlobalMaximumGroupMappingsAutorpThreshold.IsNull() {
		data.GlobalMaximumGroupMappingsAutorpThreshold = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/bsr/crp-cache/maximum-crp-cache"); value.Exists() {
		data.GlobalMaximumBsrCrpCacheMaximum = types.Int64Value(value.Int())
	} else if data.GlobalMaximumBsrCrpCacheMaximum.IsNull() {
		data.GlobalMaximumBsrCrpCacheMaximum = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/bsr/crp-cache/threshold"); value.Exists() {
		data.GlobalMaximumBsrCrpCacheThreshold = types.Int64Value(value.Int())
	} else if data.GlobalMaximumBsrCrpCacheThreshold.IsNull() {
		data.GlobalMaximumBsrCrpCacheThreshold = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/routes/maximum-routes"); value.Exists() {
		data.MaximumRoutes = types.Int64Value(value.Int())
	} else if data.MaximumRoutes.IsNull() {
		data.MaximumRoutes = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/routes/threshold"); value.Exists() {
		data.MaximumRoutesThreshold = types.Int64Value(value.Int())
	} else if data.MaximumRoutesThreshold.IsNull() {
		data.MaximumRoutesThreshold = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/route-interfaces/maximum-route-interfaces"); value.Exists() {
		data.MaximumRouteInterfaces = types.Int64Value(value.Int())
	} else if data.MaximumRouteInterfaces.IsNull() {
		data.MaximumRouteInterfaces = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/route-interfaces/threshold"); value.Exists() {
		data.MaximumRouteInterfacesThreshold = types.Int64Value(value.Int())
	} else if data.MaximumRouteInterfacesThreshold.IsNull() {
		data.MaximumRouteInterfacesThreshold = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/register-states/maximum-register-states"); value.Exists() {
		data.MaximumRegisterStates = types.Int64Value(value.Int())
	} else if data.MaximumRegisterStates.IsNull() {
		data.MaximumRegisterStates = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/register-states/threshold"); value.Exists() {
		data.MaximumRegisterStatesThreshold = types.Int64Value(value.Int())
	} else if data.MaximumRegisterStatesThreshold.IsNull() {
		data.MaximumRegisterStatesThreshold = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/group-mappings/bsr/maximum-bsr"); value.Exists() {
		data.MaximumGroupMappingsBsr = types.Int64Value(value.Int())
	} else if data.MaximumGroupMappingsBsr.IsNull() {
		data.MaximumGroupMappingsBsr = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/group-mappings/bsr/threshold"); value.Exists() {
		data.MaximumGroupMappingsBsrThreshold = types.Int64Value(value.Int())
	} else if data.MaximumGroupMappingsBsrThreshold.IsNull() {
		data.MaximumGroupMappingsBsrThreshold = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/group-mappings/autorp/maximum-autorp"); value.Exists() {
		data.MaximumGroupMappingsAutorp = types.Int64Value(value.Int())
	} else if data.MaximumGroupMappingsAutorp.IsNull() {
		data.MaximumGroupMappingsAutorp = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/group-mappings/autorp/threshold"); value.Exists() {
		data.MaximumGroupMappingsAutorpThreshold = types.Int64Value(value.Int())
	} else if data.MaximumGroupMappingsAutorpThreshold.IsNull() {
		data.MaximumGroupMappingsAutorpThreshold = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/bsr/crp-cache/maximum-crp-cache"); value.Exists() {
		data.MaximumBsrCrpCacheMaximum = types.Int64Value(value.Int())
	} else if data.MaximumBsrCrpCacheMaximum.IsNull() {
		data.MaximumBsrCrpCacheMaximum = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/bsr/crp-cache/threshold"); value.Exists() {
		data.MaximumBsrCrpCacheThreshold = types.Int64Value(value.Int())
	} else if data.MaximumBsrCrpCacheThreshold.IsNull() {
		data.MaximumBsrCrpCacheThreshold = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/log/neighbor/changes"); value.Exists() {
		data.LogNeighborChanges = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.LogNeighborChanges.IsNull() {
			data.LogNeighborChanges = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rpf-vector/allow-ebgp"); value.Exists() {
		data.RpfVectorAllowEbgp = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RpfVectorAllowEbgp.IsNull() {
			data.RpfVectorAllowEbgp = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rpf-vector/disable-ibgp"); value.Exists() {
		data.RpfVectorDisableIbgp = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RpfVectorDisableIbgp.IsNull() {
			data.RpfVectorDisableIbgp = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rpf-vector/use-standard-encoding"); value.Exists() {
		data.RpfVectorStandardEncoding = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.RpfVectorStandardEncoding.IsNull() {
			data.RpfVectorStandardEncoding = types.BoolNull()
		}
	}
	for i := range data.RpfVectorInjects {
		keys := [...]string{"source-address", "masklen"}
		keyValues := [...]string{data.RpfVectorInjects[i].SourceAddress.ValueString(), strconv.FormatInt(data.RpfVectorInjects[i].SourceMask.ValueInt64(), 10)}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/rpf-vector-injects/inject").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "source-address"); value.Exists() {
			data.RpfVectorInjects[i].SourceAddress = types.StringValue(value.String())
		} else if data.RpfVectorInjects[i].SourceAddress.IsNull() {
			data.RpfVectorInjects[i].SourceAddress = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "masklen"); value.Exists() {
			data.RpfVectorInjects[i].SourceMask = types.Int64Value(value.Int())
		} else if data.RpfVectorInjects[i].SourceMask.IsNull() {
			data.RpfVectorInjects[i].SourceMask = types.Int64Null()
		}
		if childElements := helpers.GetAllChildElements(r, "rpf-vector"); len(childElements) > 0 {
			data.RpfVectorInjects[i].RpfVectors = helpers.GetStringListXML(childElements)
		}
	}
	for i := range data.ExplicitRpfVectorInjects {
		keys := [...]string{"source-address", "masklen"}
		keyValues := [...]string{data.ExplicitRpfVectorInjects[i].SourceAddress.ValueString(), strconv.FormatInt(data.ExplicitRpfVectorInjects[i].SourceMask.ValueInt64(), 10)}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/explicit-rpf-vector/injects/inject").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "source-address"); value.Exists() {
			data.ExplicitRpfVectorInjects[i].SourceAddress = types.StringValue(value.String())
		} else if data.ExplicitRpfVectorInjects[i].SourceAddress.IsNull() {
			data.ExplicitRpfVectorInjects[i].SourceAddress = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "masklen"); value.Exists() {
			data.ExplicitRpfVectorInjects[i].SourceMask = types.Int64Value(value.Int())
		} else if data.ExplicitRpfVectorInjects[i].SourceMask.IsNull() {
			data.ExplicitRpfVectorInjects[i].SourceMask = types.Int64Null()
		}
		if childElements := helpers.GetAllChildElements(r, "rpf-vector"); len(childElements) > 0 {
			data.ExplicitRpfVectorInjects[i].RpfVectors = helpers.GetStringListXML(childElements)
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rpf/topology/route-policy"); value.Exists() {
		data.RpfTopologyRoutePolicy = types.StringValue(value.String())
	} else if data.RpfTopologyRoutePolicy.IsNull() {
		data.RpfTopologyRoutePolicy = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/neighbor-filter"); value.Exists() {
		data.MdtNeighborFilter = types.StringValue(value.String())
	} else if data.MdtNeighborFilter.IsNull() {
		data.MdtNeighborFilter = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/data/switchover-interval"); value.Exists() {
		data.MdtDataSwitchoverInterval = types.Int64Value(value.Int())
	} else if data.MdtDataSwitchoverInterval.IsNull() {
		data.MdtDataSwitchoverInterval = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/data/announce-interval"); value.Exists() {
		data.MdtDataAnnounceInterval = types.Int64Value(value.Int())
	} else if data.MdtDataAnnounceInterval.IsNull() {
		data.MdtDataAnnounceInterval = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/type"); value.Exists() {
		data.MdtCMulticastType = types.StringValue(value.String())
	} else if data.MdtCMulticastType.IsNull() {
		data.MdtCMulticastType = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/announce-pim-join-tlv"); value.Exists() {
		data.MdtCMulticastAnnouncePimJoinTlv = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.MdtCMulticastAnnouncePimJoinTlv.IsNull() {
			data.MdtCMulticastAnnouncePimJoinTlv = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/shared-tree-prune"); value.Exists() {
		data.MdtCMulticastSharedTreePrune = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.MdtCMulticastSharedTreePrune.IsNull() {
			data.MdtCMulticastSharedTreePrune = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/suppress-shared-tree-join"); value.Exists() {
		data.MdtCMulticastSuppressSharedTreeJoin = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.MdtCMulticastSuppressSharedTreeJoin.IsNull() {
			data.MdtCMulticastSuppressSharedTreeJoin = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/suppress-pim-data-signaling"); value.Exists() {
		data.MdtCMulticastSuppressPimDataSignaling = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.MdtCMulticastSuppressPimDataSignaling.IsNull() {
			data.MdtCMulticastSuppressPimDataSignaling = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/mdt-hello/enable"); value.Exists() {
		data.MdtCMulticastHelloEnable = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.MdtCMulticastHelloEnable.IsNull() {
			data.MdtCMulticastHelloEnable = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/shared-tree-prune-delay"); value.Exists() {
		data.MdtCMulticastSharedTreePruneDelay = types.Int64Value(value.Int())
	} else if data.MdtCMulticastSharedTreePruneDelay.IsNull() {
		data.MdtCMulticastSharedTreePruneDelay = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/source-tree-prune-delay"); value.Exists() {
		data.MdtCMulticastSourceTreePruneDelay = types.Int64Value(value.Int())
	} else if data.MdtCMulticastSourceTreePruneDelay.IsNull() {
		data.MdtCMulticastSourceTreePruneDelay = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/migration/route-policy"); value.Exists() {
		data.MdtCMulticastMigrationRoutePolicy = types.StringValue(value.String())
	} else if data.MdtCMulticastMigrationRoutePolicy.IsNull() {
		data.MdtCMulticastMigrationRoutePolicy = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/allow-rp"); value.Exists() {
		data.AllowRp = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.AllowRp.IsNull() {
			data.AllowRp = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/allow-rp/rp-list"); value.Exists() {
		data.AllowRpList = types.StringValue(value.String())
	} else if data.AllowRpList.IsNull() {
		data.AllowRpList = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/allow-rp/group-list"); value.Exists() {
		data.AllowRpGroupList = types.StringValue(value.String())
	} else if data.AllowRpGroupList.IsNull() {
		data.AllowRpGroupList = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sg-expiry-timer/sg-expiry-timer-value"); value.Exists() {
		data.SgExpiryTimer = types.Int64Value(value.Int())
	} else if data.SgExpiryTimer.IsNull() {
		data.SgExpiryTimer = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sg-expiry-timer/sg-list"); value.Exists() {
		data.SgList = types.StringValue(value.String())
	} else if data.SgList.IsNull() {
		data.SgList = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/ssm/range"); value.Exists() {
		data.SsmRange = types.StringValue(value.String())
	} else if data.SsmRange.IsNull() {
		data.SsmRange = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/ssm/disable"); value.Exists() {
		data.SsmDisable = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.SsmDisable.IsNull() {
			data.SsmDisable = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/ssm/allow-override"); value.Exists() {
		data.SsmAllowOverride = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.SsmAllowOverride.IsNull() {
			data.SsmAllowOverride = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rpf-redirect/route-policy"); value.Exists() {
		data.RpfRedirectRoutePolicy = types.StringValue(value.String())
	} else if data.RpfRedirectRoutePolicy.IsNull() {
		data.RpfRedirectRoutePolicy = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/multipath"); value.Exists() {
		data.Multipath = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.Multipath.IsNull() {
			data.Multipath = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/multipath/hash/source"); value.Exists() {
		data.MultipathHashSource = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.MultipathHashSource.IsNull() {
			data.MultipathHashSource = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/multipath/hash/source-nexthop"); value.Exists() {
		data.MultipathHashSourceNexthop = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.MultipathHashSourceNexthop.IsNull() {
			data.MultipathHashSourceNexthop = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/multipath/hash/source-group"); value.Exists() {
		data.MultipathHashSourceGroup = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.MultipathHashSourceGroup.IsNull() {
			data.MultipathHashSourceGroup = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/auto-rp/mapping-agent/interface-name"); value.Exists() {
		data.AutoRpMappingAgentInterface = types.StringValue(value.String())
	} else if data.AutoRpMappingAgentInterface.IsNull() {
		data.AutoRpMappingAgentInterface = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/auto-rp/mapping-agent/scope"); value.Exists() {
		data.AutoRpMappingAgentScope = types.Int64Value(value.Int())
	} else if data.AutoRpMappingAgentScope.IsNull() {
		data.AutoRpMappingAgentScope = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/auto-rp/mapping-agent/interval"); value.Exists() {
		data.AutoRpMappingAgentInterval = types.Int64Value(value.Int())
	} else if data.AutoRpMappingAgentInterval.IsNull() {
		data.AutoRpMappingAgentInterval = types.Int64Null()
	}
	for i := range data.AutoRpCandidateRps {
		keys := [...]string{"interface-name"}
		keyValues := [...]string{data.AutoRpCandidateRps[i].InterfaceName.ValueString()}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/auto-rp/candidate-rps/candidate-rp").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "interface-name"); value.Exists() {
			data.AutoRpCandidateRps[i].InterfaceName = types.StringValue(value.String())
		} else if data.AutoRpCandidateRps[i].InterfaceName.IsNull() {
			data.AutoRpCandidateRps[i].InterfaceName = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "scope"); value.Exists() {
			data.AutoRpCandidateRps[i].Scope = types.Int64Value(value.Int())
		} else if data.AutoRpCandidateRps[i].Scope.IsNull() {
			data.AutoRpCandidateRps[i].Scope = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "group-list"); value.Exists() {
			data.AutoRpCandidateRps[i].GroupList = types.StringValue(value.String())
		} else if data.AutoRpCandidateRps[i].GroupList.IsNull() {
			data.AutoRpCandidateRps[i].GroupList = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "interval"); value.Exists() {
			data.AutoRpCandidateRps[i].Interval = types.Int64Value(value.Int())
		} else if data.AutoRpCandidateRps[i].Interval.IsNull() {
			data.AutoRpCandidateRps[i].Interval = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "bidir/scope"); value.Exists() {
			data.AutoRpCandidateRps[i].BidirScope = types.Int64Value(value.Int())
		} else if data.AutoRpCandidateRps[i].BidirScope.IsNull() {
			data.AutoRpCandidateRps[i].BidirScope = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "bidir/group-list"); value.Exists() {
			data.AutoRpCandidateRps[i].BidirGroupList = types.StringValue(value.String())
		} else if data.AutoRpCandidateRps[i].BidirGroupList.IsNull() {
			data.AutoRpCandidateRps[i].BidirGroupList = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "bidir/interval"); value.Exists() {
			data.AutoRpCandidateRps[i].BidirInterval = types.Int64Value(value.Int())
		} else if data.AutoRpCandidateRps[i].BidirInterval.IsNull() {
			data.AutoRpCandidateRps[i].BidirInterval = types.Int64Null()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/auto-rp/listen/disable"); value.Exists() {
		data.AutoRpListenDisable = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.AutoRpListenDisable.IsNull() {
			data.AutoRpListenDisable = types.BoolNull()
		}
	}
	for i := range data.AutoRpRelayVrfs {
		keys := [...]string{"vrf-name"}
		keyValues := [...]string{data.AutoRpRelayVrfs[i].VrfName.ValueString()}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/auto-rp/relay/vrfs/vrf").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "vrf-name"); value.Exists() {
			data.AutoRpRelayVrfs[i].VrfName = types.StringValue(value.String())
		} else if data.AutoRpRelayVrfs[i].VrfName.IsNull() {
			data.AutoRpRelayVrfs[i].VrfName = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "listen"); value.Exists() {
			data.AutoRpRelayVrfs[i].Listen = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.AutoRpRelayVrfs[i].Listen.IsNull() {
				data.AutoRpRelayVrfs[i].Listen = types.BoolNull()
			}
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/bsr/candidate-bsr/address"); value.Exists() {
		data.BsrCandidateBsrAddress = types.StringValue(value.String())
	} else if data.BsrCandidateBsrAddress.IsNull() {
		data.BsrCandidateBsrAddress = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/bsr/candidate-bsr/hash-mask-len"); value.Exists() {
		data.BsrCandidateBsrHashMaskLen = types.Int64Value(value.Int())
	} else if data.BsrCandidateBsrHashMaskLen.IsNull() {
		data.BsrCandidateBsrHashMaskLen = types.Int64Null()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/bsr/candidate-bsr/priority"); value.Exists() {
		data.BsrCandidateBsrPriority = types.Int64Value(value.Int())
	} else if data.BsrCandidateBsrPriority.IsNull() {
		data.BsrCandidateBsrPriority = types.Int64Null()
	}
	for i := range data.BsrCandidateRps {
		keys := [...]string{"address"}
		keyValues := [...]string{data.BsrCandidateRps[i].Address.ValueString()}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/bsr/candidate-rps/candidate-rp").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "address"); value.Exists() {
			data.BsrCandidateRps[i].Address = types.StringValue(value.String())
		} else if data.BsrCandidateRps[i].Address.IsNull() {
			data.BsrCandidateRps[i].Address = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "group-list"); value.Exists() {
			data.BsrCandidateRps[i].GroupList = types.StringValue(value.String())
		} else if data.BsrCandidateRps[i].GroupList.IsNull() {
			data.BsrCandidateRps[i].GroupList = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "priority"); value.Exists() {
			data.BsrCandidateRps[i].Priority = types.Int64Value(value.Int())
		} else if data.BsrCandidateRps[i].Priority.IsNull() {
			data.BsrCandidateRps[i].Priority = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "interval"); value.Exists() {
			data.BsrCandidateRps[i].Interval = types.Int64Value(value.Int())
		} else if data.BsrCandidateRps[i].Interval.IsNull() {
			data.BsrCandidateRps[i].Interval = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "bidir/group-list"); value.Exists() {
			data.BsrCandidateRps[i].BidirGroupList = types.StringValue(value.String())
		} else if data.BsrCandidateRps[i].BidirGroupList.IsNull() {
			data.BsrCandidateRps[i].BidirGroupList = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "bidir/priority"); value.Exists() {
			data.BsrCandidateRps[i].BidirPriority = types.Int64Value(value.Int())
		} else if data.BsrCandidateRps[i].BidirPriority.IsNull() {
			data.BsrCandidateRps[i].BidirPriority = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "bidir/interval"); value.Exists() {
			data.BsrCandidateRps[i].BidirInterval = types.Int64Value(value.Int())
		} else if data.BsrCandidateRps[i].BidirInterval.IsNull() {
			data.BsrCandidateRps[i].BidirInterval = types.Int64Null()
		}
	}
	for i := range data.BsrRelayVrfs {
		keys := [...]string{"vrf-name"}
		keyValues := [...]string{data.BsrRelayVrfs[i].VrfName.ValueString()}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/bsr/relay/vrfs/vrf").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "vrf-name"); value.Exists() {
			data.BsrRelayVrfs[i].VrfName = types.StringValue(value.String())
		} else if data.BsrRelayVrfs[i].VrfName.IsNull() {
			data.BsrRelayVrfs[i].VrfName = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "listen"); value.Exists() {
			data.BsrRelayVrfs[i].Listen = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.BsrRelayVrfs[i].Listen.IsNull() {
				data.BsrRelayVrfs[i].Listen = types.BoolNull()
			}
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr"); value.Exists() {
		data.Mofrr = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.Mofrr.IsNull() {
			data.Mofrr = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr/flow"); value.Exists() {
		data.MofrrFlow = types.StringValue(value.String())
	} else if data.MofrrFlow.IsNull() {
		data.MofrrFlow = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr/rib"); value.Exists() {
		data.MofrrRib = types.StringValue(value.String())
	} else if data.MofrrRib.IsNull() {
		data.MofrrRib = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr/protect"); value.Exists() {
		data.MofrrProtect = types.StringValue(value.String())
	} else if data.MofrrProtect.IsNull() {
		data.MofrrProtect = types.StringNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr/local-fault-only"); value.Exists() {
		data.MofrrProtectLocalFaultOnly = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.MofrrProtectLocalFaultOnly.IsNull() {
			data.MofrrProtectLocalFaultOnly = types.BoolNull()
		}
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr/non-revertive"); value.Exists() {
		data.MofrrNonRevertive = types.BoolValue(true)
	} else {
		// For presence-based booleans, only set to null if it's already null
		if data.MofrrNonRevertive.IsNull() {
			data.MofrrNonRevertive = types.BoolNull()
		}
	}
	for i := range data.MofrrCloneJoins {
		keys := [...]string{"address"}
		keyValues := [...]string{data.MofrrCloneJoins[i].SourceAddress.ValueString()}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr/clone/joins/join").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "address"); value.Exists() {
			data.MofrrCloneJoins[i].SourceAddress = types.StringValue(value.String())
		} else if data.MofrrCloneJoins[i].SourceAddress.IsNull() {
			data.MofrrCloneJoins[i].SourceAddress = types.StringNull()
		}
		for ci := range data.MofrrCloneJoins[i].To {
			keys := [...]string{"address"}
			keyValues := [...]string{data.MofrrCloneJoins[i].To[ci].PrimaryAddress.ValueString()}

			var cr xmldot.Result
			helpers.GetFromXPath(r, "to").ForEach(
				func(_ int, v xmldot.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := helpers.GetFromXPath(cr, "address"); value.Exists() {
				data.MofrrCloneJoins[i].To[ci].PrimaryAddress = types.StringValue(value.String())
			} else {
				data.MofrrCloneJoins[i].To[ci].PrimaryAddress = types.StringNull()
			}
		}
	}
	for i := range data.MofrrCloneSources {
		keys := [...]string{"address"}
		keyValues := [...]string{data.MofrrCloneSources[i].SourceAddress.ValueString()}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr/clone/sources/source").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "address"); value.Exists() {
			data.MofrrCloneSources[i].SourceAddress = types.StringValue(value.String())
		} else if data.MofrrCloneSources[i].SourceAddress.IsNull() {
			data.MofrrCloneSources[i].SourceAddress = types.StringNull()
		}
		for ci := range data.MofrrCloneSources[i].To {
			keys := [...]string{"address"}
			keyValues := [...]string{data.MofrrCloneSources[i].To[ci].PrimaryAddress.ValueString()}

			var cr xmldot.Result
			helpers.GetFromXPath(r, "to").ForEach(
				func(_ int, v xmldot.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := helpers.GetFromXPath(cr, "address"); value.Exists() {
				data.MofrrCloneSources[i].To[ci].PrimaryAddress = types.StringValue(value.String())
			} else {
				data.MofrrCloneSources[i].To[ci].PrimaryAddress = types.StringNull()
			}
		}
	}
	for i := range data.SrP2mpPolicies {
		keys := [...]string{"sr-p2mp-policy-id"}
		keyValues := [...]string{data.SrP2mpPolicies[i].PolicyName.ValueString()}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/sr-p2mp-policies/sr-p2mp-policy").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "sr-p2mp-policy-id"); value.Exists() {
			data.SrP2mpPolicies[i].PolicyName = types.StringValue(value.String())
		} else if data.SrP2mpPolicies[i].PolicyName.IsNull() {
			data.SrP2mpPolicies[i].PolicyName = types.StringNull()
		}
		for ci := range data.SrP2mpPolicies[i].StaticGroups {
			keys := [...]string{"group-address"}
			keyValues := [...]string{data.SrP2mpPolicies[i].StaticGroups[ci].GroupAddress.ValueString()}

			var cr xmldot.Result
			helpers.GetFromXPath(r, "static-group/group-address").ForEach(
				func(_ int, v xmldot.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := helpers.GetFromXPath(cr, "group-address"); value.Exists() {
				data.SrP2mpPolicies[i].StaticGroups[ci].GroupAddress = types.StringValue(value.String())
			} else {
				data.SrP2mpPolicies[i].StaticGroups[ci].GroupAddress = types.StringNull()
			}
			if value := helpers.GetFromXPath(cr, "group-address-only"); value.Exists() {
				if !data.SrP2mpPolicies[i].StaticGroups[ci].GroupAddressOnly.IsNull() {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupAddressOnly = types.BoolValue(true)
				}
			} else {
				// For presence-based booleans, only set to false if the attribute is null in state
				if data.SrP2mpPolicies[i].StaticGroups[ci].GroupAddressOnly.IsNull() {
					data.SrP2mpPolicies[i].StaticGroups[ci].GroupAddressOnly = types.BoolNull()
				}
			}
		}
	}
	for i := range data.Interfaces {
		keys := [...]string{"interface-name"}
		keyValues := [...]string{data.Interfaces[i].InterfaceName.ValueString()}

		var r xmldot.Result
		helpers.GetFromXPath(res, "data"+data.getXPath()+"/interfaces/interface").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "interface-name"); value.Exists() {
			data.Interfaces[i].InterfaceName = types.StringValue(value.String())
		} else if data.Interfaces[i].InterfaceName.IsNull() {
			data.Interfaces[i].InterfaceName = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "enable"); value.Exists() {
			data.Interfaces[i].Enable = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Interfaces[i].Enable.IsNull() {
				data.Interfaces[i].Enable = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "disable"); value.Exists() {
			data.Interfaces[i].Disable = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Interfaces[i].Disable.IsNull() {
				data.Interfaces[i].Disable = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "dr-priority"); value.Exists() {
			data.Interfaces[i].DrPriority = types.Int64Value(value.Int())
		} else if data.Interfaces[i].DrPriority.IsNull() {
			data.Interfaces[i].DrPriority = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "hello-interval"); value.Exists() {
			data.Interfaces[i].HelloInterval = types.Int64Value(value.Int())
		} else if data.Interfaces[i].HelloInterval.IsNull() {
			data.Interfaces[i].HelloInterval = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "join-prune-interval"); value.Exists() {
			data.Interfaces[i].JoinPruneInterval = types.Int64Value(value.Int())
		} else if data.Interfaces[i].JoinPruneInterval.IsNull() {
			data.Interfaces[i].JoinPruneInterval = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "join-prune-mtu"); value.Exists() {
			data.Interfaces[i].JoinPruneMtu = types.Int64Value(value.Int())
		} else if data.Interfaces[i].JoinPruneMtu.IsNull() {
			data.Interfaces[i].JoinPruneMtu = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "propagation-delay"); value.Exists() {
			data.Interfaces[i].PropagationDelay = types.Int64Value(value.Int())
		} else if data.Interfaces[i].PropagationDelay.IsNull() {
			data.Interfaces[i].PropagationDelay = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "override-interval"); value.Exists() {
			data.Interfaces[i].OverrideInterval = types.Int64Value(value.Int())
		} else if data.Interfaces[i].OverrideInterval.IsNull() {
			data.Interfaces[i].OverrideInterval = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "neighbor-filter"); value.Exists() {
			data.Interfaces[i].NeighborFilter = types.StringValue(value.String())
		} else if data.Interfaces[i].NeighborFilter.IsNull() {
			data.Interfaces[i].NeighborFilter = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "maximum/route-interfaces/maximum-route-interfaces"); value.Exists() {
			data.Interfaces[i].MaximumRouteInterfaces = types.Int64Value(value.Int())
		} else if data.Interfaces[i].MaximumRouteInterfaces.IsNull() {
			data.Interfaces[i].MaximumRouteInterfaces = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "maximum/route-interfaces/threshold"); value.Exists() {
			data.Interfaces[i].MaximumRouteInterfacesThreshold = types.Int64Value(value.Int())
		} else if data.Interfaces[i].MaximumRouteInterfacesThreshold.IsNull() {
			data.Interfaces[i].MaximumRouteInterfacesThreshold = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "maximum/route-interfaces/access-list"); value.Exists() {
			data.Interfaces[i].MaximumRouteInterfacesAccessList = types.StringValue(value.String())
		} else if data.Interfaces[i].MaximumRouteInterfacesAccessList.IsNull() {
			data.Interfaces[i].MaximumRouteInterfacesAccessList = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "bfd/multiplier"); value.Exists() {
			data.Interfaces[i].BfdMultiplier = types.Int64Value(value.Int())
		} else if data.Interfaces[i].BfdMultiplier.IsNull() {
			data.Interfaces[i].BfdMultiplier = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "bfd/minimum-interval"); value.Exists() {
			data.Interfaces[i].BfdMinimumInterval = types.Int64Value(value.Int())
		} else if data.Interfaces[i].BfdMinimumInterval.IsNull() {
			data.Interfaces[i].BfdMinimumInterval = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "bfd/fast-detect"); value.Exists() {
			data.Interfaces[i].BfdFastDetect = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Interfaces[i].BfdFastDetect.IsNull() {
				data.Interfaces[i].BfdFastDetect = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "bsr-border"); value.Exists() {
			data.Interfaces[i].BsrBorder = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Interfaces[i].BsrBorder.IsNull() {
				data.Interfaces[i].BsrBorder = types.BoolNull()
			}
		}
	}
}

// End of section. //template:end updateFromBodyXML
// Section below is generated&owned by "gen/generator.go". //template:begin fromBody

func (data *RouterPIMIPv4) fromBody(ctx context.Context, res gjson.Result) {
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	if value := res.Get(prefix + "rp-addresses.rp-address"); value.Exists() {
		data.RpAddresses = make([]RouterPIMIPv4RpAddresses, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4RpAddresses{}
			if cValue := v.Get("address"); cValue.Exists() {
				item.Address = types.StringValue(cValue.String())
			}
			if cValue := v.Get("access-list"); cValue.Exists() {
				item.AccessList = types.StringValue(cValue.String())
			}
			if cValue := v.Get("override"); cValue.Exists() {
				item.Override = types.BoolValue(true)
			} else {
				item.Override = types.BoolValue(false)
			}
			data.RpAddresses = append(data.RpAddresses, item)
			return true
		})
	}
	if value := res.Get(prefix + "rp-addresses.bidir.rp-address"); value.Exists() {
		data.RpAddressesBidir = make([]RouterPIMIPv4RpAddressesBidir, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4RpAddressesBidir{}
			if cValue := v.Get("address"); cValue.Exists() {
				item.Address = types.StringValue(cValue.String())
			}
			if cValue := v.Get("access-list"); cValue.Exists() {
				item.AccessList = types.StringValue(cValue.String())
			}
			if cValue := v.Get("override"); cValue.Exists() {
				item.Override = types.BoolValue(true)
			} else {
				item.Override = types.BoolValue(false)
			}
			data.RpAddressesBidir = append(data.RpAddressesBidir, item)
			return true
		})
	}
	if value := res.Get(prefix + "rp-static-deny"); value.Exists() {
		data.RpStaticDeny = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "accept-register"); value.Exists() {
		data.AcceptRegister = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "suppress-data-registers"); value.Exists() {
		data.SuppressDataRegisters = types.BoolValue(true)
	} else {
		data.SuppressDataRegisters = types.BoolNull()
	}
	if value := res.Get(prefix + "register-source"); value.Exists() {
		data.RegisterSource = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "suppress-rpf-change-prunes"); value.Exists() {
		data.SuppressRpfChangePrunes = types.BoolValue(true)
	} else {
		data.SuppressRpfChangePrunes = types.BoolNull()
	}
	if value := res.Get(prefix + "neighbor-filter"); value.Exists() {
		data.NeighborFilter = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "convergence.rpf-conflict-join-delay"); value.Exists() {
		data.ConvergenceRpfConflictJoinDelay = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "convergence.link-down-prune-delay"); value.Exists() {
		data.ConvergenceLinkDownPruneDelay = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "spt-threshold.infinity"); value.Exists() {
		data.SptThresholdInfinity = types.BoolValue(true)
	} else {
		data.SptThresholdInfinity = types.BoolNull()
	}
	if value := res.Get(prefix + "spt-threshold.infinity.group-list"); value.Exists() {
		data.SptThresholdInfinityGroupList = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "old-register-checksum"); value.Exists() {
		data.OldRegisterChecksum = types.BoolValue(true)
	} else {
		data.OldRegisterChecksum = types.BoolNull()
	}
	if value := res.Get(prefix + "nsf.lifetime"); value.Exists() {
		data.NsfLifetime = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "neighbor-check-on-send.enable"); value.Exists() {
		data.NeighborCheckOnSend = types.BoolValue(true)
	} else {
		data.NeighborCheckOnSend = types.BoolNull()
	}
	if value := res.Get(prefix + "neighbor-check-on-recv.enable"); value.Exists() {
		data.NeighborCheckOnRecv = types.BoolValue(true)
	} else {
		data.NeighborCheckOnRecv = types.BoolNull()
	}
	if value := res.Get(prefix + "hello-interval"); value.Exists() {
		data.HelloInterval = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "mdt-hello-interval"); value.Exists() {
		data.MdtHelloInterval = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "dr-priority"); value.Exists() {
		data.DrPriority = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "join-prune-interval"); value.Exists() {
		data.JoinPruneInterval = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "join-prune-mtu"); value.Exists() {
		data.JoinPruneMtu = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "propagation-delay"); value.Exists() {
		data.PropagationDelay = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "override-interval"); value.Exists() {
		data.OverrideInterval = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.routes.maximum-routes"); value.Exists() {
		data.GlobalMaximumRoutes = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.routes.threshold"); value.Exists() {
		data.GlobalMaximumRoutesThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.route-interfaces.maximum-route-interfaces"); value.Exists() {
		data.GlobalMaximumRouteInterfaces = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.route-interfaces.threshold"); value.Exists() {
		data.GlobalMaximumRouteInterfacesThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.register-states.maximum-register-states"); value.Exists() {
		data.GlobalMaximumRegisterStates = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.register-states.threshold"); value.Exists() {
		data.GlobalMaximumRegisterStatesThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.packet-queue.high-priority"); value.Exists() {
		data.GlobalMaximumPacketQueueHighPriority = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.packet-queue.low-priority"); value.Exists() {
		data.GlobalMaximumPacketQueueLowPriority = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.group-mappings.bsr.maximum-bsr"); value.Exists() {
		data.GlobalMaximumGroupMappingsBsr = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.group-mappings.bsr.threshold"); value.Exists() {
		data.GlobalMaximumGroupMappingsBsrThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.group-mappings.autorp.maximum-autorp"); value.Exists() {
		data.GlobalMaximumGroupMappingsAutorp = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.group-mappings.autorp.threshold"); value.Exists() {
		data.GlobalMaximumGroupMappingsAutorpThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.bsr.crp-cache.maximum-crp-cache"); value.Exists() {
		data.GlobalMaximumBsrCrpCacheMaximum = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.bsr.crp-cache.threshold"); value.Exists() {
		data.GlobalMaximumBsrCrpCacheThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.routes.maximum-routes"); value.Exists() {
		data.MaximumRoutes = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.routes.threshold"); value.Exists() {
		data.MaximumRoutesThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.route-interfaces.maximum-route-interfaces"); value.Exists() {
		data.MaximumRouteInterfaces = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.route-interfaces.threshold"); value.Exists() {
		data.MaximumRouteInterfacesThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.register-states.maximum-register-states"); value.Exists() {
		data.MaximumRegisterStates = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.register-states.threshold"); value.Exists() {
		data.MaximumRegisterStatesThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.group-mappings.bsr.maximum-bsr"); value.Exists() {
		data.MaximumGroupMappingsBsr = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.group-mappings.bsr.threshold"); value.Exists() {
		data.MaximumGroupMappingsBsrThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.group-mappings.autorp.maximum-autorp"); value.Exists() {
		data.MaximumGroupMappingsAutorp = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.group-mappings.autorp.threshold"); value.Exists() {
		data.MaximumGroupMappingsAutorpThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.bsr.crp-cache.maximum-crp-cache"); value.Exists() {
		data.MaximumBsrCrpCacheMaximum = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.bsr.crp-cache.threshold"); value.Exists() {
		data.MaximumBsrCrpCacheThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "log.neighbor.changes"); value.Exists() {
		data.LogNeighborChanges = types.BoolValue(true)
	} else {
		data.LogNeighborChanges = types.BoolNull()
	}
	if value := res.Get(prefix + "rpf-vector.allow-ebgp"); value.Exists() {
		data.RpfVectorAllowEbgp = types.BoolValue(true)
	} else {
		data.RpfVectorAllowEbgp = types.BoolNull()
	}
	if value := res.Get(prefix + "rpf-vector.disable-ibgp"); value.Exists() {
		data.RpfVectorDisableIbgp = types.BoolValue(true)
	} else {
		data.RpfVectorDisableIbgp = types.BoolNull()
	}
	if value := res.Get(prefix + "rpf-vector.use-standard-encoding"); value.Exists() {
		data.RpfVectorStandardEncoding = types.BoolValue(true)
	} else {
		data.RpfVectorStandardEncoding = types.BoolNull()
	}
	if value := res.Get(prefix + "rpf-vector-injects.inject"); value.Exists() {
		data.RpfVectorInjects = make([]RouterPIMIPv4RpfVectorInjects, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4RpfVectorInjects{}
			if cValue := v.Get("source-address"); cValue.Exists() {
				item.SourceAddress = types.StringValue(cValue.String())
			}
			if cValue := v.Get("masklen"); cValue.Exists() {
				item.SourceMask = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("rpf-vector"); cValue.Exists() {
				item.RpfVectors = helpers.GetStringList(cValue.Array())
			} else {
				item.RpfVectors = types.ListNull(types.StringType)
			}
			data.RpfVectorInjects = append(data.RpfVectorInjects, item)
			return true
		})
	}
	if value := res.Get(prefix + "explicit-rpf-vector.injects.inject"); value.Exists() {
		data.ExplicitRpfVectorInjects = make([]RouterPIMIPv4ExplicitRpfVectorInjects, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4ExplicitRpfVectorInjects{}
			if cValue := v.Get("source-address"); cValue.Exists() {
				item.SourceAddress = types.StringValue(cValue.String())
			}
			if cValue := v.Get("masklen"); cValue.Exists() {
				item.SourceMask = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("rpf-vector"); cValue.Exists() {
				item.RpfVectors = helpers.GetStringList(cValue.Array())
			} else {
				item.RpfVectors = types.ListNull(types.StringType)
			}
			data.ExplicitRpfVectorInjects = append(data.ExplicitRpfVectorInjects, item)
			return true
		})
	}
	if value := res.Get(prefix + "rpf.topology.route-policy"); value.Exists() {
		data.RpfTopologyRoutePolicy = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "mdt.neighbor-filter"); value.Exists() {
		data.MdtNeighborFilter = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "mdt.data.switchover-interval"); value.Exists() {
		data.MdtDataSwitchoverInterval = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "mdt.data.announce-interval"); value.Exists() {
		data.MdtDataAnnounceInterval = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "mdt.c-multicast-routing.type"); value.Exists() {
		data.MdtCMulticastType = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "mdt.c-multicast-routing.announce-pim-join-tlv"); value.Exists() {
		data.MdtCMulticastAnnouncePimJoinTlv = types.BoolValue(true)
	} else {
		data.MdtCMulticastAnnouncePimJoinTlv = types.BoolNull()
	}
	if value := res.Get(prefix + "mdt.c-multicast-routing.shared-tree-prune"); value.Exists() {
		data.MdtCMulticastSharedTreePrune = types.BoolValue(true)
	} else {
		data.MdtCMulticastSharedTreePrune = types.BoolNull()
	}
	if value := res.Get(prefix + "mdt.c-multicast-routing.suppress-shared-tree-join"); value.Exists() {
		data.MdtCMulticastSuppressSharedTreeJoin = types.BoolValue(true)
	} else {
		data.MdtCMulticastSuppressSharedTreeJoin = types.BoolNull()
	}
	if value := res.Get(prefix + "mdt.c-multicast-routing.suppress-pim-data-signaling"); value.Exists() {
		data.MdtCMulticastSuppressPimDataSignaling = types.BoolValue(true)
	} else {
		data.MdtCMulticastSuppressPimDataSignaling = types.BoolNull()
	}
	if value := res.Get(prefix + "mdt.c-multicast-routing.mdt-hello.enable"); value.Exists() {
		data.MdtCMulticastHelloEnable = types.BoolValue(true)
	} else {
		data.MdtCMulticastHelloEnable = types.BoolNull()
	}
	if value := res.Get(prefix + "mdt.c-multicast-routing.shared-tree-prune-delay"); value.Exists() {
		data.MdtCMulticastSharedTreePruneDelay = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "mdt.c-multicast-routing.source-tree-prune-delay"); value.Exists() {
		data.MdtCMulticastSourceTreePruneDelay = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "mdt.c-multicast-routing.migration.route-policy"); value.Exists() {
		data.MdtCMulticastMigrationRoutePolicy = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "allow-rp"); value.Exists() {
		data.AllowRp = types.BoolValue(true)
	} else {
		data.AllowRp = types.BoolNull()
	}
	if value := res.Get(prefix + "allow-rp.rp-list"); value.Exists() {
		data.AllowRpList = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "allow-rp.group-list"); value.Exists() {
		data.AllowRpGroupList = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "sg-expiry-timer.sg-expiry-timer-value"); value.Exists() {
		data.SgExpiryTimer = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "sg-expiry-timer.sg-list"); value.Exists() {
		data.SgList = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "ssm.range"); value.Exists() {
		data.SsmRange = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "ssm.disable"); value.Exists() {
		data.SsmDisable = types.BoolValue(true)
	} else {
		data.SsmDisable = types.BoolNull()
	}
	if value := res.Get(prefix + "ssm.allow-override"); value.Exists() {
		data.SsmAllowOverride = types.BoolValue(true)
	} else {
		data.SsmAllowOverride = types.BoolNull()
	}
	if value := res.Get(prefix + "rpf-redirect.route-policy"); value.Exists() {
		data.RpfRedirectRoutePolicy = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "multipath"); value.Exists() {
		data.Multipath = types.BoolValue(true)
	} else {
		data.Multipath = types.BoolNull()
	}
	if value := res.Get(prefix + "multipath.hash.source"); value.Exists() {
		data.MultipathHashSource = types.BoolValue(true)
	} else {
		data.MultipathHashSource = types.BoolNull()
	}
	if value := res.Get(prefix + "multipath.hash.source-nexthop"); value.Exists() {
		data.MultipathHashSourceNexthop = types.BoolValue(true)
	} else {
		data.MultipathHashSourceNexthop = types.BoolNull()
	}
	if value := res.Get(prefix + "multipath.hash.source-group"); value.Exists() {
		data.MultipathHashSourceGroup = types.BoolValue(true)
	} else {
		data.MultipathHashSourceGroup = types.BoolNull()
	}
	if value := res.Get(prefix + "auto-rp.mapping-agent.interface-name"); value.Exists() {
		data.AutoRpMappingAgentInterface = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "auto-rp.mapping-agent.scope"); value.Exists() {
		data.AutoRpMappingAgentScope = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "auto-rp.mapping-agent.interval"); value.Exists() {
		data.AutoRpMappingAgentInterval = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "auto-rp.candidate-rps.candidate-rp"); value.Exists() {
		data.AutoRpCandidateRps = make([]RouterPIMIPv4AutoRpCandidateRps, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4AutoRpCandidateRps{}
			if cValue := v.Get("interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("scope"); cValue.Exists() {
				item.Scope = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("group-list"); cValue.Exists() {
				item.GroupList = types.StringValue(cValue.String())
			}
			if cValue := v.Get("interval"); cValue.Exists() {
				item.Interval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("bidir.scope"); cValue.Exists() {
				item.BidirScope = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("bidir.group-list"); cValue.Exists() {
				item.BidirGroupList = types.StringValue(cValue.String())
			}
			if cValue := v.Get("bidir.interval"); cValue.Exists() {
				item.BidirInterval = types.Int64Value(cValue.Int())
			}
			data.AutoRpCandidateRps = append(data.AutoRpCandidateRps, item)
			return true
		})
	}
	if value := res.Get(prefix + "auto-rp.listen.disable"); value.Exists() {
		data.AutoRpListenDisable = types.BoolValue(true)
	} else {
		data.AutoRpListenDisable = types.BoolNull()
	}
	if value := res.Get(prefix + "auto-rp.relay.vrfs.vrf"); value.Exists() {
		data.AutoRpRelayVrfs = make([]RouterPIMIPv4AutoRpRelayVrfs, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4AutoRpRelayVrfs{}
			if cValue := v.Get("vrf-name"); cValue.Exists() {
				item.VrfName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("listen"); cValue.Exists() {
				item.Listen = types.BoolValue(true)
			} else {
				item.Listen = types.BoolValue(false)
			}
			data.AutoRpRelayVrfs = append(data.AutoRpRelayVrfs, item)
			return true
		})
	}
	if value := res.Get(prefix + "bsr.candidate-bsr.address"); value.Exists() {
		data.BsrCandidateBsrAddress = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "bsr.candidate-bsr.hash-mask-len"); value.Exists() {
		data.BsrCandidateBsrHashMaskLen = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "bsr.candidate-bsr.priority"); value.Exists() {
		data.BsrCandidateBsrPriority = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "bsr.candidate-rps.candidate-rp"); value.Exists() {
		data.BsrCandidateRps = make([]RouterPIMIPv4BsrCandidateRps, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4BsrCandidateRps{}
			if cValue := v.Get("address"); cValue.Exists() {
				item.Address = types.StringValue(cValue.String())
			}
			if cValue := v.Get("group-list"); cValue.Exists() {
				item.GroupList = types.StringValue(cValue.String())
			}
			if cValue := v.Get("priority"); cValue.Exists() {
				item.Priority = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("interval"); cValue.Exists() {
				item.Interval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("bidir.group-list"); cValue.Exists() {
				item.BidirGroupList = types.StringValue(cValue.String())
			}
			if cValue := v.Get("bidir.priority"); cValue.Exists() {
				item.BidirPriority = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("bidir.interval"); cValue.Exists() {
				item.BidirInterval = types.Int64Value(cValue.Int())
			}
			data.BsrCandidateRps = append(data.BsrCandidateRps, item)
			return true
		})
	}
	if value := res.Get(prefix + "bsr.relay.vrfs.vrf"); value.Exists() {
		data.BsrRelayVrfs = make([]RouterPIMIPv4BsrRelayVrfs, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4BsrRelayVrfs{}
			if cValue := v.Get("vrf-name"); cValue.Exists() {
				item.VrfName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("listen"); cValue.Exists() {
				item.Listen = types.BoolValue(true)
			} else {
				item.Listen = types.BoolValue(false)
			}
			data.BsrRelayVrfs = append(data.BsrRelayVrfs, item)
			return true
		})
	}
	if value := res.Get(prefix + "mofrr"); value.Exists() {
		data.Mofrr = types.BoolValue(true)
	} else {
		data.Mofrr = types.BoolNull()
	}
	if value := res.Get(prefix + "mofrr.flow"); value.Exists() {
		data.MofrrFlow = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "mofrr.rib"); value.Exists() {
		data.MofrrRib = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "mofrr.protect"); value.Exists() {
		data.MofrrProtect = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "mofrr.local-fault-only"); value.Exists() {
		data.MofrrProtectLocalFaultOnly = types.BoolValue(true)
	} else {
		data.MofrrProtectLocalFaultOnly = types.BoolNull()
	}
	if value := res.Get(prefix + "mofrr.non-revertive"); value.Exists() {
		data.MofrrNonRevertive = types.BoolValue(true)
	} else {
		data.MofrrNonRevertive = types.BoolNull()
	}
	if value := res.Get(prefix + "mofrr.clone.joins.join"); value.Exists() {
		data.MofrrCloneJoins = make([]RouterPIMIPv4MofrrCloneJoins, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4MofrrCloneJoins{}
			if cValue := v.Get("address"); cValue.Exists() {
				item.SourceAddress = types.StringValue(cValue.String())
			}
			if cValue := v.Get("to"); cValue.Exists() {
				item.To = make([]RouterPIMIPv4MofrrCloneJoinsTo, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := RouterPIMIPv4MofrrCloneJoinsTo{}
					if ccValue := cv.Get("address"); ccValue.Exists() {
						cItem.PrimaryAddress = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("and"); ccValue.Exists() {
						cItem.And = make([]RouterPIMIPv4MofrrCloneJoinsToAnd, 0)
						ccValue.ForEach(func(cck, ccv gjson.Result) bool {
							ccItem := RouterPIMIPv4MofrrCloneJoinsToAnd{}
							if cccValue := ccv.Get("address"); cccValue.Exists() {
								ccItem.BackupAddress = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get(""); cccValue.Exists() {
								ccItem.Masklen = make([]RouterPIMIPv4MofrrCloneJoinsToAndMasklen, 0)
								cccValue.ForEach(func(ccck, cccv gjson.Result) bool {
									cccItem := RouterPIMIPv4MofrrCloneJoinsToAndMasklen{}
									if ccccValue := cccv.Get(""); ccccValue.Exists() {
										cccItem.MaskLength = types.Int64Value(ccccValue.Int())
									}
									ccItem.Masklen = append(ccItem.Masklen, cccItem)
									return true
								})
							}
							cItem.And = append(cItem.And, ccItem)
							return true
						})
					}
					item.To = append(item.To, cItem)
					return true
				})
			}
			data.MofrrCloneJoins = append(data.MofrrCloneJoins, item)
			return true
		})
	}
	if value := res.Get(prefix + "mofrr.clone.sources.source"); value.Exists() {
		data.MofrrCloneSources = make([]RouterPIMIPv4MofrrCloneSources, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4MofrrCloneSources{}
			if cValue := v.Get("address"); cValue.Exists() {
				item.SourceAddress = types.StringValue(cValue.String())
			}
			if cValue := v.Get("to"); cValue.Exists() {
				item.To = make([]RouterPIMIPv4MofrrCloneSourcesTo, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := RouterPIMIPv4MofrrCloneSourcesTo{}
					if ccValue := cv.Get("address"); ccValue.Exists() {
						cItem.PrimaryAddress = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("and"); ccValue.Exists() {
						cItem.And = make([]RouterPIMIPv4MofrrCloneSourcesToAnd, 0)
						ccValue.ForEach(func(cck, ccv gjson.Result) bool {
							ccItem := RouterPIMIPv4MofrrCloneSourcesToAnd{}
							if cccValue := ccv.Get("address"); cccValue.Exists() {
								ccItem.BackupAddress = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get(""); cccValue.Exists() {
								ccItem.Masklen = make([]RouterPIMIPv4MofrrCloneSourcesToAndMasklen, 0)
								cccValue.ForEach(func(ccck, cccv gjson.Result) bool {
									cccItem := RouterPIMIPv4MofrrCloneSourcesToAndMasklen{}
									if ccccValue := cccv.Get(""); ccccValue.Exists() {
										cccItem.MaskLength = types.Int64Value(ccccValue.Int())
									}
									ccItem.Masklen = append(ccItem.Masklen, cccItem)
									return true
								})
							}
							cItem.And = append(cItem.And, ccItem)
							return true
						})
					}
					item.To = append(item.To, cItem)
					return true
				})
			}
			data.MofrrCloneSources = append(data.MofrrCloneSources, item)
			return true
		})
	}
	if value := res.Get(prefix + "sr-p2mp-policies.sr-p2mp-policy"); value.Exists() {
		data.SrP2mpPolicies = make([]RouterPIMIPv4SrP2mpPolicies, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4SrP2mpPolicies{}
			if cValue := v.Get("sr-p2mp-policy-id"); cValue.Exists() {
				item.PolicyName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("static-group.group-address"); cValue.Exists() {
				item.StaticGroups = make([]RouterPIMIPv4SrP2mpPoliciesStaticGroups, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := RouterPIMIPv4SrP2mpPoliciesStaticGroups{}
					if ccValue := cv.Get("group-address"); ccValue.Exists() {
						cItem.GroupAddress = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("group-address-only"); ccValue.Exists() {
						cItem.GroupAddressOnly = types.BoolValue(true)
					} else {
						cItem.GroupAddressOnly = types.BoolValue(false)
					}
					if ccValue := cv.Get("group-address-inc-mask"); ccValue.Exists() {
						cItem.GroupMasks = make([]RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasks, 0)
						ccValue.ForEach(func(cck, ccv gjson.Result) bool {
							ccItem := RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasks{}
							if cccValue := ccv.Get("group-mask-address"); cccValue.Exists() {
								ccItem.GroupIncMask = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("group-address-count"); cccValue.Exists() {
								ccItem.GroupCount = types.Int64Value(cccValue.Int())
							}
							cItem.GroupMasks = append(cItem.GroupMasks, ccItem)
							return true
						})
					}
					if ccValue := cv.Get("group-mask-address-source-address-inc-mask"); ccValue.Exists() {
						cItem.GroupMasksSourceAddresses = make([]RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasksSourceAddresses, 0)
						ccValue.ForEach(func(cck, ccv gjson.Result) bool {
							ccItem := RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasksSourceAddresses{}
							if cccValue := ccv.Get("group-mask-address"); cccValue.Exists() {
								ccItem.GroupIncMask = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("source-address"); cccValue.Exists() {
								ccItem.SourceIp = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("group-address-count"); cccValue.Exists() {
								ccItem.GroupCount = types.Int64Value(cccValue.Int())
							}
							cItem.GroupMasksSourceAddresses = append(cItem.GroupMasksSourceAddresses, ccItem)
							return true
						})
					}
					if ccValue := cv.Get("source-address-source-mask-address-inc-mask"); ccValue.Exists() {
						cItem.SourceMasks = make([]RouterPIMIPv4SrP2mpPoliciesStaticGroupsSourceMasks, 0)
						ccValue.ForEach(func(cck, ccv gjson.Result) bool {
							ccItem := RouterPIMIPv4SrP2mpPoliciesStaticGroupsSourceMasks{}
							if cccValue := ccv.Get("source-address"); cccValue.Exists() {
								ccItem.SourceIp = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("source-mask-address"); cccValue.Exists() {
								ccItem.SourceIncMask = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("source-address-count"); cccValue.Exists() {
								ccItem.SourceCount = types.Int64Value(cccValue.Int())
							}
							cItem.SourceMasks = append(cItem.SourceMasks, ccItem)
							return true
						})
					}
					if ccValue := cv.Get("group-mask-address-source-address-source-mask-address-inc-mask"); ccValue.Exists() {
						cItem.GroupMasksSourceMasks = make([]RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasksSourceMasks, 0)
						ccValue.ForEach(func(cck, ccv gjson.Result) bool {
							ccItem := RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasksSourceMasks{}
							if cccValue := ccv.Get("group-mask-address"); cccValue.Exists() {
								ccItem.GroupIncMask = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("source-address"); cccValue.Exists() {
								ccItem.SourceIp = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("source-mask-address"); cccValue.Exists() {
								ccItem.SourceIncMask = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("group-address-count"); cccValue.Exists() {
								ccItem.GroupCount = types.Int64Value(cccValue.Int())
							}
							if cccValue := ccv.Get("source-address-count"); cccValue.Exists() {
								ccItem.SourceCount = types.Int64Value(cccValue.Int())
							}
							cItem.GroupMasksSourceMasks = append(cItem.GroupMasksSourceMasks, ccItem)
							return true
						})
					}
					item.StaticGroups = append(item.StaticGroups, cItem)
					return true
				})
			}
			data.SrP2mpPolicies = append(data.SrP2mpPolicies, item)
			return true
		})
	}
	if value := res.Get(prefix + "interfaces.interface"); value.Exists() {
		data.Interfaces = make([]RouterPIMIPv4Interfaces, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4Interfaces{}
			if cValue := v.Get("interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("enable"); cValue.Exists() {
				item.Enable = types.BoolValue(true)
			} else {
				item.Enable = types.BoolValue(false)
			}
			if cValue := v.Get("disable"); cValue.Exists() {
				item.Disable = types.BoolValue(true)
			} else {
				item.Disable = types.BoolValue(false)
			}
			if cValue := v.Get("dr-priority"); cValue.Exists() {
				item.DrPriority = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("hello-interval"); cValue.Exists() {
				item.HelloInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("join-prune-interval"); cValue.Exists() {
				item.JoinPruneInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("join-prune-mtu"); cValue.Exists() {
				item.JoinPruneMtu = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("propagation-delay"); cValue.Exists() {
				item.PropagationDelay = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("override-interval"); cValue.Exists() {
				item.OverrideInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("neighbor-filter"); cValue.Exists() {
				item.NeighborFilter = types.StringValue(cValue.String())
			}
			if cValue := v.Get("maximum.route-interfaces.maximum-route-interfaces"); cValue.Exists() {
				item.MaximumRouteInterfaces = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("maximum.route-interfaces.threshold"); cValue.Exists() {
				item.MaximumRouteInterfacesThreshold = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("maximum.route-interfaces.access-list"); cValue.Exists() {
				item.MaximumRouteInterfacesAccessList = types.StringValue(cValue.String())
			}
			if cValue := v.Get("bfd.multiplier"); cValue.Exists() {
				item.BfdMultiplier = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("bfd.minimum-interval"); cValue.Exists() {
				item.BfdMinimumInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("bfd.fast-detect"); cValue.Exists() {
				item.BfdFastDetect = types.BoolValue(true)
			} else {
				item.BfdFastDetect = types.BoolValue(false)
			}
			if cValue := v.Get("bsr-border"); cValue.Exists() {
				item.BsrBorder = types.BoolValue(true)
			} else {
				item.BsrBorder = types.BoolValue(false)
			}
			data.Interfaces = append(data.Interfaces, item)
			return true
		})
	}
}

// End of section. //template:end fromBody
// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyData

func (data *RouterPIMIPv4Data) fromBody(ctx context.Context, res gjson.Result) {
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	if value := res.Get(prefix + "rp-addresses.rp-address"); value.Exists() {
		data.RpAddresses = make([]RouterPIMIPv4RpAddresses, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4RpAddresses{}
			if cValue := v.Get("address"); cValue.Exists() {
				item.Address = types.StringValue(cValue.String())
			}
			if cValue := v.Get("access-list"); cValue.Exists() {
				item.AccessList = types.StringValue(cValue.String())
			}
			if cValue := v.Get("override"); cValue.Exists() {
				item.Override = types.BoolValue(true)
			} else {
				item.Override = types.BoolNull()
			}
			data.RpAddresses = append(data.RpAddresses, item)
			return true
		})
	}
	if value := res.Get(prefix + "rp-addresses.bidir.rp-address"); value.Exists() {
		data.RpAddressesBidir = make([]RouterPIMIPv4RpAddressesBidir, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4RpAddressesBidir{}
			if cValue := v.Get("address"); cValue.Exists() {
				item.Address = types.StringValue(cValue.String())
			}
			if cValue := v.Get("access-list"); cValue.Exists() {
				item.AccessList = types.StringValue(cValue.String())
			}
			if cValue := v.Get("override"); cValue.Exists() {
				item.Override = types.BoolValue(true)
			} else {
				item.Override = types.BoolNull()
			}
			data.RpAddressesBidir = append(data.RpAddressesBidir, item)
			return true
		})
	}
	if value := res.Get(prefix + "rp-static-deny"); value.Exists() {
		data.RpStaticDeny = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "accept-register"); value.Exists() {
		data.AcceptRegister = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "suppress-data-registers"); value.Exists() {
		data.SuppressDataRegisters = types.BoolValue(true)
	} else {
		data.SuppressDataRegisters = types.BoolNull()
	}
	if value := res.Get(prefix + "register-source"); value.Exists() {
		data.RegisterSource = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "suppress-rpf-change-prunes"); value.Exists() {
		data.SuppressRpfChangePrunes = types.BoolValue(true)
	} else {
		data.SuppressRpfChangePrunes = types.BoolNull()
	}
	if value := res.Get(prefix + "neighbor-filter"); value.Exists() {
		data.NeighborFilter = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "convergence.rpf-conflict-join-delay"); value.Exists() {
		data.ConvergenceRpfConflictJoinDelay = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "convergence.link-down-prune-delay"); value.Exists() {
		data.ConvergenceLinkDownPruneDelay = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "spt-threshold.infinity"); value.Exists() {
		data.SptThresholdInfinity = types.BoolValue(true)
	} else {
		data.SptThresholdInfinity = types.BoolNull()
	}
	if value := res.Get(prefix + "spt-threshold.infinity.group-list"); value.Exists() {
		data.SptThresholdInfinityGroupList = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "old-register-checksum"); value.Exists() {
		data.OldRegisterChecksum = types.BoolValue(true)
	} else {
		data.OldRegisterChecksum = types.BoolNull()
	}
	if value := res.Get(prefix + "nsf.lifetime"); value.Exists() {
		data.NsfLifetime = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "neighbor-check-on-send.enable"); value.Exists() {
		data.NeighborCheckOnSend = types.BoolValue(true)
	} else {
		data.NeighborCheckOnSend = types.BoolNull()
	}
	if value := res.Get(prefix + "neighbor-check-on-recv.enable"); value.Exists() {
		data.NeighborCheckOnRecv = types.BoolValue(true)
	} else {
		data.NeighborCheckOnRecv = types.BoolNull()
	}
	if value := res.Get(prefix + "hello-interval"); value.Exists() {
		data.HelloInterval = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "mdt-hello-interval"); value.Exists() {
		data.MdtHelloInterval = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "dr-priority"); value.Exists() {
		data.DrPriority = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "join-prune-interval"); value.Exists() {
		data.JoinPruneInterval = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "join-prune-mtu"); value.Exists() {
		data.JoinPruneMtu = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "propagation-delay"); value.Exists() {
		data.PropagationDelay = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "override-interval"); value.Exists() {
		data.OverrideInterval = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.routes.maximum-routes"); value.Exists() {
		data.GlobalMaximumRoutes = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.routes.threshold"); value.Exists() {
		data.GlobalMaximumRoutesThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.route-interfaces.maximum-route-interfaces"); value.Exists() {
		data.GlobalMaximumRouteInterfaces = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.route-interfaces.threshold"); value.Exists() {
		data.GlobalMaximumRouteInterfacesThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.register-states.maximum-register-states"); value.Exists() {
		data.GlobalMaximumRegisterStates = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.register-states.threshold"); value.Exists() {
		data.GlobalMaximumRegisterStatesThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.packet-queue.high-priority"); value.Exists() {
		data.GlobalMaximumPacketQueueHighPriority = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.packet-queue.low-priority"); value.Exists() {
		data.GlobalMaximumPacketQueueLowPriority = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.group-mappings.bsr.maximum-bsr"); value.Exists() {
		data.GlobalMaximumGroupMappingsBsr = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.group-mappings.bsr.threshold"); value.Exists() {
		data.GlobalMaximumGroupMappingsBsrThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.group-mappings.autorp.maximum-autorp"); value.Exists() {
		data.GlobalMaximumGroupMappingsAutorp = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.group-mappings.autorp.threshold"); value.Exists() {
		data.GlobalMaximumGroupMappingsAutorpThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.bsr.crp-cache.maximum-crp-cache"); value.Exists() {
		data.GlobalMaximumBsrCrpCacheMaximum = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "global.maximum.bsr.crp-cache.threshold"); value.Exists() {
		data.GlobalMaximumBsrCrpCacheThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.routes.maximum-routes"); value.Exists() {
		data.MaximumRoutes = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.routes.threshold"); value.Exists() {
		data.MaximumRoutesThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.route-interfaces.maximum-route-interfaces"); value.Exists() {
		data.MaximumRouteInterfaces = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.route-interfaces.threshold"); value.Exists() {
		data.MaximumRouteInterfacesThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.register-states.maximum-register-states"); value.Exists() {
		data.MaximumRegisterStates = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.register-states.threshold"); value.Exists() {
		data.MaximumRegisterStatesThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.group-mappings.bsr.maximum-bsr"); value.Exists() {
		data.MaximumGroupMappingsBsr = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.group-mappings.bsr.threshold"); value.Exists() {
		data.MaximumGroupMappingsBsrThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.group-mappings.autorp.maximum-autorp"); value.Exists() {
		data.MaximumGroupMappingsAutorp = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.group-mappings.autorp.threshold"); value.Exists() {
		data.MaximumGroupMappingsAutorpThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.bsr.crp-cache.maximum-crp-cache"); value.Exists() {
		data.MaximumBsrCrpCacheMaximum = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "maximum.bsr.crp-cache.threshold"); value.Exists() {
		data.MaximumBsrCrpCacheThreshold = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "log.neighbor.changes"); value.Exists() {
		data.LogNeighborChanges = types.BoolValue(true)
	} else {
		data.LogNeighborChanges = types.BoolNull()
	}
	if value := res.Get(prefix + "rpf-vector.allow-ebgp"); value.Exists() {
		data.RpfVectorAllowEbgp = types.BoolValue(true)
	} else {
		data.RpfVectorAllowEbgp = types.BoolNull()
	}
	if value := res.Get(prefix + "rpf-vector.disable-ibgp"); value.Exists() {
		data.RpfVectorDisableIbgp = types.BoolValue(true)
	} else {
		data.RpfVectorDisableIbgp = types.BoolNull()
	}
	if value := res.Get(prefix + "rpf-vector.use-standard-encoding"); value.Exists() {
		data.RpfVectorStandardEncoding = types.BoolValue(true)
	} else {
		data.RpfVectorStandardEncoding = types.BoolNull()
	}
	if value := res.Get(prefix + "rpf-vector-injects.inject"); value.Exists() {
		data.RpfVectorInjects = make([]RouterPIMIPv4RpfVectorInjects, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4RpfVectorInjects{}
			if cValue := v.Get("source-address"); cValue.Exists() {
				item.SourceAddress = types.StringValue(cValue.String())
			}
			if cValue := v.Get("masklen"); cValue.Exists() {
				item.SourceMask = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("rpf-vector"); cValue.Exists() {
				item.RpfVectors = helpers.GetStringList(cValue.Array())
			} else {
				item.RpfVectors = types.ListNull(types.StringType)
			}
			data.RpfVectorInjects = append(data.RpfVectorInjects, item)
			return true
		})
	}
	if value := res.Get(prefix + "explicit-rpf-vector.injects.inject"); value.Exists() {
		data.ExplicitRpfVectorInjects = make([]RouterPIMIPv4ExplicitRpfVectorInjects, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4ExplicitRpfVectorInjects{}
			if cValue := v.Get("source-address"); cValue.Exists() {
				item.SourceAddress = types.StringValue(cValue.String())
			}
			if cValue := v.Get("masklen"); cValue.Exists() {
				item.SourceMask = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("rpf-vector"); cValue.Exists() {
				item.RpfVectors = helpers.GetStringList(cValue.Array())
			} else {
				item.RpfVectors = types.ListNull(types.StringType)
			}
			data.ExplicitRpfVectorInjects = append(data.ExplicitRpfVectorInjects, item)
			return true
		})
	}
	if value := res.Get(prefix + "rpf.topology.route-policy"); value.Exists() {
		data.RpfTopologyRoutePolicy = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "mdt.neighbor-filter"); value.Exists() {
		data.MdtNeighborFilter = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "mdt.data.switchover-interval"); value.Exists() {
		data.MdtDataSwitchoverInterval = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "mdt.data.announce-interval"); value.Exists() {
		data.MdtDataAnnounceInterval = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "mdt.c-multicast-routing.type"); value.Exists() {
		data.MdtCMulticastType = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "mdt.c-multicast-routing.announce-pim-join-tlv"); value.Exists() {
		data.MdtCMulticastAnnouncePimJoinTlv = types.BoolValue(true)
	} else {
		data.MdtCMulticastAnnouncePimJoinTlv = types.BoolNull()
	}
	if value := res.Get(prefix + "mdt.c-multicast-routing.shared-tree-prune"); value.Exists() {
		data.MdtCMulticastSharedTreePrune = types.BoolValue(true)
	} else {
		data.MdtCMulticastSharedTreePrune = types.BoolNull()
	}
	if value := res.Get(prefix + "mdt.c-multicast-routing.suppress-shared-tree-join"); value.Exists() {
		data.MdtCMulticastSuppressSharedTreeJoin = types.BoolValue(true)
	} else {
		data.MdtCMulticastSuppressSharedTreeJoin = types.BoolNull()
	}
	if value := res.Get(prefix + "mdt.c-multicast-routing.suppress-pim-data-signaling"); value.Exists() {
		data.MdtCMulticastSuppressPimDataSignaling = types.BoolValue(true)
	} else {
		data.MdtCMulticastSuppressPimDataSignaling = types.BoolNull()
	}
	if value := res.Get(prefix + "mdt.c-multicast-routing.mdt-hello.enable"); value.Exists() {
		data.MdtCMulticastHelloEnable = types.BoolValue(true)
	} else {
		data.MdtCMulticastHelloEnable = types.BoolNull()
	}
	if value := res.Get(prefix + "mdt.c-multicast-routing.shared-tree-prune-delay"); value.Exists() {
		data.MdtCMulticastSharedTreePruneDelay = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "mdt.c-multicast-routing.source-tree-prune-delay"); value.Exists() {
		data.MdtCMulticastSourceTreePruneDelay = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "mdt.c-multicast-routing.migration.route-policy"); value.Exists() {
		data.MdtCMulticastMigrationRoutePolicy = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "allow-rp"); value.Exists() {
		data.AllowRp = types.BoolValue(true)
	} else {
		data.AllowRp = types.BoolNull()
	}
	if value := res.Get(prefix + "allow-rp.rp-list"); value.Exists() {
		data.AllowRpList = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "allow-rp.group-list"); value.Exists() {
		data.AllowRpGroupList = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "sg-expiry-timer.sg-expiry-timer-value"); value.Exists() {
		data.SgExpiryTimer = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "sg-expiry-timer.sg-list"); value.Exists() {
		data.SgList = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "ssm.range"); value.Exists() {
		data.SsmRange = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "ssm.disable"); value.Exists() {
		data.SsmDisable = types.BoolValue(true)
	} else {
		data.SsmDisable = types.BoolNull()
	}
	if value := res.Get(prefix + "ssm.allow-override"); value.Exists() {
		data.SsmAllowOverride = types.BoolValue(true)
	} else {
		data.SsmAllowOverride = types.BoolNull()
	}
	if value := res.Get(prefix + "rpf-redirect.route-policy"); value.Exists() {
		data.RpfRedirectRoutePolicy = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "multipath"); value.Exists() {
		data.Multipath = types.BoolValue(true)
	} else {
		data.Multipath = types.BoolNull()
	}
	if value := res.Get(prefix + "multipath.hash.source"); value.Exists() {
		data.MultipathHashSource = types.BoolValue(true)
	} else {
		data.MultipathHashSource = types.BoolNull()
	}
	if value := res.Get(prefix + "multipath.hash.source-nexthop"); value.Exists() {
		data.MultipathHashSourceNexthop = types.BoolValue(true)
	} else {
		data.MultipathHashSourceNexthop = types.BoolNull()
	}
	if value := res.Get(prefix + "multipath.hash.source-group"); value.Exists() {
		data.MultipathHashSourceGroup = types.BoolValue(true)
	} else {
		data.MultipathHashSourceGroup = types.BoolNull()
	}
	if value := res.Get(prefix + "auto-rp.mapping-agent.interface-name"); value.Exists() {
		data.AutoRpMappingAgentInterface = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "auto-rp.mapping-agent.scope"); value.Exists() {
		data.AutoRpMappingAgentScope = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "auto-rp.mapping-agent.interval"); value.Exists() {
		data.AutoRpMappingAgentInterval = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "auto-rp.candidate-rps.candidate-rp"); value.Exists() {
		data.AutoRpCandidateRps = make([]RouterPIMIPv4AutoRpCandidateRps, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4AutoRpCandidateRps{}
			if cValue := v.Get("interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("scope"); cValue.Exists() {
				item.Scope = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("group-list"); cValue.Exists() {
				item.GroupList = types.StringValue(cValue.String())
			}
			if cValue := v.Get("interval"); cValue.Exists() {
				item.Interval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("bidir.scope"); cValue.Exists() {
				item.BidirScope = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("bidir.group-list"); cValue.Exists() {
				item.BidirGroupList = types.StringValue(cValue.String())
			}
			if cValue := v.Get("bidir.interval"); cValue.Exists() {
				item.BidirInterval = types.Int64Value(cValue.Int())
			}
			data.AutoRpCandidateRps = append(data.AutoRpCandidateRps, item)
			return true
		})
	}
	if value := res.Get(prefix + "auto-rp.listen.disable"); value.Exists() {
		data.AutoRpListenDisable = types.BoolValue(true)
	} else {
		data.AutoRpListenDisable = types.BoolNull()
	}
	if value := res.Get(prefix + "auto-rp.relay.vrfs.vrf"); value.Exists() {
		data.AutoRpRelayVrfs = make([]RouterPIMIPv4AutoRpRelayVrfs, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4AutoRpRelayVrfs{}
			if cValue := v.Get("vrf-name"); cValue.Exists() {
				item.VrfName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("listen"); cValue.Exists() {
				item.Listen = types.BoolValue(true)
			} else {
				item.Listen = types.BoolNull()
			}
			data.AutoRpRelayVrfs = append(data.AutoRpRelayVrfs, item)
			return true
		})
	}
	if value := res.Get(prefix + "bsr.candidate-bsr.address"); value.Exists() {
		data.BsrCandidateBsrAddress = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "bsr.candidate-bsr.hash-mask-len"); value.Exists() {
		data.BsrCandidateBsrHashMaskLen = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "bsr.candidate-bsr.priority"); value.Exists() {
		data.BsrCandidateBsrPriority = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "bsr.candidate-rps.candidate-rp"); value.Exists() {
		data.BsrCandidateRps = make([]RouterPIMIPv4BsrCandidateRps, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4BsrCandidateRps{}
			if cValue := v.Get("address"); cValue.Exists() {
				item.Address = types.StringValue(cValue.String())
			}
			if cValue := v.Get("group-list"); cValue.Exists() {
				item.GroupList = types.StringValue(cValue.String())
			}
			if cValue := v.Get("priority"); cValue.Exists() {
				item.Priority = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("interval"); cValue.Exists() {
				item.Interval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("bidir.group-list"); cValue.Exists() {
				item.BidirGroupList = types.StringValue(cValue.String())
			}
			if cValue := v.Get("bidir.priority"); cValue.Exists() {
				item.BidirPriority = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("bidir.interval"); cValue.Exists() {
				item.BidirInterval = types.Int64Value(cValue.Int())
			}
			data.BsrCandidateRps = append(data.BsrCandidateRps, item)
			return true
		})
	}
	if value := res.Get(prefix + "bsr.relay.vrfs.vrf"); value.Exists() {
		data.BsrRelayVrfs = make([]RouterPIMIPv4BsrRelayVrfs, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4BsrRelayVrfs{}
			if cValue := v.Get("vrf-name"); cValue.Exists() {
				item.VrfName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("listen"); cValue.Exists() {
				item.Listen = types.BoolValue(true)
			} else {
				item.Listen = types.BoolNull()
			}
			data.BsrRelayVrfs = append(data.BsrRelayVrfs, item)
			return true
		})
	}
	if value := res.Get(prefix + "mofrr"); value.Exists() {
		data.Mofrr = types.BoolValue(true)
	} else {
		data.Mofrr = types.BoolNull()
	}
	if value := res.Get(prefix + "mofrr.flow"); value.Exists() {
		data.MofrrFlow = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "mofrr.rib"); value.Exists() {
		data.MofrrRib = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "mofrr.protect"); value.Exists() {
		data.MofrrProtect = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "mofrr.local-fault-only"); value.Exists() {
		data.MofrrProtectLocalFaultOnly = types.BoolValue(true)
	} else {
		data.MofrrProtectLocalFaultOnly = types.BoolNull()
	}
	if value := res.Get(prefix + "mofrr.non-revertive"); value.Exists() {
		data.MofrrNonRevertive = types.BoolValue(true)
	} else {
		data.MofrrNonRevertive = types.BoolNull()
	}
	if value := res.Get(prefix + "mofrr.clone.joins.join"); value.Exists() {
		data.MofrrCloneJoins = make([]RouterPIMIPv4MofrrCloneJoins, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4MofrrCloneJoins{}
			if cValue := v.Get("address"); cValue.Exists() {
				item.SourceAddress = types.StringValue(cValue.String())
			}
			if cValue := v.Get("to"); cValue.Exists() {
				item.To = make([]RouterPIMIPv4MofrrCloneJoinsTo, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := RouterPIMIPv4MofrrCloneJoinsTo{}
					if ccValue := cv.Get("address"); ccValue.Exists() {
						cItem.PrimaryAddress = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("and"); ccValue.Exists() {
						cItem.And = make([]RouterPIMIPv4MofrrCloneJoinsToAnd, 0)
						ccValue.ForEach(func(cck, ccv gjson.Result) bool {
							ccItem := RouterPIMIPv4MofrrCloneJoinsToAnd{}
							if cccValue := ccv.Get("address"); cccValue.Exists() {
								ccItem.BackupAddress = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get(""); cccValue.Exists() {
								ccItem.Masklen = make([]RouterPIMIPv4MofrrCloneJoinsToAndMasklen, 0)
								cccValue.ForEach(func(ccck, cccv gjson.Result) bool {
									cccItem := RouterPIMIPv4MofrrCloneJoinsToAndMasklen{}
									if ccccValue := cccv.Get(""); ccccValue.Exists() {
										cccItem.MaskLength = types.Int64Value(ccccValue.Int())
									}
									ccItem.Masklen = append(ccItem.Masklen, cccItem)
									return true
								})
							}
							cItem.And = append(cItem.And, ccItem)
							return true
						})
					}
					item.To = append(item.To, cItem)
					return true
				})
			}
			data.MofrrCloneJoins = append(data.MofrrCloneJoins, item)
			return true
		})
	}
	if value := res.Get(prefix + "mofrr.clone.sources.source"); value.Exists() {
		data.MofrrCloneSources = make([]RouterPIMIPv4MofrrCloneSources, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4MofrrCloneSources{}
			if cValue := v.Get("address"); cValue.Exists() {
				item.SourceAddress = types.StringValue(cValue.String())
			}
			if cValue := v.Get("to"); cValue.Exists() {
				item.To = make([]RouterPIMIPv4MofrrCloneSourcesTo, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := RouterPIMIPv4MofrrCloneSourcesTo{}
					if ccValue := cv.Get("address"); ccValue.Exists() {
						cItem.PrimaryAddress = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("and"); ccValue.Exists() {
						cItem.And = make([]RouterPIMIPv4MofrrCloneSourcesToAnd, 0)
						ccValue.ForEach(func(cck, ccv gjson.Result) bool {
							ccItem := RouterPIMIPv4MofrrCloneSourcesToAnd{}
							if cccValue := ccv.Get("address"); cccValue.Exists() {
								ccItem.BackupAddress = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get(""); cccValue.Exists() {
								ccItem.Masklen = make([]RouterPIMIPv4MofrrCloneSourcesToAndMasklen, 0)
								cccValue.ForEach(func(ccck, cccv gjson.Result) bool {
									cccItem := RouterPIMIPv4MofrrCloneSourcesToAndMasklen{}
									if ccccValue := cccv.Get(""); ccccValue.Exists() {
										cccItem.MaskLength = types.Int64Value(ccccValue.Int())
									}
									ccItem.Masklen = append(ccItem.Masklen, cccItem)
									return true
								})
							}
							cItem.And = append(cItem.And, ccItem)
							return true
						})
					}
					item.To = append(item.To, cItem)
					return true
				})
			}
			data.MofrrCloneSources = append(data.MofrrCloneSources, item)
			return true
		})
	}
	if value := res.Get(prefix + "sr-p2mp-policies.sr-p2mp-policy"); value.Exists() {
		data.SrP2mpPolicies = make([]RouterPIMIPv4SrP2mpPolicies, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4SrP2mpPolicies{}
			if cValue := v.Get("sr-p2mp-policy-id"); cValue.Exists() {
				item.PolicyName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("static-group.group-address"); cValue.Exists() {
				item.StaticGroups = make([]RouterPIMIPv4SrP2mpPoliciesStaticGroups, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := RouterPIMIPv4SrP2mpPoliciesStaticGroups{}
					if ccValue := cv.Get("group-address"); ccValue.Exists() {
						cItem.GroupAddress = types.StringValue(ccValue.String())
					}
					if ccValue := cv.Get("group-address-only"); ccValue.Exists() {
						cItem.GroupAddressOnly = types.BoolValue(true)
					} else {
						cItem.GroupAddressOnly = types.BoolNull()
					}
					if ccValue := cv.Get("group-address-inc-mask"); ccValue.Exists() {
						cItem.GroupMasks = make([]RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasks, 0)
						ccValue.ForEach(func(cck, ccv gjson.Result) bool {
							ccItem := RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasks{}
							if cccValue := ccv.Get("group-mask-address"); cccValue.Exists() {
								ccItem.GroupIncMask = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("group-address-count"); cccValue.Exists() {
								ccItem.GroupCount = types.Int64Value(cccValue.Int())
							}
							cItem.GroupMasks = append(cItem.GroupMasks, ccItem)
							return true
						})
					}
					if ccValue := cv.Get("group-mask-address-source-address-inc-mask"); ccValue.Exists() {
						cItem.GroupMasksSourceAddresses = make([]RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasksSourceAddresses, 0)
						ccValue.ForEach(func(cck, ccv gjson.Result) bool {
							ccItem := RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasksSourceAddresses{}
							if cccValue := ccv.Get("group-mask-address"); cccValue.Exists() {
								ccItem.GroupIncMask = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("source-address"); cccValue.Exists() {
								ccItem.SourceIp = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("group-address-count"); cccValue.Exists() {
								ccItem.GroupCount = types.Int64Value(cccValue.Int())
							}
							cItem.GroupMasksSourceAddresses = append(cItem.GroupMasksSourceAddresses, ccItem)
							return true
						})
					}
					if ccValue := cv.Get("source-address-source-mask-address-inc-mask"); ccValue.Exists() {
						cItem.SourceMasks = make([]RouterPIMIPv4SrP2mpPoliciesStaticGroupsSourceMasks, 0)
						ccValue.ForEach(func(cck, ccv gjson.Result) bool {
							ccItem := RouterPIMIPv4SrP2mpPoliciesStaticGroupsSourceMasks{}
							if cccValue := ccv.Get("source-address"); cccValue.Exists() {
								ccItem.SourceIp = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("source-mask-address"); cccValue.Exists() {
								ccItem.SourceIncMask = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("source-address-count"); cccValue.Exists() {
								ccItem.SourceCount = types.Int64Value(cccValue.Int())
							}
							cItem.SourceMasks = append(cItem.SourceMasks, ccItem)
							return true
						})
					}
					if ccValue := cv.Get("group-mask-address-source-address-source-mask-address-inc-mask"); ccValue.Exists() {
						cItem.GroupMasksSourceMasks = make([]RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasksSourceMasks, 0)
						ccValue.ForEach(func(cck, ccv gjson.Result) bool {
							ccItem := RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasksSourceMasks{}
							if cccValue := ccv.Get("group-mask-address"); cccValue.Exists() {
								ccItem.GroupIncMask = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("source-address"); cccValue.Exists() {
								ccItem.SourceIp = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("source-mask-address"); cccValue.Exists() {
								ccItem.SourceIncMask = types.StringValue(cccValue.String())
							}
							if cccValue := ccv.Get("group-address-count"); cccValue.Exists() {
								ccItem.GroupCount = types.Int64Value(cccValue.Int())
							}
							if cccValue := ccv.Get("source-address-count"); cccValue.Exists() {
								ccItem.SourceCount = types.Int64Value(cccValue.Int())
							}
							cItem.GroupMasksSourceMasks = append(cItem.GroupMasksSourceMasks, ccItem)
							return true
						})
					}
					item.StaticGroups = append(item.StaticGroups, cItem)
					return true
				})
			}
			data.SrP2mpPolicies = append(data.SrP2mpPolicies, item)
			return true
		})
	}
	if value := res.Get(prefix + "interfaces.interface"); value.Exists() {
		data.Interfaces = make([]RouterPIMIPv4Interfaces, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := RouterPIMIPv4Interfaces{}
			if cValue := v.Get("interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("enable"); cValue.Exists() {
				item.Enable = types.BoolValue(true)
			} else {
				item.Enable = types.BoolNull()
			}
			if cValue := v.Get("disable"); cValue.Exists() {
				item.Disable = types.BoolValue(true)
			} else {
				item.Disable = types.BoolNull()
			}
			if cValue := v.Get("dr-priority"); cValue.Exists() {
				item.DrPriority = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("hello-interval"); cValue.Exists() {
				item.HelloInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("join-prune-interval"); cValue.Exists() {
				item.JoinPruneInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("join-prune-mtu"); cValue.Exists() {
				item.JoinPruneMtu = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("propagation-delay"); cValue.Exists() {
				item.PropagationDelay = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("override-interval"); cValue.Exists() {
				item.OverrideInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("neighbor-filter"); cValue.Exists() {
				item.NeighborFilter = types.StringValue(cValue.String())
			}
			if cValue := v.Get("maximum.route-interfaces.maximum-route-interfaces"); cValue.Exists() {
				item.MaximumRouteInterfaces = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("maximum.route-interfaces.threshold"); cValue.Exists() {
				item.MaximumRouteInterfacesThreshold = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("maximum.route-interfaces.access-list"); cValue.Exists() {
				item.MaximumRouteInterfacesAccessList = types.StringValue(cValue.String())
			}
			if cValue := v.Get("bfd.multiplier"); cValue.Exists() {
				item.BfdMultiplier = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("bfd.minimum-interval"); cValue.Exists() {
				item.BfdMinimumInterval = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("bfd.fast-detect"); cValue.Exists() {
				item.BfdFastDetect = types.BoolValue(true)
			} else {
				item.BfdFastDetect = types.BoolNull()
			}
			if cValue := v.Get("bsr-border"); cValue.Exists() {
				item.BsrBorder = types.BoolValue(true)
			} else {
				item.BsrBorder = types.BoolNull()
			}
			data.Interfaces = append(data.Interfaces, item)
			return true
		})
	}
}

// End of section. //template:end fromBodyData
// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyXML

func (data *RouterPIMIPv4) fromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rp-addresses/rp-address"); value.Exists() {
		data.RpAddresses = make([]RouterPIMIPv4RpAddresses, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4RpAddresses{}
			if cValue := helpers.GetFromXPath(v, "address"); cValue.Exists() {
				item.Address = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "access-list"); cValue.Exists() {
				item.AccessList = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "override"); cValue.Exists() {
				item.Override = types.BoolValue(true)
			} else {
				item.Override = types.BoolNull()
			}
			data.RpAddresses = append(data.RpAddresses, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rp-addresses/bidir/rp-address"); value.Exists() {
		data.RpAddressesBidir = make([]RouterPIMIPv4RpAddressesBidir, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4RpAddressesBidir{}
			if cValue := helpers.GetFromXPath(v, "address"); cValue.Exists() {
				item.Address = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "access-list"); cValue.Exists() {
				item.AccessList = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "override"); cValue.Exists() {
				item.Override = types.BoolValue(true)
			} else {
				item.Override = types.BoolNull()
			}
			data.RpAddressesBidir = append(data.RpAddressesBidir, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rp-static-deny"); value.Exists() {
		data.RpStaticDeny = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/accept-register"); value.Exists() {
		data.AcceptRegister = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/suppress-data-registers"); value.Exists() {
		data.SuppressDataRegisters = types.BoolValue(true)
	} else {
		data.SuppressDataRegisters = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/register-source"); value.Exists() {
		data.RegisterSource = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/suppress-rpf-change-prunes"); value.Exists() {
		data.SuppressRpfChangePrunes = types.BoolValue(true)
	} else {
		data.SuppressRpfChangePrunes = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/neighbor-filter"); value.Exists() {
		data.NeighborFilter = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/convergence/rpf-conflict-join-delay"); value.Exists() {
		data.ConvergenceRpfConflictJoinDelay = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/convergence/link-down-prune-delay"); value.Exists() {
		data.ConvergenceLinkDownPruneDelay = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/spt-threshold/infinity"); value.Exists() {
		data.SptThresholdInfinity = types.BoolValue(true)
	} else {
		data.SptThresholdInfinity = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/spt-threshold/infinity/group-list"); value.Exists() {
		data.SptThresholdInfinityGroupList = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/old-register-checksum"); value.Exists() {
		data.OldRegisterChecksum = types.BoolValue(true)
	} else {
		data.OldRegisterChecksum = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/nsf/lifetime"); value.Exists() {
		data.NsfLifetime = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/neighbor-check-on-send/enable"); value.Exists() {
		data.NeighborCheckOnSend = types.BoolValue(true)
	} else {
		data.NeighborCheckOnSend = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/neighbor-check-on-recv/enable"); value.Exists() {
		data.NeighborCheckOnRecv = types.BoolValue(true)
	} else {
		data.NeighborCheckOnRecv = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/hello-interval"); value.Exists() {
		data.HelloInterval = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt-hello-interval"); value.Exists() {
		data.MdtHelloInterval = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dr-priority"); value.Exists() {
		data.DrPriority = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/join-prune-interval"); value.Exists() {
		data.JoinPruneInterval = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/join-prune-mtu"); value.Exists() {
		data.JoinPruneMtu = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/propagation-delay"); value.Exists() {
		data.PropagationDelay = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/override-interval"); value.Exists() {
		data.OverrideInterval = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/routes/maximum-routes"); value.Exists() {
		data.GlobalMaximumRoutes = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/routes/threshold"); value.Exists() {
		data.GlobalMaximumRoutesThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/route-interfaces/maximum-route-interfaces"); value.Exists() {
		data.GlobalMaximumRouteInterfaces = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/route-interfaces/threshold"); value.Exists() {
		data.GlobalMaximumRouteInterfacesThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/register-states/maximum-register-states"); value.Exists() {
		data.GlobalMaximumRegisterStates = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/register-states/threshold"); value.Exists() {
		data.GlobalMaximumRegisterStatesThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/packet-queue/high-priority"); value.Exists() {
		data.GlobalMaximumPacketQueueHighPriority = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/packet-queue/low-priority"); value.Exists() {
		data.GlobalMaximumPacketQueueLowPriority = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/group-mappings/bsr/maximum-bsr"); value.Exists() {
		data.GlobalMaximumGroupMappingsBsr = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/group-mappings/bsr/threshold"); value.Exists() {
		data.GlobalMaximumGroupMappingsBsrThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/group-mappings/autorp/maximum-autorp"); value.Exists() {
		data.GlobalMaximumGroupMappingsAutorp = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/group-mappings/autorp/threshold"); value.Exists() {
		data.GlobalMaximumGroupMappingsAutorpThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/bsr/crp-cache/maximum-crp-cache"); value.Exists() {
		data.GlobalMaximumBsrCrpCacheMaximum = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/bsr/crp-cache/threshold"); value.Exists() {
		data.GlobalMaximumBsrCrpCacheThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/routes/maximum-routes"); value.Exists() {
		data.MaximumRoutes = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/routes/threshold"); value.Exists() {
		data.MaximumRoutesThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/route-interfaces/maximum-route-interfaces"); value.Exists() {
		data.MaximumRouteInterfaces = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/route-interfaces/threshold"); value.Exists() {
		data.MaximumRouteInterfacesThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/register-states/maximum-register-states"); value.Exists() {
		data.MaximumRegisterStates = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/register-states/threshold"); value.Exists() {
		data.MaximumRegisterStatesThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/group-mappings/bsr/maximum-bsr"); value.Exists() {
		data.MaximumGroupMappingsBsr = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/group-mappings/bsr/threshold"); value.Exists() {
		data.MaximumGroupMappingsBsrThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/group-mappings/autorp/maximum-autorp"); value.Exists() {
		data.MaximumGroupMappingsAutorp = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/group-mappings/autorp/threshold"); value.Exists() {
		data.MaximumGroupMappingsAutorpThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/bsr/crp-cache/maximum-crp-cache"); value.Exists() {
		data.MaximumBsrCrpCacheMaximum = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/bsr/crp-cache/threshold"); value.Exists() {
		data.MaximumBsrCrpCacheThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/log/neighbor/changes"); value.Exists() {
		data.LogNeighborChanges = types.BoolValue(true)
	} else {
		data.LogNeighborChanges = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rpf-vector/allow-ebgp"); value.Exists() {
		data.RpfVectorAllowEbgp = types.BoolValue(true)
	} else {
		data.RpfVectorAllowEbgp = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rpf-vector/disable-ibgp"); value.Exists() {
		data.RpfVectorDisableIbgp = types.BoolValue(true)
	} else {
		data.RpfVectorDisableIbgp = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rpf-vector/use-standard-encoding"); value.Exists() {
		data.RpfVectorStandardEncoding = types.BoolValue(true)
	} else {
		data.RpfVectorStandardEncoding = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rpf-vector-injects/inject"); value.Exists() {
		data.RpfVectorInjects = make([]RouterPIMIPv4RpfVectorInjects, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4RpfVectorInjects{}
			if cValue := helpers.GetFromXPath(v, "source-address"); cValue.Exists() {
				item.SourceAddress = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "masklen"); cValue.Exists() {
				item.SourceMask = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "rpf-vector"); cValue.Exists() {
				item.RpfVectors = helpers.GetStringListXML(cValue.Array())
			} else {
				item.RpfVectors = types.ListNull(types.StringType)
			}
			data.RpfVectorInjects = append(data.RpfVectorInjects, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/explicit-rpf-vector/injects/inject"); value.Exists() {
		data.ExplicitRpfVectorInjects = make([]RouterPIMIPv4ExplicitRpfVectorInjects, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4ExplicitRpfVectorInjects{}
			if cValue := helpers.GetFromXPath(v, "source-address"); cValue.Exists() {
				item.SourceAddress = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "masklen"); cValue.Exists() {
				item.SourceMask = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "rpf-vector"); cValue.Exists() {
				item.RpfVectors = helpers.GetStringListXML(cValue.Array())
			} else {
				item.RpfVectors = types.ListNull(types.StringType)
			}
			data.ExplicitRpfVectorInjects = append(data.ExplicitRpfVectorInjects, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rpf/topology/route-policy"); value.Exists() {
		data.RpfTopologyRoutePolicy = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/neighbor-filter"); value.Exists() {
		data.MdtNeighborFilter = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/data/switchover-interval"); value.Exists() {
		data.MdtDataSwitchoverInterval = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/data/announce-interval"); value.Exists() {
		data.MdtDataAnnounceInterval = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/type"); value.Exists() {
		data.MdtCMulticastType = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/announce-pim-join-tlv"); value.Exists() {
		data.MdtCMulticastAnnouncePimJoinTlv = types.BoolValue(true)
	} else {
		data.MdtCMulticastAnnouncePimJoinTlv = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/shared-tree-prune"); value.Exists() {
		data.MdtCMulticastSharedTreePrune = types.BoolValue(true)
	} else {
		data.MdtCMulticastSharedTreePrune = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/suppress-shared-tree-join"); value.Exists() {
		data.MdtCMulticastSuppressSharedTreeJoin = types.BoolValue(true)
	} else {
		data.MdtCMulticastSuppressSharedTreeJoin = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/suppress-pim-data-signaling"); value.Exists() {
		data.MdtCMulticastSuppressPimDataSignaling = types.BoolValue(true)
	} else {
		data.MdtCMulticastSuppressPimDataSignaling = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/mdt-hello/enable"); value.Exists() {
		data.MdtCMulticastHelloEnable = types.BoolValue(true)
	} else {
		data.MdtCMulticastHelloEnable = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/shared-tree-prune-delay"); value.Exists() {
		data.MdtCMulticastSharedTreePruneDelay = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/source-tree-prune-delay"); value.Exists() {
		data.MdtCMulticastSourceTreePruneDelay = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/migration/route-policy"); value.Exists() {
		data.MdtCMulticastMigrationRoutePolicy = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/allow-rp"); value.Exists() {
		data.AllowRp = types.BoolValue(true)
	} else {
		data.AllowRp = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/allow-rp/rp-list"); value.Exists() {
		data.AllowRpList = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/allow-rp/group-list"); value.Exists() {
		data.AllowRpGroupList = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sg-expiry-timer/sg-expiry-timer-value"); value.Exists() {
		data.SgExpiryTimer = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sg-expiry-timer/sg-list"); value.Exists() {
		data.SgList = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/ssm/range"); value.Exists() {
		data.SsmRange = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/ssm/disable"); value.Exists() {
		data.SsmDisable = types.BoolValue(true)
	} else {
		data.SsmDisable = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/ssm/allow-override"); value.Exists() {
		data.SsmAllowOverride = types.BoolValue(true)
	} else {
		data.SsmAllowOverride = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rpf-redirect/route-policy"); value.Exists() {
		data.RpfRedirectRoutePolicy = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/multipath"); value.Exists() {
		data.Multipath = types.BoolValue(true)
	} else {
		data.Multipath = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/multipath/hash/source"); value.Exists() {
		data.MultipathHashSource = types.BoolValue(true)
	} else {
		data.MultipathHashSource = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/multipath/hash/source-nexthop"); value.Exists() {
		data.MultipathHashSourceNexthop = types.BoolValue(true)
	} else {
		data.MultipathHashSourceNexthop = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/multipath/hash/source-group"); value.Exists() {
		data.MultipathHashSourceGroup = types.BoolValue(true)
	} else {
		data.MultipathHashSourceGroup = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/auto-rp/mapping-agent/interface-name"); value.Exists() {
		data.AutoRpMappingAgentInterface = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/auto-rp/mapping-agent/scope"); value.Exists() {
		data.AutoRpMappingAgentScope = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/auto-rp/mapping-agent/interval"); value.Exists() {
		data.AutoRpMappingAgentInterval = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/auto-rp/candidate-rps/candidate-rp"); value.Exists() {
		data.AutoRpCandidateRps = make([]RouterPIMIPv4AutoRpCandidateRps, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4AutoRpCandidateRps{}
			if cValue := helpers.GetFromXPath(v, "interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "scope"); cValue.Exists() {
				item.Scope = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "group-list"); cValue.Exists() {
				item.GroupList = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "interval"); cValue.Exists() {
				item.Interval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "bidir/scope"); cValue.Exists() {
				item.BidirScope = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "bidir/group-list"); cValue.Exists() {
				item.BidirGroupList = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "bidir/interval"); cValue.Exists() {
				item.BidirInterval = types.Int64Value(cValue.Int())
			}
			data.AutoRpCandidateRps = append(data.AutoRpCandidateRps, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/auto-rp/listen/disable"); value.Exists() {
		data.AutoRpListenDisable = types.BoolValue(true)
	} else {
		data.AutoRpListenDisable = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/auto-rp/relay/vrfs/vrf"); value.Exists() {
		data.AutoRpRelayVrfs = make([]RouterPIMIPv4AutoRpRelayVrfs, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4AutoRpRelayVrfs{}
			if cValue := helpers.GetFromXPath(v, "vrf-name"); cValue.Exists() {
				item.VrfName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "listen"); cValue.Exists() {
				item.Listen = types.BoolValue(true)
			} else {
				item.Listen = types.BoolNull()
			}
			data.AutoRpRelayVrfs = append(data.AutoRpRelayVrfs, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/bsr/candidate-bsr/address"); value.Exists() {
		data.BsrCandidateBsrAddress = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/bsr/candidate-bsr/hash-mask-len"); value.Exists() {
		data.BsrCandidateBsrHashMaskLen = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/bsr/candidate-bsr/priority"); value.Exists() {
		data.BsrCandidateBsrPriority = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/bsr/candidate-rps/candidate-rp"); value.Exists() {
		data.BsrCandidateRps = make([]RouterPIMIPv4BsrCandidateRps, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4BsrCandidateRps{}
			if cValue := helpers.GetFromXPath(v, "address"); cValue.Exists() {
				item.Address = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "group-list"); cValue.Exists() {
				item.GroupList = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "priority"); cValue.Exists() {
				item.Priority = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "interval"); cValue.Exists() {
				item.Interval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "bidir/group-list"); cValue.Exists() {
				item.BidirGroupList = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "bidir/priority"); cValue.Exists() {
				item.BidirPriority = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "bidir/interval"); cValue.Exists() {
				item.BidirInterval = types.Int64Value(cValue.Int())
			}
			data.BsrCandidateRps = append(data.BsrCandidateRps, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/bsr/relay/vrfs/vrf"); value.Exists() {
		data.BsrRelayVrfs = make([]RouterPIMIPv4BsrRelayVrfs, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4BsrRelayVrfs{}
			if cValue := helpers.GetFromXPath(v, "vrf-name"); cValue.Exists() {
				item.VrfName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "listen"); cValue.Exists() {
				item.Listen = types.BoolValue(true)
			} else {
				item.Listen = types.BoolNull()
			}
			data.BsrRelayVrfs = append(data.BsrRelayVrfs, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr"); value.Exists() {
		data.Mofrr = types.BoolValue(true)
	} else {
		data.Mofrr = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr/flow"); value.Exists() {
		data.MofrrFlow = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr/rib"); value.Exists() {
		data.MofrrRib = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr/protect"); value.Exists() {
		data.MofrrProtect = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr/local-fault-only"); value.Exists() {
		data.MofrrProtectLocalFaultOnly = types.BoolValue(true)
	} else {
		data.MofrrProtectLocalFaultOnly = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr/non-revertive"); value.Exists() {
		data.MofrrNonRevertive = types.BoolValue(true)
	} else {
		data.MofrrNonRevertive = types.BoolNull()
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr/clone/joins/join"); value.Exists() {
		data.MofrrCloneJoins = make([]RouterPIMIPv4MofrrCloneJoins, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4MofrrCloneJoins{}
			if cValue := helpers.GetFromXPath(v, "address"); cValue.Exists() {
				item.SourceAddress = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "to"); cValue.Exists() {
				item.To = make([]RouterPIMIPv4MofrrCloneJoinsTo, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := RouterPIMIPv4MofrrCloneJoinsTo{}
					if ccValue := helpers.GetFromXPath(cv, "address"); ccValue.Exists() {
						cItem.PrimaryAddress = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "and"); ccValue.Exists() {
						cItem.And = make([]RouterPIMIPv4MofrrCloneJoinsToAnd, 0)
						ccValue.ForEach(func(_ int, ccv xmldot.Result) bool {
							ccItem := RouterPIMIPv4MofrrCloneJoinsToAnd{}
							if cccValue := helpers.GetFromXPath(ccv, "address"); cccValue.Exists() {
								ccItem.BackupAddress = types.StringValue(cccValue.String())
							}
							if cccValue := helpers.GetFromXPath(ccv, ""); cccValue.Exists() {
								ccItem.Masklen = make([]RouterPIMIPv4MofrrCloneJoinsToAndMasklen, 0)
								cccValue.ForEach(func(_ int, cccv xmldot.Result) bool {
									cccItem := RouterPIMIPv4MofrrCloneJoinsToAndMasklen{}
									if ccccValue := helpers.GetFromXPath(cccv, ""); ccccValue.Exists() {
										cccItem.MaskLength = types.Int64Value(ccccValue.Int())
									}
									ccItem.Masklen = append(ccItem.Masklen, cccItem)
									return true
								})
							}
							cItem.And = append(cItem.And, ccItem)
							return true
						})
					}
					item.To = append(item.To, cItem)
					return true
				})
			}
			data.MofrrCloneJoins = append(data.MofrrCloneJoins, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr/clone/sources/source"); value.Exists() {
		data.MofrrCloneSources = make([]RouterPIMIPv4MofrrCloneSources, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4MofrrCloneSources{}
			if cValue := helpers.GetFromXPath(v, "address"); cValue.Exists() {
				item.SourceAddress = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "to"); cValue.Exists() {
				item.To = make([]RouterPIMIPv4MofrrCloneSourcesTo, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := RouterPIMIPv4MofrrCloneSourcesTo{}
					if ccValue := helpers.GetFromXPath(cv, "address"); ccValue.Exists() {
						cItem.PrimaryAddress = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "and"); ccValue.Exists() {
						cItem.And = make([]RouterPIMIPv4MofrrCloneSourcesToAnd, 0)
						ccValue.ForEach(func(_ int, ccv xmldot.Result) bool {
							ccItem := RouterPIMIPv4MofrrCloneSourcesToAnd{}
							if cccValue := helpers.GetFromXPath(ccv, "address"); cccValue.Exists() {
								ccItem.BackupAddress = types.StringValue(cccValue.String())
							}
							if cccValue := helpers.GetFromXPath(ccv, ""); cccValue.Exists() {
								ccItem.Masklen = make([]RouterPIMIPv4MofrrCloneSourcesToAndMasklen, 0)
								cccValue.ForEach(func(_ int, cccv xmldot.Result) bool {
									cccItem := RouterPIMIPv4MofrrCloneSourcesToAndMasklen{}
									if ccccValue := helpers.GetFromXPath(cccv, ""); ccccValue.Exists() {
										cccItem.MaskLength = types.Int64Value(ccccValue.Int())
									}
									ccItem.Masklen = append(ccItem.Masklen, cccItem)
									return true
								})
							}
							cItem.And = append(cItem.And, ccItem)
							return true
						})
					}
					item.To = append(item.To, cItem)
					return true
				})
			}
			data.MofrrCloneSources = append(data.MofrrCloneSources, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sr-p2mp-policies/sr-p2mp-policy"); value.Exists() {
		data.SrP2mpPolicies = make([]RouterPIMIPv4SrP2mpPolicies, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4SrP2mpPolicies{}
			if cValue := helpers.GetFromXPath(v, "sr-p2mp-policy-id"); cValue.Exists() {
				item.PolicyName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "static-group/group-address"); cValue.Exists() {
				item.StaticGroups = make([]RouterPIMIPv4SrP2mpPoliciesStaticGroups, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := RouterPIMIPv4SrP2mpPoliciesStaticGroups{}
					if ccValue := helpers.GetFromXPath(cv, "group-address"); ccValue.Exists() {
						cItem.GroupAddress = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "group-address-only"); ccValue.Exists() {
						cItem.GroupAddressOnly = types.BoolValue(true)
					} else {
						cItem.GroupAddressOnly = types.BoolNull()
					}
					if ccValue := helpers.GetFromXPath(cv, "group-address-inc-mask"); ccValue.Exists() {
						cItem.GroupMasks = make([]RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasks, 0)
						ccValue.ForEach(func(_ int, ccv xmldot.Result) bool {
							ccItem := RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasks{}
							if cccValue := helpers.GetFromXPath(ccv, "group-mask-address"); cccValue.Exists() {
								ccItem.GroupIncMask = types.StringValue(cccValue.String())
							}
							if cccValue := helpers.GetFromXPath(ccv, "group-address-count"); cccValue.Exists() {
								ccItem.GroupCount = types.Int64Value(cccValue.Int())
							}
							cItem.GroupMasks = append(cItem.GroupMasks, ccItem)
							return true
						})
					}
					if ccValue := helpers.GetFromXPath(cv, "group-mask-address-source-address-inc-mask"); ccValue.Exists() {
						cItem.GroupMasksSourceAddresses = make([]RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasksSourceAddresses, 0)
						ccValue.ForEach(func(_ int, ccv xmldot.Result) bool {
							ccItem := RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasksSourceAddresses{}
							if cccValue := helpers.GetFromXPath(ccv, "group-mask-address"); cccValue.Exists() {
								ccItem.GroupIncMask = types.StringValue(cccValue.String())
							}
							if cccValue := helpers.GetFromXPath(ccv, "source-address"); cccValue.Exists() {
								ccItem.SourceIp = types.StringValue(cccValue.String())
							}
							if cccValue := helpers.GetFromXPath(ccv, "group-address-count"); cccValue.Exists() {
								ccItem.GroupCount = types.Int64Value(cccValue.Int())
							}
							cItem.GroupMasksSourceAddresses = append(cItem.GroupMasksSourceAddresses, ccItem)
							return true
						})
					}
					if ccValue := helpers.GetFromXPath(cv, "source-address-source-mask-address-inc-mask"); ccValue.Exists() {
						cItem.SourceMasks = make([]RouterPIMIPv4SrP2mpPoliciesStaticGroupsSourceMasks, 0)
						ccValue.ForEach(func(_ int, ccv xmldot.Result) bool {
							ccItem := RouterPIMIPv4SrP2mpPoliciesStaticGroupsSourceMasks{}
							if cccValue := helpers.GetFromXPath(ccv, "source-address"); cccValue.Exists() {
								ccItem.SourceIp = types.StringValue(cccValue.String())
							}
							if cccValue := helpers.GetFromXPath(ccv, "source-mask-address"); cccValue.Exists() {
								ccItem.SourceIncMask = types.StringValue(cccValue.String())
							}
							if cccValue := helpers.GetFromXPath(ccv, "source-address-count"); cccValue.Exists() {
								ccItem.SourceCount = types.Int64Value(cccValue.Int())
							}
							cItem.SourceMasks = append(cItem.SourceMasks, ccItem)
							return true
						})
					}
					if ccValue := helpers.GetFromXPath(cv, "group-mask-address-source-address-source-mask-address-inc-mask"); ccValue.Exists() {
						cItem.GroupMasksSourceMasks = make([]RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasksSourceMasks, 0)
						ccValue.ForEach(func(_ int, ccv xmldot.Result) bool {
							ccItem := RouterPIMIPv4SrP2mpPoliciesStaticGroupsGroupMasksSourceMasks{}
							if cccValue := helpers.GetFromXPath(ccv, "group-mask-address"); cccValue.Exists() {
								ccItem.GroupIncMask = types.StringValue(cccValue.String())
							}
							if cccValue := helpers.GetFromXPath(ccv, "source-address"); cccValue.Exists() {
								ccItem.SourceIp = types.StringValue(cccValue.String())
							}
							if cccValue := helpers.GetFromXPath(ccv, "source-mask-address"); cccValue.Exists() {
								ccItem.SourceIncMask = types.StringValue(cccValue.String())
							}
							if cccValue := helpers.GetFromXPath(ccv, "group-address-count"); cccValue.Exists() {
								ccItem.GroupCount = types.Int64Value(cccValue.Int())
							}
							if cccValue := helpers.GetFromXPath(ccv, "source-address-count"); cccValue.Exists() {
								ccItem.SourceCount = types.Int64Value(cccValue.Int())
							}
							cItem.GroupMasksSourceMasks = append(cItem.GroupMasksSourceMasks, ccItem)
							return true
						})
					}
					item.StaticGroups = append(item.StaticGroups, cItem)
					return true
				})
			}
			data.SrP2mpPolicies = append(data.SrP2mpPolicies, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/interfaces/interface"); value.Exists() {
		data.Interfaces = make([]RouterPIMIPv4Interfaces, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4Interfaces{}
			if cValue := helpers.GetFromXPath(v, "interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "enable"); cValue.Exists() {
				item.Enable = types.BoolValue(true)
			} else {
				item.Enable = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "disable"); cValue.Exists() {
				item.Disable = types.BoolValue(true)
			} else {
				item.Disable = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "dr-priority"); cValue.Exists() {
				item.DrPriority = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "hello-interval"); cValue.Exists() {
				item.HelloInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "join-prune-interval"); cValue.Exists() {
				item.JoinPruneInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "join-prune-mtu"); cValue.Exists() {
				item.JoinPruneMtu = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "propagation-delay"); cValue.Exists() {
				item.PropagationDelay = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "override-interval"); cValue.Exists() {
				item.OverrideInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "neighbor-filter"); cValue.Exists() {
				item.NeighborFilter = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "maximum/route-interfaces/maximum-route-interfaces"); cValue.Exists() {
				item.MaximumRouteInterfaces = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "maximum/route-interfaces/threshold"); cValue.Exists() {
				item.MaximumRouteInterfacesThreshold = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "maximum/route-interfaces/access-list"); cValue.Exists() {
				item.MaximumRouteInterfacesAccessList = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "bfd/multiplier"); cValue.Exists() {
				item.BfdMultiplier = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "bfd/minimum-interval"); cValue.Exists() {
				item.BfdMinimumInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "bfd/fast-detect"); cValue.Exists() {
				item.BfdFastDetect = types.BoolValue(true)
			} else {
				item.BfdFastDetect = types.BoolNull()
			}
			if cValue := helpers.GetFromXPath(v, "bsr-border"); cValue.Exists() {
				item.BsrBorder = types.BoolValue(true)
			} else {
				item.BsrBorder = types.BoolNull()
			}
			data.Interfaces = append(data.Interfaces, item)
			return true
		})
	}
}

// End of section. //template:end fromBodyXML
// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyDataXML

func (data *RouterPIMIPv4Data) fromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rp-addresses/rp-address"); value.Exists() {
		data.RpAddresses = make([]RouterPIMIPv4RpAddresses, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4RpAddresses{}
			if cValue := helpers.GetFromXPath(v, "address"); cValue.Exists() {
				item.Address = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "access-list"); cValue.Exists() {
				item.AccessList = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "override"); cValue.Exists() {
				item.Override = types.BoolValue(true)
			} else {
				item.Override = types.BoolValue(false)
			}
			data.RpAddresses = append(data.RpAddresses, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rp-addresses/bidir/rp-address"); value.Exists() {
		data.RpAddressesBidir = make([]RouterPIMIPv4RpAddressesBidir, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4RpAddressesBidir{}
			if cValue := helpers.GetFromXPath(v, "address"); cValue.Exists() {
				item.Address = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "access-list"); cValue.Exists() {
				item.AccessList = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "override"); cValue.Exists() {
				item.Override = types.BoolValue(true)
			} else {
				item.Override = types.BoolValue(false)
			}
			data.RpAddressesBidir = append(data.RpAddressesBidir, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rp-static-deny"); value.Exists() {
		data.RpStaticDeny = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/accept-register"); value.Exists() {
		data.AcceptRegister = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/suppress-data-registers"); value.Exists() {
		data.SuppressDataRegisters = types.BoolValue(true)
	} else {
		data.SuppressDataRegisters = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/register-source"); value.Exists() {
		data.RegisterSource = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/suppress-rpf-change-prunes"); value.Exists() {
		data.SuppressRpfChangePrunes = types.BoolValue(true)
	} else {
		data.SuppressRpfChangePrunes = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/neighbor-filter"); value.Exists() {
		data.NeighborFilter = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/convergence/rpf-conflict-join-delay"); value.Exists() {
		data.ConvergenceRpfConflictJoinDelay = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/convergence/link-down-prune-delay"); value.Exists() {
		data.ConvergenceLinkDownPruneDelay = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/spt-threshold/infinity"); value.Exists() {
		data.SptThresholdInfinity = types.BoolValue(true)
	} else {
		data.SptThresholdInfinity = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/spt-threshold/infinity/group-list"); value.Exists() {
		data.SptThresholdInfinityGroupList = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/old-register-checksum"); value.Exists() {
		data.OldRegisterChecksum = types.BoolValue(true)
	} else {
		data.OldRegisterChecksum = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/nsf/lifetime"); value.Exists() {
		data.NsfLifetime = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/neighbor-check-on-send/enable"); value.Exists() {
		data.NeighborCheckOnSend = types.BoolValue(true)
	} else {
		data.NeighborCheckOnSend = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/neighbor-check-on-recv/enable"); value.Exists() {
		data.NeighborCheckOnRecv = types.BoolValue(true)
	} else {
		data.NeighborCheckOnRecv = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/hello-interval"); value.Exists() {
		data.HelloInterval = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt-hello-interval"); value.Exists() {
		data.MdtHelloInterval = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/dr-priority"); value.Exists() {
		data.DrPriority = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/join-prune-interval"); value.Exists() {
		data.JoinPruneInterval = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/join-prune-mtu"); value.Exists() {
		data.JoinPruneMtu = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/propagation-delay"); value.Exists() {
		data.PropagationDelay = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/override-interval"); value.Exists() {
		data.OverrideInterval = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/routes/maximum-routes"); value.Exists() {
		data.GlobalMaximumRoutes = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/routes/threshold"); value.Exists() {
		data.GlobalMaximumRoutesThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/route-interfaces/maximum-route-interfaces"); value.Exists() {
		data.GlobalMaximumRouteInterfaces = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/route-interfaces/threshold"); value.Exists() {
		data.GlobalMaximumRouteInterfacesThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/register-states/maximum-register-states"); value.Exists() {
		data.GlobalMaximumRegisterStates = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/register-states/threshold"); value.Exists() {
		data.GlobalMaximumRegisterStatesThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/packet-queue/high-priority"); value.Exists() {
		data.GlobalMaximumPacketQueueHighPriority = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/packet-queue/low-priority"); value.Exists() {
		data.GlobalMaximumPacketQueueLowPriority = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/group-mappings/bsr/maximum-bsr"); value.Exists() {
		data.GlobalMaximumGroupMappingsBsr = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/group-mappings/bsr/threshold"); value.Exists() {
		data.GlobalMaximumGroupMappingsBsrThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/group-mappings/autorp/maximum-autorp"); value.Exists() {
		data.GlobalMaximumGroupMappingsAutorp = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/group-mappings/autorp/threshold"); value.Exists() {
		data.GlobalMaximumGroupMappingsAutorpThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/bsr/crp-cache/maximum-crp-cache"); value.Exists() {
		data.GlobalMaximumBsrCrpCacheMaximum = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/global/maximum/bsr/crp-cache/threshold"); value.Exists() {
		data.GlobalMaximumBsrCrpCacheThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/routes/maximum-routes"); value.Exists() {
		data.MaximumRoutes = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/routes/threshold"); value.Exists() {
		data.MaximumRoutesThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/route-interfaces/maximum-route-interfaces"); value.Exists() {
		data.MaximumRouteInterfaces = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/route-interfaces/threshold"); value.Exists() {
		data.MaximumRouteInterfacesThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/register-states/maximum-register-states"); value.Exists() {
		data.MaximumRegisterStates = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/register-states/threshold"); value.Exists() {
		data.MaximumRegisterStatesThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/group-mappings/bsr/maximum-bsr"); value.Exists() {
		data.MaximumGroupMappingsBsr = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/group-mappings/bsr/threshold"); value.Exists() {
		data.MaximumGroupMappingsBsrThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/group-mappings/autorp/maximum-autorp"); value.Exists() {
		data.MaximumGroupMappingsAutorp = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/group-mappings/autorp/threshold"); value.Exists() {
		data.MaximumGroupMappingsAutorpThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/bsr/crp-cache/maximum-crp-cache"); value.Exists() {
		data.MaximumBsrCrpCacheMaximum = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/maximum/bsr/crp-cache/threshold"); value.Exists() {
		data.MaximumBsrCrpCacheThreshold = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/log/neighbor/changes"); value.Exists() {
		data.LogNeighborChanges = types.BoolValue(true)
	} else {
		data.LogNeighborChanges = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rpf-vector/allow-ebgp"); value.Exists() {
		data.RpfVectorAllowEbgp = types.BoolValue(true)
	} else {
		data.RpfVectorAllowEbgp = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rpf-vector/disable-ibgp"); value.Exists() {
		data.RpfVectorDisableIbgp = types.BoolValue(true)
	} else {
		data.RpfVectorDisableIbgp = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rpf-vector/use-standard-encoding"); value.Exists() {
		data.RpfVectorStandardEncoding = types.BoolValue(true)
	} else {
		data.RpfVectorStandardEncoding = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rpf-vector-injects/inject"); value.Exists() {
		data.RpfVectorInjects = make([]RouterPIMIPv4RpfVectorInjects, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4RpfVectorInjects{}
			if cValue := helpers.GetFromXPath(v, "source-address"); cValue.Exists() {
				item.SourceAddress = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "masklen"); cValue.Exists() {
				item.SourceMask = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "rpf-vector"); cValue.Exists() {
				item.RpfVectors = helpers.GetStringListXML(cValue.Array())
			} else {
				item.RpfVectors = types.ListNull(types.StringType)
			}
			data.RpfVectorInjects = append(data.RpfVectorInjects, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/explicit-rpf-vector/injects/inject"); value.Exists() {
		data.ExplicitRpfVectorInjects = make([]RouterPIMIPv4ExplicitRpfVectorInjects, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4ExplicitRpfVectorInjects{}
			if cValue := helpers.GetFromXPath(v, "source-address"); cValue.Exists() {
				item.SourceAddress = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "masklen"); cValue.Exists() {
				item.SourceMask = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "rpf-vector"); cValue.Exists() {
				item.RpfVectors = helpers.GetStringListXML(cValue.Array())
			} else {
				item.RpfVectors = types.ListNull(types.StringType)
			}
			data.ExplicitRpfVectorInjects = append(data.ExplicitRpfVectorInjects, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rpf/topology/route-policy"); value.Exists() {
		data.RpfTopologyRoutePolicy = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/neighbor-filter"); value.Exists() {
		data.MdtNeighborFilter = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/data/switchover-interval"); value.Exists() {
		data.MdtDataSwitchoverInterval = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/data/announce-interval"); value.Exists() {
		data.MdtDataAnnounceInterval = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/type"); value.Exists() {
		data.MdtCMulticastType = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/announce-pim-join-tlv"); value.Exists() {
		data.MdtCMulticastAnnouncePimJoinTlv = types.BoolValue(true)
	} else {
		data.MdtCMulticastAnnouncePimJoinTlv = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/shared-tree-prune"); value.Exists() {
		data.MdtCMulticastSharedTreePrune = types.BoolValue(true)
	} else {
		data.MdtCMulticastSharedTreePrune = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/suppress-shared-tree-join"); value.Exists() {
		data.MdtCMulticastSuppressSharedTreeJoin = types.BoolValue(true)
	} else {
		data.MdtCMulticastSuppressSharedTreeJoin = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/suppress-pim-data-signaling"); value.Exists() {
		data.MdtCMulticastSuppressPimDataSignaling = types.BoolValue(true)
	} else {
		data.MdtCMulticastSuppressPimDataSignaling = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/mdt-hello/enable"); value.Exists() {
		data.MdtCMulticastHelloEnable = types.BoolValue(true)
	} else {
		data.MdtCMulticastHelloEnable = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/shared-tree-prune-delay"); value.Exists() {
		data.MdtCMulticastSharedTreePruneDelay = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/source-tree-prune-delay"); value.Exists() {
		data.MdtCMulticastSourceTreePruneDelay = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mdt/c-multicast-routing/migration/route-policy"); value.Exists() {
		data.MdtCMulticastMigrationRoutePolicy = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/allow-rp"); value.Exists() {
		data.AllowRp = types.BoolValue(true)
	} else {
		data.AllowRp = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/allow-rp/rp-list"); value.Exists() {
		data.AllowRpList = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/allow-rp/group-list"); value.Exists() {
		data.AllowRpGroupList = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sg-expiry-timer/sg-expiry-timer-value"); value.Exists() {
		data.SgExpiryTimer = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sg-expiry-timer/sg-list"); value.Exists() {
		data.SgList = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/ssm/range"); value.Exists() {
		data.SsmRange = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/ssm/disable"); value.Exists() {
		data.SsmDisable = types.BoolValue(true)
	} else {
		data.SsmDisable = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/ssm/allow-override"); value.Exists() {
		data.SsmAllowOverride = types.BoolValue(true)
	} else {
		data.SsmAllowOverride = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/rpf-redirect/route-policy"); value.Exists() {
		data.RpfRedirectRoutePolicy = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/multipath"); value.Exists() {
		data.Multipath = types.BoolValue(true)
	} else {
		data.Multipath = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/multipath/hash/source"); value.Exists() {
		data.MultipathHashSource = types.BoolValue(true)
	} else {
		data.MultipathHashSource = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/multipath/hash/source-nexthop"); value.Exists() {
		data.MultipathHashSourceNexthop = types.BoolValue(true)
	} else {
		data.MultipathHashSourceNexthop = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/multipath/hash/source-group"); value.Exists() {
		data.MultipathHashSourceGroup = types.BoolValue(true)
	} else {
		data.MultipathHashSourceGroup = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/auto-rp/mapping-agent/interface-name"); value.Exists() {
		data.AutoRpMappingAgentInterface = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/auto-rp/mapping-agent/scope"); value.Exists() {
		data.AutoRpMappingAgentScope = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/auto-rp/mapping-agent/interval"); value.Exists() {
		data.AutoRpMappingAgentInterval = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/auto-rp/candidate-rps/candidate-rp"); value.Exists() {
		data.AutoRpCandidateRps = make([]RouterPIMIPv4AutoRpCandidateRps, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4AutoRpCandidateRps{}
			if cValue := helpers.GetFromXPath(v, "interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "scope"); cValue.Exists() {
				item.Scope = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "group-list"); cValue.Exists() {
				item.GroupList = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "interval"); cValue.Exists() {
				item.Interval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "bidir/scope"); cValue.Exists() {
				item.BidirScope = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "bidir/group-list"); cValue.Exists() {
				item.BidirGroupList = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "bidir/interval"); cValue.Exists() {
				item.BidirInterval = types.Int64Value(cValue.Int())
			}
			data.AutoRpCandidateRps = append(data.AutoRpCandidateRps, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/auto-rp/listen/disable"); value.Exists() {
		data.AutoRpListenDisable = types.BoolValue(true)
	} else {
		data.AutoRpListenDisable = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/auto-rp/relay/vrfs/vrf"); value.Exists() {
		data.AutoRpRelayVrfs = make([]RouterPIMIPv4AutoRpRelayVrfs, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4AutoRpRelayVrfs{}
			if cValue := helpers.GetFromXPath(v, "vrf-name"); cValue.Exists() {
				item.VrfName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "listen"); cValue.Exists() {
				item.Listen = types.BoolValue(true)
			} else {
				item.Listen = types.BoolValue(false)
			}
			data.AutoRpRelayVrfs = append(data.AutoRpRelayVrfs, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/bsr/candidate-bsr/address"); value.Exists() {
		data.BsrCandidateBsrAddress = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/bsr/candidate-bsr/hash-mask-len"); value.Exists() {
		data.BsrCandidateBsrHashMaskLen = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/bsr/candidate-bsr/priority"); value.Exists() {
		data.BsrCandidateBsrPriority = types.Int64Value(value.Int())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/bsr/candidate-rps/candidate-rp"); value.Exists() {
		data.BsrCandidateRps = make([]RouterPIMIPv4BsrCandidateRps, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4BsrCandidateRps{}
			if cValue := helpers.GetFromXPath(v, "address"); cValue.Exists() {
				item.Address = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "group-list"); cValue.Exists() {
				item.GroupList = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "priority"); cValue.Exists() {
				item.Priority = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "interval"); cValue.Exists() {
				item.Interval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "bidir/group-list"); cValue.Exists() {
				item.BidirGroupList = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "bidir/priority"); cValue.Exists() {
				item.BidirPriority = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "bidir/interval"); cValue.Exists() {
				item.BidirInterval = types.Int64Value(cValue.Int())
			}
			data.BsrCandidateRps = append(data.BsrCandidateRps, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/bsr/relay/vrfs/vrf"); value.Exists() {
		data.BsrRelayVrfs = make([]RouterPIMIPv4BsrRelayVrfs, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4BsrRelayVrfs{}
			if cValue := helpers.GetFromXPath(v, "vrf-name"); cValue.Exists() {
				item.VrfName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "listen"); cValue.Exists() {
				item.Listen = types.BoolValue(true)
			} else {
				item.Listen = types.BoolValue(false)
			}
			data.BsrRelayVrfs = append(data.BsrRelayVrfs, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr"); value.Exists() {
		data.Mofrr = types.BoolValue(true)
	} else {
		data.Mofrr = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr/flow"); value.Exists() {
		data.MofrrFlow = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr/rib"); value.Exists() {
		data.MofrrRib = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr/protect"); value.Exists() {
		data.MofrrProtect = types.StringValue(value.String())
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr/local-fault-only"); value.Exists() {
		data.MofrrProtectLocalFaultOnly = types.BoolValue(true)
	} else {
		data.MofrrProtectLocalFaultOnly = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr/non-revertive"); value.Exists() {
		data.MofrrNonRevertive = types.BoolValue(true)
	} else {
		data.MofrrNonRevertive = types.BoolValue(false)
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr/clone/joins/join"); value.Exists() {
		data.MofrrCloneJoins = make([]RouterPIMIPv4MofrrCloneJoins, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4MofrrCloneJoins{}
			if cValue := helpers.GetFromXPath(v, "address"); cValue.Exists() {
				item.SourceAddress = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "to"); cValue.Exists() {
				item.To = make([]RouterPIMIPv4MofrrCloneJoinsTo, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := RouterPIMIPv4MofrrCloneJoinsTo{}
					if ccValue := helpers.GetFromXPath(cv, "address"); ccValue.Exists() {
						cItem.PrimaryAddress = types.StringValue(ccValue.String())
					}
					item.To = append(item.To, cItem)
					return true
				})
			}
			data.MofrrCloneJoins = append(data.MofrrCloneJoins, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/mofrr/clone/sources/source"); value.Exists() {
		data.MofrrCloneSources = make([]RouterPIMIPv4MofrrCloneSources, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4MofrrCloneSources{}
			if cValue := helpers.GetFromXPath(v, "address"); cValue.Exists() {
				item.SourceAddress = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "to"); cValue.Exists() {
				item.To = make([]RouterPIMIPv4MofrrCloneSourcesTo, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := RouterPIMIPv4MofrrCloneSourcesTo{}
					if ccValue := helpers.GetFromXPath(cv, "address"); ccValue.Exists() {
						cItem.PrimaryAddress = types.StringValue(ccValue.String())
					}
					item.To = append(item.To, cItem)
					return true
				})
			}
			data.MofrrCloneSources = append(data.MofrrCloneSources, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/sr-p2mp-policies/sr-p2mp-policy"); value.Exists() {
		data.SrP2mpPolicies = make([]RouterPIMIPv4SrP2mpPolicies, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4SrP2mpPolicies{}
			if cValue := helpers.GetFromXPath(v, "sr-p2mp-policy-id"); cValue.Exists() {
				item.PolicyName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "static-group/group-address"); cValue.Exists() {
				item.StaticGroups = make([]RouterPIMIPv4SrP2mpPoliciesStaticGroups, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := RouterPIMIPv4SrP2mpPoliciesStaticGroups{}
					if ccValue := helpers.GetFromXPath(cv, "group-address"); ccValue.Exists() {
						cItem.GroupAddress = types.StringValue(ccValue.String())
					}
					if ccValue := helpers.GetFromXPath(cv, "group-address-only"); ccValue.Exists() {
						cItem.GroupAddressOnly = types.BoolValue(true)
					} else {
					}
					item.StaticGroups = append(item.StaticGroups, cItem)
					return true
				})
			}
			data.SrP2mpPolicies = append(data.SrP2mpPolicies, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data"+data.getXPath()+"/interfaces/interface"); value.Exists() {
		data.Interfaces = make([]RouterPIMIPv4Interfaces, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := RouterPIMIPv4Interfaces{}
			if cValue := helpers.GetFromXPath(v, "interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "enable"); cValue.Exists() {
				item.Enable = types.BoolValue(true)
			} else {
				item.Enable = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "disable"); cValue.Exists() {
				item.Disable = types.BoolValue(true)
			} else {
				item.Disable = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "dr-priority"); cValue.Exists() {
				item.DrPriority = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "hello-interval"); cValue.Exists() {
				item.HelloInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "join-prune-interval"); cValue.Exists() {
				item.JoinPruneInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "join-prune-mtu"); cValue.Exists() {
				item.JoinPruneMtu = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "propagation-delay"); cValue.Exists() {
				item.PropagationDelay = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "override-interval"); cValue.Exists() {
				item.OverrideInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "neighbor-filter"); cValue.Exists() {
				item.NeighborFilter = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "maximum/route-interfaces/maximum-route-interfaces"); cValue.Exists() {
				item.MaximumRouteInterfaces = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "maximum/route-interfaces/threshold"); cValue.Exists() {
				item.MaximumRouteInterfacesThreshold = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "maximum/route-interfaces/access-list"); cValue.Exists() {
				item.MaximumRouteInterfacesAccessList = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "bfd/multiplier"); cValue.Exists() {
				item.BfdMultiplier = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "bfd/minimum-interval"); cValue.Exists() {
				item.BfdMinimumInterval = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "bfd/fast-detect"); cValue.Exists() {
				item.BfdFastDetect = types.BoolValue(true)
			} else {
				item.BfdFastDetect = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "bsr-border"); cValue.Exists() {
				item.BsrBorder = types.BoolValue(true)
			} else {
				item.BsrBorder = types.BoolValue(false)
			}
			data.Interfaces = append(data.Interfaces, item)
			return true
		})
	}
}

// End of section. //template:end fromBodyDataXML
// Section below is generated&owned by "gen/generator.go". //template:begin getDeletedItems

func (data *RouterPIMIPv4) getDeletedItems(ctx context.Context, state RouterPIMIPv4) []string {
	deletedItems := make([]string, 0)
	for i := range state.Interfaces {
		keys := [...]string{"interface-name"}
		stateKeyValues := [...]string{state.Interfaces[i].InterfaceName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.Interfaces[i].InterfaceName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Interfaces {
			found = true
			if state.Interfaces[i].InterfaceName.ValueString() != data.Interfaces[j].InterfaceName.ValueString() {
				found = false
			}
			if found {
				if !state.Interfaces[i].BsrBorder.IsNull() && data.Interfaces[j].BsrBorder.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/bsr-border", state.getPath(), keyString))
				}
				if !state.Interfaces[i].BfdFastDetect.IsNull() && data.Interfaces[j].BfdFastDetect.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/bfd/fast-detect", state.getPath(), keyString))
				}
				if !state.Interfaces[i].BfdMinimumInterval.IsNull() && data.Interfaces[j].BfdMinimumInterval.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/bfd/minimum-interval", state.getPath(), keyString))
				}
				if !state.Interfaces[i].BfdMultiplier.IsNull() && data.Interfaces[j].BfdMultiplier.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/bfd/multiplier", state.getPath(), keyString))
				}
				if !state.Interfaces[i].MaximumRouteInterfacesAccessList.IsNull() && data.Interfaces[j].MaximumRouteInterfacesAccessList.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/maximum/route-interfaces", state.getPath(), keyString))
				}
				if !state.Interfaces[i].MaximumRouteInterfacesThreshold.IsNull() && data.Interfaces[j].MaximumRouteInterfacesThreshold.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/maximum/route-interfaces", state.getPath(), keyString))
				}
				if !state.Interfaces[i].MaximumRouteInterfaces.IsNull() && data.Interfaces[j].MaximumRouteInterfaces.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/maximum/route-interfaces", state.getPath(), keyString))
				}
				if !state.Interfaces[i].NeighborFilter.IsNull() && data.Interfaces[j].NeighborFilter.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/neighbor-filter", state.getPath(), keyString))
				}
				if !state.Interfaces[i].OverrideInterval.IsNull() && data.Interfaces[j].OverrideInterval.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/override-interval", state.getPath(), keyString))
				}
				if !state.Interfaces[i].PropagationDelay.IsNull() && data.Interfaces[j].PropagationDelay.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/propagation-delay", state.getPath(), keyString))
				}
				if !state.Interfaces[i].JoinPruneMtu.IsNull() && data.Interfaces[j].JoinPruneMtu.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/join-prune-mtu", state.getPath(), keyString))
				}
				if !state.Interfaces[i].JoinPruneInterval.IsNull() && data.Interfaces[j].JoinPruneInterval.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/join-prune-interval", state.getPath(), keyString))
				}
				if !state.Interfaces[i].HelloInterval.IsNull() && data.Interfaces[j].HelloInterval.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/hello-interval", state.getPath(), keyString))
				}
				if !state.Interfaces[i].DrPriority.IsNull() && data.Interfaces[j].DrPriority.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/dr-priority", state.getPath(), keyString))
				}
				if !state.Interfaces[i].Disable.IsNull() && data.Interfaces[j].Disable.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/disable", state.getPath(), keyString))
				}
				if !state.Interfaces[i].Enable.IsNull() && data.Interfaces[j].Enable.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/enable", state.getPath(), keyString))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v", state.getPath(), keyString))
		}
	}
	for i := range state.SrP2mpPolicies {
		keys := [...]string{"sr-p2mp-policy-id"}
		stateKeyValues := [...]string{state.SrP2mpPolicies[i].PolicyName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.SrP2mpPolicies[i].PolicyName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.SrP2mpPolicies {
			found = true
			if state.SrP2mpPolicies[i].PolicyName.ValueString() != data.SrP2mpPolicies[j].PolicyName.ValueString() {
				found = false
			}
			if found {
				for ci := range state.SrP2mpPolicies[i].StaticGroups {
					ckeys := [...]string{"group-address"}
					cstateKeyValues := [...]string{state.SrP2mpPolicies[i].StaticGroups[ci].GroupAddress.ValueString()}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.SrP2mpPolicies[i].StaticGroups[ci].GroupAddress.ValueString()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.SrP2mpPolicies[j].StaticGroups {
						found = true
						if state.SrP2mpPolicies[i].StaticGroups[ci].GroupAddress.ValueString() != data.SrP2mpPolicies[j].StaticGroups[cj].GroupAddress.ValueString() {
							found = false
						}
						if found {
							for cci := range state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks {
								cckeys := [...]string{"group-mask-address", "source-address", "source-mask-address"}
								ccstateKeyValues := [...]string{state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].GroupIncMask.ValueString(), state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].SourceIp.ValueString(), state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].SourceIncMask.ValueString()}
								cckeyString := ""
								for ccki := range cckeys {
									cckeyString += "[" + cckeys[ccki] + "=" + ccstateKeyValues[ccki] + "]"
								}

								ccemptyKeys := true
								if !reflect.ValueOf(state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].GroupIncMask.ValueString()).IsZero() {
									ccemptyKeys = false
								}
								if !reflect.ValueOf(state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].SourceIp.ValueString()).IsZero() {
									ccemptyKeys = false
								}
								if !reflect.ValueOf(state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].SourceIncMask.ValueString()).IsZero() {
									ccemptyKeys = false
								}
								if ccemptyKeys {
									continue
								}

								found := false
								for ccj := range data.SrP2mpPolicies[j].StaticGroups[cj].GroupMasksSourceMasks {
									found = true
									if state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].GroupIncMask.ValueString() != data.SrP2mpPolicies[j].StaticGroups[cj].GroupMasksSourceMasks[ccj].GroupIncMask.ValueString() {
										found = false
									}
									if state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].SourceIp.ValueString() != data.SrP2mpPolicies[j].StaticGroups[cj].GroupMasksSourceMasks[ccj].SourceIp.ValueString() {
										found = false
									}
									if state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].SourceIncMask.ValueString() != data.SrP2mpPolicies[j].StaticGroups[cj].GroupMasksSourceMasks[ccj].SourceIncMask.ValueString() {
										found = false
									}
									if found {
										if !state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].SourceCount.IsNull() && data.SrP2mpPolicies[j].StaticGroups[cj].GroupMasksSourceMasks[ccj].SourceCount.IsNull() {
											deletedItems = append(deletedItems, fmt.Sprintf("%v/sr-p2mp-policies/sr-p2mp-policy%v/static-group/group-address%v/group-mask-address-source-address-source-mask-address-inc-mask%v/source-address-count", state.getPath(), keyString, ckeyString, cckeyString))
										}
										if !state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].GroupCount.IsNull() && data.SrP2mpPolicies[j].StaticGroups[cj].GroupMasksSourceMasks[ccj].GroupCount.IsNull() {
											deletedItems = append(deletedItems, fmt.Sprintf("%v/sr-p2mp-policies/sr-p2mp-policy%v/static-group/group-address%v/group-mask-address-source-address-source-mask-address-inc-mask%v/group-address-count", state.getPath(), keyString, ckeyString, cckeyString))
										}
										break
									}
								}
								if !found {
									deletedItems = append(deletedItems, fmt.Sprintf("%v/sr-p2mp-policies/sr-p2mp-policy%v/static-group/group-address%v/group-mask-address-source-address-source-mask-address-inc-mask%v", state.getPath(), keyString, ckeyString, cckeyString))
								}
							}
							for cci := range state.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks {
								cckeys := [...]string{"source-address", "source-mask-address"}
								ccstateKeyValues := [...]string{state.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks[cci].SourceIp.ValueString(), state.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks[cci].SourceIncMask.ValueString()}
								cckeyString := ""
								for ccki := range cckeys {
									cckeyString += "[" + cckeys[ccki] + "=" + ccstateKeyValues[ccki] + "]"
								}

								ccemptyKeys := true
								if !reflect.ValueOf(state.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks[cci].SourceIp.ValueString()).IsZero() {
									ccemptyKeys = false
								}
								if !reflect.ValueOf(state.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks[cci].SourceIncMask.ValueString()).IsZero() {
									ccemptyKeys = false
								}
								if ccemptyKeys {
									continue
								}

								found := false
								for ccj := range data.SrP2mpPolicies[j].StaticGroups[cj].SourceMasks {
									found = true
									if state.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks[cci].SourceIp.ValueString() != data.SrP2mpPolicies[j].StaticGroups[cj].SourceMasks[ccj].SourceIp.ValueString() {
										found = false
									}
									if state.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks[cci].SourceIncMask.ValueString() != data.SrP2mpPolicies[j].StaticGroups[cj].SourceMasks[ccj].SourceIncMask.ValueString() {
										found = false
									}
									if found {
										if !state.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks[cci].SourceCount.IsNull() && data.SrP2mpPolicies[j].StaticGroups[cj].SourceMasks[ccj].SourceCount.IsNull() {
											deletedItems = append(deletedItems, fmt.Sprintf("%v/sr-p2mp-policies/sr-p2mp-policy%v/static-group/group-address%v/source-address-source-mask-address-inc-mask%v/source-address-count", state.getPath(), keyString, ckeyString, cckeyString))
										}
										break
									}
								}
								if !found {
									deletedItems = append(deletedItems, fmt.Sprintf("%v/sr-p2mp-policies/sr-p2mp-policy%v/static-group/group-address%v/source-address-source-mask-address-inc-mask%v", state.getPath(), keyString, ckeyString, cckeyString))
								}
							}
							for cci := range state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses {
								cckeys := [...]string{"group-mask-address", "source-address"}
								ccstateKeyValues := [...]string{state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses[cci].GroupIncMask.ValueString(), state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses[cci].SourceIp.ValueString()}
								cckeyString := ""
								for ccki := range cckeys {
									cckeyString += "[" + cckeys[ccki] + "=" + ccstateKeyValues[ccki] + "]"
								}

								ccemptyKeys := true
								if !reflect.ValueOf(state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses[cci].GroupIncMask.ValueString()).IsZero() {
									ccemptyKeys = false
								}
								if !reflect.ValueOf(state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses[cci].SourceIp.ValueString()).IsZero() {
									ccemptyKeys = false
								}
								if ccemptyKeys {
									continue
								}

								found := false
								for ccj := range data.SrP2mpPolicies[j].StaticGroups[cj].GroupMasksSourceAddresses {
									found = true
									if state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses[cci].GroupIncMask.ValueString() != data.SrP2mpPolicies[j].StaticGroups[cj].GroupMasksSourceAddresses[ccj].GroupIncMask.ValueString() {
										found = false
									}
									if state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses[cci].SourceIp.ValueString() != data.SrP2mpPolicies[j].StaticGroups[cj].GroupMasksSourceAddresses[ccj].SourceIp.ValueString() {
										found = false
									}
									if found {
										if !state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses[cci].GroupCount.IsNull() && data.SrP2mpPolicies[j].StaticGroups[cj].GroupMasksSourceAddresses[ccj].GroupCount.IsNull() {
											deletedItems = append(deletedItems, fmt.Sprintf("%v/sr-p2mp-policies/sr-p2mp-policy%v/static-group/group-address%v/group-mask-address-source-address-inc-mask%v/group-address-count", state.getPath(), keyString, ckeyString, cckeyString))
										}
										break
									}
								}
								if !found {
									deletedItems = append(deletedItems, fmt.Sprintf("%v/sr-p2mp-policies/sr-p2mp-policy%v/static-group/group-address%v/group-mask-address-source-address-inc-mask%v", state.getPath(), keyString, ckeyString, cckeyString))
								}
							}
							for cci := range state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasks {
								cckeys := [...]string{"group-mask-address"}
								ccstateKeyValues := [...]string{state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasks[cci].GroupIncMask.ValueString()}
								cckeyString := ""
								for ccki := range cckeys {
									cckeyString += "[" + cckeys[ccki] + "=" + ccstateKeyValues[ccki] + "]"
								}

								ccemptyKeys := true
								if !reflect.ValueOf(state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasks[cci].GroupIncMask.ValueString()).IsZero() {
									ccemptyKeys = false
								}
								if ccemptyKeys {
									continue
								}

								found := false
								for ccj := range data.SrP2mpPolicies[j].StaticGroups[cj].GroupMasks {
									found = true
									if state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasks[cci].GroupIncMask.ValueString() != data.SrP2mpPolicies[j].StaticGroups[cj].GroupMasks[ccj].GroupIncMask.ValueString() {
										found = false
									}
									if found {
										if !state.SrP2mpPolicies[i].StaticGroups[ci].GroupMasks[cci].GroupCount.IsNull() && data.SrP2mpPolicies[j].StaticGroups[cj].GroupMasks[ccj].GroupCount.IsNull() {
											deletedItems = append(deletedItems, fmt.Sprintf("%v/sr-p2mp-policies/sr-p2mp-policy%v/static-group/group-address%v/group-address-inc-mask%v/group-address-count", state.getPath(), keyString, ckeyString, cckeyString))
										}
										break
									}
								}
								if !found {
									deletedItems = append(deletedItems, fmt.Sprintf("%v/sr-p2mp-policies/sr-p2mp-policy%v/static-group/group-address%v/group-address-inc-mask%v", state.getPath(), keyString, ckeyString, cckeyString))
								}
							}
							if !state.SrP2mpPolicies[i].StaticGroups[ci].GroupAddressOnly.IsNull() && data.SrP2mpPolicies[j].StaticGroups[cj].GroupAddressOnly.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/sr-p2mp-policies/sr-p2mp-policy%v/static-group/group-address%v/group-address-only", state.getPath(), keyString, ckeyString))
							}
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/sr-p2mp-policies/sr-p2mp-policy%v/static-group/group-address%v", state.getPath(), keyString, ckeyString))
					}
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/sr-p2mp-policies/sr-p2mp-policy%v", state.getPath(), keyString))
		}
	}
	for i := range state.MofrrCloneSources {
		keys := [...]string{"address"}
		stateKeyValues := [...]string{state.MofrrCloneSources[i].SourceAddress.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.MofrrCloneSources[i].SourceAddress.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.MofrrCloneSources {
			found = true
			if state.MofrrCloneSources[i].SourceAddress.ValueString() != data.MofrrCloneSources[j].SourceAddress.ValueString() {
				found = false
			}
			if found {
				for ci := range state.MofrrCloneSources[i].To {
					ckeys := [...]string{"address"}
					cstateKeyValues := [...]string{state.MofrrCloneSources[i].To[ci].PrimaryAddress.ValueString()}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.MofrrCloneSources[i].To[ci].PrimaryAddress.ValueString()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.MofrrCloneSources[j].To {
						found = true
						if state.MofrrCloneSources[i].To[ci].PrimaryAddress.ValueString() != data.MofrrCloneSources[j].To[cj].PrimaryAddress.ValueString() {
							found = false
						}
						if found {
							for cci := range state.MofrrCloneSources[i].To[ci].And {
								cckeys := [...]string{"address"}
								ccstateKeyValues := [...]string{state.MofrrCloneSources[i].To[ci].And[cci].BackupAddress.ValueString()}
								cckeyString := ""
								for ccki := range cckeys {
									cckeyString += "[" + cckeys[ccki] + "=" + ccstateKeyValues[ccki] + "]"
								}

								ccemptyKeys := true
								if !reflect.ValueOf(state.MofrrCloneSources[i].To[ci].And[cci].BackupAddress.ValueString()).IsZero() {
									ccemptyKeys = false
								}
								if ccemptyKeys {
									continue
								}

								found := false
								for ccj := range data.MofrrCloneSources[j].To[cj].And {
									found = true
									if state.MofrrCloneSources[i].To[ci].And[cci].BackupAddress.ValueString() != data.MofrrCloneSources[j].To[cj].And[ccj].BackupAddress.ValueString() {
										found = false
									}
									if found {
										for ccci := range state.MofrrCloneSources[i].To[ci].And[cci].Masklen {
											ccckeys := [...]string{""}
											cccstateKeyValues := [...]string{strconv.FormatInt(state.MofrrCloneSources[i].To[ci].And[cci].Masklen[ccci].MaskLength.ValueInt64(), 10)}
											ccckeyString := ""
											for cccki := range ccckeys {
												ccckeyString += "[" + ccckeys[cccki] + "=" + cccstateKeyValues[cccki] + "]"
											}

											cccemptyKeys := true
											if !reflect.ValueOf(state.MofrrCloneSources[i].To[ci].And[cci].Masklen[ccci].MaskLength.ValueInt64()).IsZero() {
												cccemptyKeys = false
											}
											if cccemptyKeys {
												continue
											}

											found := false
											for cccj := range data.MofrrCloneSources[j].To[cj].And[ccj].Masklen {
												found = true
												if state.MofrrCloneSources[i].To[ci].And[cci].Masklen[ccci].MaskLength.ValueInt64() != data.MofrrCloneSources[j].To[cj].And[ccj].Masklen[cccj].MaskLength.ValueInt64() {
													found = false
												}
												if found {
													break
												}
											}
											if !found {
												deletedItems = append(deletedItems, fmt.Sprintf("%v/mofrr/clone/sources/source%v/to%v/and%v/%v", state.getPath(), keyString, ckeyString, cckeyString, ccckeyString))
											}
										}
										break
									}
								}
								if !found {
									deletedItems = append(deletedItems, fmt.Sprintf("%v/mofrr/clone/sources/source%v/to%v/and%v", state.getPath(), keyString, ckeyString, cckeyString))
								}
							}
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/mofrr/clone/sources/source%v/to%v", state.getPath(), keyString, ckeyString))
					}
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/mofrr/clone/sources/source%v", state.getPath(), keyString))
		}
	}
	for i := range state.MofrrCloneJoins {
		keys := [...]string{"address"}
		stateKeyValues := [...]string{state.MofrrCloneJoins[i].SourceAddress.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.MofrrCloneJoins[i].SourceAddress.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.MofrrCloneJoins {
			found = true
			if state.MofrrCloneJoins[i].SourceAddress.ValueString() != data.MofrrCloneJoins[j].SourceAddress.ValueString() {
				found = false
			}
			if found {
				for ci := range state.MofrrCloneJoins[i].To {
					ckeys := [...]string{"address"}
					cstateKeyValues := [...]string{state.MofrrCloneJoins[i].To[ci].PrimaryAddress.ValueString()}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.MofrrCloneJoins[i].To[ci].PrimaryAddress.ValueString()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.MofrrCloneJoins[j].To {
						found = true
						if state.MofrrCloneJoins[i].To[ci].PrimaryAddress.ValueString() != data.MofrrCloneJoins[j].To[cj].PrimaryAddress.ValueString() {
							found = false
						}
						if found {
							for cci := range state.MofrrCloneJoins[i].To[ci].And {
								cckeys := [...]string{"address"}
								ccstateKeyValues := [...]string{state.MofrrCloneJoins[i].To[ci].And[cci].BackupAddress.ValueString()}
								cckeyString := ""
								for ccki := range cckeys {
									cckeyString += "[" + cckeys[ccki] + "=" + ccstateKeyValues[ccki] + "]"
								}

								ccemptyKeys := true
								if !reflect.ValueOf(state.MofrrCloneJoins[i].To[ci].And[cci].BackupAddress.ValueString()).IsZero() {
									ccemptyKeys = false
								}
								if ccemptyKeys {
									continue
								}

								found := false
								for ccj := range data.MofrrCloneJoins[j].To[cj].And {
									found = true
									if state.MofrrCloneJoins[i].To[ci].And[cci].BackupAddress.ValueString() != data.MofrrCloneJoins[j].To[cj].And[ccj].BackupAddress.ValueString() {
										found = false
									}
									if found {
										for ccci := range state.MofrrCloneJoins[i].To[ci].And[cci].Masklen {
											ccckeys := [...]string{""}
											cccstateKeyValues := [...]string{strconv.FormatInt(state.MofrrCloneJoins[i].To[ci].And[cci].Masklen[ccci].MaskLength.ValueInt64(), 10)}
											ccckeyString := ""
											for cccki := range ccckeys {
												ccckeyString += "[" + ccckeys[cccki] + "=" + cccstateKeyValues[cccki] + "]"
											}

											cccemptyKeys := true
											if !reflect.ValueOf(state.MofrrCloneJoins[i].To[ci].And[cci].Masklen[ccci].MaskLength.ValueInt64()).IsZero() {
												cccemptyKeys = false
											}
											if cccemptyKeys {
												continue
											}

											found := false
											for cccj := range data.MofrrCloneJoins[j].To[cj].And[ccj].Masklen {
												found = true
												if state.MofrrCloneJoins[i].To[ci].And[cci].Masklen[ccci].MaskLength.ValueInt64() != data.MofrrCloneJoins[j].To[cj].And[ccj].Masklen[cccj].MaskLength.ValueInt64() {
													found = false
												}
												if found {
													break
												}
											}
											if !found {
												deletedItems = append(deletedItems, fmt.Sprintf("%v/mofrr/clone/joins/join%v/to%v/and%v/%v", state.getPath(), keyString, ckeyString, cckeyString, ccckeyString))
											}
										}
										break
									}
								}
								if !found {
									deletedItems = append(deletedItems, fmt.Sprintf("%v/mofrr/clone/joins/join%v/to%v/and%v", state.getPath(), keyString, ckeyString, cckeyString))
								}
							}
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/mofrr/clone/joins/join%v/to%v", state.getPath(), keyString, ckeyString))
					}
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/mofrr/clone/joins/join%v", state.getPath(), keyString))
		}
	}
	if !state.MofrrNonRevertive.IsNull() && data.MofrrNonRevertive.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/mofrr/non-revertive", state.getPath()))
	}
	if !state.MofrrProtectLocalFaultOnly.IsNull() && data.MofrrProtectLocalFaultOnly.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/mofrr/local-fault-only", state.getPath()))
	}
	if !state.MofrrProtect.IsNull() && data.MofrrProtect.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/mofrr/protect", state.getPath()))
	}
	if !state.MofrrRib.IsNull() && data.MofrrRib.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/mofrr/rib", state.getPath()))
	}
	if !state.MofrrFlow.IsNull() && data.MofrrFlow.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/mofrr/flow", state.getPath()))
	}
	if !state.Mofrr.IsNull() && data.Mofrr.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/mofrr", state.getPath()))
	}
	for i := range state.BsrRelayVrfs {
		keys := [...]string{"vrf-name"}
		stateKeyValues := [...]string{state.BsrRelayVrfs[i].VrfName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.BsrRelayVrfs[i].VrfName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.BsrRelayVrfs {
			found = true
			if state.BsrRelayVrfs[i].VrfName.ValueString() != data.BsrRelayVrfs[j].VrfName.ValueString() {
				found = false
			}
			if found {
				if !state.BsrRelayVrfs[i].Listen.IsNull() && data.BsrRelayVrfs[j].Listen.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/bsr/relay/vrfs/vrf%v/listen", state.getPath(), keyString))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/bsr/relay/vrfs/vrf%v", state.getPath(), keyString))
		}
	}
	for i := range state.BsrCandidateRps {
		keys := [...]string{"address"}
		stateKeyValues := [...]string{state.BsrCandidateRps[i].Address.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.BsrCandidateRps[i].Address.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.BsrCandidateRps {
			found = true
			if state.BsrCandidateRps[i].Address.ValueString() != data.BsrCandidateRps[j].Address.ValueString() {
				found = false
			}
			if found {
				if !state.BsrCandidateRps[i].BidirInterval.IsNull() && data.BsrCandidateRps[j].BidirInterval.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/bsr/candidate-rps/candidate-rp%v/bidir/interval", state.getPath(), keyString))
				}
				if !state.BsrCandidateRps[i].BidirPriority.IsNull() && data.BsrCandidateRps[j].BidirPriority.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/bsr/candidate-rps/candidate-rp%v/bidir/priority", state.getPath(), keyString))
				}
				if !state.BsrCandidateRps[i].BidirGroupList.IsNull() && data.BsrCandidateRps[j].BidirGroupList.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/bsr/candidate-rps/candidate-rp%v/bidir/group-list", state.getPath(), keyString))
				}
				if !state.BsrCandidateRps[i].Interval.IsNull() && data.BsrCandidateRps[j].Interval.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/bsr/candidate-rps/candidate-rp%v/interval", state.getPath(), keyString))
				}
				if !state.BsrCandidateRps[i].Priority.IsNull() && data.BsrCandidateRps[j].Priority.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/bsr/candidate-rps/candidate-rp%v/priority", state.getPath(), keyString))
				}
				if !state.BsrCandidateRps[i].GroupList.IsNull() && data.BsrCandidateRps[j].GroupList.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/bsr/candidate-rps/candidate-rp%v/group-list", state.getPath(), keyString))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/bsr/candidate-rps/candidate-rp%v", state.getPath(), keyString))
		}
	}
	if !state.BsrCandidateBsrPriority.IsNull() && data.BsrCandidateBsrPriority.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/bsr/candidate-bsr", state.getPath()))
	}
	if !state.BsrCandidateBsrHashMaskLen.IsNull() && data.BsrCandidateBsrHashMaskLen.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/bsr/candidate-bsr", state.getPath()))
	}
	if !state.BsrCandidateBsrAddress.IsNull() && data.BsrCandidateBsrAddress.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/bsr/candidate-bsr", state.getPath()))
	}
	for i := range state.AutoRpRelayVrfs {
		keys := [...]string{"vrf-name"}
		stateKeyValues := [...]string{state.AutoRpRelayVrfs[i].VrfName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.AutoRpRelayVrfs[i].VrfName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.AutoRpRelayVrfs {
			found = true
			if state.AutoRpRelayVrfs[i].VrfName.ValueString() != data.AutoRpRelayVrfs[j].VrfName.ValueString() {
				found = false
			}
			if found {
				if !state.AutoRpRelayVrfs[i].Listen.IsNull() && data.AutoRpRelayVrfs[j].Listen.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/auto-rp/relay/vrfs/vrf%v/listen", state.getPath(), keyString))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/auto-rp/relay/vrfs/vrf%v", state.getPath(), keyString))
		}
	}
	if !state.AutoRpListenDisable.IsNull() && data.AutoRpListenDisable.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/auto-rp/listen/disable", state.getPath()))
	}
	for i := range state.AutoRpCandidateRps {
		keys := [...]string{"interface-name"}
		stateKeyValues := [...]string{state.AutoRpCandidateRps[i].InterfaceName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.AutoRpCandidateRps[i].InterfaceName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.AutoRpCandidateRps {
			found = true
			if state.AutoRpCandidateRps[i].InterfaceName.ValueString() != data.AutoRpCandidateRps[j].InterfaceName.ValueString() {
				found = false
			}
			if found {
				if !state.AutoRpCandidateRps[i].BidirInterval.IsNull() && data.AutoRpCandidateRps[j].BidirInterval.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/auto-rp/candidate-rps/candidate-rp%v/bidir/interval", state.getPath(), keyString))
				}
				if !state.AutoRpCandidateRps[i].BidirGroupList.IsNull() && data.AutoRpCandidateRps[j].BidirGroupList.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/auto-rp/candidate-rps/candidate-rp%v/bidir/group-list", state.getPath(), keyString))
				}
				if !state.AutoRpCandidateRps[i].BidirScope.IsNull() && data.AutoRpCandidateRps[j].BidirScope.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/auto-rp/candidate-rps/candidate-rp%v/bidir/scope", state.getPath(), keyString))
				}
				if !state.AutoRpCandidateRps[i].Interval.IsNull() && data.AutoRpCandidateRps[j].Interval.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/auto-rp/candidate-rps/candidate-rp%v/interval", state.getPath(), keyString))
				}
				if !state.AutoRpCandidateRps[i].GroupList.IsNull() && data.AutoRpCandidateRps[j].GroupList.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/auto-rp/candidate-rps/candidate-rp%v/group-list", state.getPath(), keyString))
				}
				if !state.AutoRpCandidateRps[i].Scope.IsNull() && data.AutoRpCandidateRps[j].Scope.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/auto-rp/candidate-rps/candidate-rp%v/scope", state.getPath(), keyString))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/auto-rp/candidate-rps/candidate-rp%v", state.getPath(), keyString))
		}
	}
	if !state.AutoRpMappingAgentInterval.IsNull() && data.AutoRpMappingAgentInterval.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/auto-rp/mapping-agent", state.getPath()))
	}
	if !state.AutoRpMappingAgentScope.IsNull() && data.AutoRpMappingAgentScope.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/auto-rp/mapping-agent", state.getPath()))
	}
	if !state.AutoRpMappingAgentInterface.IsNull() && data.AutoRpMappingAgentInterface.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/auto-rp/mapping-agent", state.getPath()))
	}
	if !state.MultipathHashSourceGroup.IsNull() && data.MultipathHashSourceGroup.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/multipath/hash", state.getPath()))
	}
	if !state.MultipathHashSourceNexthop.IsNull() && data.MultipathHashSourceNexthop.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/multipath/hash", state.getPath()))
	}
	if !state.MultipathHashSource.IsNull() && data.MultipathHashSource.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/multipath/hash", state.getPath()))
	}
	if !state.Multipath.IsNull() && data.Multipath.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/multipath", state.getPath()))
	}
	if !state.RpfRedirectRoutePolicy.IsNull() && data.RpfRedirectRoutePolicy.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/rpf-redirect/route-policy", state.getPath()))
	}
	if !state.SsmAllowOverride.IsNull() && data.SsmAllowOverride.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/ssm/allow-override", state.getPath()))
	}
	if !state.SsmDisable.IsNull() && data.SsmDisable.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/ssm/disable", state.getPath()))
	}
	if !state.SsmRange.IsNull() && data.SsmRange.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/ssm/range", state.getPath()))
	}
	if !state.SgList.IsNull() && data.SgList.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/sg-expiry-timer", state.getPath()))
	}
	if !state.SgExpiryTimer.IsNull() && data.SgExpiryTimer.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/sg-expiry-timer", state.getPath()))
	}
	if !state.AllowRpGroupList.IsNull() && data.AllowRpGroupList.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/allow-rp/group-list", state.getPath()))
	}
	if !state.AllowRpList.IsNull() && data.AllowRpList.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/allow-rp/rp-list", state.getPath()))
	}
	if !state.AllowRp.IsNull() && data.AllowRp.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/allow-rp", state.getPath()))
	}
	if !state.MdtCMulticastMigrationRoutePolicy.IsNull() && data.MdtCMulticastMigrationRoutePolicy.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/mdt/c-multicast-routing", state.getPath()))
	}
	if !state.MdtCMulticastSourceTreePruneDelay.IsNull() && data.MdtCMulticastSourceTreePruneDelay.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/mdt/c-multicast-routing", state.getPath()))
	}
	if !state.MdtCMulticastSharedTreePruneDelay.IsNull() && data.MdtCMulticastSharedTreePruneDelay.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/mdt/c-multicast-routing", state.getPath()))
	}
	if !state.MdtCMulticastHelloEnable.IsNull() && data.MdtCMulticastHelloEnable.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/mdt/c-multicast-routing/mdt-hello", state.getPath()))
	}
	if !state.MdtCMulticastSuppressPimDataSignaling.IsNull() && data.MdtCMulticastSuppressPimDataSignaling.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/mdt/c-multicast-routing", state.getPath()))
	}
	if !state.MdtCMulticastSuppressSharedTreeJoin.IsNull() && data.MdtCMulticastSuppressSharedTreeJoin.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/mdt/c-multicast-routing", state.getPath()))
	}
	if !state.MdtCMulticastSharedTreePrune.IsNull() && data.MdtCMulticastSharedTreePrune.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/mdt/c-multicast-routing", state.getPath()))
	}
	if !state.MdtCMulticastAnnouncePimJoinTlv.IsNull() && data.MdtCMulticastAnnouncePimJoinTlv.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/mdt/c-multicast-routing", state.getPath()))
	}
	if !state.MdtCMulticastType.IsNull() && data.MdtCMulticastType.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/mdt/c-multicast-routing", state.getPath()))
	}
	if !state.MdtDataAnnounceInterval.IsNull() && data.MdtDataAnnounceInterval.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/mdt/data/announce-interval", state.getPath()))
	}
	if !state.MdtDataSwitchoverInterval.IsNull() && data.MdtDataSwitchoverInterval.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/mdt/data/switchover-interval", state.getPath()))
	}
	if !state.MdtNeighborFilter.IsNull() && data.MdtNeighborFilter.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/mdt/neighbor-filter", state.getPath()))
	}
	if !state.RpfTopologyRoutePolicy.IsNull() && data.RpfTopologyRoutePolicy.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/rpf/topology/route-policy", state.getPath()))
	}
	for i := range state.ExplicitRpfVectorInjects {
		keys := [...]string{"source-address", "masklen"}
		stateKeyValues := [...]string{state.ExplicitRpfVectorInjects[i].SourceAddress.ValueString(), strconv.FormatInt(state.ExplicitRpfVectorInjects[i].SourceMask.ValueInt64(), 10)}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.ExplicitRpfVectorInjects[i].SourceAddress.ValueString()).IsZero() {
			emptyKeys = false
		}
		if !reflect.ValueOf(state.ExplicitRpfVectorInjects[i].SourceMask.ValueInt64()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.ExplicitRpfVectorInjects {
			found = true
			if state.ExplicitRpfVectorInjects[i].SourceAddress.ValueString() != data.ExplicitRpfVectorInjects[j].SourceAddress.ValueString() {
				found = false
			}
			if state.ExplicitRpfVectorInjects[i].SourceMask.ValueInt64() != data.ExplicitRpfVectorInjects[j].SourceMask.ValueInt64() {
				found = false
			}
			if found {
				if !state.ExplicitRpfVectorInjects[i].RpfVectors.IsNull() && data.ExplicitRpfVectorInjects[j].RpfVectors.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/explicit-rpf-vector/injects/inject%v/rpf-vector", state.getPath(), keyString))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/explicit-rpf-vector/injects/inject%v", state.getPath(), keyString))
		}
	}
	for i := range state.RpfVectorInjects {
		keys := [...]string{"source-address", "masklen"}
		stateKeyValues := [...]string{state.RpfVectorInjects[i].SourceAddress.ValueString(), strconv.FormatInt(state.RpfVectorInjects[i].SourceMask.ValueInt64(), 10)}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.RpfVectorInjects[i].SourceAddress.ValueString()).IsZero() {
			emptyKeys = false
		}
		if !reflect.ValueOf(state.RpfVectorInjects[i].SourceMask.ValueInt64()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.RpfVectorInjects {
			found = true
			if state.RpfVectorInjects[i].SourceAddress.ValueString() != data.RpfVectorInjects[j].SourceAddress.ValueString() {
				found = false
			}
			if state.RpfVectorInjects[i].SourceMask.ValueInt64() != data.RpfVectorInjects[j].SourceMask.ValueInt64() {
				found = false
			}
			if found {
				if !state.RpfVectorInjects[i].RpfVectors.IsNull() && data.RpfVectorInjects[j].RpfVectors.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/rpf-vector-injects/inject%v/rpf-vector", state.getPath(), keyString))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/rpf-vector-injects/inject%v", state.getPath(), keyString))
		}
	}
	if !state.RpfVectorStandardEncoding.IsNull() && data.RpfVectorStandardEncoding.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/rpf-vector", state.getPath()))
	}
	if !state.RpfVectorDisableIbgp.IsNull() && data.RpfVectorDisableIbgp.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/rpf-vector", state.getPath()))
	}
	if !state.RpfVectorAllowEbgp.IsNull() && data.RpfVectorAllowEbgp.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/rpf-vector", state.getPath()))
	}
	if !state.LogNeighborChanges.IsNull() && data.LogNeighborChanges.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/log/neighbor/changes", state.getPath()))
	}
	if !state.MaximumBsrCrpCacheThreshold.IsNull() && data.MaximumBsrCrpCacheThreshold.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/maximum/bsr/crp-cache", state.getPath()))
	}
	if !state.MaximumBsrCrpCacheMaximum.IsNull() && data.MaximumBsrCrpCacheMaximum.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/maximum/bsr/crp-cache", state.getPath()))
	}
	if !state.MaximumGroupMappingsAutorpThreshold.IsNull() && data.MaximumGroupMappingsAutorpThreshold.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/maximum/group-mappings/autorp", state.getPath()))
	}
	if !state.MaximumGroupMappingsAutorp.IsNull() && data.MaximumGroupMappingsAutorp.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/maximum/group-mappings/autorp", state.getPath()))
	}
	if !state.MaximumGroupMappingsBsrThreshold.IsNull() && data.MaximumGroupMappingsBsrThreshold.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/maximum/group-mappings/bsr", state.getPath()))
	}
	if !state.MaximumGroupMappingsBsr.IsNull() && data.MaximumGroupMappingsBsr.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/maximum/group-mappings/bsr", state.getPath()))
	}
	if !state.MaximumRegisterStatesThreshold.IsNull() && data.MaximumRegisterStatesThreshold.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/maximum/register-states", state.getPath()))
	}
	if !state.MaximumRegisterStates.IsNull() && data.MaximumRegisterStates.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/maximum/register-states", state.getPath()))
	}
	if !state.MaximumRouteInterfacesThreshold.IsNull() && data.MaximumRouteInterfacesThreshold.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/maximum/route-interfaces", state.getPath()))
	}
	if !state.MaximumRouteInterfaces.IsNull() && data.MaximumRouteInterfaces.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/maximum/route-interfaces", state.getPath()))
	}
	if !state.MaximumRoutesThreshold.IsNull() && data.MaximumRoutesThreshold.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/maximum/routes", state.getPath()))
	}
	if !state.MaximumRoutes.IsNull() && data.MaximumRoutes.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/maximum/routes", state.getPath()))
	}
	if !state.GlobalMaximumBsrCrpCacheThreshold.IsNull() && data.GlobalMaximumBsrCrpCacheThreshold.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/global/maximum/bsr/crp-cache", state.getPath()))
	}
	if !state.GlobalMaximumBsrCrpCacheMaximum.IsNull() && data.GlobalMaximumBsrCrpCacheMaximum.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/global/maximum/bsr/crp-cache", state.getPath()))
	}
	if !state.GlobalMaximumGroupMappingsAutorpThreshold.IsNull() && data.GlobalMaximumGroupMappingsAutorpThreshold.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/global/maximum/group-mappings/autorp", state.getPath()))
	}
	if !state.GlobalMaximumGroupMappingsAutorp.IsNull() && data.GlobalMaximumGroupMappingsAutorp.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/global/maximum/group-mappings/autorp", state.getPath()))
	}
	if !state.GlobalMaximumGroupMappingsBsrThreshold.IsNull() && data.GlobalMaximumGroupMappingsBsrThreshold.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/global/maximum/group-mappings/bsr", state.getPath()))
	}
	if !state.GlobalMaximumGroupMappingsBsr.IsNull() && data.GlobalMaximumGroupMappingsBsr.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/global/maximum/group-mappings/bsr", state.getPath()))
	}
	if !state.GlobalMaximumPacketQueueLowPriority.IsNull() && data.GlobalMaximumPacketQueueLowPriority.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/global/maximum/packet-queue/low-priority", state.getPath()))
	}
	if !state.GlobalMaximumPacketQueueHighPriority.IsNull() && data.GlobalMaximumPacketQueueHighPriority.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/global/maximum/packet-queue/high-priority", state.getPath()))
	}
	if !state.GlobalMaximumRegisterStatesThreshold.IsNull() && data.GlobalMaximumRegisterStatesThreshold.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/global/maximum/register-states", state.getPath()))
	}
	if !state.GlobalMaximumRegisterStates.IsNull() && data.GlobalMaximumRegisterStates.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/global/maximum/register-states", state.getPath()))
	}
	if !state.GlobalMaximumRouteInterfacesThreshold.IsNull() && data.GlobalMaximumRouteInterfacesThreshold.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/global/maximum/route-interfaces", state.getPath()))
	}
	if !state.GlobalMaximumRouteInterfaces.IsNull() && data.GlobalMaximumRouteInterfaces.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/global/maximum/route-interfaces", state.getPath()))
	}
	if !state.GlobalMaximumRoutesThreshold.IsNull() && data.GlobalMaximumRoutesThreshold.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/global/maximum/routes", state.getPath()))
	}
	if !state.GlobalMaximumRoutes.IsNull() && data.GlobalMaximumRoutes.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/global/maximum/routes", state.getPath()))
	}
	if !state.OverrideInterval.IsNull() && data.OverrideInterval.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/override-interval", state.getPath()))
	}
	if !state.PropagationDelay.IsNull() && data.PropagationDelay.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/propagation-delay", state.getPath()))
	}
	if !state.JoinPruneMtu.IsNull() && data.JoinPruneMtu.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/join-prune-mtu", state.getPath()))
	}
	if !state.JoinPruneInterval.IsNull() && data.JoinPruneInterval.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/join-prune-interval", state.getPath()))
	}
	if !state.DrPriority.IsNull() && data.DrPriority.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/dr-priority", state.getPath()))
	}
	if !state.MdtHelloInterval.IsNull() && data.MdtHelloInterval.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/mdt-hello-interval", state.getPath()))
	}
	if !state.HelloInterval.IsNull() && data.HelloInterval.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/hello-interval", state.getPath()))
	}
	if !state.NeighborCheckOnRecv.IsNull() && data.NeighborCheckOnRecv.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/neighbor-check-on-recv/enable", state.getPath()))
	}
	if !state.NeighborCheckOnSend.IsNull() && data.NeighborCheckOnSend.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/neighbor-check-on-send/enable", state.getPath()))
	}
	if !state.NsfLifetime.IsNull() && data.NsfLifetime.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/nsf/lifetime", state.getPath()))
	}
	if !state.OldRegisterChecksum.IsNull() && data.OldRegisterChecksum.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/old-register-checksum", state.getPath()))
	}
	if !state.SptThresholdInfinityGroupList.IsNull() && data.SptThresholdInfinityGroupList.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/spt-threshold/infinity/group-list", state.getPath()))
	}
	if !state.SptThresholdInfinity.IsNull() && data.SptThresholdInfinity.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/spt-threshold/infinity", state.getPath()))
	}
	if !state.ConvergenceLinkDownPruneDelay.IsNull() && data.ConvergenceLinkDownPruneDelay.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/convergence/link-down-prune-delay", state.getPath()))
	}
	if !state.ConvergenceRpfConflictJoinDelay.IsNull() && data.ConvergenceRpfConflictJoinDelay.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/convergence/rpf-conflict-join-delay", state.getPath()))
	}
	if !state.NeighborFilter.IsNull() && data.NeighborFilter.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/neighbor-filter", state.getPath()))
	}
	if !state.SuppressRpfChangePrunes.IsNull() && data.SuppressRpfChangePrunes.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/suppress-rpf-change-prunes", state.getPath()))
	}
	if !state.RegisterSource.IsNull() && data.RegisterSource.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/register-source", state.getPath()))
	}
	if !state.SuppressDataRegisters.IsNull() && data.SuppressDataRegisters.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/suppress-data-registers", state.getPath()))
	}
	if !state.AcceptRegister.IsNull() && data.AcceptRegister.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/accept-register", state.getPath()))
	}
	if !state.RpStaticDeny.IsNull() && data.RpStaticDeny.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/rp-static-deny", state.getPath()))
	}
	for i := range state.RpAddressesBidir {
		keys := [...]string{"address"}
		stateKeyValues := [...]string{state.RpAddressesBidir[i].Address.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.RpAddressesBidir[i].Address.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.RpAddressesBidir {
			found = true
			if state.RpAddressesBidir[i].Address.ValueString() != data.RpAddressesBidir[j].Address.ValueString() {
				found = false
			}
			if found {
				if !state.RpAddressesBidir[i].Override.IsNull() && data.RpAddressesBidir[j].Override.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/rp-addresses/bidir/rp-address%v/override", state.getPath(), keyString))
				}
				if !state.RpAddressesBidir[i].AccessList.IsNull() && data.RpAddressesBidir[j].AccessList.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/rp-addresses/bidir/rp-address%v/access-list", state.getPath(), keyString))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/rp-addresses/bidir/rp-address%v", state.getPath(), keyString))
		}
	}
	for i := range state.RpAddresses {
		keys := [...]string{"address"}
		stateKeyValues := [...]string{state.RpAddresses[i].Address.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.RpAddresses[i].Address.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.RpAddresses {
			found = true
			if state.RpAddresses[i].Address.ValueString() != data.RpAddresses[j].Address.ValueString() {
				found = false
			}
			if found {
				if !state.RpAddresses[i].Override.IsNull() && data.RpAddresses[j].Override.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/rp-addresses/rp-address%v/override", state.getPath(), keyString))
				}
				if !state.RpAddresses[i].AccessList.IsNull() && data.RpAddresses[j].AccessList.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/rp-addresses/rp-address%v/access-list", state.getPath(), keyString))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/rp-addresses/rp-address%v", state.getPath(), keyString))
		}
	}
	return deletedItems
}

// End of section. //template:end getDeletedItems
// Section below is generated&owned by "gen/generator.go". //template:begin getEmptyLeafsDelete

func (data *RouterPIMIPv4) getEmptyLeafsDelete(ctx context.Context, state *RouterPIMIPv4) []string {
	emptyLeafsDelete := make([]string, 0)
	for i := range data.Interfaces {
		keys := [...]string{"interface-name"}
		keyValues := [...]string{data.Interfaces[i].InterfaceName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		// Only delete if state has true and plan has false
		if !data.Interfaces[i].BsrBorder.IsNull() && !data.Interfaces[i].BsrBorder.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Interfaces) && !state.Interfaces[i].BsrBorder.IsNull() && state.Interfaces[i].BsrBorder.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/interfaces/interface%v/bsr-border", data.getXPath(), keyString))
			}
		}
		// Only delete if state has true and plan has false
		if !data.Interfaces[i].BfdFastDetect.IsNull() && !data.Interfaces[i].BfdFastDetect.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Interfaces) && !state.Interfaces[i].BfdFastDetect.IsNull() && state.Interfaces[i].BfdFastDetect.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/interfaces/interface%v/bfd/fast-detect", data.getXPath(), keyString))
			}
		}
		// Only delete if state has true and plan has false
		if !data.Interfaces[i].Disable.IsNull() && !data.Interfaces[i].Disable.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Interfaces) && !state.Interfaces[i].Disable.IsNull() && state.Interfaces[i].Disable.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/interfaces/interface%v/disable", data.getXPath(), keyString))
			}
		}
		// Only delete if state has true and plan has false
		if !data.Interfaces[i].Enable.IsNull() && !data.Interfaces[i].Enable.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Interfaces) && !state.Interfaces[i].Enable.IsNull() && state.Interfaces[i].Enable.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/interfaces/interface%v/enable", data.getXPath(), keyString))
			}
		}
	}
	for i := range data.SrP2mpPolicies {
		keys := [...]string{"sr-p2mp-policy-id"}
		keyValues := [...]string{data.SrP2mpPolicies[i].PolicyName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		for ci := range data.SrP2mpPolicies[i].StaticGroups {
			ckeys := [...]string{"group-address"}
			ckeyValues := [...]string{data.SrP2mpPolicies[i].StaticGroups[ci].GroupAddress.ValueString()}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
			for cci := range data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks {
				cckeys := [...]string{"group-mask-address", "source-address", "source-mask-address"}
				cckeyValues := [...]string{data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].GroupIncMask.ValueString(), data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].SourceIp.ValueString(), data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceMasks[cci].SourceIncMask.ValueString()}
				cckeyString := ""
				for ccki := range cckeys {
					cckeyString += "[" + cckeys[ccki] + "=" + cckeyValues[ccki] + "]"
				}
			}
			for cci := range data.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks {
				cckeys := [...]string{"source-address", "source-mask-address"}
				cckeyValues := [...]string{data.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks[cci].SourceIp.ValueString(), data.SrP2mpPolicies[i].StaticGroups[ci].SourceMasks[cci].SourceIncMask.ValueString()}
				cckeyString := ""
				for ccki := range cckeys {
					cckeyString += "[" + cckeys[ccki] + "=" + cckeyValues[ccki] + "]"
				}
			}
			for cci := range data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses {
				cckeys := [...]string{"group-mask-address", "source-address"}
				cckeyValues := [...]string{data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses[cci].GroupIncMask.ValueString(), data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasksSourceAddresses[cci].SourceIp.ValueString()}
				cckeyString := ""
				for ccki := range cckeys {
					cckeyString += "[" + cckeys[ccki] + "=" + cckeyValues[ccki] + "]"
				}
			}
			for cci := range data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasks {
				cckeys := [...]string{"group-mask-address"}
				cckeyValues := [...]string{data.SrP2mpPolicies[i].StaticGroups[ci].GroupMasks[cci].GroupIncMask.ValueString()}
				cckeyString := ""
				for ccki := range cckeys {
					cckeyString += "[" + cckeys[ccki] + "=" + cckeyValues[ccki] + "]"
				}
			}
			// Only delete if state has true and plan has false
			if !data.SrP2mpPolicies[i].StaticGroups[ci].GroupAddressOnly.IsNull() && !data.SrP2mpPolicies[i].StaticGroups[ci].GroupAddressOnly.ValueBool() {
				// Check if corresponding state item exists and has true value
				if state != nil && i < len(state.SrP2mpPolicies) && ci < len(state.SrP2mpPolicies[i].StaticGroups) && !state.SrP2mpPolicies[i].StaticGroups[ci].GroupAddressOnly.IsNull() && state.SrP2mpPolicies[i].StaticGroups[ci].GroupAddressOnly.ValueBool() {
					emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/sr-p2mp-policies/sr-p2mp-policy%v/static-group/group-address%v/group-address-only", data.getXPath(), keyString, ckeyString))
				}
			}
		}
	}
	for i := range data.MofrrCloneSources {
		keys := [...]string{"address"}
		keyValues := [...]string{data.MofrrCloneSources[i].SourceAddress.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		for ci := range data.MofrrCloneSources[i].To {
			ckeys := [...]string{"address"}
			ckeyValues := [...]string{data.MofrrCloneSources[i].To[ci].PrimaryAddress.ValueString()}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
			for cci := range data.MofrrCloneSources[i].To[ci].And {
				cckeys := [...]string{"address"}
				cckeyValues := [...]string{data.MofrrCloneSources[i].To[ci].And[cci].BackupAddress.ValueString()}
				cckeyString := ""
				for ccki := range cckeys {
					cckeyString += "[" + cckeys[ccki] + "=" + cckeyValues[ccki] + "]"
				}
				for ccci := range data.MofrrCloneSources[i].To[ci].And[cci].Masklen {
					ccckeys := [...]string{""}
					ccckeyValues := [...]string{strconv.FormatInt(data.MofrrCloneSources[i].To[ci].And[cci].Masklen[ccci].MaskLength.ValueInt64(), 10)}
					ccckeyString := ""
					for cccki := range ccckeys {
						ccckeyString += "[" + ccckeys[cccki] + "=" + ccckeyValues[cccki] + "]"
					}
				}
			}
		}
	}
	for i := range data.MofrrCloneJoins {
		keys := [...]string{"address"}
		keyValues := [...]string{data.MofrrCloneJoins[i].SourceAddress.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		for ci := range data.MofrrCloneJoins[i].To {
			ckeys := [...]string{"address"}
			ckeyValues := [...]string{data.MofrrCloneJoins[i].To[ci].PrimaryAddress.ValueString()}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
			for cci := range data.MofrrCloneJoins[i].To[ci].And {
				cckeys := [...]string{"address"}
				cckeyValues := [...]string{data.MofrrCloneJoins[i].To[ci].And[cci].BackupAddress.ValueString()}
				cckeyString := ""
				for ccki := range cckeys {
					cckeyString += "[" + cckeys[ccki] + "=" + cckeyValues[ccki] + "]"
				}
				for ccci := range data.MofrrCloneJoins[i].To[ci].And[cci].Masklen {
					ccckeys := [...]string{""}
					ccckeyValues := [...]string{strconv.FormatInt(data.MofrrCloneJoins[i].To[ci].And[cci].Masklen[ccci].MaskLength.ValueInt64(), 10)}
					ccckeyString := ""
					for cccki := range ccckeys {
						ccckeyString += "[" + ccckeys[cccki] + "=" + ccckeyValues[cccki] + "]"
					}
				}
			}
		}
	}
	// Only delete if state has true and plan has false
	if !data.MofrrNonRevertive.IsNull() && !data.MofrrNonRevertive.ValueBool() {
		if state != nil && !state.MofrrNonRevertive.IsNull() && state.MofrrNonRevertive.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/mofrr/non-revertive", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.MofrrProtectLocalFaultOnly.IsNull() && !data.MofrrProtectLocalFaultOnly.ValueBool() {
		if state != nil && !state.MofrrProtectLocalFaultOnly.IsNull() && state.MofrrProtectLocalFaultOnly.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/mofrr/local-fault-only", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.Mofrr.IsNull() && !data.Mofrr.ValueBool() {
		if state != nil && !state.Mofrr.IsNull() && state.Mofrr.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/mofrr", data.getXPath()))
		}
	}
	for i := range data.BsrRelayVrfs {
		keys := [...]string{"vrf-name"}
		keyValues := [...]string{data.BsrRelayVrfs[i].VrfName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		// Only delete if state has true and plan has false
		if !data.BsrRelayVrfs[i].Listen.IsNull() && !data.BsrRelayVrfs[i].Listen.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.BsrRelayVrfs) && !state.BsrRelayVrfs[i].Listen.IsNull() && state.BsrRelayVrfs[i].Listen.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/bsr/relay/vrfs/vrf%v/listen", data.getXPath(), keyString))
			}
		}
	}
	for i := range data.BsrCandidateRps {
		keys := [...]string{"address"}
		keyValues := [...]string{data.BsrCandidateRps[i].Address.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
	}
	for i := range data.AutoRpRelayVrfs {
		keys := [...]string{"vrf-name"}
		keyValues := [...]string{data.AutoRpRelayVrfs[i].VrfName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		// Only delete if state has true and plan has false
		if !data.AutoRpRelayVrfs[i].Listen.IsNull() && !data.AutoRpRelayVrfs[i].Listen.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.AutoRpRelayVrfs) && !state.AutoRpRelayVrfs[i].Listen.IsNull() && state.AutoRpRelayVrfs[i].Listen.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/auto-rp/relay/vrfs/vrf%v/listen", data.getXPath(), keyString))
			}
		}
	}
	// Only delete if state has true and plan has false
	if !data.AutoRpListenDisable.IsNull() && !data.AutoRpListenDisable.ValueBool() {
		if state != nil && !state.AutoRpListenDisable.IsNull() && state.AutoRpListenDisable.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/auto-rp/listen/disable", data.getXPath()))
		}
	}
	for i := range data.AutoRpCandidateRps {
		keys := [...]string{"interface-name"}
		keyValues := [...]string{data.AutoRpCandidateRps[i].InterfaceName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
	}
	// Only delete if state has true and plan has false
	if !data.MultipathHashSourceGroup.IsNull() && !data.MultipathHashSourceGroup.ValueBool() {
		if state != nil && !state.MultipathHashSourceGroup.IsNull() && state.MultipathHashSourceGroup.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/multipath/hash", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.MultipathHashSourceNexthop.IsNull() && !data.MultipathHashSourceNexthop.ValueBool() {
		if state != nil && !state.MultipathHashSourceNexthop.IsNull() && state.MultipathHashSourceNexthop.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/multipath/hash", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.MultipathHashSource.IsNull() && !data.MultipathHashSource.ValueBool() {
		if state != nil && !state.MultipathHashSource.IsNull() && state.MultipathHashSource.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/multipath/hash", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.Multipath.IsNull() && !data.Multipath.ValueBool() {
		if state != nil && !state.Multipath.IsNull() && state.Multipath.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/multipath", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.SsmAllowOverride.IsNull() && !data.SsmAllowOverride.ValueBool() {
		if state != nil && !state.SsmAllowOverride.IsNull() && state.SsmAllowOverride.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/ssm/allow-override", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.SsmDisable.IsNull() && !data.SsmDisable.ValueBool() {
		if state != nil && !state.SsmDisable.IsNull() && state.SsmDisable.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/ssm/disable", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.AllowRp.IsNull() && !data.AllowRp.ValueBool() {
		if state != nil && !state.AllowRp.IsNull() && state.AllowRp.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/allow-rp", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.MdtCMulticastHelloEnable.IsNull() && !data.MdtCMulticastHelloEnable.ValueBool() {
		if state != nil && !state.MdtCMulticastHelloEnable.IsNull() && state.MdtCMulticastHelloEnable.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/mdt/c-multicast-routing/mdt-hello", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.MdtCMulticastSuppressPimDataSignaling.IsNull() && !data.MdtCMulticastSuppressPimDataSignaling.ValueBool() {
		if state != nil && !state.MdtCMulticastSuppressPimDataSignaling.IsNull() && state.MdtCMulticastSuppressPimDataSignaling.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/mdt/c-multicast-routing", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.MdtCMulticastSuppressSharedTreeJoin.IsNull() && !data.MdtCMulticastSuppressSharedTreeJoin.ValueBool() {
		if state != nil && !state.MdtCMulticastSuppressSharedTreeJoin.IsNull() && state.MdtCMulticastSuppressSharedTreeJoin.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/mdt/c-multicast-routing", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.MdtCMulticastSharedTreePrune.IsNull() && !data.MdtCMulticastSharedTreePrune.ValueBool() {
		if state != nil && !state.MdtCMulticastSharedTreePrune.IsNull() && state.MdtCMulticastSharedTreePrune.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/mdt/c-multicast-routing", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.MdtCMulticastAnnouncePimJoinTlv.IsNull() && !data.MdtCMulticastAnnouncePimJoinTlv.ValueBool() {
		if state != nil && !state.MdtCMulticastAnnouncePimJoinTlv.IsNull() && state.MdtCMulticastAnnouncePimJoinTlv.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/mdt/c-multicast-routing", data.getXPath()))
		}
	}
	for i := range data.ExplicitRpfVectorInjects {
		keys := [...]string{"source-address", "masklen"}
		keyValues := [...]string{data.ExplicitRpfVectorInjects[i].SourceAddress.ValueString(), strconv.FormatInt(data.ExplicitRpfVectorInjects[i].SourceMask.ValueInt64(), 10)}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
	}
	for i := range data.RpfVectorInjects {
		keys := [...]string{"source-address", "masklen"}
		keyValues := [...]string{data.RpfVectorInjects[i].SourceAddress.ValueString(), strconv.FormatInt(data.RpfVectorInjects[i].SourceMask.ValueInt64(), 10)}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
	}
	// Only delete if state has true and plan has false
	if !data.RpfVectorStandardEncoding.IsNull() && !data.RpfVectorStandardEncoding.ValueBool() {
		if state != nil && !state.RpfVectorStandardEncoding.IsNull() && state.RpfVectorStandardEncoding.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/rpf-vector", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RpfVectorDisableIbgp.IsNull() && !data.RpfVectorDisableIbgp.ValueBool() {
		if state != nil && !state.RpfVectorDisableIbgp.IsNull() && state.RpfVectorDisableIbgp.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/rpf-vector", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.RpfVectorAllowEbgp.IsNull() && !data.RpfVectorAllowEbgp.ValueBool() {
		if state != nil && !state.RpfVectorAllowEbgp.IsNull() && state.RpfVectorAllowEbgp.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/rpf-vector", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.LogNeighborChanges.IsNull() && !data.LogNeighborChanges.ValueBool() {
		if state != nil && !state.LogNeighborChanges.IsNull() && state.LogNeighborChanges.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/log/neighbor/changes", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.NeighborCheckOnRecv.IsNull() && !data.NeighborCheckOnRecv.ValueBool() {
		if state != nil && !state.NeighborCheckOnRecv.IsNull() && state.NeighborCheckOnRecv.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/neighbor-check-on-recv/enable", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.NeighborCheckOnSend.IsNull() && !data.NeighborCheckOnSend.ValueBool() {
		if state != nil && !state.NeighborCheckOnSend.IsNull() && state.NeighborCheckOnSend.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/neighbor-check-on-send/enable", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.OldRegisterChecksum.IsNull() && !data.OldRegisterChecksum.ValueBool() {
		if state != nil && !state.OldRegisterChecksum.IsNull() && state.OldRegisterChecksum.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/old-register-checksum", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.SptThresholdInfinity.IsNull() && !data.SptThresholdInfinity.ValueBool() {
		if state != nil && !state.SptThresholdInfinity.IsNull() && state.SptThresholdInfinity.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/spt-threshold/infinity", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.SuppressRpfChangePrunes.IsNull() && !data.SuppressRpfChangePrunes.ValueBool() {
		if state != nil && !state.SuppressRpfChangePrunes.IsNull() && state.SuppressRpfChangePrunes.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/suppress-rpf-change-prunes", data.getXPath()))
		}
	}
	// Only delete if state has true and plan has false
	if !data.SuppressDataRegisters.IsNull() && !data.SuppressDataRegisters.ValueBool() {
		if state != nil && !state.SuppressDataRegisters.IsNull() && state.SuppressDataRegisters.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/suppress-data-registers", data.getXPath()))
		}
	}
	for i := range data.RpAddressesBidir {
		keys := [...]string{"address"}
		keyValues := [...]string{data.RpAddressesBidir[i].Address.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		// Only delete if state has true and plan has false
		if !data.RpAddressesBidir[i].Override.IsNull() && !data.RpAddressesBidir[i].Override.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.RpAddressesBidir) && !state.RpAddressesBidir[i].Override.IsNull() && state.RpAddressesBidir[i].Override.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/rp-addresses/bidir/rp-address%v/override", data.getXPath(), keyString))
			}
		}
	}
	for i := range data.RpAddresses {
		keys := [...]string{"address"}
		keyValues := [...]string{data.RpAddresses[i].Address.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		// Only delete if state has true and plan has false
		if !data.RpAddresses[i].Override.IsNull() && !data.RpAddresses[i].Override.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.RpAddresses) && !state.RpAddresses[i].Override.IsNull() && state.RpAddresses[i].Override.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/rp-addresses/rp-address%v/override", data.getXPath(), keyString))
			}
		}
	}
	return emptyLeafsDelete
}

// End of section. //template:end getEmptyLeafsDelete
// Section below is generated&owned by "gen/generator.go". //template:begin getDeletePaths

func (data *RouterPIMIPv4) getDeletePaths(ctx context.Context) []string {
	var deletePaths []string
	for i := range data.Interfaces {
		keyValues := [...]string{data.Interfaces[i].InterfaceName.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/interfaces/interface=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	for i := range data.SrP2mpPolicies {
		keyValues := [...]string{data.SrP2mpPolicies[i].PolicyName.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/sr-p2mp-policies/sr-p2mp-policy=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	for i := range data.MofrrCloneSources {
		keyValues := [...]string{data.MofrrCloneSources[i].SourceAddress.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/mofrr/clone/sources/source=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	for i := range data.MofrrCloneJoins {
		keyValues := [...]string{data.MofrrCloneJoins[i].SourceAddress.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/mofrr/clone/joins/join=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	if !data.MofrrNonRevertive.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/mofrr/non-revertive", data.getPath()))
	}
	if !data.MofrrProtectLocalFaultOnly.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/mofrr/local-fault-only", data.getPath()))
	}
	if !data.MofrrProtect.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/mofrr/protect", data.getPath()))
	}
	if !data.MofrrRib.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/mofrr/rib", data.getPath()))
	}
	if !data.MofrrFlow.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/mofrr/flow", data.getPath()))
	}
	if !data.Mofrr.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/mofrr", data.getPath()))
	}
	for i := range data.BsrRelayVrfs {
		keyValues := [...]string{data.BsrRelayVrfs[i].VrfName.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/bsr/relay/vrfs/vrf=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	for i := range data.BsrCandidateRps {
		keyValues := [...]string{data.BsrCandidateRps[i].Address.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/bsr/candidate-rps/candidate-rp=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	if !data.BsrCandidateBsrPriority.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/bsr/candidate-bsr", data.getPath()))
	}
	if !data.BsrCandidateBsrHashMaskLen.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/bsr/candidate-bsr", data.getPath()))
	}
	if !data.BsrCandidateBsrAddress.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/bsr/candidate-bsr", data.getPath()))
	}
	for i := range data.AutoRpRelayVrfs {
		keyValues := [...]string{data.AutoRpRelayVrfs[i].VrfName.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/auto-rp/relay/vrfs/vrf=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	if !data.AutoRpListenDisable.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/auto-rp/listen/disable", data.getPath()))
	}
	for i := range data.AutoRpCandidateRps {
		keyValues := [...]string{data.AutoRpCandidateRps[i].InterfaceName.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/auto-rp/candidate-rps/candidate-rp=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	if !data.AutoRpMappingAgentInterval.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/auto-rp/mapping-agent", data.getPath()))
	}
	if !data.AutoRpMappingAgentScope.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/auto-rp/mapping-agent", data.getPath()))
	}
	if !data.AutoRpMappingAgentInterface.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/auto-rp/mapping-agent", data.getPath()))
	}
	if !data.MultipathHashSourceGroup.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/multipath/hash", data.getPath()))
	}
	if !data.MultipathHashSourceNexthop.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/multipath/hash", data.getPath()))
	}
	if !data.MultipathHashSource.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/multipath/hash", data.getPath()))
	}
	if !data.Multipath.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/multipath", data.getPath()))
	}
	if !data.RpfRedirectRoutePolicy.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/rpf-redirect/route-policy", data.getPath()))
	}
	if !data.SsmAllowOverride.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/ssm/allow-override", data.getPath()))
	}
	if !data.SsmDisable.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/ssm/disable", data.getPath()))
	}
	if !data.SsmRange.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/ssm/range", data.getPath()))
	}
	if !data.SgList.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/sg-expiry-timer", data.getPath()))
	}
	if !data.SgExpiryTimer.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/sg-expiry-timer", data.getPath()))
	}
	if !data.AllowRpGroupList.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/allow-rp/group-list", data.getPath()))
	}
	if !data.AllowRpList.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/allow-rp/rp-list", data.getPath()))
	}
	if !data.AllowRp.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/allow-rp", data.getPath()))
	}
	if !data.MdtCMulticastMigrationRoutePolicy.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/mdt/c-multicast-routing", data.getPath()))
	}
	if !data.MdtCMulticastSourceTreePruneDelay.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/mdt/c-multicast-routing", data.getPath()))
	}
	if !data.MdtCMulticastSharedTreePruneDelay.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/mdt/c-multicast-routing", data.getPath()))
	}
	if !data.MdtCMulticastHelloEnable.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/mdt/c-multicast-routing/mdt-hello", data.getPath()))
	}
	if !data.MdtCMulticastSuppressPimDataSignaling.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/mdt/c-multicast-routing", data.getPath()))
	}
	if !data.MdtCMulticastSuppressSharedTreeJoin.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/mdt/c-multicast-routing", data.getPath()))
	}
	if !data.MdtCMulticastSharedTreePrune.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/mdt/c-multicast-routing", data.getPath()))
	}
	if !data.MdtCMulticastAnnouncePimJoinTlv.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/mdt/c-multicast-routing", data.getPath()))
	}
	if !data.MdtCMulticastType.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/mdt/c-multicast-routing", data.getPath()))
	}
	if !data.MdtDataAnnounceInterval.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/mdt/data/announce-interval", data.getPath()))
	}
	if !data.MdtDataSwitchoverInterval.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/mdt/data/switchover-interval", data.getPath()))
	}
	if !data.MdtNeighborFilter.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/mdt/neighbor-filter", data.getPath()))
	}
	if !data.RpfTopologyRoutePolicy.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/rpf/topology/route-policy", data.getPath()))
	}
	for i := range data.ExplicitRpfVectorInjects {
		keyValues := [...]string{data.ExplicitRpfVectorInjects[i].SourceAddress.ValueString(), strconv.FormatInt(data.ExplicitRpfVectorInjects[i].SourceMask.ValueInt64(), 10)}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/explicit-rpf-vector/injects/inject=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	for i := range data.RpfVectorInjects {
		keyValues := [...]string{data.RpfVectorInjects[i].SourceAddress.ValueString(), strconv.FormatInt(data.RpfVectorInjects[i].SourceMask.ValueInt64(), 10)}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/rpf-vector-injects/inject=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	if !data.RpfVectorStandardEncoding.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/rpf-vector", data.getPath()))
	}
	if !data.RpfVectorDisableIbgp.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/rpf-vector", data.getPath()))
	}
	if !data.RpfVectorAllowEbgp.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/rpf-vector", data.getPath()))
	}
	if !data.LogNeighborChanges.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/log/neighbor/changes", data.getPath()))
	}
	if !data.MaximumBsrCrpCacheThreshold.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/maximum/bsr/crp-cache", data.getPath()))
	}
	if !data.MaximumBsrCrpCacheMaximum.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/maximum/bsr/crp-cache", data.getPath()))
	}
	if !data.MaximumGroupMappingsAutorpThreshold.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/maximum/group-mappings/autorp", data.getPath()))
	}
	if !data.MaximumGroupMappingsAutorp.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/maximum/group-mappings/autorp", data.getPath()))
	}
	if !data.MaximumGroupMappingsBsrThreshold.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/maximum/group-mappings/bsr", data.getPath()))
	}
	if !data.MaximumGroupMappingsBsr.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/maximum/group-mappings/bsr", data.getPath()))
	}
	if !data.MaximumRegisterStatesThreshold.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/maximum/register-states", data.getPath()))
	}
	if !data.MaximumRegisterStates.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/maximum/register-states", data.getPath()))
	}
	if !data.MaximumRouteInterfacesThreshold.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/maximum/route-interfaces", data.getPath()))
	}
	if !data.MaximumRouteInterfaces.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/maximum/route-interfaces", data.getPath()))
	}
	if !data.MaximumRoutesThreshold.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/maximum/routes", data.getPath()))
	}
	if !data.MaximumRoutes.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/maximum/routes", data.getPath()))
	}
	if !data.GlobalMaximumBsrCrpCacheThreshold.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/global/maximum/bsr/crp-cache", data.getPath()))
	}
	if !data.GlobalMaximumBsrCrpCacheMaximum.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/global/maximum/bsr/crp-cache", data.getPath()))
	}
	if !data.GlobalMaximumGroupMappingsAutorpThreshold.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/global/maximum/group-mappings/autorp", data.getPath()))
	}
	if !data.GlobalMaximumGroupMappingsAutorp.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/global/maximum/group-mappings/autorp", data.getPath()))
	}
	if !data.GlobalMaximumGroupMappingsBsrThreshold.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/global/maximum/group-mappings/bsr", data.getPath()))
	}
	if !data.GlobalMaximumGroupMappingsBsr.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/global/maximum/group-mappings/bsr", data.getPath()))
	}
	if !data.GlobalMaximumPacketQueueLowPriority.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/global/maximum/packet-queue/low-priority", data.getPath()))
	}
	if !data.GlobalMaximumPacketQueueHighPriority.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/global/maximum/packet-queue/high-priority", data.getPath()))
	}
	if !data.GlobalMaximumRegisterStatesThreshold.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/global/maximum/register-states", data.getPath()))
	}
	if !data.GlobalMaximumRegisterStates.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/global/maximum/register-states", data.getPath()))
	}
	if !data.GlobalMaximumRouteInterfacesThreshold.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/global/maximum/route-interfaces", data.getPath()))
	}
	if !data.GlobalMaximumRouteInterfaces.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/global/maximum/route-interfaces", data.getPath()))
	}
	if !data.GlobalMaximumRoutesThreshold.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/global/maximum/routes", data.getPath()))
	}
	if !data.GlobalMaximumRoutes.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/global/maximum/routes", data.getPath()))
	}
	if !data.OverrideInterval.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/override-interval", data.getPath()))
	}
	if !data.PropagationDelay.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/propagation-delay", data.getPath()))
	}
	if !data.JoinPruneMtu.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/join-prune-mtu", data.getPath()))
	}
	if !data.JoinPruneInterval.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/join-prune-interval", data.getPath()))
	}
	if !data.DrPriority.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/dr-priority", data.getPath()))
	}
	if !data.MdtHelloInterval.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/mdt-hello-interval", data.getPath()))
	}
	if !data.HelloInterval.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/hello-interval", data.getPath()))
	}
	if !data.NeighborCheckOnRecv.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/neighbor-check-on-recv/enable", data.getPath()))
	}
	if !data.NeighborCheckOnSend.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/neighbor-check-on-send/enable", data.getPath()))
	}
	if !data.NsfLifetime.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/nsf/lifetime", data.getPath()))
	}
	if !data.OldRegisterChecksum.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/old-register-checksum", data.getPath()))
	}
	if !data.SptThresholdInfinityGroupList.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/spt-threshold/infinity/group-list", data.getPath()))
	}
	if !data.SptThresholdInfinity.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/spt-threshold/infinity", data.getPath()))
	}
	if !data.ConvergenceLinkDownPruneDelay.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/convergence/link-down-prune-delay", data.getPath()))
	}
	if !data.ConvergenceRpfConflictJoinDelay.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/convergence/rpf-conflict-join-delay", data.getPath()))
	}
	if !data.NeighborFilter.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/neighbor-filter", data.getPath()))
	}
	if !data.SuppressRpfChangePrunes.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/suppress-rpf-change-prunes", data.getPath()))
	}
	if !data.RegisterSource.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/register-source", data.getPath()))
	}
	if !data.SuppressDataRegisters.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/suppress-data-registers", data.getPath()))
	}
	if !data.AcceptRegister.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/accept-register", data.getPath()))
	}
	if !data.RpStaticDeny.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/rp-static-deny", data.getPath()))
	}
	for i := range data.RpAddressesBidir {
		keyValues := [...]string{data.RpAddressesBidir[i].Address.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/rp-addresses/bidir/rp-address=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	for i := range data.RpAddresses {
		keyValues := [...]string{data.RpAddresses[i].Address.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/rp-addresses/rp-address=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}

	return deletePaths
}

// End of section. //template:end getDeletePaths
// Section below is generated&owned by "gen/generator.go". //template:begin addDeletedItemsXML

func (data *RouterPIMIPv4) addDeletedItemsXML(ctx context.Context, state RouterPIMIPv4, body string) string {
	deleteXml := ""
	deletedPaths := make(map[string]bool)
	_ = deletedPaths // Avoid unused variable error when no delete_parent attributes exist
	for i := range state.Interfaces {
		stateKeys := [...]string{"interface-name"}
		stateKeyValues := [...]string{state.Interfaces[i].InterfaceName.ValueString()}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.Interfaces[i].InterfaceName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Interfaces {
			found = true
			if state.Interfaces[i].InterfaceName.ValueString() != data.Interfaces[j].InterfaceName.ValueString() {
				found = false
			}
			if found {
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Interfaces[i].BsrBorder.IsNull() && state.Interfaces[i].BsrBorder.ValueBool() && data.Interfaces[j].BsrBorder.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/bsr-border", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Interfaces[i].BfdFastDetect.IsNull() && state.Interfaces[i].BfdFastDetect.ValueBool() && data.Interfaces[j].BfdFastDetect.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/bfd/fast-detect", predicates))
				}
				if !state.Interfaces[i].BfdMinimumInterval.IsNull() && data.Interfaces[j].BfdMinimumInterval.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/bfd/minimum-interval", predicates))
				}
				if !state.Interfaces[i].BfdMultiplier.IsNull() && data.Interfaces[j].BfdMultiplier.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/bfd/multiplier", predicates))
				}
				if !state.Interfaces[i].MaximumRouteInterfacesAccessList.IsNull() && data.Interfaces[j].MaximumRouteInterfacesAccessList.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/maximum/route-interfaces", predicates))
				}
				if !state.Interfaces[i].MaximumRouteInterfacesThreshold.IsNull() && data.Interfaces[j].MaximumRouteInterfacesThreshold.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/maximum/route-interfaces", predicates))
				}
				if !state.Interfaces[i].MaximumRouteInterfaces.IsNull() && data.Interfaces[j].MaximumRouteInterfaces.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/maximum/route-interfaces", predicates))
				}
				if !state.Interfaces[i].NeighborFilter.IsNull() && data.Interfaces[j].NeighborFilter.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/neighbor-filter", predicates))
				}
				if !state.Interfaces[i].OverrideInterval.IsNull() && data.Interfaces[j].OverrideInterval.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/override-interval", predicates))
				}
				if !state.Interfaces[i].PropagationDelay.IsNull() && data.Interfaces[j].PropagationDelay.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/propagation-delay", predicates))
				}
				if !state.Interfaces[i].JoinPruneMtu.IsNull() && data.Interfaces[j].JoinPruneMtu.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/join-prune-mtu", predicates))
				}
				if !state.Interfaces[i].JoinPruneInterval.IsNull() && data.Interfaces[j].JoinPruneInterval.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/join-prune-interval", predicates))
				}
				if !state.Interfaces[i].HelloInterval.IsNull() && data.Interfaces[j].HelloInterval.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/hello-interval", predicates))
				}
				if !state.Interfaces[i].DrPriority.IsNull() && data.Interfaces[j].DrPriority.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/dr-priority", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Interfaces[i].Disable.IsNull() && state.Interfaces[i].Disable.ValueBool() && data.Interfaces[j].Disable.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/disable", predicates))
				}
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.Interfaces[i].Enable.IsNull() && state.Interfaces[i].Enable.ValueBool() && data.Interfaces[j].Enable.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/enable", predicates))
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v", predicates))
		}
	}
	for i := range state.SrP2mpPolicies {
		stateKeys := [...]string{"sr-p2mp-policy-id"}
		stateKeyValues := [...]string{state.SrP2mpPolicies[i].PolicyName.ValueString()}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.SrP2mpPolicies[i].PolicyName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.SrP2mpPolicies {
			found = true
			if state.SrP2mpPolicies[i].PolicyName.ValueString() != data.SrP2mpPolicies[j].PolicyName.ValueString() {
				found = false
			}
			if found {
				for ci := range state.SrP2mpPolicies[i].StaticGroups {
					cstateKeys := [...]string{"group-address"}
					cstateKeyValues := [...]string{state.SrP2mpPolicies[i].StaticGroups[ci].GroupAddress.ValueString()}
					cpredicates := ""
					for i := range cstateKeys {
						cpredicates += fmt.Sprintf("[%s='%s']", cstateKeys[i], cstateKeyValues[i])
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.SrP2mpPolicies[i].StaticGroups[ci].GroupAddress.ValueString()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.SrP2mpPolicies[j].StaticGroups {
						found = true
						if state.SrP2mpPolicies[i].StaticGroups[ci].GroupAddress.ValueString() != data.SrP2mpPolicies[j].StaticGroups[cj].GroupAddress.ValueString() {
							found = false
						}
						if found {
							// For boolean fields, only delete if state was true (presence container was set)
							if !state.SrP2mpPolicies[i].StaticGroups[ci].GroupAddressOnly.IsNull() && state.SrP2mpPolicies[i].StaticGroups[ci].GroupAddressOnly.ValueBool() && data.SrP2mpPolicies[j].StaticGroups[cj].GroupAddressOnly.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/sr-p2mp-policies/sr-p2mp-policy%v/static-group/group-address%v/group-address-only", predicates, cpredicates))
							}
							break
						}
					}
					if !found {
						deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/sr-p2mp-policies/sr-p2mp-policy%v/static-group/group-address%v", predicates, cpredicates))
					}
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/sr-p2mp-policies/sr-p2mp-policy%v", predicates))
		}
	}
	for i := range state.MofrrCloneSources {
		stateKeys := [...]string{"address"}
		stateKeyValues := [...]string{state.MofrrCloneSources[i].SourceAddress.ValueString()}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.MofrrCloneSources[i].SourceAddress.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.MofrrCloneSources {
			found = true
			if state.MofrrCloneSources[i].SourceAddress.ValueString() != data.MofrrCloneSources[j].SourceAddress.ValueString() {
				found = false
			}
			if found {
				for ci := range state.MofrrCloneSources[i].To {
					cstateKeys := [...]string{"address"}
					cstateKeyValues := [...]string{state.MofrrCloneSources[i].To[ci].PrimaryAddress.ValueString()}
					cpredicates := ""
					for i := range cstateKeys {
						cpredicates += fmt.Sprintf("[%s='%s']", cstateKeys[i], cstateKeyValues[i])
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.MofrrCloneSources[i].To[ci].PrimaryAddress.ValueString()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.MofrrCloneSources[j].To {
						found = true
						if state.MofrrCloneSources[i].To[ci].PrimaryAddress.ValueString() != data.MofrrCloneSources[j].To[cj].PrimaryAddress.ValueString() {
							found = false
						}
						if found {
							break
						}
					}
					if !found {
						deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/mofrr/clone/sources/source%v/to%v", predicates, cpredicates))
					}
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/mofrr/clone/sources/source%v", predicates))
		}
	}
	for i := range state.MofrrCloneJoins {
		stateKeys := [...]string{"address"}
		stateKeyValues := [...]string{state.MofrrCloneJoins[i].SourceAddress.ValueString()}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.MofrrCloneJoins[i].SourceAddress.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.MofrrCloneJoins {
			found = true
			if state.MofrrCloneJoins[i].SourceAddress.ValueString() != data.MofrrCloneJoins[j].SourceAddress.ValueString() {
				found = false
			}
			if found {
				for ci := range state.MofrrCloneJoins[i].To {
					cstateKeys := [...]string{"address"}
					cstateKeyValues := [...]string{state.MofrrCloneJoins[i].To[ci].PrimaryAddress.ValueString()}
					cpredicates := ""
					for i := range cstateKeys {
						cpredicates += fmt.Sprintf("[%s='%s']", cstateKeys[i], cstateKeyValues[i])
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.MofrrCloneJoins[i].To[ci].PrimaryAddress.ValueString()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.MofrrCloneJoins[j].To {
						found = true
						if state.MofrrCloneJoins[i].To[ci].PrimaryAddress.ValueString() != data.MofrrCloneJoins[j].To[cj].PrimaryAddress.ValueString() {
							found = false
						}
						if found {
							break
						}
					}
					if !found {
						deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/mofrr/clone/joins/join%v/to%v", predicates, cpredicates))
					}
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/mofrr/clone/joins/join%v", predicates))
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.MofrrNonRevertive.IsNull() && state.MofrrNonRevertive.ValueBool() && data.MofrrNonRevertive.IsNull() {
		deletePath := state.getXPath() + "/mofrr/non-revertive"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.MofrrProtectLocalFaultOnly.IsNull() && state.MofrrProtectLocalFaultOnly.ValueBool() && data.MofrrProtectLocalFaultOnly.IsNull() {
		deletePath := state.getXPath() + "/mofrr/local-fault-only"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MofrrProtect.IsNull() && data.MofrrProtect.IsNull() {
		deletePath := state.getXPath() + "/mofrr/protect"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MofrrRib.IsNull() && data.MofrrRib.IsNull() {
		deletePath := state.getXPath() + "/mofrr/rib"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MofrrFlow.IsNull() && data.MofrrFlow.IsNull() {
		deletePath := state.getXPath() + "/mofrr/flow"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.Mofrr.IsNull() && state.Mofrr.ValueBool() && data.Mofrr.IsNull() {
		deletePath := state.getXPath() + "/mofrr"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	for i := range state.BsrRelayVrfs {
		stateKeys := [...]string{"vrf-name"}
		stateKeyValues := [...]string{state.BsrRelayVrfs[i].VrfName.ValueString()}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.BsrRelayVrfs[i].VrfName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.BsrRelayVrfs {
			found = true
			if state.BsrRelayVrfs[i].VrfName.ValueString() != data.BsrRelayVrfs[j].VrfName.ValueString() {
				found = false
			}
			if found {
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.BsrRelayVrfs[i].Listen.IsNull() && state.BsrRelayVrfs[i].Listen.ValueBool() && data.BsrRelayVrfs[j].Listen.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/bsr/relay/vrfs/vrf%v/listen", predicates))
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/bsr/relay/vrfs/vrf%v", predicates))
		}
	}
	for i := range state.BsrCandidateRps {
		stateKeys := [...]string{"address"}
		stateKeyValues := [...]string{state.BsrCandidateRps[i].Address.ValueString()}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.BsrCandidateRps[i].Address.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.BsrCandidateRps {
			found = true
			if state.BsrCandidateRps[i].Address.ValueString() != data.BsrCandidateRps[j].Address.ValueString() {
				found = false
			}
			if found {
				if !state.BsrCandidateRps[i].BidirInterval.IsNull() && data.BsrCandidateRps[j].BidirInterval.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/bsr/candidate-rps/candidate-rp%v/bidir/interval", predicates))
				}
				if !state.BsrCandidateRps[i].BidirPriority.IsNull() && data.BsrCandidateRps[j].BidirPriority.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/bsr/candidate-rps/candidate-rp%v/bidir/priority", predicates))
				}
				if !state.BsrCandidateRps[i].BidirGroupList.IsNull() && data.BsrCandidateRps[j].BidirGroupList.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/bsr/candidate-rps/candidate-rp%v/bidir/group-list", predicates))
				}
				if !state.BsrCandidateRps[i].Interval.IsNull() && data.BsrCandidateRps[j].Interval.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/bsr/candidate-rps/candidate-rp%v/interval", predicates))
				}
				if !state.BsrCandidateRps[i].Priority.IsNull() && data.BsrCandidateRps[j].Priority.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/bsr/candidate-rps/candidate-rp%v/priority", predicates))
				}
				if !state.BsrCandidateRps[i].GroupList.IsNull() && data.BsrCandidateRps[j].GroupList.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/bsr/candidate-rps/candidate-rp%v/group-list", predicates))
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/bsr/candidate-rps/candidate-rp%v", predicates))
		}
	}
	if !state.BsrCandidateBsrPriority.IsNull() && data.BsrCandidateBsrPriority.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/bsr/candidate-bsr"
		predicates := make(map[string]string)
		if !state.BsrCandidateBsrAddress.IsNull() {
			predicates["address"] = fmt.Sprintf("%v", state.BsrCandidateBsrAddress.ValueString())
		}
		if !state.BsrCandidateBsrHashMaskLen.IsNull() {
			predicates["hash-mask-len"] = fmt.Sprintf("%v", state.BsrCandidateBsrHashMaskLen.ValueInt64())
		}
		predicates["priority"] = fmt.Sprintf("%v", state.BsrCandidateBsrPriority.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.BsrCandidateBsrHashMaskLen.IsNull() && data.BsrCandidateBsrHashMaskLen.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/bsr/candidate-bsr"
		predicates := make(map[string]string)
		if !state.BsrCandidateBsrAddress.IsNull() {
			predicates["address"] = fmt.Sprintf("%v", state.BsrCandidateBsrAddress.ValueString())
		}
		if !state.BsrCandidateBsrPriority.IsNull() {
			predicates["priority"] = fmt.Sprintf("%v", state.BsrCandidateBsrPriority.ValueInt64())
		}
		predicates["hash-mask-len"] = fmt.Sprintf("%v", state.BsrCandidateBsrHashMaskLen.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.BsrCandidateBsrAddress.IsNull() && data.BsrCandidateBsrAddress.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/bsr/candidate-bsr"
		predicates := make(map[string]string)
		if !state.BsrCandidateBsrHashMaskLen.IsNull() {
			predicates["hash-mask-len"] = fmt.Sprintf("%v", state.BsrCandidateBsrHashMaskLen.ValueInt64())
		}
		if !state.BsrCandidateBsrPriority.IsNull() {
			predicates["priority"] = fmt.Sprintf("%v", state.BsrCandidateBsrPriority.ValueInt64())
		}
		predicates["address"] = fmt.Sprintf("%v", state.BsrCandidateBsrAddress.ValueString())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	for i := range state.AutoRpRelayVrfs {
		stateKeys := [...]string{"vrf-name"}
		stateKeyValues := [...]string{state.AutoRpRelayVrfs[i].VrfName.ValueString()}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.AutoRpRelayVrfs[i].VrfName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.AutoRpRelayVrfs {
			found = true
			if state.AutoRpRelayVrfs[i].VrfName.ValueString() != data.AutoRpRelayVrfs[j].VrfName.ValueString() {
				found = false
			}
			if found {
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.AutoRpRelayVrfs[i].Listen.IsNull() && state.AutoRpRelayVrfs[i].Listen.ValueBool() && data.AutoRpRelayVrfs[j].Listen.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/auto-rp/relay/vrfs/vrf%v/listen", predicates))
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/auto-rp/relay/vrfs/vrf%v", predicates))
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.AutoRpListenDisable.IsNull() && state.AutoRpListenDisable.ValueBool() && data.AutoRpListenDisable.IsNull() {
		deletePath := state.getXPath() + "/auto-rp/listen/disable"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	for i := range state.AutoRpCandidateRps {
		stateKeys := [...]string{"interface-name"}
		stateKeyValues := [...]string{state.AutoRpCandidateRps[i].InterfaceName.ValueString()}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.AutoRpCandidateRps[i].InterfaceName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.AutoRpCandidateRps {
			found = true
			if state.AutoRpCandidateRps[i].InterfaceName.ValueString() != data.AutoRpCandidateRps[j].InterfaceName.ValueString() {
				found = false
			}
			if found {
				if !state.AutoRpCandidateRps[i].BidirInterval.IsNull() && data.AutoRpCandidateRps[j].BidirInterval.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/auto-rp/candidate-rps/candidate-rp%v/bidir/interval", predicates))
				}
				if !state.AutoRpCandidateRps[i].BidirGroupList.IsNull() && data.AutoRpCandidateRps[j].BidirGroupList.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/auto-rp/candidate-rps/candidate-rp%v/bidir/group-list", predicates))
				}
				if !state.AutoRpCandidateRps[i].BidirScope.IsNull() && data.AutoRpCandidateRps[j].BidirScope.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/auto-rp/candidate-rps/candidate-rp%v/bidir/scope", predicates))
				}
				if !state.AutoRpCandidateRps[i].Interval.IsNull() && data.AutoRpCandidateRps[j].Interval.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/auto-rp/candidate-rps/candidate-rp%v/interval", predicates))
				}
				if !state.AutoRpCandidateRps[i].GroupList.IsNull() && data.AutoRpCandidateRps[j].GroupList.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/auto-rp/candidate-rps/candidate-rp%v/group-list", predicates))
				}
				if !state.AutoRpCandidateRps[i].Scope.IsNull() && data.AutoRpCandidateRps[j].Scope.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/auto-rp/candidate-rps/candidate-rp%v/scope", predicates))
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/auto-rp/candidate-rps/candidate-rp%v", predicates))
		}
	}
	if !state.AutoRpMappingAgentInterval.IsNull() && data.AutoRpMappingAgentInterval.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/auto-rp/mapping-agent"
		predicates := make(map[string]string)
		if !state.AutoRpMappingAgentInterface.IsNull() {
			predicates["interface-name"] = fmt.Sprintf("%v", state.AutoRpMappingAgentInterface.ValueString())
		}
		if !state.AutoRpMappingAgentScope.IsNull() {
			predicates["scope"] = fmt.Sprintf("%v", state.AutoRpMappingAgentScope.ValueInt64())
		}
		predicates["interval"] = fmt.Sprintf("%v", state.AutoRpMappingAgentInterval.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.AutoRpMappingAgentScope.IsNull() && data.AutoRpMappingAgentScope.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/auto-rp/mapping-agent"
		predicates := make(map[string]string)
		if !state.AutoRpMappingAgentInterface.IsNull() {
			predicates["interface-name"] = fmt.Sprintf("%v", state.AutoRpMappingAgentInterface.ValueString())
		}
		if !state.AutoRpMappingAgentInterval.IsNull() {
			predicates["interval"] = fmt.Sprintf("%v", state.AutoRpMappingAgentInterval.ValueInt64())
		}
		predicates["scope"] = fmt.Sprintf("%v", state.AutoRpMappingAgentScope.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.AutoRpMappingAgentInterface.IsNull() && data.AutoRpMappingAgentInterface.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/auto-rp/mapping-agent"
		predicates := make(map[string]string)
		if !state.AutoRpMappingAgentScope.IsNull() {
			predicates["scope"] = fmt.Sprintf("%v", state.AutoRpMappingAgentScope.ValueInt64())
		}
		if !state.AutoRpMappingAgentInterval.IsNull() {
			predicates["interval"] = fmt.Sprintf("%v", state.AutoRpMappingAgentInterval.ValueInt64())
		}
		predicates["interface-name"] = fmt.Sprintf("%v", state.AutoRpMappingAgentInterface.ValueString())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.MultipathHashSourceGroup.IsNull() && state.MultipathHashSourceGroup.ValueBool() && data.MultipathHashSourceGroup.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/multipath/hash"
		predicates := make(map[string]string)
		if !state.MultipathHashSource.IsNull() {
			predicates["source"] = fmt.Sprintf("%v", state.MultipathHashSource.ValueBool())
		}
		if !state.MultipathHashSourceNexthop.IsNull() {
			predicates["source-nexthop"] = fmt.Sprintf("%v", state.MultipathHashSourceNexthop.ValueBool())
		}
		predicates["source-group"] = fmt.Sprintf("%v", state.MultipathHashSourceGroup.ValueBool())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.MultipathHashSourceNexthop.IsNull() && state.MultipathHashSourceNexthop.ValueBool() && data.MultipathHashSourceNexthop.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/multipath/hash"
		predicates := make(map[string]string)
		if !state.MultipathHashSource.IsNull() {
			predicates["source"] = fmt.Sprintf("%v", state.MultipathHashSource.ValueBool())
		}
		if !state.MultipathHashSourceGroup.IsNull() {
			predicates["source-group"] = fmt.Sprintf("%v", state.MultipathHashSourceGroup.ValueBool())
		}
		predicates["source-nexthop"] = fmt.Sprintf("%v", state.MultipathHashSourceNexthop.ValueBool())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.MultipathHashSource.IsNull() && state.MultipathHashSource.ValueBool() && data.MultipathHashSource.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/multipath/hash"
		predicates := make(map[string]string)
		if !state.MultipathHashSourceNexthop.IsNull() {
			predicates["source-nexthop"] = fmt.Sprintf("%v", state.MultipathHashSourceNexthop.ValueBool())
		}
		if !state.MultipathHashSourceGroup.IsNull() {
			predicates["source-group"] = fmt.Sprintf("%v", state.MultipathHashSourceGroup.ValueBool())
		}
		predicates["source"] = fmt.Sprintf("%v", state.MultipathHashSource.ValueBool())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.Multipath.IsNull() && state.Multipath.ValueBool() && data.Multipath.IsNull() {
		deletePath := state.getXPath() + "/multipath"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.RpfRedirectRoutePolicy.IsNull() && data.RpfRedirectRoutePolicy.IsNull() {
		deletePath := state.getXPath() + "/rpf-redirect/route-policy"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.SsmAllowOverride.IsNull() && state.SsmAllowOverride.ValueBool() && data.SsmAllowOverride.IsNull() {
		deletePath := state.getXPath() + "/ssm/allow-override"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.SsmDisable.IsNull() && state.SsmDisable.ValueBool() && data.SsmDisable.IsNull() {
		deletePath := state.getXPath() + "/ssm/disable"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.SsmRange.IsNull() && data.SsmRange.IsNull() {
		deletePath := state.getXPath() + "/ssm/range"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.SgList.IsNull() && data.SgList.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/sg-expiry-timer"
		predicates := make(map[string]string)
		if !state.SgExpiryTimer.IsNull() {
			predicates["sg-expiry-timer-value"] = fmt.Sprintf("%v", state.SgExpiryTimer.ValueInt64())
		}
		predicates["sg-list"] = fmt.Sprintf("%v", state.SgList.ValueString())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.SgExpiryTimer.IsNull() && data.SgExpiryTimer.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/sg-expiry-timer"
		predicates := make(map[string]string)
		if !state.SgList.IsNull() {
			predicates["sg-list"] = fmt.Sprintf("%v", state.SgList.ValueString())
		}
		predicates["sg-expiry-timer-value"] = fmt.Sprintf("%v", state.SgExpiryTimer.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.AllowRpGroupList.IsNull() && data.AllowRpGroupList.IsNull() {
		deletePath := state.getXPath() + "/allow-rp/group-list"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.AllowRpList.IsNull() && data.AllowRpList.IsNull() {
		deletePath := state.getXPath() + "/allow-rp/rp-list"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.AllowRp.IsNull() && state.AllowRp.ValueBool() && data.AllowRp.IsNull() {
		deletePath := state.getXPath() + "/allow-rp"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MdtCMulticastMigrationRoutePolicy.IsNull() && data.MdtCMulticastMigrationRoutePolicy.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/mdt/c-multicast-routing"
		predicates := make(map[string]string)
		if !state.MdtCMulticastType.IsNull() {
			predicates["type"] = fmt.Sprintf("%v", state.MdtCMulticastType.ValueString())
		}
		if !state.MdtCMulticastAnnouncePimJoinTlv.IsNull() {
			predicates["announce-pim-join-tlv"] = fmt.Sprintf("%v", state.MdtCMulticastAnnouncePimJoinTlv.ValueBool())
		}
		if !state.MdtCMulticastSharedTreePrune.IsNull() {
			predicates["shared-tree-prune"] = fmt.Sprintf("%v", state.MdtCMulticastSharedTreePrune.ValueBool())
		}
		if !state.MdtCMulticastSuppressSharedTreeJoin.IsNull() {
			predicates["suppress-shared-tree-join"] = fmt.Sprintf("%v", state.MdtCMulticastSuppressSharedTreeJoin.ValueBool())
		}
		if !state.MdtCMulticastSuppressPimDataSignaling.IsNull() {
			predicates["suppress-pim-data-signaling"] = fmt.Sprintf("%v", state.MdtCMulticastSuppressPimDataSignaling.ValueBool())
		}
		if !state.MdtCMulticastSharedTreePruneDelay.IsNull() {
			predicates["shared-tree-prune-delay"] = fmt.Sprintf("%v", state.MdtCMulticastSharedTreePruneDelay.ValueInt64())
		}
		if !state.MdtCMulticastSourceTreePruneDelay.IsNull() {
			predicates["source-tree-prune-delay"] = fmt.Sprintf("%v", state.MdtCMulticastSourceTreePruneDelay.ValueInt64())
		}
		predicates["route-policy"] = fmt.Sprintf("%v", state.MdtCMulticastMigrationRoutePolicy.ValueString())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MdtCMulticastSourceTreePruneDelay.IsNull() && data.MdtCMulticastSourceTreePruneDelay.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/mdt/c-multicast-routing"
		predicates := make(map[string]string)
		if !state.MdtCMulticastType.IsNull() {
			predicates["type"] = fmt.Sprintf("%v", state.MdtCMulticastType.ValueString())
		}
		if !state.MdtCMulticastAnnouncePimJoinTlv.IsNull() {
			predicates["announce-pim-join-tlv"] = fmt.Sprintf("%v", state.MdtCMulticastAnnouncePimJoinTlv.ValueBool())
		}
		if !state.MdtCMulticastSharedTreePrune.IsNull() {
			predicates["shared-tree-prune"] = fmt.Sprintf("%v", state.MdtCMulticastSharedTreePrune.ValueBool())
		}
		if !state.MdtCMulticastSuppressSharedTreeJoin.IsNull() {
			predicates["suppress-shared-tree-join"] = fmt.Sprintf("%v", state.MdtCMulticastSuppressSharedTreeJoin.ValueBool())
		}
		if !state.MdtCMulticastSuppressPimDataSignaling.IsNull() {
			predicates["suppress-pim-data-signaling"] = fmt.Sprintf("%v", state.MdtCMulticastSuppressPimDataSignaling.ValueBool())
		}
		if !state.MdtCMulticastSharedTreePruneDelay.IsNull() {
			predicates["shared-tree-prune-delay"] = fmt.Sprintf("%v", state.MdtCMulticastSharedTreePruneDelay.ValueInt64())
		}
		if !state.MdtCMulticastMigrationRoutePolicy.IsNull() {
			predicates["route-policy"] = fmt.Sprintf("%v", state.MdtCMulticastMigrationRoutePolicy.ValueString())
		}
		predicates["source-tree-prune-delay"] = fmt.Sprintf("%v", state.MdtCMulticastSourceTreePruneDelay.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MdtCMulticastSharedTreePruneDelay.IsNull() && data.MdtCMulticastSharedTreePruneDelay.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/mdt/c-multicast-routing"
		predicates := make(map[string]string)
		if !state.MdtCMulticastType.IsNull() {
			predicates["type"] = fmt.Sprintf("%v", state.MdtCMulticastType.ValueString())
		}
		if !state.MdtCMulticastAnnouncePimJoinTlv.IsNull() {
			predicates["announce-pim-join-tlv"] = fmt.Sprintf("%v", state.MdtCMulticastAnnouncePimJoinTlv.ValueBool())
		}
		if !state.MdtCMulticastSharedTreePrune.IsNull() {
			predicates["shared-tree-prune"] = fmt.Sprintf("%v", state.MdtCMulticastSharedTreePrune.ValueBool())
		}
		if !state.MdtCMulticastSuppressSharedTreeJoin.IsNull() {
			predicates["suppress-shared-tree-join"] = fmt.Sprintf("%v", state.MdtCMulticastSuppressSharedTreeJoin.ValueBool())
		}
		if !state.MdtCMulticastSuppressPimDataSignaling.IsNull() {
			predicates["suppress-pim-data-signaling"] = fmt.Sprintf("%v", state.MdtCMulticastSuppressPimDataSignaling.ValueBool())
		}
		if !state.MdtCMulticastSourceTreePruneDelay.IsNull() {
			predicates["source-tree-prune-delay"] = fmt.Sprintf("%v", state.MdtCMulticastSourceTreePruneDelay.ValueInt64())
		}
		if !state.MdtCMulticastMigrationRoutePolicy.IsNull() {
			predicates["route-policy"] = fmt.Sprintf("%v", state.MdtCMulticastMigrationRoutePolicy.ValueString())
		}
		predicates["shared-tree-prune-delay"] = fmt.Sprintf("%v", state.MdtCMulticastSharedTreePruneDelay.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.MdtCMulticastHelloEnable.IsNull() && state.MdtCMulticastHelloEnable.ValueBool() && data.MdtCMulticastHelloEnable.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/mdt/c-multicast-routing/mdt-hello"
		predicates := make(map[string]string)
		predicates["enable"] = fmt.Sprintf("%v", state.MdtCMulticastHelloEnable.ValueBool())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.MdtCMulticastSuppressPimDataSignaling.IsNull() && state.MdtCMulticastSuppressPimDataSignaling.ValueBool() && data.MdtCMulticastSuppressPimDataSignaling.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/mdt/c-multicast-routing"
		predicates := make(map[string]string)
		if !state.MdtCMulticastType.IsNull() {
			predicates["type"] = fmt.Sprintf("%v", state.MdtCMulticastType.ValueString())
		}
		if !state.MdtCMulticastAnnouncePimJoinTlv.IsNull() {
			predicates["announce-pim-join-tlv"] = fmt.Sprintf("%v", state.MdtCMulticastAnnouncePimJoinTlv.ValueBool())
		}
		if !state.MdtCMulticastSharedTreePrune.IsNull() {
			predicates["shared-tree-prune"] = fmt.Sprintf("%v", state.MdtCMulticastSharedTreePrune.ValueBool())
		}
		if !state.MdtCMulticastSuppressSharedTreeJoin.IsNull() {
			predicates["suppress-shared-tree-join"] = fmt.Sprintf("%v", state.MdtCMulticastSuppressSharedTreeJoin.ValueBool())
		}
		if !state.MdtCMulticastSharedTreePruneDelay.IsNull() {
			predicates["shared-tree-prune-delay"] = fmt.Sprintf("%v", state.MdtCMulticastSharedTreePruneDelay.ValueInt64())
		}
		if !state.MdtCMulticastSourceTreePruneDelay.IsNull() {
			predicates["source-tree-prune-delay"] = fmt.Sprintf("%v", state.MdtCMulticastSourceTreePruneDelay.ValueInt64())
		}
		if !state.MdtCMulticastMigrationRoutePolicy.IsNull() {
			predicates["route-policy"] = fmt.Sprintf("%v", state.MdtCMulticastMigrationRoutePolicy.ValueString())
		}
		predicates["suppress-pim-data-signaling"] = fmt.Sprintf("%v", state.MdtCMulticastSuppressPimDataSignaling.ValueBool())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.MdtCMulticastSuppressSharedTreeJoin.IsNull() && state.MdtCMulticastSuppressSharedTreeJoin.ValueBool() && data.MdtCMulticastSuppressSharedTreeJoin.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/mdt/c-multicast-routing"
		predicates := make(map[string]string)
		if !state.MdtCMulticastType.IsNull() {
			predicates["type"] = fmt.Sprintf("%v", state.MdtCMulticastType.ValueString())
		}
		if !state.MdtCMulticastAnnouncePimJoinTlv.IsNull() {
			predicates["announce-pim-join-tlv"] = fmt.Sprintf("%v", state.MdtCMulticastAnnouncePimJoinTlv.ValueBool())
		}
		if !state.MdtCMulticastSharedTreePrune.IsNull() {
			predicates["shared-tree-prune"] = fmt.Sprintf("%v", state.MdtCMulticastSharedTreePrune.ValueBool())
		}
		if !state.MdtCMulticastSuppressPimDataSignaling.IsNull() {
			predicates["suppress-pim-data-signaling"] = fmt.Sprintf("%v", state.MdtCMulticastSuppressPimDataSignaling.ValueBool())
		}
		if !state.MdtCMulticastSharedTreePruneDelay.IsNull() {
			predicates["shared-tree-prune-delay"] = fmt.Sprintf("%v", state.MdtCMulticastSharedTreePruneDelay.ValueInt64())
		}
		if !state.MdtCMulticastSourceTreePruneDelay.IsNull() {
			predicates["source-tree-prune-delay"] = fmt.Sprintf("%v", state.MdtCMulticastSourceTreePruneDelay.ValueInt64())
		}
		if !state.MdtCMulticastMigrationRoutePolicy.IsNull() {
			predicates["route-policy"] = fmt.Sprintf("%v", state.MdtCMulticastMigrationRoutePolicy.ValueString())
		}
		predicates["suppress-shared-tree-join"] = fmt.Sprintf("%v", state.MdtCMulticastSuppressSharedTreeJoin.ValueBool())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.MdtCMulticastSharedTreePrune.IsNull() && state.MdtCMulticastSharedTreePrune.ValueBool() && data.MdtCMulticastSharedTreePrune.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/mdt/c-multicast-routing"
		predicates := make(map[string]string)
		if !state.MdtCMulticastType.IsNull() {
			predicates["type"] = fmt.Sprintf("%v", state.MdtCMulticastType.ValueString())
		}
		if !state.MdtCMulticastAnnouncePimJoinTlv.IsNull() {
			predicates["announce-pim-join-tlv"] = fmt.Sprintf("%v", state.MdtCMulticastAnnouncePimJoinTlv.ValueBool())
		}
		if !state.MdtCMulticastSuppressSharedTreeJoin.IsNull() {
			predicates["suppress-shared-tree-join"] = fmt.Sprintf("%v", state.MdtCMulticastSuppressSharedTreeJoin.ValueBool())
		}
		if !state.MdtCMulticastSuppressPimDataSignaling.IsNull() {
			predicates["suppress-pim-data-signaling"] = fmt.Sprintf("%v", state.MdtCMulticastSuppressPimDataSignaling.ValueBool())
		}
		if !state.MdtCMulticastSharedTreePruneDelay.IsNull() {
			predicates["shared-tree-prune-delay"] = fmt.Sprintf("%v", state.MdtCMulticastSharedTreePruneDelay.ValueInt64())
		}
		if !state.MdtCMulticastSourceTreePruneDelay.IsNull() {
			predicates["source-tree-prune-delay"] = fmt.Sprintf("%v", state.MdtCMulticastSourceTreePruneDelay.ValueInt64())
		}
		if !state.MdtCMulticastMigrationRoutePolicy.IsNull() {
			predicates["route-policy"] = fmt.Sprintf("%v", state.MdtCMulticastMigrationRoutePolicy.ValueString())
		}
		predicates["shared-tree-prune"] = fmt.Sprintf("%v", state.MdtCMulticastSharedTreePrune.ValueBool())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.MdtCMulticastAnnouncePimJoinTlv.IsNull() && state.MdtCMulticastAnnouncePimJoinTlv.ValueBool() && data.MdtCMulticastAnnouncePimJoinTlv.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/mdt/c-multicast-routing"
		predicates := make(map[string]string)
		if !state.MdtCMulticastType.IsNull() {
			predicates["type"] = fmt.Sprintf("%v", state.MdtCMulticastType.ValueString())
		}
		if !state.MdtCMulticastSharedTreePrune.IsNull() {
			predicates["shared-tree-prune"] = fmt.Sprintf("%v", state.MdtCMulticastSharedTreePrune.ValueBool())
		}
		if !state.MdtCMulticastSuppressSharedTreeJoin.IsNull() {
			predicates["suppress-shared-tree-join"] = fmt.Sprintf("%v", state.MdtCMulticastSuppressSharedTreeJoin.ValueBool())
		}
		if !state.MdtCMulticastSuppressPimDataSignaling.IsNull() {
			predicates["suppress-pim-data-signaling"] = fmt.Sprintf("%v", state.MdtCMulticastSuppressPimDataSignaling.ValueBool())
		}
		if !state.MdtCMulticastSharedTreePruneDelay.IsNull() {
			predicates["shared-tree-prune-delay"] = fmt.Sprintf("%v", state.MdtCMulticastSharedTreePruneDelay.ValueInt64())
		}
		if !state.MdtCMulticastSourceTreePruneDelay.IsNull() {
			predicates["source-tree-prune-delay"] = fmt.Sprintf("%v", state.MdtCMulticastSourceTreePruneDelay.ValueInt64())
		}
		if !state.MdtCMulticastMigrationRoutePolicy.IsNull() {
			predicates["route-policy"] = fmt.Sprintf("%v", state.MdtCMulticastMigrationRoutePolicy.ValueString())
		}
		predicates["announce-pim-join-tlv"] = fmt.Sprintf("%v", state.MdtCMulticastAnnouncePimJoinTlv.ValueBool())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MdtCMulticastType.IsNull() && data.MdtCMulticastType.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/mdt/c-multicast-routing"
		predicates := make(map[string]string)
		if !state.MdtCMulticastAnnouncePimJoinTlv.IsNull() {
			predicates["announce-pim-join-tlv"] = fmt.Sprintf("%v", state.MdtCMulticastAnnouncePimJoinTlv.ValueBool())
		}
		if !state.MdtCMulticastSharedTreePrune.IsNull() {
			predicates["shared-tree-prune"] = fmt.Sprintf("%v", state.MdtCMulticastSharedTreePrune.ValueBool())
		}
		if !state.MdtCMulticastSuppressSharedTreeJoin.IsNull() {
			predicates["suppress-shared-tree-join"] = fmt.Sprintf("%v", state.MdtCMulticastSuppressSharedTreeJoin.ValueBool())
		}
		if !state.MdtCMulticastSuppressPimDataSignaling.IsNull() {
			predicates["suppress-pim-data-signaling"] = fmt.Sprintf("%v", state.MdtCMulticastSuppressPimDataSignaling.ValueBool())
		}
		if !state.MdtCMulticastSharedTreePruneDelay.IsNull() {
			predicates["shared-tree-prune-delay"] = fmt.Sprintf("%v", state.MdtCMulticastSharedTreePruneDelay.ValueInt64())
		}
		if !state.MdtCMulticastSourceTreePruneDelay.IsNull() {
			predicates["source-tree-prune-delay"] = fmt.Sprintf("%v", state.MdtCMulticastSourceTreePruneDelay.ValueInt64())
		}
		if !state.MdtCMulticastMigrationRoutePolicy.IsNull() {
			predicates["route-policy"] = fmt.Sprintf("%v", state.MdtCMulticastMigrationRoutePolicy.ValueString())
		}
		predicates["type"] = fmt.Sprintf("%v", state.MdtCMulticastType.ValueString())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MdtDataAnnounceInterval.IsNull() && data.MdtDataAnnounceInterval.IsNull() {
		deletePath := state.getXPath() + "/mdt/data/announce-interval"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MdtDataSwitchoverInterval.IsNull() && data.MdtDataSwitchoverInterval.IsNull() {
		deletePath := state.getXPath() + "/mdt/data/switchover-interval"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MdtNeighborFilter.IsNull() && data.MdtNeighborFilter.IsNull() {
		deletePath := state.getXPath() + "/mdt/neighbor-filter"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.RpfTopologyRoutePolicy.IsNull() && data.RpfTopologyRoutePolicy.IsNull() {
		deletePath := state.getXPath() + "/rpf/topology/route-policy"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	for i := range state.ExplicitRpfVectorInjects {
		stateKeys := [...]string{"source-address", "masklen"}
		stateKeyValues := [...]string{state.ExplicitRpfVectorInjects[i].SourceAddress.ValueString(), strconv.FormatInt(state.ExplicitRpfVectorInjects[i].SourceMask.ValueInt64(), 10)}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.ExplicitRpfVectorInjects[i].SourceAddress.ValueString()).IsZero() {
			emptyKeys = false
		}
		if !reflect.ValueOf(state.ExplicitRpfVectorInjects[i].SourceMask.ValueInt64()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.ExplicitRpfVectorInjects {
			found = true
			if state.ExplicitRpfVectorInjects[i].SourceAddress.ValueString() != data.ExplicitRpfVectorInjects[j].SourceAddress.ValueString() {
				found = false
			}
			if state.ExplicitRpfVectorInjects[i].SourceMask.ValueInt64() != data.ExplicitRpfVectorInjects[j].SourceMask.ValueInt64() {
				found = false
			}
			if found {
				if !state.ExplicitRpfVectorInjects[i].RpfVectors.IsNull() {
					if data.ExplicitRpfVectorInjects[j].RpfVectors.IsNull() {
						var values []string
						state.ExplicitRpfVectorInjects[i].RpfVectors.ElementsAs(ctx, &values, false)
						for _, v := range values {
							deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/explicit-rpf-vector/injects/inject%v/rpf-vector[.=%v]", predicates, v))
						}
					} else {
						var dataValues, stateValues []string
						data.ExplicitRpfVectorInjects[i].RpfVectors.ElementsAs(ctx, &dataValues, false)
						state.ExplicitRpfVectorInjects[j].RpfVectors.ElementsAs(ctx, &stateValues, false)
						for _, v := range stateValues {
							found := false
							for _, vv := range dataValues {
								if v == vv {
									found = true
									break
								}
							}
							if !found {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/explicit-rpf-vector/injects/inject%v/rpf-vector[.=%v]", predicates, v))
							}
						}
					}
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/explicit-rpf-vector/injects/inject%v", predicates))
		}
	}
	for i := range state.RpfVectorInjects {
		stateKeys := [...]string{"source-address", "masklen"}
		stateKeyValues := [...]string{state.RpfVectorInjects[i].SourceAddress.ValueString(), strconv.FormatInt(state.RpfVectorInjects[i].SourceMask.ValueInt64(), 10)}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.RpfVectorInjects[i].SourceAddress.ValueString()).IsZero() {
			emptyKeys = false
		}
		if !reflect.ValueOf(state.RpfVectorInjects[i].SourceMask.ValueInt64()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.RpfVectorInjects {
			found = true
			if state.RpfVectorInjects[i].SourceAddress.ValueString() != data.RpfVectorInjects[j].SourceAddress.ValueString() {
				found = false
			}
			if state.RpfVectorInjects[i].SourceMask.ValueInt64() != data.RpfVectorInjects[j].SourceMask.ValueInt64() {
				found = false
			}
			if found {
				if !state.RpfVectorInjects[i].RpfVectors.IsNull() {
					if data.RpfVectorInjects[j].RpfVectors.IsNull() {
						var values []string
						state.RpfVectorInjects[i].RpfVectors.ElementsAs(ctx, &values, false)
						for _, v := range values {
							deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/rpf-vector-injects/inject%v/rpf-vector[.=%v]", predicates, v))
						}
					} else {
						var dataValues, stateValues []string
						data.RpfVectorInjects[i].RpfVectors.ElementsAs(ctx, &dataValues, false)
						state.RpfVectorInjects[j].RpfVectors.ElementsAs(ctx, &stateValues, false)
						for _, v := range stateValues {
							found := false
							for _, vv := range dataValues {
								if v == vv {
									found = true
									break
								}
							}
							if !found {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/rpf-vector-injects/inject%v/rpf-vector[.=%v]", predicates, v))
							}
						}
					}
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/rpf-vector-injects/inject%v", predicates))
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RpfVectorStandardEncoding.IsNull() && state.RpfVectorStandardEncoding.ValueBool() && data.RpfVectorStandardEncoding.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/rpf-vector"
		predicates := make(map[string]string)
		if !state.RpfVectorAllowEbgp.IsNull() {
			predicates["allow-ebgp"] = fmt.Sprintf("%v", state.RpfVectorAllowEbgp.ValueBool())
		}
		if !state.RpfVectorDisableIbgp.IsNull() {
			predicates["disable-ibgp"] = fmt.Sprintf("%v", state.RpfVectorDisableIbgp.ValueBool())
		}
		predicates["use-standard-encoding"] = fmt.Sprintf("%v", state.RpfVectorStandardEncoding.ValueBool())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RpfVectorDisableIbgp.IsNull() && state.RpfVectorDisableIbgp.ValueBool() && data.RpfVectorDisableIbgp.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/rpf-vector"
		predicates := make(map[string]string)
		if !state.RpfVectorAllowEbgp.IsNull() {
			predicates["allow-ebgp"] = fmt.Sprintf("%v", state.RpfVectorAllowEbgp.ValueBool())
		}
		if !state.RpfVectorStandardEncoding.IsNull() {
			predicates["use-standard-encoding"] = fmt.Sprintf("%v", state.RpfVectorStandardEncoding.ValueBool())
		}
		predicates["disable-ibgp"] = fmt.Sprintf("%v", state.RpfVectorDisableIbgp.ValueBool())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.RpfVectorAllowEbgp.IsNull() && state.RpfVectorAllowEbgp.ValueBool() && data.RpfVectorAllowEbgp.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/rpf-vector"
		predicates := make(map[string]string)
		if !state.RpfVectorDisableIbgp.IsNull() {
			predicates["disable-ibgp"] = fmt.Sprintf("%v", state.RpfVectorDisableIbgp.ValueBool())
		}
		if !state.RpfVectorStandardEncoding.IsNull() {
			predicates["use-standard-encoding"] = fmt.Sprintf("%v", state.RpfVectorStandardEncoding.ValueBool())
		}
		predicates["allow-ebgp"] = fmt.Sprintf("%v", state.RpfVectorAllowEbgp.ValueBool())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.LogNeighborChanges.IsNull() && state.LogNeighborChanges.ValueBool() && data.LogNeighborChanges.IsNull() {
		deletePath := state.getXPath() + "/log/neighbor/changes"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MaximumBsrCrpCacheThreshold.IsNull() && data.MaximumBsrCrpCacheThreshold.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/maximum/bsr/crp-cache"
		predicates := make(map[string]string)
		if !state.MaximumBsrCrpCacheMaximum.IsNull() {
			predicates["maximum-crp-cache"] = fmt.Sprintf("%v", state.MaximumBsrCrpCacheMaximum.ValueInt64())
		}
		predicates["threshold"] = fmt.Sprintf("%v", state.MaximumBsrCrpCacheThreshold.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MaximumBsrCrpCacheMaximum.IsNull() && data.MaximumBsrCrpCacheMaximum.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/maximum/bsr/crp-cache"
		predicates := make(map[string]string)
		if !state.MaximumBsrCrpCacheThreshold.IsNull() {
			predicates["threshold"] = fmt.Sprintf("%v", state.MaximumBsrCrpCacheThreshold.ValueInt64())
		}
		predicates["maximum-crp-cache"] = fmt.Sprintf("%v", state.MaximumBsrCrpCacheMaximum.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MaximumGroupMappingsAutorpThreshold.IsNull() && data.MaximumGroupMappingsAutorpThreshold.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/maximum/group-mappings/autorp"
		predicates := make(map[string]string)
		if !state.MaximumGroupMappingsAutorp.IsNull() {
			predicates["maximum-autorp"] = fmt.Sprintf("%v", state.MaximumGroupMappingsAutorp.ValueInt64())
		}
		predicates["threshold"] = fmt.Sprintf("%v", state.MaximumGroupMappingsAutorpThreshold.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MaximumGroupMappingsAutorp.IsNull() && data.MaximumGroupMappingsAutorp.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/maximum/group-mappings/autorp"
		predicates := make(map[string]string)
		if !state.MaximumGroupMappingsAutorpThreshold.IsNull() {
			predicates["threshold"] = fmt.Sprintf("%v", state.MaximumGroupMappingsAutorpThreshold.ValueInt64())
		}
		predicates["maximum-autorp"] = fmt.Sprintf("%v", state.MaximumGroupMappingsAutorp.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MaximumGroupMappingsBsrThreshold.IsNull() && data.MaximumGroupMappingsBsrThreshold.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/maximum/group-mappings/bsr"
		predicates := make(map[string]string)
		if !state.MaximumGroupMappingsBsr.IsNull() {
			predicates["maximum-bsr"] = fmt.Sprintf("%v", state.MaximumGroupMappingsBsr.ValueInt64())
		}
		predicates["threshold"] = fmt.Sprintf("%v", state.MaximumGroupMappingsBsrThreshold.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MaximumGroupMappingsBsr.IsNull() && data.MaximumGroupMappingsBsr.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/maximum/group-mappings/bsr"
		predicates := make(map[string]string)
		if !state.MaximumGroupMappingsBsrThreshold.IsNull() {
			predicates["threshold"] = fmt.Sprintf("%v", state.MaximumGroupMappingsBsrThreshold.ValueInt64())
		}
		predicates["maximum-bsr"] = fmt.Sprintf("%v", state.MaximumGroupMappingsBsr.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MaximumRegisterStatesThreshold.IsNull() && data.MaximumRegisterStatesThreshold.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/maximum/register-states"
		predicates := make(map[string]string)
		if !state.MaximumRegisterStates.IsNull() {
			predicates["maximum-register-states"] = fmt.Sprintf("%v", state.MaximumRegisterStates.ValueInt64())
		}
		predicates["threshold"] = fmt.Sprintf("%v", state.MaximumRegisterStatesThreshold.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MaximumRegisterStates.IsNull() && data.MaximumRegisterStates.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/maximum/register-states"
		predicates := make(map[string]string)
		if !state.MaximumRegisterStatesThreshold.IsNull() {
			predicates["threshold"] = fmt.Sprintf("%v", state.MaximumRegisterStatesThreshold.ValueInt64())
		}
		predicates["maximum-register-states"] = fmt.Sprintf("%v", state.MaximumRegisterStates.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MaximumRouteInterfacesThreshold.IsNull() && data.MaximumRouteInterfacesThreshold.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/maximum/route-interfaces"
		predicates := make(map[string]string)
		if !state.MaximumRouteInterfaces.IsNull() {
			predicates["maximum-route-interfaces"] = fmt.Sprintf("%v", state.MaximumRouteInterfaces.ValueInt64())
		}
		predicates["threshold"] = fmt.Sprintf("%v", state.MaximumRouteInterfacesThreshold.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MaximumRouteInterfaces.IsNull() && data.MaximumRouteInterfaces.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/maximum/route-interfaces"
		predicates := make(map[string]string)
		if !state.MaximumRouteInterfacesThreshold.IsNull() {
			predicates["threshold"] = fmt.Sprintf("%v", state.MaximumRouteInterfacesThreshold.ValueInt64())
		}
		predicates["maximum-route-interfaces"] = fmt.Sprintf("%v", state.MaximumRouteInterfaces.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MaximumRoutesThreshold.IsNull() && data.MaximumRoutesThreshold.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/maximum/routes"
		predicates := make(map[string]string)
		if !state.MaximumRoutes.IsNull() {
			predicates["maximum-routes"] = fmt.Sprintf("%v", state.MaximumRoutes.ValueInt64())
		}
		predicates["threshold"] = fmt.Sprintf("%v", state.MaximumRoutesThreshold.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MaximumRoutes.IsNull() && data.MaximumRoutes.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/maximum/routes"
		predicates := make(map[string]string)
		if !state.MaximumRoutesThreshold.IsNull() {
			predicates["threshold"] = fmt.Sprintf("%v", state.MaximumRoutesThreshold.ValueInt64())
		}
		predicates["maximum-routes"] = fmt.Sprintf("%v", state.MaximumRoutes.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.GlobalMaximumBsrCrpCacheThreshold.IsNull() && data.GlobalMaximumBsrCrpCacheThreshold.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/global/maximum/bsr/crp-cache"
		predicates := make(map[string]string)
		if !state.GlobalMaximumBsrCrpCacheMaximum.IsNull() {
			predicates["maximum-crp-cache"] = fmt.Sprintf("%v", state.GlobalMaximumBsrCrpCacheMaximum.ValueInt64())
		}
		predicates["threshold"] = fmt.Sprintf("%v", state.GlobalMaximumBsrCrpCacheThreshold.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.GlobalMaximumBsrCrpCacheMaximum.IsNull() && data.GlobalMaximumBsrCrpCacheMaximum.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/global/maximum/bsr/crp-cache"
		predicates := make(map[string]string)
		if !state.GlobalMaximumBsrCrpCacheThreshold.IsNull() {
			predicates["threshold"] = fmt.Sprintf("%v", state.GlobalMaximumBsrCrpCacheThreshold.ValueInt64())
		}
		predicates["maximum-crp-cache"] = fmt.Sprintf("%v", state.GlobalMaximumBsrCrpCacheMaximum.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.GlobalMaximumGroupMappingsAutorpThreshold.IsNull() && data.GlobalMaximumGroupMappingsAutorpThreshold.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/global/maximum/group-mappings/autorp"
		predicates := make(map[string]string)
		if !state.GlobalMaximumGroupMappingsAutorp.IsNull() {
			predicates["maximum-autorp"] = fmt.Sprintf("%v", state.GlobalMaximumGroupMappingsAutorp.ValueInt64())
		}
		predicates["threshold"] = fmt.Sprintf("%v", state.GlobalMaximumGroupMappingsAutorpThreshold.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.GlobalMaximumGroupMappingsAutorp.IsNull() && data.GlobalMaximumGroupMappingsAutorp.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/global/maximum/group-mappings/autorp"
		predicates := make(map[string]string)
		if !state.GlobalMaximumGroupMappingsAutorpThreshold.IsNull() {
			predicates["threshold"] = fmt.Sprintf("%v", state.GlobalMaximumGroupMappingsAutorpThreshold.ValueInt64())
		}
		predicates["maximum-autorp"] = fmt.Sprintf("%v", state.GlobalMaximumGroupMappingsAutorp.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.GlobalMaximumGroupMappingsBsrThreshold.IsNull() && data.GlobalMaximumGroupMappingsBsrThreshold.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/global/maximum/group-mappings/bsr"
		predicates := make(map[string]string)
		if !state.GlobalMaximumGroupMappingsBsr.IsNull() {
			predicates["maximum-bsr"] = fmt.Sprintf("%v", state.GlobalMaximumGroupMappingsBsr.ValueInt64())
		}
		predicates["threshold"] = fmt.Sprintf("%v", state.GlobalMaximumGroupMappingsBsrThreshold.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.GlobalMaximumGroupMappingsBsr.IsNull() && data.GlobalMaximumGroupMappingsBsr.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/global/maximum/group-mappings/bsr"
		predicates := make(map[string]string)
		if !state.GlobalMaximumGroupMappingsBsrThreshold.IsNull() {
			predicates["threshold"] = fmt.Sprintf("%v", state.GlobalMaximumGroupMappingsBsrThreshold.ValueInt64())
		}
		predicates["maximum-bsr"] = fmt.Sprintf("%v", state.GlobalMaximumGroupMappingsBsr.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.GlobalMaximumPacketQueueLowPriority.IsNull() && data.GlobalMaximumPacketQueueLowPriority.IsNull() {
		deletePath := state.getXPath() + "/global/maximum/packet-queue/low-priority"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.GlobalMaximumPacketQueueHighPriority.IsNull() && data.GlobalMaximumPacketQueueHighPriority.IsNull() {
		deletePath := state.getXPath() + "/global/maximum/packet-queue/high-priority"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.GlobalMaximumRegisterStatesThreshold.IsNull() && data.GlobalMaximumRegisterStatesThreshold.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/global/maximum/register-states"
		predicates := make(map[string]string)
		if !state.GlobalMaximumRegisterStates.IsNull() {
			predicates["maximum-register-states"] = fmt.Sprintf("%v", state.GlobalMaximumRegisterStates.ValueInt64())
		}
		predicates["threshold"] = fmt.Sprintf("%v", state.GlobalMaximumRegisterStatesThreshold.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.GlobalMaximumRegisterStates.IsNull() && data.GlobalMaximumRegisterStates.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/global/maximum/register-states"
		predicates := make(map[string]string)
		if !state.GlobalMaximumRegisterStatesThreshold.IsNull() {
			predicates["threshold"] = fmt.Sprintf("%v", state.GlobalMaximumRegisterStatesThreshold.ValueInt64())
		}
		predicates["maximum-register-states"] = fmt.Sprintf("%v", state.GlobalMaximumRegisterStates.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.GlobalMaximumRouteInterfacesThreshold.IsNull() && data.GlobalMaximumRouteInterfacesThreshold.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/global/maximum/route-interfaces"
		predicates := make(map[string]string)
		if !state.GlobalMaximumRouteInterfaces.IsNull() {
			predicates["maximum-route-interfaces"] = fmt.Sprintf("%v", state.GlobalMaximumRouteInterfaces.ValueInt64())
		}
		predicates["threshold"] = fmt.Sprintf("%v", state.GlobalMaximumRouteInterfacesThreshold.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.GlobalMaximumRouteInterfaces.IsNull() && data.GlobalMaximumRouteInterfaces.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/global/maximum/route-interfaces"
		predicates := make(map[string]string)
		if !state.GlobalMaximumRouteInterfacesThreshold.IsNull() {
			predicates["threshold"] = fmt.Sprintf("%v", state.GlobalMaximumRouteInterfacesThreshold.ValueInt64())
		}
		predicates["maximum-route-interfaces"] = fmt.Sprintf("%v", state.GlobalMaximumRouteInterfaces.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.GlobalMaximumRoutesThreshold.IsNull() && data.GlobalMaximumRoutesThreshold.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/global/maximum/routes"
		predicates := make(map[string]string)
		if !state.GlobalMaximumRoutes.IsNull() {
			predicates["maximum-routes"] = fmt.Sprintf("%v", state.GlobalMaximumRoutes.ValueInt64())
		}
		predicates["threshold"] = fmt.Sprintf("%v", state.GlobalMaximumRoutesThreshold.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.GlobalMaximumRoutes.IsNull() && data.GlobalMaximumRoutes.IsNull() {
		// Build predicates for delete_parent by finding sibling attributes with same parent path
		deletePath := state.getXPath() + "/global/maximum/routes"
		predicates := make(map[string]string)
		if !state.GlobalMaximumRoutesThreshold.IsNull() {
			predicates["threshold"] = fmt.Sprintf("%v", state.GlobalMaximumRoutesThreshold.ValueInt64())
		}
		predicates["maximum-routes"] = fmt.Sprintf("%v", state.GlobalMaximumRoutes.ValueInt64())
		// Sort keys to ensure consistent ordering
		keys := make([]string, 0, len(predicates))
		for k := range predicates {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			deletePath += fmt.Sprintf("[%s='%s']", k, predicates[k])
		}
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.OverrideInterval.IsNull() && data.OverrideInterval.IsNull() {
		deletePath := state.getXPath() + "/override-interval"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.PropagationDelay.IsNull() && data.PropagationDelay.IsNull() {
		deletePath := state.getXPath() + "/propagation-delay"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.JoinPruneMtu.IsNull() && data.JoinPruneMtu.IsNull() {
		deletePath := state.getXPath() + "/join-prune-mtu"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.JoinPruneInterval.IsNull() && data.JoinPruneInterval.IsNull() {
		deletePath := state.getXPath() + "/join-prune-interval"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.DrPriority.IsNull() && data.DrPriority.IsNull() {
		deletePath := state.getXPath() + "/dr-priority"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.MdtHelloInterval.IsNull() && data.MdtHelloInterval.IsNull() {
		deletePath := state.getXPath() + "/mdt-hello-interval"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.HelloInterval.IsNull() && data.HelloInterval.IsNull() {
		deletePath := state.getXPath() + "/hello-interval"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.NeighborCheckOnRecv.IsNull() && state.NeighborCheckOnRecv.ValueBool() && data.NeighborCheckOnRecv.IsNull() {
		deletePath := state.getXPath() + "/neighbor-check-on-recv/enable"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.NeighborCheckOnSend.IsNull() && state.NeighborCheckOnSend.ValueBool() && data.NeighborCheckOnSend.IsNull() {
		deletePath := state.getXPath() + "/neighbor-check-on-send/enable"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.NsfLifetime.IsNull() && data.NsfLifetime.IsNull() {
		deletePath := state.getXPath() + "/nsf/lifetime"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.OldRegisterChecksum.IsNull() && state.OldRegisterChecksum.ValueBool() && data.OldRegisterChecksum.IsNull() {
		deletePath := state.getXPath() + "/old-register-checksum"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.SptThresholdInfinityGroupList.IsNull() && data.SptThresholdInfinityGroupList.IsNull() {
		deletePath := state.getXPath() + "/spt-threshold/infinity/group-list"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.SptThresholdInfinity.IsNull() && state.SptThresholdInfinity.ValueBool() && data.SptThresholdInfinity.IsNull() {
		deletePath := state.getXPath() + "/spt-threshold/infinity"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.ConvergenceLinkDownPruneDelay.IsNull() && data.ConvergenceLinkDownPruneDelay.IsNull() {
		deletePath := state.getXPath() + "/convergence/link-down-prune-delay"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.ConvergenceRpfConflictJoinDelay.IsNull() && data.ConvergenceRpfConflictJoinDelay.IsNull() {
		deletePath := state.getXPath() + "/convergence/rpf-conflict-join-delay"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.NeighborFilter.IsNull() && data.NeighborFilter.IsNull() {
		deletePath := state.getXPath() + "/neighbor-filter"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.SuppressRpfChangePrunes.IsNull() && state.SuppressRpfChangePrunes.ValueBool() && data.SuppressRpfChangePrunes.IsNull() {
		deletePath := state.getXPath() + "/suppress-rpf-change-prunes"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.RegisterSource.IsNull() && data.RegisterSource.IsNull() {
		deletePath := state.getXPath() + "/register-source"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	// For boolean fields, only delete if state was true (presence container was set)
	if !state.SuppressDataRegisters.IsNull() && state.SuppressDataRegisters.ValueBool() && data.SuppressDataRegisters.IsNull() {
		deletePath := state.getXPath() + "/suppress-data-registers"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.AcceptRegister.IsNull() && data.AcceptRegister.IsNull() {
		deletePath := state.getXPath() + "/accept-register"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	if !state.RpStaticDeny.IsNull() && data.RpStaticDeny.IsNull() {
		deletePath := state.getXPath() + "/rp-static-deny"
		if !deletedPaths[deletePath] {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, deletePath)
			deletedPaths[deletePath] = true
		}
	}
	for i := range state.RpAddressesBidir {
		stateKeys := [...]string{"address"}
		stateKeyValues := [...]string{state.RpAddressesBidir[i].Address.ValueString()}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.RpAddressesBidir[i].Address.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.RpAddressesBidir {
			found = true
			if state.RpAddressesBidir[i].Address.ValueString() != data.RpAddressesBidir[j].Address.ValueString() {
				found = false
			}
			if found {
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.RpAddressesBidir[i].Override.IsNull() && state.RpAddressesBidir[i].Override.ValueBool() && data.RpAddressesBidir[j].Override.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/rp-addresses/bidir/rp-address%v/override", predicates))
				}
				if !state.RpAddressesBidir[i].AccessList.IsNull() && data.RpAddressesBidir[j].AccessList.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/rp-addresses/bidir/rp-address%v/access-list", predicates))
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/rp-addresses/bidir/rp-address%v", predicates))
		}
	}
	for i := range state.RpAddresses {
		stateKeys := [...]string{"address"}
		stateKeyValues := [...]string{state.RpAddresses[i].Address.ValueString()}
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.RpAddresses[i].Address.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.RpAddresses {
			found = true
			if state.RpAddresses[i].Address.ValueString() != data.RpAddresses[j].Address.ValueString() {
				found = false
			}
			if found {
				// For boolean fields, only delete if state was true (presence container was set)
				if !state.RpAddresses[i].Override.IsNull() && state.RpAddresses[i].Override.ValueBool() && data.RpAddresses[j].Override.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/rp-addresses/rp-address%v/override", predicates))
				}
				if !state.RpAddresses[i].AccessList.IsNull() && data.RpAddresses[j].AccessList.IsNull() {
					deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/rp-addresses/rp-address%v/access-list", predicates))
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/rp-addresses/rp-address%v", predicates))
		}
	}

	b := netconf.NewBody(deleteXml)
	b = helpers.CleanupRedundantRemoveOperations(b)
	return b.Res()
}

// End of section. //template:end addDeletedItemsXML
// Section below is generated&owned by "gen/generator.go". //template:begin addDeletePathsXML

func (data *RouterPIMIPv4) addDeletePathsXML(ctx context.Context, body string) string {
	b := netconf.NewBody(body)
	for i := range data.Interfaces {
		keys := [...]string{"interface-name"}
		keyValues := [...]string{data.Interfaces[i].InterfaceName.ValueString()}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/interfaces/interface%v", predicates))
	}
	for i := range data.SrP2mpPolicies {
		keys := [...]string{"sr-p2mp-policy-id"}
		keyValues := [...]string{data.SrP2mpPolicies[i].PolicyName.ValueString()}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/sr-p2mp-policies/sr-p2mp-policy%v", predicates))
	}
	for i := range data.MofrrCloneSources {
		keys := [...]string{"address"}
		keyValues := [...]string{data.MofrrCloneSources[i].SourceAddress.ValueString()}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/mofrr/clone/sources/source%v", predicates))
	}
	for i := range data.MofrrCloneJoins {
		keys := [...]string{"address"}
		keyValues := [...]string{data.MofrrCloneJoins[i].SourceAddress.ValueString()}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/mofrr/clone/joins/join%v", predicates))
	}
	if !data.MofrrNonRevertive.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/mofrr/non-revertive")
	}
	if !data.MofrrProtectLocalFaultOnly.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/mofrr/local-fault-only")
	}
	if !data.MofrrProtect.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/mofrr/protect")
	}
	if !data.MofrrRib.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/mofrr/rib")
	}
	if !data.MofrrFlow.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/mofrr/flow")
	}
	if !data.Mofrr.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/mofrr")
	}
	for i := range data.BsrRelayVrfs {
		keys := [...]string{"vrf-name"}
		keyValues := [...]string{data.BsrRelayVrfs[i].VrfName.ValueString()}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/bsr/relay/vrfs/vrf%v", predicates))
	}
	for i := range data.BsrCandidateRps {
		keys := [...]string{"address"}
		keyValues := [...]string{data.BsrCandidateRps[i].Address.ValueString()}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/bsr/candidate-rps/candidate-rp%v", predicates))
	}
	if !data.BsrCandidateBsrPriority.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/bsr/candidate-bsr")
	}
	if !data.BsrCandidateBsrHashMaskLen.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/bsr/candidate-bsr")
	}
	if !data.BsrCandidateBsrAddress.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/bsr/candidate-bsr")
	}
	for i := range data.AutoRpRelayVrfs {
		keys := [...]string{"vrf-name"}
		keyValues := [...]string{data.AutoRpRelayVrfs[i].VrfName.ValueString()}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/auto-rp/relay/vrfs/vrf%v", predicates))
	}
	if !data.AutoRpListenDisable.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/auto-rp/listen/disable")
	}
	for i := range data.AutoRpCandidateRps {
		keys := [...]string{"interface-name"}
		keyValues := [...]string{data.AutoRpCandidateRps[i].InterfaceName.ValueString()}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/auto-rp/candidate-rps/candidate-rp%v", predicates))
	}
	if !data.AutoRpMappingAgentInterval.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/auto-rp/mapping-agent")
	}
	if !data.AutoRpMappingAgentScope.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/auto-rp/mapping-agent")
	}
	if !data.AutoRpMappingAgentInterface.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/auto-rp/mapping-agent")
	}
	if !data.MultipathHashSourceGroup.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/multipath/hash")
	}
	if !data.MultipathHashSourceNexthop.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/multipath/hash")
	}
	if !data.MultipathHashSource.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/multipath/hash")
	}
	if !data.Multipath.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/multipath")
	}
	if !data.RpfRedirectRoutePolicy.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/rpf-redirect/route-policy")
	}
	if !data.SsmAllowOverride.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/ssm/allow-override")
	}
	if !data.SsmDisable.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/ssm/disable")
	}
	if !data.SsmRange.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/ssm/range")
	}
	if !data.SgList.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/sg-expiry-timer")
	}
	if !data.SgExpiryTimer.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/sg-expiry-timer")
	}
	if !data.AllowRpGroupList.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/allow-rp/group-list")
	}
	if !data.AllowRpList.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/allow-rp/rp-list")
	}
	if !data.AllowRp.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/allow-rp")
	}
	if !data.MdtCMulticastMigrationRoutePolicy.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/mdt/c-multicast-routing")
	}
	if !data.MdtCMulticastSourceTreePruneDelay.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/mdt/c-multicast-routing")
	}
	if !data.MdtCMulticastSharedTreePruneDelay.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/mdt/c-multicast-routing")
	}
	if !data.MdtCMulticastHelloEnable.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/mdt/c-multicast-routing/mdt-hello")
	}
	if !data.MdtCMulticastSuppressPimDataSignaling.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/mdt/c-multicast-routing")
	}
	if !data.MdtCMulticastSuppressSharedTreeJoin.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/mdt/c-multicast-routing")
	}
	if !data.MdtCMulticastSharedTreePrune.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/mdt/c-multicast-routing")
	}
	if !data.MdtCMulticastAnnouncePimJoinTlv.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/mdt/c-multicast-routing")
	}
	if !data.MdtCMulticastType.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/mdt/c-multicast-routing")
	}
	if !data.MdtDataAnnounceInterval.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/mdt/data/announce-interval")
	}
	if !data.MdtDataSwitchoverInterval.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/mdt/data/switchover-interval")
	}
	if !data.MdtNeighborFilter.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/mdt/neighbor-filter")
	}
	if !data.RpfTopologyRoutePolicy.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/rpf/topology/route-policy")
	}
	for i := range data.ExplicitRpfVectorInjects {
		keys := [...]string{"source-address", "masklen"}
		keyValues := [...]string{data.ExplicitRpfVectorInjects[i].SourceAddress.ValueString(), strconv.FormatInt(data.ExplicitRpfVectorInjects[i].SourceMask.ValueInt64(), 10)}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/explicit-rpf-vector/injects/inject%v", predicates))
	}
	for i := range data.RpfVectorInjects {
		keys := [...]string{"source-address", "masklen"}
		keyValues := [...]string{data.RpfVectorInjects[i].SourceAddress.ValueString(), strconv.FormatInt(data.RpfVectorInjects[i].SourceMask.ValueInt64(), 10)}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/rpf-vector-injects/inject%v", predicates))
	}
	if !data.RpfVectorStandardEncoding.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/rpf-vector")
	}
	if !data.RpfVectorDisableIbgp.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/rpf-vector")
	}
	if !data.RpfVectorAllowEbgp.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/rpf-vector")
	}
	if !data.LogNeighborChanges.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/log/neighbor/changes")
	}
	if !data.MaximumBsrCrpCacheThreshold.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/maximum/bsr/crp-cache")
	}
	if !data.MaximumBsrCrpCacheMaximum.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/maximum/bsr/crp-cache")
	}
	if !data.MaximumGroupMappingsAutorpThreshold.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/maximum/group-mappings/autorp")
	}
	if !data.MaximumGroupMappingsAutorp.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/maximum/group-mappings/autorp")
	}
	if !data.MaximumGroupMappingsBsrThreshold.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/maximum/group-mappings/bsr")
	}
	if !data.MaximumGroupMappingsBsr.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/maximum/group-mappings/bsr")
	}
	if !data.MaximumRegisterStatesThreshold.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/maximum/register-states")
	}
	if !data.MaximumRegisterStates.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/maximum/register-states")
	}
	if !data.MaximumRouteInterfacesThreshold.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/maximum/route-interfaces")
	}
	if !data.MaximumRouteInterfaces.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/maximum/route-interfaces")
	}
	if !data.MaximumRoutesThreshold.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/maximum/routes")
	}
	if !data.MaximumRoutes.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/maximum/routes")
	}
	if !data.GlobalMaximumBsrCrpCacheThreshold.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/global/maximum/bsr/crp-cache")
	}
	if !data.GlobalMaximumBsrCrpCacheMaximum.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/global/maximum/bsr/crp-cache")
	}
	if !data.GlobalMaximumGroupMappingsAutorpThreshold.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/global/maximum/group-mappings/autorp")
	}
	if !data.GlobalMaximumGroupMappingsAutorp.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/global/maximum/group-mappings/autorp")
	}
	if !data.GlobalMaximumGroupMappingsBsrThreshold.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/global/maximum/group-mappings/bsr")
	}
	if !data.GlobalMaximumGroupMappingsBsr.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/global/maximum/group-mappings/bsr")
	}
	if !data.GlobalMaximumPacketQueueLowPriority.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/global/maximum/packet-queue/low-priority")
	}
	if !data.GlobalMaximumPacketQueueHighPriority.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/global/maximum/packet-queue/high-priority")
	}
	if !data.GlobalMaximumRegisterStatesThreshold.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/global/maximum/register-states")
	}
	if !data.GlobalMaximumRegisterStates.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/global/maximum/register-states")
	}
	if !data.GlobalMaximumRouteInterfacesThreshold.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/global/maximum/route-interfaces")
	}
	if !data.GlobalMaximumRouteInterfaces.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/global/maximum/route-interfaces")
	}
	if !data.GlobalMaximumRoutesThreshold.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/global/maximum/routes")
	}
	if !data.GlobalMaximumRoutes.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/global/maximum/routes")
	}
	if !data.OverrideInterval.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/override-interval")
	}
	if !data.PropagationDelay.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/propagation-delay")
	}
	if !data.JoinPruneMtu.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/join-prune-mtu")
	}
	if !data.JoinPruneInterval.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/join-prune-interval")
	}
	if !data.DrPriority.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/dr-priority")
	}
	if !data.MdtHelloInterval.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/mdt-hello-interval")
	}
	if !data.HelloInterval.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/hello-interval")
	}
	if !data.NeighborCheckOnRecv.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/neighbor-check-on-recv/enable")
	}
	if !data.NeighborCheckOnSend.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/neighbor-check-on-send/enable")
	}
	if !data.NsfLifetime.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/nsf/lifetime")
	}
	if !data.OldRegisterChecksum.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/old-register-checksum")
	}
	if !data.SptThresholdInfinityGroupList.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/spt-threshold/infinity/group-list")
	}
	if !data.SptThresholdInfinity.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/spt-threshold/infinity")
	}
	if !data.ConvergenceLinkDownPruneDelay.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/convergence/link-down-prune-delay")
	}
	if !data.ConvergenceRpfConflictJoinDelay.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/convergence/rpf-conflict-join-delay")
	}
	if !data.NeighborFilter.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/neighbor-filter")
	}
	if !data.SuppressRpfChangePrunes.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/suppress-rpf-change-prunes")
	}
	if !data.RegisterSource.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/register-source")
	}
	if !data.SuppressDataRegisters.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/suppress-data-registers")
	}
	if !data.AcceptRegister.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/accept-register")
	}
	if !data.RpStaticDeny.IsNull() {
		b = helpers.RemoveFromXPath(b, data.getXPath()+"/rp-static-deny")
	}
	for i := range data.RpAddressesBidir {
		keys := [...]string{"address"}
		keyValues := [...]string{data.RpAddressesBidir[i].Address.ValueString()}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/rp-addresses/bidir/rp-address%v", predicates))
	}
	for i := range data.RpAddresses {
		keys := [...]string{"address"}
		keyValues := [...]string{data.RpAddresses[i].Address.ValueString()}
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/rp-addresses/rp-address%v", predicates))
	}

	b = helpers.CleanupRedundantRemoveOperations(b)
	return b.Res()
}

// End of section. //template:end addDeletePathsXML
