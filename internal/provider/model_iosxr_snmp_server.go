// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"reflect"
	"strconv"

	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

type SNMPServer struct {
	Device                         types.String                `tfsdk:"device"`
	Id                             types.String                `tfsdk:"id"`
	TrapsRf                        types.Bool                  `tfsdk:"traps_rf"`
	TrapsBfd                       types.Bool                  `tfsdk:"traps_bfd"`
	TrapsNtp                       types.Bool                  `tfsdk:"traps_ntp"`
	TrapsEthernetOamEvents         types.Bool                  `tfsdk:"traps_ethernet_oam_events"`
	TrapsCopyComplete              types.Bool                  `tfsdk:"traps_copy_complete"`
	TrapsSnmpLinkup                types.Bool                  `tfsdk:"traps_snmp_linkup"`
	TrapsSnmpLinkdown              types.Bool                  `tfsdk:"traps_snmp_linkdown"`
	TrapsPower                     types.Bool                  `tfsdk:"traps_power"`
	TrapsConfig                    types.Bool                  `tfsdk:"traps_config"`
	TrapsEntity                    types.Bool                  `tfsdk:"traps_entity"`
	TrapsSystem                    types.Bool                  `tfsdk:"traps_system"`
	TrapsBridgemib                 types.Bool                  `tfsdk:"traps_bridgemib"`
	TrapsEntityStateOperstatus     types.Bool                  `tfsdk:"traps_entity_state_operstatus"`
	TrapsEntityRedundancyAll       types.Bool                  `tfsdk:"traps_entity_redundancy_all"`
	TrapSourceBoth                 types.String                `tfsdk:"trap_source_both"`
	TrapsL2vpnAll                  types.Bool                  `tfsdk:"traps_l2vpn_all"`
	TrapsL2vpnVcUp                 types.Bool                  `tfsdk:"traps_l2vpn_vc_up"`
	TrapsL2vpnVcDown               types.Bool                  `tfsdk:"traps_l2vpn_vc_down"`
	TrapsSensor                    types.Bool                  `tfsdk:"traps_sensor"`
	TrapsFruCtrl                   types.Bool                  `tfsdk:"traps_fru_ctrl"`
	TrapsIsisAuthenticationFailure types.String                `tfsdk:"traps_isis_authentication_failure"`
	TrapsBgpCbgp2Updown            types.Bool                  `tfsdk:"traps_bgp_cbgp2_updown"`
	TrapsBgpBgp4MibUpdown          types.Bool                  `tfsdk:"traps_bgp_bgp4_mib_updown"`
	SnmpServerUser                 []SNMPServerSnmpServerUser  `tfsdk:"snmp_server_user"`
	SnmpServerGroup                []SNMPServerSnmpServerGroup `tfsdk:"snmp_server_group"`
}
type SNMPServerSnmpServerUser struct {
	UserName                   types.String `tfsdk:"user_name"`
	GroupName                  types.String `tfsdk:"group_name"`
	V3AuthMd5EncryptionAes     types.String `tfsdk:"v3_auth_md5_encryption_aes"`
	V3AuthMd5EncryptionDefault types.String `tfsdk:"v3_auth_md5_encryption_default"`
}
type SNMPServerSnmpServerGroup struct {
	GroupName types.String `tfsdk:"group_name"`
	V3Priv    types.Bool   `tfsdk:"v3_priv"`
	V3Read    types.String `tfsdk:"v3_read"`
	V3Write   types.String `tfsdk:"v3_write"`
	V3Context types.String `tfsdk:"v3_context"`
	V3Notify  types.String `tfsdk:"v3_notify"`
	V3Ipv4    types.String `tfsdk:"v3_ipv4"`
	V3Ipv6    types.String `tfsdk:"v3_ipv6"`
}

func (data SNMPServer) getPath() string {
	return "Cisco-IOS-XR-um-snmp-server-cfg:snmp-server"
}

func (data SNMPServer) toBody(ctx context.Context) string {
	body := "{}"
	if !data.TrapsRf.IsNull() && !data.TrapsRf.IsUnknown() {
		if data.TrapsRf.ValueBool() {
			body, _ = sjson.Set(body, "traps.rf", map[string]string{})
		}
	}
	if !data.TrapsBfd.IsNull() && !data.TrapsBfd.IsUnknown() {
		if data.TrapsBfd.ValueBool() {
			body, _ = sjson.Set(body, "traps.bfd", map[string]string{})
		}
	}
	if !data.TrapsNtp.IsNull() && !data.TrapsNtp.IsUnknown() {
		if data.TrapsNtp.ValueBool() {
			body, _ = sjson.Set(body, "traps.ntp", map[string]string{})
		}
	}
	if !data.TrapsEthernetOamEvents.IsNull() && !data.TrapsEthernetOamEvents.IsUnknown() {
		if data.TrapsEthernetOamEvents.ValueBool() {
			body, _ = sjson.Set(body, "traps.ethernet.oam.events", map[string]string{})
		}
	}
	if !data.TrapsCopyComplete.IsNull() && !data.TrapsCopyComplete.IsUnknown() {
		if data.TrapsCopyComplete.ValueBool() {
			body, _ = sjson.Set(body, "traps.copy-complete", map[string]string{})
		}
	}
	if !data.TrapsSnmpLinkup.IsNull() && !data.TrapsSnmpLinkup.IsUnknown() {
		if data.TrapsSnmpLinkup.ValueBool() {
			body, _ = sjson.Set(body, "traps.snmp.linkup", map[string]string{})
		}
	}
	if !data.TrapsSnmpLinkdown.IsNull() && !data.TrapsSnmpLinkdown.IsUnknown() {
		if data.TrapsSnmpLinkdown.ValueBool() {
			body, _ = sjson.Set(body, "traps.snmp.linkdown", map[string]string{})
		}
	}
	if !data.TrapsPower.IsNull() && !data.TrapsPower.IsUnknown() {
		if data.TrapsPower.ValueBool() {
			body, _ = sjson.Set(body, "traps.power", map[string]string{})
		}
	}
	if !data.TrapsConfig.IsNull() && !data.TrapsConfig.IsUnknown() {
		if data.TrapsConfig.ValueBool() {
			body, _ = sjson.Set(body, "traps.config", map[string]string{})
		}
	}
	if !data.TrapsEntity.IsNull() && !data.TrapsEntity.IsUnknown() {
		if data.TrapsEntity.ValueBool() {
			body, _ = sjson.Set(body, "traps.entity", map[string]string{})
		}
	}
	if !data.TrapsSystem.IsNull() && !data.TrapsSystem.IsUnknown() {
		if data.TrapsSystem.ValueBool() {
			body, _ = sjson.Set(body, "traps.system", map[string]string{})
		}
	}
	if !data.TrapsBridgemib.IsNull() && !data.TrapsBridgemib.IsUnknown() {
		if data.TrapsBridgemib.ValueBool() {
			body, _ = sjson.Set(body, "traps.bridgemib", map[string]string{})
		}
	}
	if !data.TrapsEntityStateOperstatus.IsNull() && !data.TrapsEntityStateOperstatus.IsUnknown() {
		if data.TrapsEntityStateOperstatus.ValueBool() {
			body, _ = sjson.Set(body, "traps.entity-state.operstatus", map[string]string{})
		}
	}
	if !data.TrapsEntityRedundancyAll.IsNull() && !data.TrapsEntityRedundancyAll.IsUnknown() {
		if data.TrapsEntityRedundancyAll.ValueBool() {
			body, _ = sjson.Set(body, "traps.entity-redundancy.all", map[string]string{})
		}
	}
	if !data.TrapSourceBoth.IsNull() && !data.TrapSourceBoth.IsUnknown() {
		body, _ = sjson.Set(body, "trap-source.both", data.TrapSourceBoth.ValueString())
	}
	if !data.TrapsL2vpnAll.IsNull() && !data.TrapsL2vpnAll.IsUnknown() {
		if data.TrapsL2vpnAll.ValueBool() {
			body, _ = sjson.Set(body, "traps.l2vpn.all", map[string]string{})
		}
	}
	if !data.TrapsL2vpnVcUp.IsNull() && !data.TrapsL2vpnVcUp.IsUnknown() {
		if data.TrapsL2vpnVcUp.ValueBool() {
			body, _ = sjson.Set(body, "traps.l2vpn.vc-up", map[string]string{})
		}
	}
	if !data.TrapsL2vpnVcDown.IsNull() && !data.TrapsL2vpnVcDown.IsUnknown() {
		if data.TrapsL2vpnVcDown.ValueBool() {
			body, _ = sjson.Set(body, "traps.l2vpn.vc-down", map[string]string{})
		}
	}
	if !data.TrapsSensor.IsNull() && !data.TrapsSensor.IsUnknown() {
		if data.TrapsSensor.ValueBool() {
			body, _ = sjson.Set(body, "traps.sensor", map[string]string{})
		}
	}
	if !data.TrapsFruCtrl.IsNull() && !data.TrapsFruCtrl.IsUnknown() {
		if data.TrapsFruCtrl.ValueBool() {
			body, _ = sjson.Set(body, "traps.fru-ctrl", map[string]string{})
		}
	}
	if !data.TrapsIsisAuthenticationFailure.IsNull() && !data.TrapsIsisAuthenticationFailure.IsUnknown() {
		body, _ = sjson.Set(body, "traps.isis.authentication-failure", data.TrapsIsisAuthenticationFailure.ValueString())
	}
	if !data.TrapsBgpCbgp2Updown.IsNull() && !data.TrapsBgpCbgp2Updown.IsUnknown() {
		if data.TrapsBgpCbgp2Updown.ValueBool() {
			body, _ = sjson.Set(body, "traps.bgp.cbgp2-updown", map[string]string{})
		}
	}
	if !data.TrapsBgpBgp4MibUpdown.IsNull() && !data.TrapsBgpBgp4MibUpdown.IsUnknown() {
		if data.TrapsBgpBgp4MibUpdown.ValueBool() {
			body, _ = sjson.Set(body, "traps.bgp.bgp4-mib-updown", map[string]string{})
		}
	}
	if len(data.SnmpServerUser) > 0 {
		body, _ = sjson.Set(body, "users.user", []interface{}{})
		for index, item := range data.SnmpServerUser {
			if !item.UserName.IsNull() && !item.UserName.IsUnknown() {
				body, _ = sjson.Set(body, "users.user"+"."+strconv.Itoa(index)+"."+"user-name", item.UserName.ValueString())
			}
			if !item.GroupName.IsNull() && !item.GroupName.IsUnknown() {
				body, _ = sjson.Set(body, "users.user"+"."+strconv.Itoa(index)+"."+"group-name", item.GroupName.ValueString())
			}
			if !item.V3AuthMd5EncryptionAes.IsNull() && !item.V3AuthMd5EncryptionAes.IsUnknown() {
				body, _ = sjson.Set(body, "users.user"+"."+strconv.Itoa(index)+"."+"v3.auth.md5.encryption-aes", item.V3AuthMd5EncryptionAes.ValueString())
			}
			if !item.V3AuthMd5EncryptionDefault.IsNull() && !item.V3AuthMd5EncryptionDefault.IsUnknown() {
				body, _ = sjson.Set(body, "users.user"+"."+strconv.Itoa(index)+"."+"v3.auth.md5.encryption-default", item.V3AuthMd5EncryptionDefault.ValueString())
			}
		}
	}
	if len(data.SnmpServerGroup) > 0 {
		body, _ = sjson.Set(body, "groups.group", []interface{}{})
		for index, item := range data.SnmpServerGroup {
			if !item.GroupName.IsNull() && !item.GroupName.IsUnknown() {
				body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"group-name", item.GroupName.ValueString())
			}
			if !item.V3Priv.IsNull() && !item.V3Priv.IsUnknown() {
				if item.V3Priv.ValueBool() {
					body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"v3.priv", map[string]string{})
				}
			}
			if !item.V3Read.IsNull() && !item.V3Read.IsUnknown() {
				body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"v3.read", item.V3Read.ValueString())
			}
			if !item.V3Write.IsNull() && !item.V3Write.IsUnknown() {
				body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"v3.write", item.V3Write.ValueString())
			}
			if !item.V3Context.IsNull() && !item.V3Context.IsUnknown() {
				body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"v3.context", item.V3Context.ValueString())
			}
			if !item.V3Notify.IsNull() && !item.V3Notify.IsUnknown() {
				body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"v3.notify", item.V3Notify.ValueString())
			}
			if !item.V3Ipv4.IsNull() && !item.V3Ipv4.IsUnknown() {
				body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"v3.ipv4", item.V3Ipv4.ValueString())
			}
			if !item.V3Ipv6.IsNull() && !item.V3Ipv6.IsUnknown() {
				body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"v3.ipv6", item.V3Ipv6.ValueString())
			}
		}
	}
	return body
}

func (data *SNMPServer) updateFromBody(ctx context.Context, res []byte) {
	if value := gjson.GetBytes(res, "traps.rf"); !data.TrapsRf.IsNull() {
		if value.Exists() {
			data.TrapsRf = types.BoolValue(true)
		} else {
			data.TrapsRf = types.BoolValue(false)
		}
	} else {
		data.TrapsRf = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.bfd"); !data.TrapsBfd.IsNull() {
		if value.Exists() {
			data.TrapsBfd = types.BoolValue(true)
		} else {
			data.TrapsBfd = types.BoolValue(false)
		}
	} else {
		data.TrapsBfd = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.ntp"); !data.TrapsNtp.IsNull() {
		if value.Exists() {
			data.TrapsNtp = types.BoolValue(true)
		} else {
			data.TrapsNtp = types.BoolValue(false)
		}
	} else {
		data.TrapsNtp = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.ethernet.oam.events"); !data.TrapsEthernetOamEvents.IsNull() {
		if value.Exists() {
			data.TrapsEthernetOamEvents = types.BoolValue(true)
		} else {
			data.TrapsEthernetOamEvents = types.BoolValue(false)
		}
	} else {
		data.TrapsEthernetOamEvents = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.copy-complete"); !data.TrapsCopyComplete.IsNull() {
		if value.Exists() {
			data.TrapsCopyComplete = types.BoolValue(true)
		} else {
			data.TrapsCopyComplete = types.BoolValue(false)
		}
	} else {
		data.TrapsCopyComplete = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.snmp.linkup"); !data.TrapsSnmpLinkup.IsNull() {
		if value.Exists() {
			data.TrapsSnmpLinkup = types.BoolValue(true)
		} else {
			data.TrapsSnmpLinkup = types.BoolValue(false)
		}
	} else {
		data.TrapsSnmpLinkup = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.snmp.linkdown"); !data.TrapsSnmpLinkdown.IsNull() {
		if value.Exists() {
			data.TrapsSnmpLinkdown = types.BoolValue(true)
		} else {
			data.TrapsSnmpLinkdown = types.BoolValue(false)
		}
	} else {
		data.TrapsSnmpLinkdown = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.power"); !data.TrapsPower.IsNull() {
		if value.Exists() {
			data.TrapsPower = types.BoolValue(true)
		} else {
			data.TrapsPower = types.BoolValue(false)
		}
	} else {
		data.TrapsPower = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.config"); !data.TrapsConfig.IsNull() {
		if value.Exists() {
			data.TrapsConfig = types.BoolValue(true)
		} else {
			data.TrapsConfig = types.BoolValue(false)
		}
	} else {
		data.TrapsConfig = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.entity"); !data.TrapsEntity.IsNull() {
		if value.Exists() {
			data.TrapsEntity = types.BoolValue(true)
		} else {
			data.TrapsEntity = types.BoolValue(false)
		}
	} else {
		data.TrapsEntity = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.system"); !data.TrapsSystem.IsNull() {
		if value.Exists() {
			data.TrapsSystem = types.BoolValue(true)
		} else {
			data.TrapsSystem = types.BoolValue(false)
		}
	} else {
		data.TrapsSystem = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.bridgemib"); !data.TrapsBridgemib.IsNull() {
		if value.Exists() {
			data.TrapsBridgemib = types.BoolValue(true)
		} else {
			data.TrapsBridgemib = types.BoolValue(false)
		}
	} else {
		data.TrapsBridgemib = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.entity-state.operstatus"); !data.TrapsEntityStateOperstatus.IsNull() {
		if value.Exists() {
			data.TrapsEntityStateOperstatus = types.BoolValue(true)
		} else {
			data.TrapsEntityStateOperstatus = types.BoolValue(false)
		}
	} else {
		data.TrapsEntityStateOperstatus = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.entity-redundancy.all"); !data.TrapsEntityRedundancyAll.IsNull() {
		if value.Exists() {
			data.TrapsEntityRedundancyAll = types.BoolValue(true)
		} else {
			data.TrapsEntityRedundancyAll = types.BoolValue(false)
		}
	} else {
		data.TrapsEntityRedundancyAll = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "trap-source.both"); value.Exists() && !data.TrapSourceBoth.IsNull() {
		data.TrapSourceBoth = types.StringValue(value.String())
	} else {
		data.TrapSourceBoth = types.StringNull()
	}
	if value := gjson.GetBytes(res, "traps.l2vpn.all"); !data.TrapsL2vpnAll.IsNull() {
		if value.Exists() {
			data.TrapsL2vpnAll = types.BoolValue(true)
		} else {
			data.TrapsL2vpnAll = types.BoolValue(false)
		}
	} else {
		data.TrapsL2vpnAll = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.l2vpn.vc-up"); !data.TrapsL2vpnVcUp.IsNull() {
		if value.Exists() {
			data.TrapsL2vpnVcUp = types.BoolValue(true)
		} else {
			data.TrapsL2vpnVcUp = types.BoolValue(false)
		}
	} else {
		data.TrapsL2vpnVcUp = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.l2vpn.vc-down"); !data.TrapsL2vpnVcDown.IsNull() {
		if value.Exists() {
			data.TrapsL2vpnVcDown = types.BoolValue(true)
		} else {
			data.TrapsL2vpnVcDown = types.BoolValue(false)
		}
	} else {
		data.TrapsL2vpnVcDown = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.sensor"); !data.TrapsSensor.IsNull() {
		if value.Exists() {
			data.TrapsSensor = types.BoolValue(true)
		} else {
			data.TrapsSensor = types.BoolValue(false)
		}
	} else {
		data.TrapsSensor = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.fru-ctrl"); !data.TrapsFruCtrl.IsNull() {
		if value.Exists() {
			data.TrapsFruCtrl = types.BoolValue(true)
		} else {
			data.TrapsFruCtrl = types.BoolValue(false)
		}
	} else {
		data.TrapsFruCtrl = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.isis.authentication-failure"); value.Exists() && !data.TrapsIsisAuthenticationFailure.IsNull() {
		data.TrapsIsisAuthenticationFailure = types.StringValue(value.String())
	} else {
		data.TrapsIsisAuthenticationFailure = types.StringNull()
	}
	if value := gjson.GetBytes(res, "traps.bgp.cbgp2-updown"); !data.TrapsBgpCbgp2Updown.IsNull() {
		if value.Exists() {
			data.TrapsBgpCbgp2Updown = types.BoolValue(true)
		} else {
			data.TrapsBgpCbgp2Updown = types.BoolValue(false)
		}
	} else {
		data.TrapsBgpCbgp2Updown = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.bgp.bgp4-mib-updown"); !data.TrapsBgpBgp4MibUpdown.IsNull() {
		if value.Exists() {
			data.TrapsBgpBgp4MibUpdown = types.BoolValue(true)
		} else {
			data.TrapsBgpBgp4MibUpdown = types.BoolValue(false)
		}
	} else {
		data.TrapsBgpBgp4MibUpdown = types.BoolNull()
	}
	for i := range data.SnmpServerUser {
		keys := [...]string{"user-name"}
		keyValues := [...]string{data.SnmpServerUser[i].UserName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "users.user").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("user-name"); value.Exists() && !data.SnmpServerUser[i].UserName.IsNull() {
			data.SnmpServerUser[i].UserName = types.StringValue(value.String())
		} else {
			data.SnmpServerUser[i].UserName = types.StringNull()
		}
		if value := r.Get("group-name"); value.Exists() && !data.SnmpServerUser[i].GroupName.IsNull() {
			data.SnmpServerUser[i].GroupName = types.StringValue(value.String())
		} else {
			data.SnmpServerUser[i].GroupName = types.StringNull()
		}
		if value := r.Get("v3.auth.md5.encryption-aes"); value.Exists() && !data.SnmpServerUser[i].V3AuthMd5EncryptionAes.IsNull() {
			data.SnmpServerUser[i].V3AuthMd5EncryptionAes = types.StringValue(value.String())
		} else {
			data.SnmpServerUser[i].V3AuthMd5EncryptionAes = types.StringNull()
		}
		if value := r.Get("v3.auth.md5.encryption-default"); value.Exists() && !data.SnmpServerUser[i].V3AuthMd5EncryptionDefault.IsNull() {
			data.SnmpServerUser[i].V3AuthMd5EncryptionDefault = types.StringValue(value.String())
		} else {
			data.SnmpServerUser[i].V3AuthMd5EncryptionDefault = types.StringNull()
		}
	}
	for i := range data.SnmpServerGroup {
		keys := [...]string{"group-name"}
		keyValues := [...]string{data.SnmpServerGroup[i].GroupName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "groups.group").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("group-name"); value.Exists() && !data.SnmpServerGroup[i].GroupName.IsNull() {
			data.SnmpServerGroup[i].GroupName = types.StringValue(value.String())
		} else {
			data.SnmpServerGroup[i].GroupName = types.StringNull()
		}
		if value := r.Get("v3.priv"); !data.SnmpServerGroup[i].V3Priv.IsNull() {
			if value.Exists() {
				data.SnmpServerGroup[i].V3Priv = types.BoolValue(true)
			} else {
				data.SnmpServerGroup[i].V3Priv = types.BoolValue(false)
			}
		} else {
			data.SnmpServerGroup[i].V3Priv = types.BoolNull()
		}
		if value := r.Get("v3.read"); value.Exists() && !data.SnmpServerGroup[i].V3Read.IsNull() {
			data.SnmpServerGroup[i].V3Read = types.StringValue(value.String())
		} else {
			data.SnmpServerGroup[i].V3Read = types.StringNull()
		}
		if value := r.Get("v3.write"); value.Exists() && !data.SnmpServerGroup[i].V3Write.IsNull() {
			data.SnmpServerGroup[i].V3Write = types.StringValue(value.String())
		} else {
			data.SnmpServerGroup[i].V3Write = types.StringNull()
		}
		if value := r.Get("v3.context"); value.Exists() && !data.SnmpServerGroup[i].V3Context.IsNull() {
			data.SnmpServerGroup[i].V3Context = types.StringValue(value.String())
		} else {
			data.SnmpServerGroup[i].V3Context = types.StringNull()
		}
		if value := r.Get("v3.notify"); value.Exists() && !data.SnmpServerGroup[i].V3Notify.IsNull() {
			data.SnmpServerGroup[i].V3Notify = types.StringValue(value.String())
		} else {
			data.SnmpServerGroup[i].V3Notify = types.StringNull()
		}
		if value := r.Get("v3.ipv4"); value.Exists() && !data.SnmpServerGroup[i].V3Ipv4.IsNull() {
			data.SnmpServerGroup[i].V3Ipv4 = types.StringValue(value.String())
		} else {
			data.SnmpServerGroup[i].V3Ipv4 = types.StringNull()
		}
		if value := r.Get("v3.ipv6"); value.Exists() && !data.SnmpServerGroup[i].V3Ipv6.IsNull() {
			data.SnmpServerGroup[i].V3Ipv6 = types.StringValue(value.String())
		} else {
			data.SnmpServerGroup[i].V3Ipv6 = types.StringNull()
		}
	}
}

func (data *SNMPServer) fromBody(ctx context.Context, res []byte) {
	if value := gjson.GetBytes(res, "traps.rf"); value.Exists() {
		data.TrapsRf = types.BoolValue(true)
	} else {
		data.TrapsRf = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.bfd"); value.Exists() {
		data.TrapsBfd = types.BoolValue(true)
	} else {
		data.TrapsBfd = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.ntp"); value.Exists() {
		data.TrapsNtp = types.BoolValue(true)
	} else {
		data.TrapsNtp = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.ethernet.oam.events"); value.Exists() {
		data.TrapsEthernetOamEvents = types.BoolValue(true)
	} else {
		data.TrapsEthernetOamEvents = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.copy-complete"); value.Exists() {
		data.TrapsCopyComplete = types.BoolValue(true)
	} else {
		data.TrapsCopyComplete = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.snmp.linkup"); value.Exists() {
		data.TrapsSnmpLinkup = types.BoolValue(true)
	} else {
		data.TrapsSnmpLinkup = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.snmp.linkdown"); value.Exists() {
		data.TrapsSnmpLinkdown = types.BoolValue(true)
	} else {
		data.TrapsSnmpLinkdown = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.power"); value.Exists() {
		data.TrapsPower = types.BoolValue(true)
	} else {
		data.TrapsPower = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.config"); value.Exists() {
		data.TrapsConfig = types.BoolValue(true)
	} else {
		data.TrapsConfig = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.entity"); value.Exists() {
		data.TrapsEntity = types.BoolValue(true)
	} else {
		data.TrapsEntity = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.system"); value.Exists() {
		data.TrapsSystem = types.BoolValue(true)
	} else {
		data.TrapsSystem = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.bridgemib"); value.Exists() {
		data.TrapsBridgemib = types.BoolValue(true)
	} else {
		data.TrapsBridgemib = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.entity-state.operstatus"); value.Exists() {
		data.TrapsEntityStateOperstatus = types.BoolValue(true)
	} else {
		data.TrapsEntityStateOperstatus = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.entity-redundancy.all"); value.Exists() {
		data.TrapsEntityRedundancyAll = types.BoolValue(true)
	} else {
		data.TrapsEntityRedundancyAll = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "trap-source.both"); value.Exists() {
		data.TrapSourceBoth = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "traps.l2vpn.all"); value.Exists() {
		data.TrapsL2vpnAll = types.BoolValue(true)
	} else {
		data.TrapsL2vpnAll = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.l2vpn.vc-up"); value.Exists() {
		data.TrapsL2vpnVcUp = types.BoolValue(true)
	} else {
		data.TrapsL2vpnVcUp = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.l2vpn.vc-down"); value.Exists() {
		data.TrapsL2vpnVcDown = types.BoolValue(true)
	} else {
		data.TrapsL2vpnVcDown = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.sensor"); value.Exists() {
		data.TrapsSensor = types.BoolValue(true)
	} else {
		data.TrapsSensor = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.fru-ctrl"); value.Exists() {
		data.TrapsFruCtrl = types.BoolValue(true)
	} else {
		data.TrapsFruCtrl = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.isis.authentication-failure"); value.Exists() {
		data.TrapsIsisAuthenticationFailure = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "traps.bgp.cbgp2-updown"); value.Exists() {
		data.TrapsBgpCbgp2Updown = types.BoolValue(true)
	} else {
		data.TrapsBgpCbgp2Updown = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.bgp.bgp4-mib-updown"); value.Exists() {
		data.TrapsBgpBgp4MibUpdown = types.BoolValue(true)
	} else {
		data.TrapsBgpBgp4MibUpdown = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "users.user"); value.Exists() {
		data.SnmpServerUser = make([]SNMPServerSnmpServerUser, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := SNMPServerSnmpServerUser{}
			if cValue := v.Get("user-name"); cValue.Exists() {
				item.UserName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("group-name"); cValue.Exists() {
				item.GroupName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("v3.auth.md5.encryption-aes"); cValue.Exists() {
				item.V3AuthMd5EncryptionAes = types.StringValue(cValue.String())
			}
			if cValue := v.Get("v3.auth.md5.encryption-default"); cValue.Exists() {
				item.V3AuthMd5EncryptionDefault = types.StringValue(cValue.String())
			}
			data.SnmpServerUser = append(data.SnmpServerUser, item)
			return true
		})
	}
	if value := gjson.GetBytes(res, "groups.group"); value.Exists() {
		data.SnmpServerGroup = make([]SNMPServerSnmpServerGroup, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := SNMPServerSnmpServerGroup{}
			if cValue := v.Get("group-name"); cValue.Exists() {
				item.GroupName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("v3.priv"); cValue.Exists() {
				item.V3Priv = types.BoolValue(true)
			} else {
				item.V3Priv = types.BoolValue(false)
			}
			if cValue := v.Get("v3.read"); cValue.Exists() {
				item.V3Read = types.StringValue(cValue.String())
			}
			if cValue := v.Get("v3.write"); cValue.Exists() {
				item.V3Write = types.StringValue(cValue.String())
			}
			if cValue := v.Get("v3.context"); cValue.Exists() {
				item.V3Context = types.StringValue(cValue.String())
			}
			if cValue := v.Get("v3.notify"); cValue.Exists() {
				item.V3Notify = types.StringValue(cValue.String())
			}
			if cValue := v.Get("v3.ipv4"); cValue.Exists() {
				item.V3Ipv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("v3.ipv6"); cValue.Exists() {
				item.V3Ipv6 = types.StringValue(cValue.String())
			}
			data.SnmpServerGroup = append(data.SnmpServerGroup, item)
			return true
		})
	}
}

func (data *SNMPServer) fromPlan(ctx context.Context, plan SNMPServer) {
	data.Device = plan.Device
}

func (data *SNMPServer) getDeletedListItems(ctx context.Context, state SNMPServer) []string {
	deletedListItems := make([]string, 0)
	for i := range state.SnmpServerUser {
		keys := [...]string{"user-name"}
		stateKeyValues := [...]string{state.SnmpServerUser[i].UserName.ValueString()}

		emptyKeys := true
		if !reflect.ValueOf(state.SnmpServerUser[i].UserName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.SnmpServerUser {
			found = true
			if state.SnmpServerUser[i].UserName.ValueString() != data.SnmpServerUser[j].UserName.ValueString() {
				found = false
			}
			if found {
				break
			}
		}
		if !found {
			keyString := ""
			for ki := range keys {
				keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
			}
			deletedListItems = append(deletedListItems, fmt.Sprintf("%v/users/user%v", state.getPath(), keyString))
		}
	}
	for i := range state.SnmpServerGroup {
		keys := [...]string{"group-name"}
		stateKeyValues := [...]string{state.SnmpServerGroup[i].GroupName.ValueString()}

		emptyKeys := true
		if !reflect.ValueOf(state.SnmpServerGroup[i].GroupName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.SnmpServerGroup {
			found = true
			if state.SnmpServerGroup[i].GroupName.ValueString() != data.SnmpServerGroup[j].GroupName.ValueString() {
				found = false
			}
			if found {
				break
			}
		}
		if !found {
			keyString := ""
			for ki := range keys {
				keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
			}
			deletedListItems = append(deletedListItems, fmt.Sprintf("%v/groups/group%v", state.getPath(), keyString))
		}
	}
	return deletedListItems
}

func (data *SNMPServer) getEmptyLeafsDelete(ctx context.Context) []string {
	emptyLeafsDelete := make([]string, 0)

	return emptyLeafsDelete
}
