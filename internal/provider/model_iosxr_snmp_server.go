// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"reflect"
	"strconv"

	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

type SNMPServer struct {
	Device                         types.String       `tfsdk:"device"`
	Id                             types.String       `tfsdk:"id"`
	Rf                             types.Bool         `tfsdk:"rf"`
	Bfd                            types.Bool         `tfsdk:"bfd"`
	Ntp                            types.Bool         `tfsdk:"ntp"`
	EthernetOamEvents              types.Bool         `tfsdk:"ethernet_oam_events"`
	CopyComplete                   types.Bool         `tfsdk:"copy_complete"`
	TrapsSnmpLinkup                types.Bool         `tfsdk:"traps_snmp_linkup"`
	TrapsSnmpLinkdown              types.Bool         `tfsdk:"traps_snmp_linkdown"`
	Power                          types.Bool         `tfsdk:"power"`
	Config                         types.Bool         `tfsdk:"config"`
	Entity                         types.Bool         `tfsdk:"entity"`
	System                         types.Bool         `tfsdk:"system"`
	Bridgemib                      types.Bool         `tfsdk:"bridgemib"`
	EntityStateOperstatus          types.Bool         `tfsdk:"entity_state_operstatus"`
	EntityRedundancyAll            types.Bool         `tfsdk:"entity_redundancy_all"`
	TrapSourceBoth                 types.String       `tfsdk:"trap_source_both"`
	L2vpnAll                       types.Bool         `tfsdk:"l2vpn_all"`
	L2vpnVcUp                      types.Bool         `tfsdk:"l2vpn_vc_up"`
	L2vpnVcDown                    types.Bool         `tfsdk:"l2vpn_vc_down"`
	Sensor                         types.Bool         `tfsdk:"sensor"`
	FruCtrl                        types.Bool         `tfsdk:"fru_ctrl"`
	IsisAll                        types.String       `tfsdk:"isis_all"`
	IsisDatabaseOverload           types.String       `tfsdk:"isis_database_overload"`
	IsisManualAddressDrops         types.String       `tfsdk:"isis_manual_address_drops"`
	IsisCorruptedLspDetected       types.String       `tfsdk:"isis_corrupted_lsp_detected"`
	IsisAttemptToExceedMaxSequence types.String       `tfsdk:"isis_attempt_to_exceed_max_sequence"`
	IsisIdLenMismatch              types.String       `tfsdk:"isis_id_len_mismatch"`
	IsisMaxAreaAddressesMismatch   types.String       `tfsdk:"isis_max_area_addresses_mismatch"`
	IsisOwnLspPurge                types.String       `tfsdk:"isis_own_lsp_purge"`
	IsisSequenceNumberSkip         types.String       `tfsdk:"isis_sequence_number_skip"`
	IsisAuthenticationTypeFailure  types.String       `tfsdk:"isis_authentication_type_failure"`
	IsisAuthenticationFailure      types.String       `tfsdk:"isis_authentication_failure"`
	IsisVersionSkew                types.String       `tfsdk:"isis_version_skew"`
	IsisAreaMismatch               types.String       `tfsdk:"isis_area_mismatch"`
	IsisRejectedAdjacency          types.String       `tfsdk:"isis_rejected_adjacency"`
	IsisLspTooLargeToPropagate     types.String       `tfsdk:"isis_lsp_too_large_to_propagate"`
	IsisOrigLspBuffSizeMismatch    types.String       `tfsdk:"isis_orig_lsp_buff_size_mismatch"`
	IsisProtocolsSupportedMismatch types.String       `tfsdk:"isis_protocols_supported_mismatch"`
	IsisAdjacencyChange            types.String       `tfsdk:"isis_adjacency_change"`
	IsisLspErrorDetected           types.String       `tfsdk:"isis_lsp_error_detected"`
	BgpCbgp2Updown                 types.Bool         `tfsdk:"bgp_cbgp2_updown"`
	BgpBgp4MibUpdown               types.Bool         `tfsdk:"bgp_bgp4_mib_updown"`
	Users                          []SNMPServerUsers  `tfsdk:"users"`
	Groups                         []SNMPServerGroups `tfsdk:"groups"`
}
type SNMPServerUsers struct {
	UserName                   types.String `tfsdk:"user_name"`
	GroupName                  types.String `tfsdk:"group_name"`
	V3AuthMd5EncryptionAes     types.String `tfsdk:"v3_auth_md5_encryption_aes"`
	V3AuthMd5EncryptionDefault types.String `tfsdk:"v3_auth_md5_encryption_default"`
}
type SNMPServerGroups struct {
	GroupName types.String `tfsdk:"group_name"`
	V3Priv    types.Bool   `tfsdk:"v3_priv"`
	V3Read    types.String `tfsdk:"v3_read"`
	V3Write   types.String `tfsdk:"v3_write"`
	V3Context types.String `tfsdk:"v3_context"`
	V3Notify  types.String `tfsdk:"v3_notify"`
	V3Ipv4    types.String `tfsdk:"v3_ipv4"`
	V3Ipv6    types.String `tfsdk:"v3_ipv6"`
}

func (data SNMPServer) getPath() string {
	return "Cisco-IOS-XR-um-snmp-server-cfg:/snmp-server"
}

func (data SNMPServer) toBody(ctx context.Context) string {
	body := "{}"
	if !data.Rf.IsNull() && !data.Rf.IsUnknown() {
		if data.Rf.ValueBool() {
			body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-mibs-rfmib-cfg:rf", map[string]string{})
		}
	}
	if !data.Bfd.IsNull() && !data.Bfd.IsUnknown() {
		if data.Bfd.ValueBool() {
			body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-bfd-sbfd-cfg:bfd", map[string]string{})
		}
	}
	if !data.Ntp.IsNull() && !data.Ntp.IsUnknown() {
		if data.Ntp.ValueBool() {
			body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-ntp-cfg:ntp", map[string]string{})
		}
	}
	if !data.EthernetOamEvents.IsNull() && !data.EthernetOamEvents.IsUnknown() {
		if data.EthernetOamEvents.ValueBool() {
			body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-ethernet-oam-cfg:ethernet.oam.events", map[string]string{})
		}
	}
	if !data.CopyComplete.IsNull() && !data.CopyComplete.IsUnknown() {
		if data.CopyComplete.ValueBool() {
			body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-traps-config-copy-cfg:copy-complete", map[string]string{})
		}
	}
	if !data.TrapsSnmpLinkup.IsNull() && !data.TrapsSnmpLinkup.IsUnknown() {
		if data.TrapsSnmpLinkup.ValueBool() {
			body, _ = sjson.Set(body, "traps.snmp.linkup", map[string]string{})
		}
	}
	if !data.TrapsSnmpLinkdown.IsNull() && !data.TrapsSnmpLinkdown.IsUnknown() {
		if data.TrapsSnmpLinkdown.ValueBool() {
			body, _ = sjson.Set(body, "traps.snmp.linkdown", map[string]string{})
		}
	}
	if !data.Power.IsNull() && !data.Power.IsUnknown() {
		if data.Power.ValueBool() {
			body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-traps-power-cfg:power", map[string]string{})
		}
	}
	if !data.Config.IsNull() && !data.Config.IsUnknown() {
		if data.Config.ValueBool() {
			body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-cfg-mibs-cfg:config", map[string]string{})
		}
	}
	if !data.Entity.IsNull() && !data.Entity.IsUnknown() {
		if data.Entity.ValueBool() {
			body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-traps-entity-cfg:entity", map[string]string{})
		}
	}
	if !data.System.IsNull() && !data.System.IsUnknown() {
		if data.System.ValueBool() {
			body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-traps-system-cfg:system", map[string]string{})
		}
	}
	if !data.Bridgemib.IsNull() && !data.Bridgemib.IsUnknown() {
		if data.Bridgemib.ValueBool() {
			body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-traps-bridgemib-cfg:bridgemib", map[string]string{})
		}
	}
	if !data.EntityStateOperstatus.IsNull() && !data.EntityStateOperstatus.IsUnknown() {
		if data.EntityStateOperstatus.ValueBool() {
			body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-traps-entity-state-cfg:entity-state.operstatus", map[string]string{})
		}
	}
	if !data.EntityRedundancyAll.IsNull() && !data.EntityRedundancyAll.IsUnknown() {
		if data.EntityRedundancyAll.ValueBool() {
			body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-traps-entity-redundancy-cfg:entity-redundancy.all", map[string]string{})
		}
	}
	if !data.TrapSourceBoth.IsNull() && !data.TrapSourceBoth.IsUnknown() {
		body, _ = sjson.Set(body, "trap-source.both", data.TrapSourceBoth.ValueString())
	}
	if !data.L2vpnAll.IsNull() && !data.L2vpnAll.IsUnknown() {
		if data.L2vpnAll.ValueBool() {
			body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-l2vpn-cfg:l2vpn.all", map[string]string{})
		}
	}
	if !data.L2vpnVcUp.IsNull() && !data.L2vpnVcUp.IsUnknown() {
		if data.L2vpnVcUp.ValueBool() {
			body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-l2vpn-cfg:l2vpn.vc-up", map[string]string{})
		}
	}
	if !data.L2vpnVcDown.IsNull() && !data.L2vpnVcDown.IsUnknown() {
		if data.L2vpnVcDown.ValueBool() {
			body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-l2vpn-cfg:l2vpn.vc-down", map[string]string{})
		}
	}
	if !data.Sensor.IsNull() && !data.Sensor.IsUnknown() {
		if data.Sensor.ValueBool() {
			body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-mibs-sensormib-cfg:sensor", map[string]string{})
		}
	}
	if !data.FruCtrl.IsNull() && !data.FruCtrl.IsUnknown() {
		if data.FruCtrl.ValueBool() {
			body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-traps-fru-ctrl-cfg:fru-ctrl", map[string]string{})
		}
	}
	if !data.IsisAll.IsNull() && !data.IsisAll.IsUnknown() {
		body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.all", data.IsisAll.ValueString())
	}
	if !data.IsisDatabaseOverload.IsNull() && !data.IsisDatabaseOverload.IsUnknown() {
		body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.database-overload", data.IsisDatabaseOverload.ValueString())
	}
	if !data.IsisManualAddressDrops.IsNull() && !data.IsisManualAddressDrops.IsUnknown() {
		body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.manual-address-drops", data.IsisManualAddressDrops.ValueString())
	}
	if !data.IsisCorruptedLspDetected.IsNull() && !data.IsisCorruptedLspDetected.IsUnknown() {
		body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.corrupted-lsp-detected", data.IsisCorruptedLspDetected.ValueString())
	}
	if !data.IsisAttemptToExceedMaxSequence.IsNull() && !data.IsisAttemptToExceedMaxSequence.IsUnknown() {
		body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.attempt-to-exceed-max-sequence", data.IsisAttemptToExceedMaxSequence.ValueString())
	}
	if !data.IsisIdLenMismatch.IsNull() && !data.IsisIdLenMismatch.IsUnknown() {
		body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.id-len-mismatch", data.IsisIdLenMismatch.ValueString())
	}
	if !data.IsisMaxAreaAddressesMismatch.IsNull() && !data.IsisMaxAreaAddressesMismatch.IsUnknown() {
		body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.max-area-addresses-mismatch", data.IsisMaxAreaAddressesMismatch.ValueString())
	}
	if !data.IsisOwnLspPurge.IsNull() && !data.IsisOwnLspPurge.IsUnknown() {
		body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.own-lsp-purge", data.IsisOwnLspPurge.ValueString())
	}
	if !data.IsisSequenceNumberSkip.IsNull() && !data.IsisSequenceNumberSkip.IsUnknown() {
		body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.sequence-number-skip", data.IsisSequenceNumberSkip.ValueString())
	}
	if !data.IsisAuthenticationTypeFailure.IsNull() && !data.IsisAuthenticationTypeFailure.IsUnknown() {
		body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.authentication-type-failure", data.IsisAuthenticationTypeFailure.ValueString())
	}
	if !data.IsisAuthenticationFailure.IsNull() && !data.IsisAuthenticationFailure.IsUnknown() {
		body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.authentication-failure", data.IsisAuthenticationFailure.ValueString())
	}
	if !data.IsisVersionSkew.IsNull() && !data.IsisVersionSkew.IsUnknown() {
		body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.version-skew", data.IsisVersionSkew.ValueString())
	}
	if !data.IsisAreaMismatch.IsNull() && !data.IsisAreaMismatch.IsUnknown() {
		body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.area-mismatch", data.IsisAreaMismatch.ValueString())
	}
	if !data.IsisRejectedAdjacency.IsNull() && !data.IsisRejectedAdjacency.IsUnknown() {
		body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.rejected-adjacency", data.IsisRejectedAdjacency.ValueString())
	}
	if !data.IsisLspTooLargeToPropagate.IsNull() && !data.IsisLspTooLargeToPropagate.IsUnknown() {
		body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.lsp-too-large-to-propagate", data.IsisLspTooLargeToPropagate.ValueString())
	}
	if !data.IsisOrigLspBuffSizeMismatch.IsNull() && !data.IsisOrigLspBuffSizeMismatch.IsUnknown() {
		body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.orig-lsp-buff-size-mismatch", data.IsisOrigLspBuffSizeMismatch.ValueString())
	}
	if !data.IsisProtocolsSupportedMismatch.IsNull() && !data.IsisProtocolsSupportedMismatch.IsUnknown() {
		body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.protocols-supported-mismatch", data.IsisProtocolsSupportedMismatch.ValueString())
	}
	if !data.IsisAdjacencyChange.IsNull() && !data.IsisAdjacencyChange.IsUnknown() {
		body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.adjacency-change", data.IsisAdjacencyChange.ValueString())
	}
	if !data.IsisLspErrorDetected.IsNull() && !data.IsisLspErrorDetected.IsUnknown() {
		body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.lsp-error-detected", data.IsisLspErrorDetected.ValueString())
	}
	if !data.BgpCbgp2Updown.IsNull() && !data.BgpCbgp2Updown.IsUnknown() {
		if data.BgpCbgp2Updown.ValueBool() {
			body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-router-bgp-cfg:bgp.cbgp2-updown", map[string]string{})
		}
	}
	if !data.BgpBgp4MibUpdown.IsNull() && !data.BgpBgp4MibUpdown.IsUnknown() {
		if data.BgpBgp4MibUpdown.ValueBool() {
			body, _ = sjson.Set(body, "traps.Cisco-IOS-XR-um-router-bgp-cfg:bgp.bgp4-mib-updown", map[string]string{})
		}
	}
	if len(data.Users) > 0 {
		body, _ = sjson.Set(body, "users.user", []interface{}{})
		for index, item := range data.Users {
			if !item.UserName.IsNull() && !item.UserName.IsUnknown() {
				body, _ = sjson.Set(body, "users.user"+"."+strconv.Itoa(index)+"."+"user-name", item.UserName.ValueString())
			}
			if !item.GroupName.IsNull() && !item.GroupName.IsUnknown() {
				body, _ = sjson.Set(body, "users.user"+"."+strconv.Itoa(index)+"."+"group-name", item.GroupName.ValueString())
			}
			if !item.V3AuthMd5EncryptionAes.IsNull() && !item.V3AuthMd5EncryptionAes.IsUnknown() {
				body, _ = sjson.Set(body, "users.user"+"."+strconv.Itoa(index)+"."+"v3.auth.md5.encryption-aes", item.V3AuthMd5EncryptionAes.ValueString())
			}
			if !item.V3AuthMd5EncryptionDefault.IsNull() && !item.V3AuthMd5EncryptionDefault.IsUnknown() {
				body, _ = sjson.Set(body, "users.user"+"."+strconv.Itoa(index)+"."+"v3.auth.md5.encryption-default", item.V3AuthMd5EncryptionDefault.ValueString())
			}
		}
	}
	if len(data.Groups) > 0 {
		body, _ = sjson.Set(body, "groups.group", []interface{}{})
		for index, item := range data.Groups {
			if !item.GroupName.IsNull() && !item.GroupName.IsUnknown() {
				body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"group-name", item.GroupName.ValueString())
			}
			if !item.V3Priv.IsNull() && !item.V3Priv.IsUnknown() {
				if item.V3Priv.ValueBool() {
					body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"v3.priv", map[string]string{})
				}
			}
			if !item.V3Read.IsNull() && !item.V3Read.IsUnknown() {
				body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"v3.read", item.V3Read.ValueString())
			}
			if !item.V3Write.IsNull() && !item.V3Write.IsUnknown() {
				body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"v3.write", item.V3Write.ValueString())
			}
			if !item.V3Context.IsNull() && !item.V3Context.IsUnknown() {
				body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"v3.context", item.V3Context.ValueString())
			}
			if !item.V3Notify.IsNull() && !item.V3Notify.IsUnknown() {
				body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"v3.notify", item.V3Notify.ValueString())
			}
			if !item.V3Ipv4.IsNull() && !item.V3Ipv4.IsUnknown() {
				body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"v3.ipv4", item.V3Ipv4.ValueString())
			}
			if !item.V3Ipv6.IsNull() && !item.V3Ipv6.IsUnknown() {
				body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"v3.ipv6", item.V3Ipv6.ValueString())
			}
		}
	}
	return body
}

func (data *SNMPServer) updateFromBody(ctx context.Context, res []byte) {
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-mibs-rfmib-cfg:rf"); !data.Rf.IsNull() {
		if value.Exists() {
			data.Rf = types.BoolValue(true)
		} else {
			data.Rf = types.BoolValue(false)
		}
	} else {
		data.Rf = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-bfd-sbfd-cfg:bfd"); !data.Bfd.IsNull() {
		if value.Exists() {
			data.Bfd = types.BoolValue(true)
		} else {
			data.Bfd = types.BoolValue(false)
		}
	} else {
		data.Bfd = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-ntp-cfg:ntp"); !data.Ntp.IsNull() {
		if value.Exists() {
			data.Ntp = types.BoolValue(true)
		} else {
			data.Ntp = types.BoolValue(false)
		}
	} else {
		data.Ntp = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-ethernet-oam-cfg:ethernet.oam.events"); !data.EthernetOamEvents.IsNull() {
		if value.Exists() {
			data.EthernetOamEvents = types.BoolValue(true)
		} else {
			data.EthernetOamEvents = types.BoolValue(false)
		}
	} else {
		data.EthernetOamEvents = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-traps-config-copy-cfg:copy-complete"); !data.CopyComplete.IsNull() {
		if value.Exists() {
			data.CopyComplete = types.BoolValue(true)
		} else {
			data.CopyComplete = types.BoolValue(false)
		}
	} else {
		data.CopyComplete = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.snmp.linkup"); !data.TrapsSnmpLinkup.IsNull() {
		if value.Exists() {
			data.TrapsSnmpLinkup = types.BoolValue(true)
		} else {
			data.TrapsSnmpLinkup = types.BoolValue(false)
		}
	} else {
		data.TrapsSnmpLinkup = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.snmp.linkdown"); !data.TrapsSnmpLinkdown.IsNull() {
		if value.Exists() {
			data.TrapsSnmpLinkdown = types.BoolValue(true)
		} else {
			data.TrapsSnmpLinkdown = types.BoolValue(false)
		}
	} else {
		data.TrapsSnmpLinkdown = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-traps-power-cfg:power"); !data.Power.IsNull() {
		if value.Exists() {
			data.Power = types.BoolValue(true)
		} else {
			data.Power = types.BoolValue(false)
		}
	} else {
		data.Power = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-cfg-mibs-cfg:config"); !data.Config.IsNull() {
		if value.Exists() {
			data.Config = types.BoolValue(true)
		} else {
			data.Config = types.BoolValue(false)
		}
	} else {
		data.Config = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-traps-entity-cfg:entity"); !data.Entity.IsNull() {
		if value.Exists() {
			data.Entity = types.BoolValue(true)
		} else {
			data.Entity = types.BoolValue(false)
		}
	} else {
		data.Entity = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-traps-system-cfg:system"); !data.System.IsNull() {
		if value.Exists() {
			data.System = types.BoolValue(true)
		} else {
			data.System = types.BoolValue(false)
		}
	} else {
		data.System = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-traps-bridgemib-cfg:bridgemib"); !data.Bridgemib.IsNull() {
		if value.Exists() {
			data.Bridgemib = types.BoolValue(true)
		} else {
			data.Bridgemib = types.BoolValue(false)
		}
	} else {
		data.Bridgemib = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-traps-entity-state-cfg:entity-state.operstatus"); !data.EntityStateOperstatus.IsNull() {
		if value.Exists() {
			data.EntityStateOperstatus = types.BoolValue(true)
		} else {
			data.EntityStateOperstatus = types.BoolValue(false)
		}
	} else {
		data.EntityStateOperstatus = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-traps-entity-redundancy-cfg:entity-redundancy.all"); !data.EntityRedundancyAll.IsNull() {
		if value.Exists() {
			data.EntityRedundancyAll = types.BoolValue(true)
		} else {
			data.EntityRedundancyAll = types.BoolValue(false)
		}
	} else {
		data.EntityRedundancyAll = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "trap-source.both"); value.Exists() && !data.TrapSourceBoth.IsNull() {
		data.TrapSourceBoth = types.StringValue(value.String())
	} else {
		data.TrapSourceBoth = types.StringNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-l2vpn-cfg:l2vpn.all"); !data.L2vpnAll.IsNull() {
		if value.Exists() {
			data.L2vpnAll = types.BoolValue(true)
		} else {
			data.L2vpnAll = types.BoolValue(false)
		}
	} else {
		data.L2vpnAll = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-l2vpn-cfg:l2vpn.vc-up"); !data.L2vpnVcUp.IsNull() {
		if value.Exists() {
			data.L2vpnVcUp = types.BoolValue(true)
		} else {
			data.L2vpnVcUp = types.BoolValue(false)
		}
	} else {
		data.L2vpnVcUp = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-l2vpn-cfg:l2vpn.vc-down"); !data.L2vpnVcDown.IsNull() {
		if value.Exists() {
			data.L2vpnVcDown = types.BoolValue(true)
		} else {
			data.L2vpnVcDown = types.BoolValue(false)
		}
	} else {
		data.L2vpnVcDown = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-mibs-sensormib-cfg:sensor"); !data.Sensor.IsNull() {
		if value.Exists() {
			data.Sensor = types.BoolValue(true)
		} else {
			data.Sensor = types.BoolValue(false)
		}
	} else {
		data.Sensor = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-traps-fru-ctrl-cfg:fru-ctrl"); !data.FruCtrl.IsNull() {
		if value.Exists() {
			data.FruCtrl = types.BoolValue(true)
		} else {
			data.FruCtrl = types.BoolValue(false)
		}
	} else {
		data.FruCtrl = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.all"); value.Exists() && !data.IsisAll.IsNull() {
		data.IsisAll = types.StringValue(value.String())
	} else {
		data.IsisAll = types.StringNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.database-overload"); value.Exists() && !data.IsisDatabaseOverload.IsNull() {
		data.IsisDatabaseOverload = types.StringValue(value.String())
	} else {
		data.IsisDatabaseOverload = types.StringNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.manual-address-drops"); value.Exists() && !data.IsisManualAddressDrops.IsNull() {
		data.IsisManualAddressDrops = types.StringValue(value.String())
	} else {
		data.IsisManualAddressDrops = types.StringNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.corrupted-lsp-detected"); value.Exists() && !data.IsisCorruptedLspDetected.IsNull() {
		data.IsisCorruptedLspDetected = types.StringValue(value.String())
	} else {
		data.IsisCorruptedLspDetected = types.StringNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.attempt-to-exceed-max-sequence"); value.Exists() && !data.IsisAttemptToExceedMaxSequence.IsNull() {
		data.IsisAttemptToExceedMaxSequence = types.StringValue(value.String())
	} else {
		data.IsisAttemptToExceedMaxSequence = types.StringNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.id-len-mismatch"); value.Exists() && !data.IsisIdLenMismatch.IsNull() {
		data.IsisIdLenMismatch = types.StringValue(value.String())
	} else {
		data.IsisIdLenMismatch = types.StringNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.max-area-addresses-mismatch"); value.Exists() && !data.IsisMaxAreaAddressesMismatch.IsNull() {
		data.IsisMaxAreaAddressesMismatch = types.StringValue(value.String())
	} else {
		data.IsisMaxAreaAddressesMismatch = types.StringNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.own-lsp-purge"); value.Exists() && !data.IsisOwnLspPurge.IsNull() {
		data.IsisOwnLspPurge = types.StringValue(value.String())
	} else {
		data.IsisOwnLspPurge = types.StringNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.sequence-number-skip"); value.Exists() && !data.IsisSequenceNumberSkip.IsNull() {
		data.IsisSequenceNumberSkip = types.StringValue(value.String())
	} else {
		data.IsisSequenceNumberSkip = types.StringNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.authentication-type-failure"); value.Exists() && !data.IsisAuthenticationTypeFailure.IsNull() {
		data.IsisAuthenticationTypeFailure = types.StringValue(value.String())
	} else {
		data.IsisAuthenticationTypeFailure = types.StringNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.authentication-failure"); value.Exists() && !data.IsisAuthenticationFailure.IsNull() {
		data.IsisAuthenticationFailure = types.StringValue(value.String())
	} else {
		data.IsisAuthenticationFailure = types.StringNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.version-skew"); value.Exists() && !data.IsisVersionSkew.IsNull() {
		data.IsisVersionSkew = types.StringValue(value.String())
	} else {
		data.IsisVersionSkew = types.StringNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.area-mismatch"); value.Exists() && !data.IsisAreaMismatch.IsNull() {
		data.IsisAreaMismatch = types.StringValue(value.String())
	} else {
		data.IsisAreaMismatch = types.StringNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.rejected-adjacency"); value.Exists() && !data.IsisRejectedAdjacency.IsNull() {
		data.IsisRejectedAdjacency = types.StringValue(value.String())
	} else {
		data.IsisRejectedAdjacency = types.StringNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.lsp-too-large-to-propagate"); value.Exists() && !data.IsisLspTooLargeToPropagate.IsNull() {
		data.IsisLspTooLargeToPropagate = types.StringValue(value.String())
	} else {
		data.IsisLspTooLargeToPropagate = types.StringNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.orig-lsp-buff-size-mismatch"); value.Exists() && !data.IsisOrigLspBuffSizeMismatch.IsNull() {
		data.IsisOrigLspBuffSizeMismatch = types.StringValue(value.String())
	} else {
		data.IsisOrigLspBuffSizeMismatch = types.StringNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.protocols-supported-mismatch"); value.Exists() && !data.IsisProtocolsSupportedMismatch.IsNull() {
		data.IsisProtocolsSupportedMismatch = types.StringValue(value.String())
	} else {
		data.IsisProtocolsSupportedMismatch = types.StringNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.adjacency-change"); value.Exists() && !data.IsisAdjacencyChange.IsNull() {
		data.IsisAdjacencyChange = types.StringValue(value.String())
	} else {
		data.IsisAdjacencyChange = types.StringNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.lsp-error-detected"); value.Exists() && !data.IsisLspErrorDetected.IsNull() {
		data.IsisLspErrorDetected = types.StringValue(value.String())
	} else {
		data.IsisLspErrorDetected = types.StringNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-bgp-cfg:bgp.cbgp2-updown"); !data.BgpCbgp2Updown.IsNull() {
		if value.Exists() {
			data.BgpCbgp2Updown = types.BoolValue(true)
		} else {
			data.BgpCbgp2Updown = types.BoolValue(false)
		}
	} else {
		data.BgpCbgp2Updown = types.BoolNull()
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-bgp-cfg:bgp.bgp4-mib-updown"); !data.BgpBgp4MibUpdown.IsNull() {
		if value.Exists() {
			data.BgpBgp4MibUpdown = types.BoolValue(true)
		} else {
			data.BgpBgp4MibUpdown = types.BoolValue(false)
		}
	} else {
		data.BgpBgp4MibUpdown = types.BoolNull()
	}
	for i := range data.Users {
		keys := [...]string{"user-name"}
		keyValues := [...]string{data.Users[i].UserName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "users.user").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("user-name"); value.Exists() && !data.Users[i].UserName.IsNull() {
			data.Users[i].UserName = types.StringValue(value.String())
		} else {
			data.Users[i].UserName = types.StringNull()
		}
		if value := r.Get("group-name"); value.Exists() && !data.Users[i].GroupName.IsNull() {
			data.Users[i].GroupName = types.StringValue(value.String())
		} else {
			data.Users[i].GroupName = types.StringNull()
		}
		if value := r.Get("v3.auth.md5.encryption-aes"); value.Exists() && !data.Users[i].V3AuthMd5EncryptionAes.IsNull() {
			data.Users[i].V3AuthMd5EncryptionAes = types.StringValue(value.String())
		} else {
			data.Users[i].V3AuthMd5EncryptionAes = types.StringNull()
		}
		if value := r.Get("v3.auth.md5.encryption-default"); value.Exists() && !data.Users[i].V3AuthMd5EncryptionDefault.IsNull() {
			data.Users[i].V3AuthMd5EncryptionDefault = types.StringValue(value.String())
		} else {
			data.Users[i].V3AuthMd5EncryptionDefault = types.StringNull()
		}
	}
	for i := range data.Groups {
		keys := [...]string{"group-name"}
		keyValues := [...]string{data.Groups[i].GroupName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "groups.group").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("group-name"); value.Exists() && !data.Groups[i].GroupName.IsNull() {
			data.Groups[i].GroupName = types.StringValue(value.String())
		} else {
			data.Groups[i].GroupName = types.StringNull()
		}
		if value := r.Get("v3.priv"); !data.Groups[i].V3Priv.IsNull() {
			if value.Exists() {
				data.Groups[i].V3Priv = types.BoolValue(true)
			} else {
				data.Groups[i].V3Priv = types.BoolValue(false)
			}
		} else {
			data.Groups[i].V3Priv = types.BoolNull()
		}
		if value := r.Get("v3.read"); value.Exists() && !data.Groups[i].V3Read.IsNull() {
			data.Groups[i].V3Read = types.StringValue(value.String())
		} else {
			data.Groups[i].V3Read = types.StringNull()
		}
		if value := r.Get("v3.write"); value.Exists() && !data.Groups[i].V3Write.IsNull() {
			data.Groups[i].V3Write = types.StringValue(value.String())
		} else {
			data.Groups[i].V3Write = types.StringNull()
		}
		if value := r.Get("v3.context"); value.Exists() && !data.Groups[i].V3Context.IsNull() {
			data.Groups[i].V3Context = types.StringValue(value.String())
		} else {
			data.Groups[i].V3Context = types.StringNull()
		}
		if value := r.Get("v3.notify"); value.Exists() && !data.Groups[i].V3Notify.IsNull() {
			data.Groups[i].V3Notify = types.StringValue(value.String())
		} else {
			data.Groups[i].V3Notify = types.StringNull()
		}
		if value := r.Get("v3.ipv4"); value.Exists() && !data.Groups[i].V3Ipv4.IsNull() {
			data.Groups[i].V3Ipv4 = types.StringValue(value.String())
		} else {
			data.Groups[i].V3Ipv4 = types.StringNull()
		}
		if value := r.Get("v3.ipv6"); value.Exists() && !data.Groups[i].V3Ipv6.IsNull() {
			data.Groups[i].V3Ipv6 = types.StringValue(value.String())
		} else {
			data.Groups[i].V3Ipv6 = types.StringNull()
		}
	}
}

func (data *SNMPServer) fromBody(ctx context.Context, res []byte) {
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-mibs-rfmib-cfg:rf"); value.Exists() {
		data.Rf = types.BoolValue(true)
	} else {
		data.Rf = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-bfd-sbfd-cfg:bfd"); value.Exists() {
		data.Bfd = types.BoolValue(true)
	} else {
		data.Bfd = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-ntp-cfg:ntp"); value.Exists() {
		data.Ntp = types.BoolValue(true)
	} else {
		data.Ntp = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-ethernet-oam-cfg:ethernet.oam.events"); value.Exists() {
		data.EthernetOamEvents = types.BoolValue(true)
	} else {
		data.EthernetOamEvents = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-traps-config-copy-cfg:copy-complete"); value.Exists() {
		data.CopyComplete = types.BoolValue(true)
	} else {
		data.CopyComplete = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.snmp.linkup"); value.Exists() {
		data.TrapsSnmpLinkup = types.BoolValue(true)
	} else {
		data.TrapsSnmpLinkup = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.snmp.linkdown"); value.Exists() {
		data.TrapsSnmpLinkdown = types.BoolValue(true)
	} else {
		data.TrapsSnmpLinkdown = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-traps-power-cfg:power"); value.Exists() {
		data.Power = types.BoolValue(true)
	} else {
		data.Power = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-cfg-mibs-cfg:config"); value.Exists() {
		data.Config = types.BoolValue(true)
	} else {
		data.Config = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-traps-entity-cfg:entity"); value.Exists() {
		data.Entity = types.BoolValue(true)
	} else {
		data.Entity = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-traps-system-cfg:system"); value.Exists() {
		data.System = types.BoolValue(true)
	} else {
		data.System = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-traps-bridgemib-cfg:bridgemib"); value.Exists() {
		data.Bridgemib = types.BoolValue(true)
	} else {
		data.Bridgemib = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-traps-entity-state-cfg:entity-state.operstatus"); value.Exists() {
		data.EntityStateOperstatus = types.BoolValue(true)
	} else {
		data.EntityStateOperstatus = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-traps-entity-redundancy-cfg:entity-redundancy.all"); value.Exists() {
		data.EntityRedundancyAll = types.BoolValue(true)
	} else {
		data.EntityRedundancyAll = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "trap-source.both"); value.Exists() {
		data.TrapSourceBoth = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-l2vpn-cfg:l2vpn.all"); value.Exists() {
		data.L2vpnAll = types.BoolValue(true)
	} else {
		data.L2vpnAll = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-l2vpn-cfg:l2vpn.vc-up"); value.Exists() {
		data.L2vpnVcUp = types.BoolValue(true)
	} else {
		data.L2vpnVcUp = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-l2vpn-cfg:l2vpn.vc-down"); value.Exists() {
		data.L2vpnVcDown = types.BoolValue(true)
	} else {
		data.L2vpnVcDown = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-mibs-sensormib-cfg:sensor"); value.Exists() {
		data.Sensor = types.BoolValue(true)
	} else {
		data.Sensor = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-traps-fru-ctrl-cfg:fru-ctrl"); value.Exists() {
		data.FruCtrl = types.BoolValue(true)
	} else {
		data.FruCtrl = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.all"); value.Exists() {
		data.IsisAll = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.database-overload"); value.Exists() {
		data.IsisDatabaseOverload = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.manual-address-drops"); value.Exists() {
		data.IsisManualAddressDrops = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.corrupted-lsp-detected"); value.Exists() {
		data.IsisCorruptedLspDetected = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.attempt-to-exceed-max-sequence"); value.Exists() {
		data.IsisAttemptToExceedMaxSequence = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.id-len-mismatch"); value.Exists() {
		data.IsisIdLenMismatch = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.max-area-addresses-mismatch"); value.Exists() {
		data.IsisMaxAreaAddressesMismatch = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.own-lsp-purge"); value.Exists() {
		data.IsisOwnLspPurge = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.sequence-number-skip"); value.Exists() {
		data.IsisSequenceNumberSkip = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.authentication-type-failure"); value.Exists() {
		data.IsisAuthenticationTypeFailure = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.authentication-failure"); value.Exists() {
		data.IsisAuthenticationFailure = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.version-skew"); value.Exists() {
		data.IsisVersionSkew = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.area-mismatch"); value.Exists() {
		data.IsisAreaMismatch = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.rejected-adjacency"); value.Exists() {
		data.IsisRejectedAdjacency = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.lsp-too-large-to-propagate"); value.Exists() {
		data.IsisLspTooLargeToPropagate = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.orig-lsp-buff-size-mismatch"); value.Exists() {
		data.IsisOrigLspBuffSizeMismatch = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.protocols-supported-mismatch"); value.Exists() {
		data.IsisProtocolsSupportedMismatch = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.adjacency-change"); value.Exists() {
		data.IsisAdjacencyChange = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-isis-cfg:isis.lsp-error-detected"); value.Exists() {
		data.IsisLspErrorDetected = types.StringValue(value.String())
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-bgp-cfg:bgp.cbgp2-updown"); value.Exists() {
		data.BgpCbgp2Updown = types.BoolValue(true)
	} else {
		data.BgpCbgp2Updown = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "traps.Cisco-IOS-XR-um-router-bgp-cfg:bgp.bgp4-mib-updown"); value.Exists() {
		data.BgpBgp4MibUpdown = types.BoolValue(true)
	} else {
		data.BgpBgp4MibUpdown = types.BoolValue(false)
	}
	if value := gjson.GetBytes(res, "users.user"); value.Exists() {
		data.Users = make([]SNMPServerUsers, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := SNMPServerUsers{}
			if cValue := v.Get("user-name"); cValue.Exists() {
				item.UserName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("group-name"); cValue.Exists() {
				item.GroupName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("v3.auth.md5.encryption-aes"); cValue.Exists() {
				item.V3AuthMd5EncryptionAes = types.StringValue(cValue.String())
			}
			if cValue := v.Get("v3.auth.md5.encryption-default"); cValue.Exists() {
				item.V3AuthMd5EncryptionDefault = types.StringValue(cValue.String())
			}
			data.Users = append(data.Users, item)
			return true
		})
	}
	if value := gjson.GetBytes(res, "groups.group"); value.Exists() {
		data.Groups = make([]SNMPServerGroups, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := SNMPServerGroups{}
			if cValue := v.Get("group-name"); cValue.Exists() {
				item.GroupName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("v3.priv"); cValue.Exists() {
				item.V3Priv = types.BoolValue(true)
			} else {
				item.V3Priv = types.BoolValue(false)
			}
			if cValue := v.Get("v3.read"); cValue.Exists() {
				item.V3Read = types.StringValue(cValue.String())
			}
			if cValue := v.Get("v3.write"); cValue.Exists() {
				item.V3Write = types.StringValue(cValue.String())
			}
			if cValue := v.Get("v3.context"); cValue.Exists() {
				item.V3Context = types.StringValue(cValue.String())
			}
			if cValue := v.Get("v3.notify"); cValue.Exists() {
				item.V3Notify = types.StringValue(cValue.String())
			}
			if cValue := v.Get("v3.ipv4"); cValue.Exists() {
				item.V3Ipv4 = types.StringValue(cValue.String())
			}
			if cValue := v.Get("v3.ipv6"); cValue.Exists() {
				item.V3Ipv6 = types.StringValue(cValue.String())
			}
			data.Groups = append(data.Groups, item)
			return true
		})
	}
}

func (data *SNMPServer) fromPlan(ctx context.Context, plan SNMPServer) {
	data.Device = plan.Device
}

func (data *SNMPServer) getDeletedListItems(ctx context.Context, state SNMPServer) []string {
	deletedListItems := make([]string, 0)
	for i := range state.Users {
		keys := [...]string{"user-name"}
		stateKeyValues := [...]string{state.Users[i].UserName.ValueString()}

		emptyKeys := true
		if !reflect.ValueOf(state.Users[i].UserName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Users {
			found = true
			if state.Users[i].UserName.ValueString() != data.Users[j].UserName.ValueString() {
				found = false
			}
			if found {
				break
			}
		}
		if !found {
			keyString := ""
			for ki := range keys {
				keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
			}
			deletedListItems = append(deletedListItems, fmt.Sprintf("%v/users/user%v", state.getPath(), keyString))
		}
	}
	for i := range state.Groups {
		keys := [...]string{"group-name"}
		stateKeyValues := [...]string{state.Groups[i].GroupName.ValueString()}

		emptyKeys := true
		if !reflect.ValueOf(state.Groups[i].GroupName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Groups {
			found = true
			if state.Groups[i].GroupName.ValueString() != data.Groups[j].GroupName.ValueString() {
				found = false
			}
			if found {
				break
			}
		}
		if !found {
			keyString := ""
			for ki := range keys {
				keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
			}
			deletedListItems = append(deletedListItems, fmt.Sprintf("%v/groups/group%v", state.getPath(), keyString))
		}
	}
	return deletedListItems
}

func (data *SNMPServer) getEmptyLeafsDelete(ctx context.Context) []string {
	emptyLeafsDelete := make([]string, 0)

	return emptyLeafsDelete
}
