// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports
import (
	"context"
	"fmt"
	"reflect"
	"strconv"

	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin types
type SRLG struct {
	Device           types.String           `tfsdk:"device"`
	Id               types.String           `tfsdk:"id"`
	DeleteMode       types.String           `tfsdk:"delete_mode"`
	Names            []SRLGNames            `tfsdk:"names"`
	Interfaces       []SRLGInterfaces       `tfsdk:"interfaces"`
	Groups           []SRLGGroups           `tfsdk:"groups"`
	InheritLocations []SRLGInheritLocations `tfsdk:"inherit_locations"`
}

type SRLGData struct {
	Device           types.String           `tfsdk:"device"`
	Id               types.String           `tfsdk:"id"`
	Names            []SRLGNames            `tfsdk:"names"`
	Interfaces       []SRLGInterfaces       `tfsdk:"interfaces"`
	Groups           []SRLGGroups           `tfsdk:"groups"`
	InheritLocations []SRLGInheritLocations `tfsdk:"inherit_locations"`
}
type SRLGNames struct {
	SrlgName    types.String `tfsdk:"srlg_name"`
	Value       types.Int64  `tfsdk:"value"`
	Description types.String `tfsdk:"description"`
}
type SRLGInterfaces struct {
	InterfaceName          types.String            `tfsdk:"interface_name"`
	IncludeOptical         types.Bool              `tfsdk:"include_optical"`
	IncludeOpticalPriority types.String            `tfsdk:"include_optical_priority"`
	Indexes                []SRLGInterfacesIndexes `tfsdk:"indexes"`
	Names                  []SRLGInterfacesNames   `tfsdk:"names"`
	Groups                 []SRLGInterfacesGroups  `tfsdk:"groups"`
}
type SRLGGroups struct {
	GroupName types.String        `tfsdk:"group_name"`
	Indexes   []SRLGGroupsIndexes `tfsdk:"indexes"`
}
type SRLGInheritLocations struct {
	LocationName types.String                  `tfsdk:"location_name"`
	Indexes      []SRLGInheritLocationsIndexes `tfsdk:"indexes"`
}
type SRLGInterfacesIndexes struct {
	IndexNumber types.Int64  `tfsdk:"index_number"`
	Value       types.Int64  `tfsdk:"value"`
	Priority    types.String `tfsdk:"priority"`
}
type SRLGInterfacesNames struct {
	SrlgName types.String `tfsdk:"srlg_name"`
}
type SRLGInterfacesGroups struct {
	IndexNumber types.Int64  `tfsdk:"index_number"`
	GroupName   types.String `tfsdk:"group_name"`
}
type SRLGGroupsIndexes struct {
	IndexNumber types.Int64  `tfsdk:"index_number"`
	Value       types.Int64  `tfsdk:"value"`
	Priority    types.String `tfsdk:"priority"`
}
type SRLGInheritLocationsIndexes struct {
	IndexNumber types.Int64  `tfsdk:"index_number"`
	Value       types.Int64  `tfsdk:"value"`
	Priority    types.String `tfsdk:"priority"`
}

// End of section. //template:end types

// Section below is generated&owned by "gen/generator.go". //template:begin getPath

func (data SRLG) getPath() string {
	return "Cisco-IOS-XR-um-vrf-cfg:/srlg"
}

func (data SRLGData) getPath() string {
	return "Cisco-IOS-XR-um-vrf-cfg:/srlg"
}

// End of section. //template:end getPath

// Section below is generated&owned by "gen/generator.go". //template:begin toBody

func (data SRLG) toBody(ctx context.Context) string {
	body := "{}"
	if len(data.Names) > 0 {
		body, _ = sjson.Set(body, "names.name", []interface{}{})
		for index, item := range data.Names {
			if !item.SrlgName.IsNull() && !item.SrlgName.IsUnknown() {
				body, _ = sjson.Set(body, "names.name"+"."+strconv.Itoa(index)+"."+"srlg-name", item.SrlgName.ValueString())
			}
			if !item.Value.IsNull() && !item.Value.IsUnknown() {
				body, _ = sjson.Set(body, "names.name"+"."+strconv.Itoa(index)+"."+"value", strconv.FormatInt(item.Value.ValueInt64(), 10))
			}
			if !item.Description.IsNull() && !item.Description.IsUnknown() {
				body, _ = sjson.Set(body, "names.name"+"."+strconv.Itoa(index)+"."+"description", item.Description.ValueString())
			}
		}
	}
	if len(data.Interfaces) > 0 {
		body, _ = sjson.Set(body, "interfaces.interface", []interface{}{})
		for index, item := range data.Interfaces {
			if !item.InterfaceName.IsNull() && !item.InterfaceName.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"interface-name", item.InterfaceName.ValueString())
			}
			if !item.IncludeOptical.IsNull() && !item.IncludeOptical.IsUnknown() {
				if item.IncludeOptical.ValueBool() {
					body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"include-optical", map[string]string{})
				}
			}
			if !item.IncludeOpticalPriority.IsNull() && !item.IncludeOpticalPriority.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"include-optical.priority", item.IncludeOpticalPriority.ValueString())
			}
			if len(item.Indexes) > 0 {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"indexes.index", []interface{}{})
				for cindex, citem := range item.Indexes {
					if !citem.IndexNumber.IsNull() && !citem.IndexNumber.IsUnknown() {
						body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"indexes.index"+"."+strconv.Itoa(cindex)+"."+"index-number", strconv.FormatInt(citem.IndexNumber.ValueInt64(), 10))
					}
					if !citem.Value.IsNull() && !citem.Value.IsUnknown() {
						body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"indexes.index"+"."+strconv.Itoa(cindex)+"."+"value", strconv.FormatInt(citem.Value.ValueInt64(), 10))
					}
					if !citem.Priority.IsNull() && !citem.Priority.IsUnknown() {
						body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"indexes.index"+"."+strconv.Itoa(cindex)+"."+"priority", citem.Priority.ValueString())
					}
				}
			}
			if len(item.Names) > 0 {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"names.name", []interface{}{})
				for cindex, citem := range item.Names {
					if !citem.SrlgName.IsNull() && !citem.SrlgName.IsUnknown() {
						body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"names.name"+"."+strconv.Itoa(cindex)+"."+"srlg-name", citem.SrlgName.ValueString())
					}
				}
			}
			if len(item.Groups) > 0 {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"groups.group", []interface{}{})
				for cindex, citem := range item.Groups {
					if !citem.IndexNumber.IsNull() && !citem.IndexNumber.IsUnknown() {
						body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"groups.group"+"."+strconv.Itoa(cindex)+"."+"index-number", strconv.FormatInt(citem.IndexNumber.ValueInt64(), 10))
					}
					if !citem.GroupName.IsNull() && !citem.GroupName.IsUnknown() {
						body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"groups.group"+"."+strconv.Itoa(cindex)+"."+"group-name", citem.GroupName.ValueString())
					}
				}
			}
		}
	}
	if len(data.Groups) > 0 {
		body, _ = sjson.Set(body, "groups.group", []interface{}{})
		for index, item := range data.Groups {
			if !item.GroupName.IsNull() && !item.GroupName.IsUnknown() {
				body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"group-name", item.GroupName.ValueString())
			}
			if len(item.Indexes) > 0 {
				body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"indexes.index", []interface{}{})
				for cindex, citem := range item.Indexes {
					if !citem.IndexNumber.IsNull() && !citem.IndexNumber.IsUnknown() {
						body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"indexes.index"+"."+strconv.Itoa(cindex)+"."+"index-number", strconv.FormatInt(citem.IndexNumber.ValueInt64(), 10))
					}
					if !citem.Value.IsNull() && !citem.Value.IsUnknown() {
						body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"indexes.index"+"."+strconv.Itoa(cindex)+"."+"value", strconv.FormatInt(citem.Value.ValueInt64(), 10))
					}
					if !citem.Priority.IsNull() && !citem.Priority.IsUnknown() {
						body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"indexes.index"+"."+strconv.Itoa(cindex)+"."+"priority", citem.Priority.ValueString())
					}
				}
			}
		}
	}
	if len(data.InheritLocations) > 0 {
		body, _ = sjson.Set(body, "inherit-locations.inherit-location", []interface{}{})
		for index, item := range data.InheritLocations {
			if !item.LocationName.IsNull() && !item.LocationName.IsUnknown() {
				body, _ = sjson.Set(body, "inherit-locations.inherit-location"+"."+strconv.Itoa(index)+"."+"location-name", item.LocationName.ValueString())
			}
			if len(item.Indexes) > 0 {
				body, _ = sjson.Set(body, "inherit-locations.inherit-location"+"."+strconv.Itoa(index)+"."+"indexes.index", []interface{}{})
				for cindex, citem := range item.Indexes {
					if !citem.IndexNumber.IsNull() && !citem.IndexNumber.IsUnknown() {
						body, _ = sjson.Set(body, "inherit-locations.inherit-location"+"."+strconv.Itoa(index)+"."+"indexes.index"+"."+strconv.Itoa(cindex)+"."+"index-number", strconv.FormatInt(citem.IndexNumber.ValueInt64(), 10))
					}
					if !citem.Value.IsNull() && !citem.Value.IsUnknown() {
						body, _ = sjson.Set(body, "inherit-locations.inherit-location"+"."+strconv.Itoa(index)+"."+"indexes.index"+"."+strconv.Itoa(cindex)+"."+"value", strconv.FormatInt(citem.Value.ValueInt64(), 10))
					}
					if !citem.Priority.IsNull() && !citem.Priority.IsUnknown() {
						body, _ = sjson.Set(body, "inherit-locations.inherit-location"+"."+strconv.Itoa(index)+"."+"indexes.index"+"."+strconv.Itoa(cindex)+"."+"priority", citem.Priority.ValueString())
					}
				}
			}
		}
	}
	return body
}

// End of section. //template:end toBody

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBody

func (data *SRLG) updateFromBody(ctx context.Context, res []byte) {
	for i := range data.Names {
		keys := [...]string{"srlg-name"}
		keyValues := [...]string{data.Names[i].SrlgName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "names.name").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("srlg-name"); value.Exists() && !data.Names[i].SrlgName.IsNull() {
			data.Names[i].SrlgName = types.StringValue(value.String())
		} else {
			data.Names[i].SrlgName = types.StringNull()
		}
		if value := r.Get("value"); value.Exists() && !data.Names[i].Value.IsNull() {
			data.Names[i].Value = types.Int64Value(value.Int())
		} else {
			data.Names[i].Value = types.Int64Null()
		}
		if value := r.Get("description"); value.Exists() && !data.Names[i].Description.IsNull() {
			data.Names[i].Description = types.StringValue(value.String())
		} else {
			data.Names[i].Description = types.StringNull()
		}
	}
	for i := range data.Interfaces {
		keys := [...]string{"interface-name"}
		keyValues := [...]string{data.Interfaces[i].InterfaceName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "interfaces.interface").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("interface-name"); value.Exists() && !data.Interfaces[i].InterfaceName.IsNull() {
			data.Interfaces[i].InterfaceName = types.StringValue(value.String())
		} else {
			data.Interfaces[i].InterfaceName = types.StringNull()
		}
		if value := r.Get("include-optical"); !data.Interfaces[i].IncludeOptical.IsNull() {
			if value.Exists() {
				data.Interfaces[i].IncludeOptical = types.BoolValue(true)
			} else {
				data.Interfaces[i].IncludeOptical = types.BoolValue(false)
			}
		} else {
			data.Interfaces[i].IncludeOptical = types.BoolNull()
		}
		if value := r.Get("include-optical.priority"); value.Exists() && !data.Interfaces[i].IncludeOpticalPriority.IsNull() {
			data.Interfaces[i].IncludeOpticalPriority = types.StringValue(value.String())
		} else {
			data.Interfaces[i].IncludeOpticalPriority = types.StringNull()
		}
		for ci := range data.Interfaces[i].Indexes {
			keys := [...]string{"index-number"}
			keyValues := [...]string{strconv.FormatInt(data.Interfaces[i].Indexes[ci].IndexNumber.ValueInt64(), 10)}

			var cr gjson.Result
			r.Get("indexes.index").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("index-number"); value.Exists() && !data.Interfaces[i].Indexes[ci].IndexNumber.IsNull() {
				data.Interfaces[i].Indexes[ci].IndexNumber = types.Int64Value(value.Int())
			} else {
				data.Interfaces[i].Indexes[ci].IndexNumber = types.Int64Null()
			}
			if value := cr.Get("value"); value.Exists() && !data.Interfaces[i].Indexes[ci].Value.IsNull() {
				data.Interfaces[i].Indexes[ci].Value = types.Int64Value(value.Int())
			} else {
				data.Interfaces[i].Indexes[ci].Value = types.Int64Null()
			}
			if value := cr.Get("priority"); value.Exists() && !data.Interfaces[i].Indexes[ci].Priority.IsNull() {
				data.Interfaces[i].Indexes[ci].Priority = types.StringValue(value.String())
			} else {
				data.Interfaces[i].Indexes[ci].Priority = types.StringNull()
			}
		}
		for ci := range data.Interfaces[i].Names {
			keys := [...]string{"srlg-name"}
			keyValues := [...]string{data.Interfaces[i].Names[ci].SrlgName.ValueString()}

			var cr gjson.Result
			r.Get("names.name").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("srlg-name"); value.Exists() && !data.Interfaces[i].Names[ci].SrlgName.IsNull() {
				data.Interfaces[i].Names[ci].SrlgName = types.StringValue(value.String())
			} else {
				data.Interfaces[i].Names[ci].SrlgName = types.StringNull()
			}
		}
		for ci := range data.Interfaces[i].Groups {
			keys := [...]string{"index-number"}
			keyValues := [...]string{strconv.FormatInt(data.Interfaces[i].Groups[ci].IndexNumber.ValueInt64(), 10)}

			var cr gjson.Result
			r.Get("groups.group").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("index-number"); value.Exists() && !data.Interfaces[i].Groups[ci].IndexNumber.IsNull() {
				data.Interfaces[i].Groups[ci].IndexNumber = types.Int64Value(value.Int())
			} else {
				data.Interfaces[i].Groups[ci].IndexNumber = types.Int64Null()
			}
			if value := cr.Get("group-name"); value.Exists() && !data.Interfaces[i].Groups[ci].GroupName.IsNull() {
				data.Interfaces[i].Groups[ci].GroupName = types.StringValue(value.String())
			} else {
				data.Interfaces[i].Groups[ci].GroupName = types.StringNull()
			}
		}
	}
	for i := range data.Groups {
		keys := [...]string{"group-name"}
		keyValues := [...]string{data.Groups[i].GroupName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "groups.group").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("group-name"); value.Exists() && !data.Groups[i].GroupName.IsNull() {
			data.Groups[i].GroupName = types.StringValue(value.String())
		} else {
			data.Groups[i].GroupName = types.StringNull()
		}
		for ci := range data.Groups[i].Indexes {
			keys := [...]string{"index-number"}
			keyValues := [...]string{strconv.FormatInt(data.Groups[i].Indexes[ci].IndexNumber.ValueInt64(), 10)}

			var cr gjson.Result
			r.Get("indexes.index").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("index-number"); value.Exists() && !data.Groups[i].Indexes[ci].IndexNumber.IsNull() {
				data.Groups[i].Indexes[ci].IndexNumber = types.Int64Value(value.Int())
			} else {
				data.Groups[i].Indexes[ci].IndexNumber = types.Int64Null()
			}
			if value := cr.Get("value"); value.Exists() && !data.Groups[i].Indexes[ci].Value.IsNull() {
				data.Groups[i].Indexes[ci].Value = types.Int64Value(value.Int())
			} else {
				data.Groups[i].Indexes[ci].Value = types.Int64Null()
			}
			if value := cr.Get("priority"); value.Exists() && !data.Groups[i].Indexes[ci].Priority.IsNull() {
				data.Groups[i].Indexes[ci].Priority = types.StringValue(value.String())
			} else {
				data.Groups[i].Indexes[ci].Priority = types.StringNull()
			}
		}
	}
	for i := range data.InheritLocations {
		keys := [...]string{"location-name"}
		keyValues := [...]string{data.InheritLocations[i].LocationName.ValueString()}

		var r gjson.Result
		gjson.GetBytes(res, "inherit-locations.inherit-location").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("location-name"); value.Exists() && !data.InheritLocations[i].LocationName.IsNull() {
			data.InheritLocations[i].LocationName = types.StringValue(value.String())
		} else {
			data.InheritLocations[i].LocationName = types.StringNull()
		}
		for ci := range data.InheritLocations[i].Indexes {
			keys := [...]string{"index-number"}
			keyValues := [...]string{strconv.FormatInt(data.InheritLocations[i].Indexes[ci].IndexNumber.ValueInt64(), 10)}

			var cr gjson.Result
			r.Get("indexes.index").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("index-number"); value.Exists() && !data.InheritLocations[i].Indexes[ci].IndexNumber.IsNull() {
				data.InheritLocations[i].Indexes[ci].IndexNumber = types.Int64Value(value.Int())
			} else {
				data.InheritLocations[i].Indexes[ci].IndexNumber = types.Int64Null()
			}
			if value := cr.Get("value"); value.Exists() && !data.InheritLocations[i].Indexes[ci].Value.IsNull() {
				data.InheritLocations[i].Indexes[ci].Value = types.Int64Value(value.Int())
			} else {
				data.InheritLocations[i].Indexes[ci].Value = types.Int64Null()
			}
			if value := cr.Get("priority"); value.Exists() && !data.InheritLocations[i].Indexes[ci].Priority.IsNull() {
				data.InheritLocations[i].Indexes[ci].Priority = types.StringValue(value.String())
			} else {
				data.InheritLocations[i].Indexes[ci].Priority = types.StringNull()
			}
		}
	}
}

// End of section. //template:end updateFromBody

// Section below is generated&owned by "gen/generator.go". //template:begin fromBody

func (data *SRLG) fromBody(ctx context.Context, res []byte) {
	if value := gjson.GetBytes(res, "names.name"); value.Exists() {
		data.Names = make([]SRLGNames, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := SRLGNames{}
			if cValue := v.Get("srlg-name"); cValue.Exists() {
				item.SrlgName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("value"); cValue.Exists() {
				item.Value = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("description"); cValue.Exists() {
				item.Description = types.StringValue(cValue.String())
			}
			data.Names = append(data.Names, item)
			return true
		})
	}
	if value := gjson.GetBytes(res, "interfaces.interface"); value.Exists() {
		data.Interfaces = make([]SRLGInterfaces, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := SRLGInterfaces{}
			if cValue := v.Get("interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("include-optical"); cValue.Exists() {
				item.IncludeOptical = types.BoolValue(true)
			} else {
				item.IncludeOptical = types.BoolValue(false)
			}
			if cValue := v.Get("include-optical.priority"); cValue.Exists() {
				item.IncludeOpticalPriority = types.StringValue(cValue.String())
			}
			if cValue := v.Get("indexes.index"); cValue.Exists() {
				item.Indexes = make([]SRLGInterfacesIndexes, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := SRLGInterfacesIndexes{}
					if ccValue := cv.Get("index-number"); ccValue.Exists() {
						cItem.IndexNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("value"); ccValue.Exists() {
						cItem.Value = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("priority"); ccValue.Exists() {
						cItem.Priority = types.StringValue(ccValue.String())
					}
					item.Indexes = append(item.Indexes, cItem)
					return true
				})
			}
			if cValue := v.Get("names.name"); cValue.Exists() {
				item.Names = make([]SRLGInterfacesNames, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := SRLGInterfacesNames{}
					if ccValue := cv.Get("srlg-name"); ccValue.Exists() {
						cItem.SrlgName = types.StringValue(ccValue.String())
					}
					item.Names = append(item.Names, cItem)
					return true
				})
			}
			if cValue := v.Get("groups.group"); cValue.Exists() {
				item.Groups = make([]SRLGInterfacesGroups, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := SRLGInterfacesGroups{}
					if ccValue := cv.Get("index-number"); ccValue.Exists() {
						cItem.IndexNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("group-name"); ccValue.Exists() {
						cItem.GroupName = types.StringValue(ccValue.String())
					}
					item.Groups = append(item.Groups, cItem)
					return true
				})
			}
			data.Interfaces = append(data.Interfaces, item)
			return true
		})
	}
	if value := gjson.GetBytes(res, "groups.group"); value.Exists() {
		data.Groups = make([]SRLGGroups, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := SRLGGroups{}
			if cValue := v.Get("group-name"); cValue.Exists() {
				item.GroupName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("indexes.index"); cValue.Exists() {
				item.Indexes = make([]SRLGGroupsIndexes, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := SRLGGroupsIndexes{}
					if ccValue := cv.Get("index-number"); ccValue.Exists() {
						cItem.IndexNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("value"); ccValue.Exists() {
						cItem.Value = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("priority"); ccValue.Exists() {
						cItem.Priority = types.StringValue(ccValue.String())
					}
					item.Indexes = append(item.Indexes, cItem)
					return true
				})
			}
			data.Groups = append(data.Groups, item)
			return true
		})
	}
	if value := gjson.GetBytes(res, "inherit-locations.inherit-location"); value.Exists() {
		data.InheritLocations = make([]SRLGInheritLocations, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := SRLGInheritLocations{}
			if cValue := v.Get("location-name"); cValue.Exists() {
				item.LocationName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("indexes.index"); cValue.Exists() {
				item.Indexes = make([]SRLGInheritLocationsIndexes, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := SRLGInheritLocationsIndexes{}
					if ccValue := cv.Get("index-number"); ccValue.Exists() {
						cItem.IndexNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("value"); ccValue.Exists() {
						cItem.Value = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("priority"); ccValue.Exists() {
						cItem.Priority = types.StringValue(ccValue.String())
					}
					item.Indexes = append(item.Indexes, cItem)
					return true
				})
			}
			data.InheritLocations = append(data.InheritLocations, item)
			return true
		})
	}
}

// End of section. //template:end fromBody

// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyData

func (data *SRLGData) fromBody(ctx context.Context, res []byte) {
	if value := gjson.GetBytes(res, "names.name"); value.Exists() {
		data.Names = make([]SRLGNames, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := SRLGNames{}
			if cValue := v.Get("srlg-name"); cValue.Exists() {
				item.SrlgName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("value"); cValue.Exists() {
				item.Value = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("description"); cValue.Exists() {
				item.Description = types.StringValue(cValue.String())
			}
			data.Names = append(data.Names, item)
			return true
		})
	}
	if value := gjson.GetBytes(res, "interfaces.interface"); value.Exists() {
		data.Interfaces = make([]SRLGInterfaces, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := SRLGInterfaces{}
			if cValue := v.Get("interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("include-optical"); cValue.Exists() {
				item.IncludeOptical = types.BoolValue(true)
			} else {
				item.IncludeOptical = types.BoolValue(false)
			}
			if cValue := v.Get("include-optical.priority"); cValue.Exists() {
				item.IncludeOpticalPriority = types.StringValue(cValue.String())
			}
			if cValue := v.Get("indexes.index"); cValue.Exists() {
				item.Indexes = make([]SRLGInterfacesIndexes, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := SRLGInterfacesIndexes{}
					if ccValue := cv.Get("index-number"); ccValue.Exists() {
						cItem.IndexNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("value"); ccValue.Exists() {
						cItem.Value = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("priority"); ccValue.Exists() {
						cItem.Priority = types.StringValue(ccValue.String())
					}
					item.Indexes = append(item.Indexes, cItem)
					return true
				})
			}
			if cValue := v.Get("names.name"); cValue.Exists() {
				item.Names = make([]SRLGInterfacesNames, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := SRLGInterfacesNames{}
					if ccValue := cv.Get("srlg-name"); ccValue.Exists() {
						cItem.SrlgName = types.StringValue(ccValue.String())
					}
					item.Names = append(item.Names, cItem)
					return true
				})
			}
			if cValue := v.Get("groups.group"); cValue.Exists() {
				item.Groups = make([]SRLGInterfacesGroups, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := SRLGInterfacesGroups{}
					if ccValue := cv.Get("index-number"); ccValue.Exists() {
						cItem.IndexNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("group-name"); ccValue.Exists() {
						cItem.GroupName = types.StringValue(ccValue.String())
					}
					item.Groups = append(item.Groups, cItem)
					return true
				})
			}
			data.Interfaces = append(data.Interfaces, item)
			return true
		})
	}
	if value := gjson.GetBytes(res, "groups.group"); value.Exists() {
		data.Groups = make([]SRLGGroups, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := SRLGGroups{}
			if cValue := v.Get("group-name"); cValue.Exists() {
				item.GroupName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("indexes.index"); cValue.Exists() {
				item.Indexes = make([]SRLGGroupsIndexes, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := SRLGGroupsIndexes{}
					if ccValue := cv.Get("index-number"); ccValue.Exists() {
						cItem.IndexNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("value"); ccValue.Exists() {
						cItem.Value = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("priority"); ccValue.Exists() {
						cItem.Priority = types.StringValue(ccValue.String())
					}
					item.Indexes = append(item.Indexes, cItem)
					return true
				})
			}
			data.Groups = append(data.Groups, item)
			return true
		})
	}
	if value := gjson.GetBytes(res, "inherit-locations.inherit-location"); value.Exists() {
		data.InheritLocations = make([]SRLGInheritLocations, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := SRLGInheritLocations{}
			if cValue := v.Get("location-name"); cValue.Exists() {
				item.LocationName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("indexes.index"); cValue.Exists() {
				item.Indexes = make([]SRLGInheritLocationsIndexes, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := SRLGInheritLocationsIndexes{}
					if ccValue := cv.Get("index-number"); ccValue.Exists() {
						cItem.IndexNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("value"); ccValue.Exists() {
						cItem.Value = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("priority"); ccValue.Exists() {
						cItem.Priority = types.StringValue(ccValue.String())
					}
					item.Indexes = append(item.Indexes, cItem)
					return true
				})
			}
			data.InheritLocations = append(data.InheritLocations, item)
			return true
		})
	}
}

// End of section. //template:end fromBodyData

// Section below is generated&owned by "gen/generator.go". //template:begin getDeletedItems

func (data *SRLG) getDeletedItems(ctx context.Context, state SRLG) []string {
	deletedItems := make([]string, 0)
	for i := range state.InheritLocations {
		keys := [...]string{"location-name"}
		stateKeyValues := [...]string{state.InheritLocations[i].LocationName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.InheritLocations[i].LocationName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.InheritLocations {
			found = true
			if state.InheritLocations[i].LocationName.ValueString() != data.InheritLocations[j].LocationName.ValueString() {
				found = false
			}
			if found {
				for ci := range state.InheritLocations[i].Indexes {
					ckeys := [...]string{"index-number"}
					cstateKeyValues := [...]string{strconv.FormatInt(state.InheritLocations[i].Indexes[ci].IndexNumber.ValueInt64(), 10)}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.InheritLocations[i].Indexes[ci].IndexNumber.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.InheritLocations[j].Indexes {
						found = true
						if state.InheritLocations[i].Indexes[ci].IndexNumber.ValueInt64() != data.InheritLocations[j].Indexes[cj].IndexNumber.ValueInt64() {
							found = false
						}
						if found {
							if !state.InheritLocations[i].Indexes[ci].Priority.IsNull() && data.InheritLocations[j].Indexes[cj].Priority.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/inherit-locations/inherit-location%v/indexes/index%v/priority", state.getPath(), keyString, ckeyString))
							}
							if !state.InheritLocations[i].Indexes[ci].Value.IsNull() && data.InheritLocations[j].Indexes[cj].Value.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/inherit-locations/inherit-location%v/indexes/index%v/value", state.getPath(), keyString, ckeyString))
							}
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/inherit-locations/inherit-location%v/indexes/index%v", state.getPath(), keyString, ckeyString))
					}
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/inherit-locations/inherit-location%v", state.getPath(), keyString))
		}
	}
	for i := range state.Groups {
		keys := [...]string{"group-name"}
		stateKeyValues := [...]string{state.Groups[i].GroupName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.Groups[i].GroupName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Groups {
			found = true
			if state.Groups[i].GroupName.ValueString() != data.Groups[j].GroupName.ValueString() {
				found = false
			}
			if found {
				for ci := range state.Groups[i].Indexes {
					ckeys := [...]string{"index-number"}
					cstateKeyValues := [...]string{strconv.FormatInt(state.Groups[i].Indexes[ci].IndexNumber.ValueInt64(), 10)}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.Groups[i].Indexes[ci].IndexNumber.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.Groups[j].Indexes {
						found = true
						if state.Groups[i].Indexes[ci].IndexNumber.ValueInt64() != data.Groups[j].Indexes[cj].IndexNumber.ValueInt64() {
							found = false
						}
						if found {
							if !state.Groups[i].Indexes[ci].Priority.IsNull() && data.Groups[j].Indexes[cj].Priority.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/groups/group%v/indexes/index%v/priority", state.getPath(), keyString, ckeyString))
							}
							if !state.Groups[i].Indexes[ci].Value.IsNull() && data.Groups[j].Indexes[cj].Value.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/groups/group%v/indexes/index%v/value", state.getPath(), keyString, ckeyString))
							}
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/groups/group%v/indexes/index%v", state.getPath(), keyString, ckeyString))
					}
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/groups/group%v", state.getPath(), keyString))
		}
	}
	for i := range state.Interfaces {
		keys := [...]string{"interface-name"}
		stateKeyValues := [...]string{state.Interfaces[i].InterfaceName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.Interfaces[i].InterfaceName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Interfaces {
			found = true
			if state.Interfaces[i].InterfaceName.ValueString() != data.Interfaces[j].InterfaceName.ValueString() {
				found = false
			}
			if found {
				for ci := range state.Interfaces[i].Groups {
					ckeys := [...]string{"index-number"}
					cstateKeyValues := [...]string{strconv.FormatInt(state.Interfaces[i].Groups[ci].IndexNumber.ValueInt64(), 10)}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.Interfaces[i].Groups[ci].IndexNumber.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.Interfaces[j].Groups {
						found = true
						if state.Interfaces[i].Groups[ci].IndexNumber.ValueInt64() != data.Interfaces[j].Groups[cj].IndexNumber.ValueInt64() {
							found = false
						}
						if found {
							if !state.Interfaces[i].Groups[ci].GroupName.IsNull() && data.Interfaces[j].Groups[cj].GroupName.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/groups/group%v/group-name", state.getPath(), keyString, ckeyString))
							}
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/groups/group%v", state.getPath(), keyString, ckeyString))
					}
				}
				for ci := range state.Interfaces[i].Names {
					ckeys := [...]string{"srlg-name"}
					cstateKeyValues := [...]string{state.Interfaces[i].Names[ci].SrlgName.ValueString()}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.Interfaces[i].Names[ci].SrlgName.ValueString()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.Interfaces[j].Names {
						found = true
						if state.Interfaces[i].Names[ci].SrlgName.ValueString() != data.Interfaces[j].Names[cj].SrlgName.ValueString() {
							found = false
						}
						if found {
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/names/name%v", state.getPath(), keyString, ckeyString))
					}
				}
				for ci := range state.Interfaces[i].Indexes {
					ckeys := [...]string{"index-number"}
					cstateKeyValues := [...]string{strconv.FormatInt(state.Interfaces[i].Indexes[ci].IndexNumber.ValueInt64(), 10)}
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "[" + ckeys[cki] + "=" + cstateKeyValues[cki] + "]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.Interfaces[i].Indexes[ci].IndexNumber.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.Interfaces[j].Indexes {
						found = true
						if state.Interfaces[i].Indexes[ci].IndexNumber.ValueInt64() != data.Interfaces[j].Indexes[cj].IndexNumber.ValueInt64() {
							found = false
						}
						if found {
							if !state.Interfaces[i].Indexes[ci].Priority.IsNull() && data.Interfaces[j].Indexes[cj].Priority.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/indexes/index%v/priority", state.getPath(), keyString, ckeyString))
							}
							if !state.Interfaces[i].Indexes[ci].Value.IsNull() && data.Interfaces[j].Indexes[cj].Value.IsNull() {
								deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/indexes/index%v/value", state.getPath(), keyString, ckeyString))
							}
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/indexes/index%v", state.getPath(), keyString, ckeyString))
					}
				}
				if !state.Interfaces[i].IncludeOpticalPriority.IsNull() && data.Interfaces[j].IncludeOpticalPriority.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/include-optical/priority", state.getPath(), keyString))
				}
				if !state.Interfaces[i].IncludeOptical.IsNull() && data.Interfaces[j].IncludeOptical.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/include-optical", state.getPath(), keyString))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v", state.getPath(), keyString))
		}
	}
	for i := range state.Names {
		keys := [...]string{"srlg-name"}
		stateKeyValues := [...]string{state.Names[i].SrlgName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + stateKeyValues[ki] + "]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.Names[i].SrlgName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Names {
			found = true
			if state.Names[i].SrlgName.ValueString() != data.Names[j].SrlgName.ValueString() {
				found = false
			}
			if found {
				if !state.Names[i].Description.IsNull() && data.Names[j].Description.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/names/name%v/description", state.getPath(), keyString))
				}
				if !state.Names[i].Value.IsNull() && data.Names[j].Value.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/names/name%v/value", state.getPath(), keyString))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/names/name%v", state.getPath(), keyString))
		}
	}
	return deletedItems
}

// End of section. //template:end getDeletedItems

// Section below is generated&owned by "gen/generator.go". //template:begin getEmptyLeafsDelete

func (data *SRLG) getEmptyLeafsDelete(ctx context.Context) []string {
	emptyLeafsDelete := make([]string, 0)
	for i := range data.InheritLocations {
		keys := [...]string{"location-name"}
		keyValues := [...]string{data.InheritLocations[i].LocationName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		for ci := range data.InheritLocations[i].Indexes {
			ckeys := [...]string{"index-number"}
			ckeyValues := [...]string{strconv.FormatInt(data.InheritLocations[i].Indexes[ci].IndexNumber.ValueInt64(), 10)}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
		}
	}
	for i := range data.Groups {
		keys := [...]string{"group-name"}
		keyValues := [...]string{data.Groups[i].GroupName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		for ci := range data.Groups[i].Indexes {
			ckeys := [...]string{"index-number"}
			ckeyValues := [...]string{strconv.FormatInt(data.Groups[i].Indexes[ci].IndexNumber.ValueInt64(), 10)}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
		}
	}
	for i := range data.Interfaces {
		keys := [...]string{"interface-name"}
		keyValues := [...]string{data.Interfaces[i].InterfaceName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		for ci := range data.Interfaces[i].Groups {
			ckeys := [...]string{"index-number"}
			ckeyValues := [...]string{strconv.FormatInt(data.Interfaces[i].Groups[ci].IndexNumber.ValueInt64(), 10)}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
		}
		for ci := range data.Interfaces[i].Names {
			ckeys := [...]string{"srlg-name"}
			ckeyValues := [...]string{data.Interfaces[i].Names[ci].SrlgName.ValueString()}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
		}
		for ci := range data.Interfaces[i].Indexes {
			ckeys := [...]string{"index-number"}
			ckeyValues := [...]string{strconv.FormatInt(data.Interfaces[i].Indexes[ci].IndexNumber.ValueInt64(), 10)}
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "[" + ckeys[cki] + "=" + ckeyValues[cki] + "]"
			}
		}
		if !data.Interfaces[i].IncludeOptical.IsNull() && !data.Interfaces[i].IncludeOptical.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/interfaces/interface%v/include-optical", data.getPath(), keyString))
		}
	}
	for i := range data.Names {
		keys := [...]string{"srlg-name"}
		keyValues := [...]string{data.Names[i].SrlgName.ValueString()}
		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
	}
	return emptyLeafsDelete
}

// End of section. //template:end getEmptyLeafsDelete

// Section below is generated&owned by "gen/generator.go". //template:begin getDeletePaths

func (data *SRLG) getDeletePaths(ctx context.Context) []string {
	var deletePaths []string
	for i := range data.InheritLocations {
		keys := [...]string{"location-name"}
		keyValues := [...]string{data.InheritLocations[i].LocationName.ValueString()}

		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		deletePaths = append(deletePaths, fmt.Sprintf("%v/inherit-locations/inherit-location%v", data.getPath(), keyString))
	}
	for i := range data.Groups {
		keys := [...]string{"group-name"}
		keyValues := [...]string{data.Groups[i].GroupName.ValueString()}

		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		deletePaths = append(deletePaths, fmt.Sprintf("%v/groups/group%v", data.getPath(), keyString))
	}
	for i := range data.Interfaces {
		keys := [...]string{"interface-name"}
		keyValues := [...]string{data.Interfaces[i].InterfaceName.ValueString()}

		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		deletePaths = append(deletePaths, fmt.Sprintf("%v/interfaces/interface%v", data.getPath(), keyString))
	}
	for i := range data.Names {
		keys := [...]string{"srlg-name"}
		keyValues := [...]string{data.Names[i].SrlgName.ValueString()}

		keyString := ""
		for ki := range keys {
			keyString += "[" + keys[ki] + "=" + keyValues[ki] + "]"
		}
		deletePaths = append(deletePaths, fmt.Sprintf("%v/names/name%v", data.getPath(), keyString))
	}
	return deletePaths
}

// End of section. //template:end getDeletePaths
