// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports
import (
	"context"
	"fmt"
	"reflect"
	"sort"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/CiscoDevNet/terraform-provider-iosxr/internal/provider/helpers"
	"github.com/tidwall/sjson"
	"github.com/tidwall/gjson"
	"github.com/netascode/xmldot"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/netascode/go-netconf"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin types
type SRLG struct {
	Device types.String `tfsdk:"device"`
	Id     types.String `tfsdk:"id"`
	DeleteMode types.String `tfsdk:"delete_mode"`
	Names []SRLGNames `tfsdk:"names"`
	Interfaces []SRLGInterfaces `tfsdk:"interfaces"`
	Groups []SRLGGroups `tfsdk:"groups"`
	InheritLocations []SRLGInheritLocations `tfsdk:"inherit_locations"`
}

type SRLGData struct {
	Device types.String `tfsdk:"device"`
	Id     types.String `tfsdk:"id"`
	Names []SRLGNames `tfsdk:"names"`
	Interfaces []SRLGInterfaces `tfsdk:"interfaces"`
	Groups []SRLGGroups `tfsdk:"groups"`
	InheritLocations []SRLGInheritLocations `tfsdk:"inherit_locations"`
}
type SRLGNames struct {
	SrlgName types.String `tfsdk:"srlg_name"`
	Value types.Int64 `tfsdk:"value"`
	Description types.String `tfsdk:"description"`
}
type SRLGInterfaces struct {
	InterfaceName types.String `tfsdk:"interface_name"`
	IncludeOptical types.Bool `tfsdk:"include_optical"`
	IncludeOpticalPriority types.String `tfsdk:"include_optical_priority"`
	Indexes []SRLGInterfacesIndexes `tfsdk:"indexes"`
	Names []SRLGInterfacesNames `tfsdk:"names"`
	Groups []SRLGInterfacesGroups `tfsdk:"groups"`
}
type SRLGGroups struct {
	GroupName types.String `tfsdk:"group_name"`
	Indexes []SRLGGroupsIndexes `tfsdk:"indexes"`
}
type SRLGInheritLocations struct {
	LocationName types.String `tfsdk:"location_name"`
	Indexes []SRLGInheritLocationsIndexes `tfsdk:"indexes"`
}
type SRLGInterfacesIndexes struct {
	IndexNumber types.Int64 `tfsdk:"index_number"`
	Value types.Int64 `tfsdk:"value"`
	Priority types.String `tfsdk:"priority"`
}
type SRLGInterfacesNames struct {
	SrlgName types.String `tfsdk:"srlg_name"`
}
type SRLGInterfacesGroups struct {
	IndexNumber types.Int64 `tfsdk:"index_number"`
	GroupName types.String `tfsdk:"group_name"`
}
type SRLGGroupsIndexes struct {
	IndexNumber types.Int64 `tfsdk:"index_number"`
	Value types.Int64 `tfsdk:"value"`
	Priority types.String `tfsdk:"priority"`
}
type SRLGInheritLocationsIndexes struct {
	IndexNumber types.Int64 `tfsdk:"index_number"`
	Value types.Int64 `tfsdk:"value"`
	Priority types.String `tfsdk:"priority"`
}

// End of section. //template:end types

// Section below is generated&owned by "gen/generator.go". //template:begin getPath

func (data SRLG) getPath() string {
	return "Cisco-IOS-XR-um-vrf-cfg:/srlg"
}

func (data SRLGData) getPath() string {
	return "Cisco-IOS-XR-um-vrf-cfg:/srlg"
}

// getXPath returns the XPath for NETCONF operations
func (data SRLG) getXPath() string {
	path := "Cisco-IOS-XR-um-vrf-cfg:/srlg"
	return path
}

func (data SRLGData) getXPath() string {
	path := "Cisco-IOS-XR-um-vrf-cfg:/srlg"
	return path
}

// End of section. //template:end getPath

// Section below is generated&owned by "gen/generator.go". //template:begin toBody

func (data SRLG) toBody(ctx context.Context) string {
	body := "{}"
	if len(data.Names) > 0 {
		body, _ = sjson.Set(body, "names.name", []interface{}{})
		for index, item := range data.Names {
			if !item.SrlgName.IsNull() && !item.SrlgName.IsUnknown() {
				body, _ = sjson.Set(body, "names.name"+"."+strconv.Itoa(index)+"."+"srlg-name", item.SrlgName.ValueString())
			}
			if !item.Value.IsNull() && !item.Value.IsUnknown() {
				body, _ = sjson.Set(body, "names.name"+"."+strconv.Itoa(index)+"."+"value", strconv.FormatInt(item.Value.ValueInt64(), 10))
			}
			if !item.Description.IsNull() && !item.Description.IsUnknown() {
				body, _ = sjson.Set(body, "names.name"+"."+strconv.Itoa(index)+"."+"description", item.Description.ValueString())
			}
		}
	}
	if len(data.Interfaces) > 0 {
		body, _ = sjson.Set(body, "interfaces.interface", []interface{}{})
		for index, item := range data.Interfaces {
			if !item.InterfaceName.IsNull() && !item.InterfaceName.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"interface-name", item.InterfaceName.ValueString())
			}
			if !item.IncludeOptical.IsNull() && !item.IncludeOptical.IsUnknown() {
				if item.IncludeOptical.ValueBool() {
					body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"include-optical", map[string]string{})
				}
			}
			if !item.IncludeOpticalPriority.IsNull() && !item.IncludeOpticalPriority.IsUnknown() {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"include-optical.priority", item.IncludeOpticalPriority.ValueString())
			}
			if len(item.Indexes) > 0 {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"indexes.index", []interface{}{})
				for cindex, citem := range item.Indexes {
					if !citem.IndexNumber.IsNull() && !citem.IndexNumber.IsUnknown() {
						body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"indexes.index"+"."+strconv.Itoa(cindex)+"."+"index-number", strconv.FormatInt(citem.IndexNumber.ValueInt64(), 10))
					}
					if !citem.Value.IsNull() && !citem.Value.IsUnknown() {
						body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"indexes.index"+"."+strconv.Itoa(cindex)+"."+"value", strconv.FormatInt(citem.Value.ValueInt64(), 10))
					}
					if !citem.Priority.IsNull() && !citem.Priority.IsUnknown() {
						body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"indexes.index"+"."+strconv.Itoa(cindex)+"."+"priority", citem.Priority.ValueString())
					}
				}
			}
			if len(item.Names) > 0 {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"names.name", []interface{}{})
				for cindex, citem := range item.Names {
					if !citem.SrlgName.IsNull() && !citem.SrlgName.IsUnknown() {
						body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"names.name"+"."+strconv.Itoa(cindex)+"."+"srlg-name", citem.SrlgName.ValueString())
					}
				}
			}
			if len(item.Groups) > 0 {
				body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"groups.group", []interface{}{})
				for cindex, citem := range item.Groups {
					if !citem.IndexNumber.IsNull() && !citem.IndexNumber.IsUnknown() {
						body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"groups.group"+"."+strconv.Itoa(cindex)+"."+"index-number", strconv.FormatInt(citem.IndexNumber.ValueInt64(), 10))
					}
					if !citem.GroupName.IsNull() && !citem.GroupName.IsUnknown() {
						body, _ = sjson.Set(body, "interfaces.interface"+"."+strconv.Itoa(index)+"."+"groups.group"+"."+strconv.Itoa(cindex)+"."+"group-name", citem.GroupName.ValueString())
					}
				}
			}
		}
	}
	if len(data.Groups) > 0 {
		body, _ = sjson.Set(body, "groups.group", []interface{}{})
		for index, item := range data.Groups {
			if !item.GroupName.IsNull() && !item.GroupName.IsUnknown() {
				body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"group-name", item.GroupName.ValueString())
			}
			if len(item.Indexes) > 0 {
				body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"indexes.index", []interface{}{})
				for cindex, citem := range item.Indexes {
					if !citem.IndexNumber.IsNull() && !citem.IndexNumber.IsUnknown() {
						body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"indexes.index"+"."+strconv.Itoa(cindex)+"."+"index-number", strconv.FormatInt(citem.IndexNumber.ValueInt64(), 10))
					}
					if !citem.Value.IsNull() && !citem.Value.IsUnknown() {
						body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"indexes.index"+"."+strconv.Itoa(cindex)+"."+"value", strconv.FormatInt(citem.Value.ValueInt64(), 10))
					}
					if !citem.Priority.IsNull() && !citem.Priority.IsUnknown() {
						body, _ = sjson.Set(body, "groups.group"+"."+strconv.Itoa(index)+"."+"indexes.index"+"."+strconv.Itoa(cindex)+"."+"priority", citem.Priority.ValueString())
					}
				}
			}
		}
	}
	if len(data.InheritLocations) > 0 {
		body, _ = sjson.Set(body, "inherit-locations.inherit-location", []interface{}{})
		for index, item := range data.InheritLocations {
			if !item.LocationName.IsNull() && !item.LocationName.IsUnknown() {
				body, _ = sjson.Set(body, "inherit-locations.inherit-location"+"."+strconv.Itoa(index)+"."+"location-name", item.LocationName.ValueString())
			}
			if len(item.Indexes) > 0 {
				body, _ = sjson.Set(body, "inherit-locations.inherit-location"+"."+strconv.Itoa(index)+"."+"indexes.index", []interface{}{})
				for cindex, citem := range item.Indexes {
					if !citem.IndexNumber.IsNull() && !citem.IndexNumber.IsUnknown() {
						body, _ = sjson.Set(body, "inherit-locations.inherit-location"+"."+strconv.Itoa(index)+"."+"indexes.index"+"."+strconv.Itoa(cindex)+"."+"index-number", strconv.FormatInt(citem.IndexNumber.ValueInt64(), 10))
					}
					if !citem.Value.IsNull() && !citem.Value.IsUnknown() {
						body, _ = sjson.Set(body, "inherit-locations.inherit-location"+"."+strconv.Itoa(index)+"."+"indexes.index"+"."+strconv.Itoa(cindex)+"."+"value", strconv.FormatInt(citem.Value.ValueInt64(), 10))
					}
					if !citem.Priority.IsNull() && !citem.Priority.IsUnknown() {
						body, _ = sjson.Set(body, "inherit-locations.inherit-location"+"."+strconv.Itoa(index)+"."+"indexes.index"+"."+strconv.Itoa(cindex)+"."+"priority", citem.Priority.ValueString())
					}
				}
			}
		}
	}
	return body
}

// End of section. //template:end toBody

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBody

func (data *SRLG) updateFromBody(ctx context.Context, res []byte) {
	for i := range data.Names {
		keys := [...]string{ "srlg-name",  }
		keyValues := [...]string{ data.Names[i].SrlgName.ValueString(),  }

		var r gjson.Result
		gjson.GetBytes(res, "names.name").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("srlg-name"); value.Exists() && !data.Names[i].SrlgName.IsNull() {
			data.Names[i].SrlgName = types.StringValue(value.String())
		} else {
			data.Names[i].SrlgName = types.StringNull()
		}
		if value := r.Get("value"); value.Exists() && !data.Names[i].Value.IsNull() {
			data.Names[i].Value = types.Int64Value(value.Int())
		} else {
			data.Names[i].Value = types.Int64Null()
		}
		if value := r.Get("description"); value.Exists() && !data.Names[i].Description.IsNull() {
			data.Names[i].Description = types.StringValue(value.String())
		} else {
			data.Names[i].Description = types.StringNull()
		}
	}
	for i := range data.Interfaces {
		keys := [...]string{ "interface-name",  }
		keyValues := [...]string{ data.Interfaces[i].InterfaceName.ValueString(),  }

		var r gjson.Result
		gjson.GetBytes(res, "interfaces.interface").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("interface-name"); value.Exists() && !data.Interfaces[i].InterfaceName.IsNull() {
			data.Interfaces[i].InterfaceName = types.StringValue(value.String())
		} else {
			data.Interfaces[i].InterfaceName = types.StringNull()
		}
		if value := r.Get("include-optical"); !data.Interfaces[i].IncludeOptical.IsNull() {
			if value.Exists() {
				data.Interfaces[i].IncludeOptical = types.BoolValue(true)
			} else {
				data.Interfaces[i].IncludeOptical = types.BoolValue(false)
			}
		} else {
			data.Interfaces[i].IncludeOptical = types.BoolNull()
		}
		if value := r.Get("include-optical.priority"); value.Exists() && !data.Interfaces[i].IncludeOpticalPriority.IsNull() {
			data.Interfaces[i].IncludeOpticalPriority = types.StringValue(value.String())
		} else {
			data.Interfaces[i].IncludeOpticalPriority = types.StringNull()
		}
		for ci := range data.Interfaces[i].Indexes {
			keys := [...]string{ "index-number",  }
			keyValues := [...]string{ strconv.FormatInt(data.Interfaces[i].Indexes[ci].IndexNumber.ValueInt64(), 10),  }

			var cr gjson.Result
			r.Get("indexes.index").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("index-number"); value.Exists() && !data.Interfaces[i].Indexes[ci].IndexNumber.IsNull() {
				data.Interfaces[i].Indexes[ci].IndexNumber = types.Int64Value(value.Int())
			} else {
				data.Interfaces[i].Indexes[ci].IndexNumber = types.Int64Null()
			}
			if value := cr.Get("value"); value.Exists() && !data.Interfaces[i].Indexes[ci].Value.IsNull() {
				data.Interfaces[i].Indexes[ci].Value = types.Int64Value(value.Int())
			} else {
				data.Interfaces[i].Indexes[ci].Value = types.Int64Null()
			}
			if value := cr.Get("priority"); value.Exists() && !data.Interfaces[i].Indexes[ci].Priority.IsNull() {
				data.Interfaces[i].Indexes[ci].Priority = types.StringValue(value.String())
			} else {
				data.Interfaces[i].Indexes[ci].Priority = types.StringNull()
			}
		}
		for ci := range data.Interfaces[i].Names {
			keys := [...]string{ "srlg-name",  }
			keyValues := [...]string{ data.Interfaces[i].Names[ci].SrlgName.ValueString(),  }

			var cr gjson.Result
			r.Get("names.name").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("srlg-name"); value.Exists() && !data.Interfaces[i].Names[ci].SrlgName.IsNull() {
				data.Interfaces[i].Names[ci].SrlgName = types.StringValue(value.String())
			} else {
				data.Interfaces[i].Names[ci].SrlgName = types.StringNull()
			}
		}
		for ci := range data.Interfaces[i].Groups {
			keys := [...]string{ "index-number",  }
			keyValues := [...]string{ strconv.FormatInt(data.Interfaces[i].Groups[ci].IndexNumber.ValueInt64(), 10),  }

			var cr gjson.Result
			r.Get("groups.group").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("index-number"); value.Exists() && !data.Interfaces[i].Groups[ci].IndexNumber.IsNull() {
				data.Interfaces[i].Groups[ci].IndexNumber = types.Int64Value(value.Int())
			} else {
				data.Interfaces[i].Groups[ci].IndexNumber = types.Int64Null()
			}
			if value := cr.Get("group-name"); value.Exists() && !data.Interfaces[i].Groups[ci].GroupName.IsNull() {
				data.Interfaces[i].Groups[ci].GroupName = types.StringValue(value.String())
			} else {
				data.Interfaces[i].Groups[ci].GroupName = types.StringNull()
			}
		}
	}
	for i := range data.Groups {
		keys := [...]string{ "group-name",  }
		keyValues := [...]string{ data.Groups[i].GroupName.ValueString(),  }

		var r gjson.Result
		gjson.GetBytes(res, "groups.group").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("group-name"); value.Exists() && !data.Groups[i].GroupName.IsNull() {
			data.Groups[i].GroupName = types.StringValue(value.String())
		} else {
			data.Groups[i].GroupName = types.StringNull()
		}
		for ci := range data.Groups[i].Indexes {
			keys := [...]string{ "index-number",  }
			keyValues := [...]string{ strconv.FormatInt(data.Groups[i].Indexes[ci].IndexNumber.ValueInt64(), 10),  }

			var cr gjson.Result
			r.Get("indexes.index").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("index-number"); value.Exists() && !data.Groups[i].Indexes[ci].IndexNumber.IsNull() {
				data.Groups[i].Indexes[ci].IndexNumber = types.Int64Value(value.Int())
			} else {
				data.Groups[i].Indexes[ci].IndexNumber = types.Int64Null()
			}
			if value := cr.Get("value"); value.Exists() && !data.Groups[i].Indexes[ci].Value.IsNull() {
				data.Groups[i].Indexes[ci].Value = types.Int64Value(value.Int())
			} else {
				data.Groups[i].Indexes[ci].Value = types.Int64Null()
			}
			if value := cr.Get("priority"); value.Exists() && !data.Groups[i].Indexes[ci].Priority.IsNull() {
				data.Groups[i].Indexes[ci].Priority = types.StringValue(value.String())
			} else {
				data.Groups[i].Indexes[ci].Priority = types.StringNull()
			}
		}
	}
	for i := range data.InheritLocations {
		keys := [...]string{ "location-name",  }
		keyValues := [...]string{ data.InheritLocations[i].LocationName.ValueString(),  }

		var r gjson.Result
		gjson.GetBytes(res, "inherit-locations.inherit-location").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("location-name"); value.Exists() && !data.InheritLocations[i].LocationName.IsNull() {
			data.InheritLocations[i].LocationName = types.StringValue(value.String())
		} else {
			data.InheritLocations[i].LocationName = types.StringNull()
		}
		for ci := range data.InheritLocations[i].Indexes {
			keys := [...]string{ "index-number",  }
			keyValues := [...]string{ strconv.FormatInt(data.InheritLocations[i].Indexes[ci].IndexNumber.ValueInt64(), 10),  }

			var cr gjson.Result
			r.Get("indexes.index").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("index-number"); value.Exists() && !data.InheritLocations[i].Indexes[ci].IndexNumber.IsNull() {
				data.InheritLocations[i].Indexes[ci].IndexNumber = types.Int64Value(value.Int())
			} else {
				data.InheritLocations[i].Indexes[ci].IndexNumber = types.Int64Null()
			}
			if value := cr.Get("value"); value.Exists() && !data.InheritLocations[i].Indexes[ci].Value.IsNull() {
				data.InheritLocations[i].Indexes[ci].Value = types.Int64Value(value.Int())
			} else {
				data.InheritLocations[i].Indexes[ci].Value = types.Int64Null()
			}
			if value := cr.Get("priority"); value.Exists() && !data.InheritLocations[i].Indexes[ci].Priority.IsNull() {
				data.InheritLocations[i].Indexes[ci].Priority = types.StringValue(value.String())
			} else {
				data.InheritLocations[i].Indexes[ci].Priority = types.StringNull()
			}
		}
	}
}

// End of section. //template:end updateFromBody
// Section below is generated&owned by "gen/generator.go". //template:begin toBodyXML

func (data SRLG) toBodyXML(ctx context.Context) string {
	body := netconf.Body{}
	if len(data.Names) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.Names {
			cBody := netconf.Body{}
			if !item.SrlgName.IsNull() && !item.SrlgName.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "srlg-name", item.SrlgName.ValueString())
			}
			if !item.Value.IsNull() && !item.Value.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "value", strconv.FormatInt(item.Value.ValueInt64(), 10))
			}
			if !item.Description.IsNull() && !item.Description.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "description", item.Description.ValueString())
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"names/name", cBody.Res())
		}
	}
	if len(data.Interfaces) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.Interfaces {
			cBody := netconf.Body{}
			if !item.InterfaceName.IsNull() && !item.InterfaceName.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "interface-name", item.InterfaceName.ValueString())
			}
			if !item.IncludeOptical.IsNull() && !item.IncludeOptical.IsUnknown() {
				if item.IncludeOptical.ValueBool() {
					cBody = helpers.SetFromXPath(cBody, "include-optical", "")
				}
			}
			if !item.IncludeOpticalPriority.IsNull() && !item.IncludeOpticalPriority.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "include-optical/priority", item.IncludeOpticalPriority.ValueString())
			}
			if len(item.Indexes) > 0 {
				for _, citem := range item.Indexes {
					ccBody := netconf.Body{}
					if !citem.IndexNumber.IsNull() && !citem.IndexNumber.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "index-number", strconv.FormatInt(citem.IndexNumber.ValueInt64(), 10))
					}
					if !citem.Value.IsNull() && !citem.Value.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "value", strconv.FormatInt(citem.Value.ValueInt64(), 10))
					}
					if !citem.Priority.IsNull() && !citem.Priority.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "priority", citem.Priority.ValueString())
					}
					cBody = helpers.SetRawFromXPath(cBody, "indexes/index", ccBody.Res())
				}
			}
			if len(item.Names) > 0 {
				for _, citem := range item.Names {
					ccBody := netconf.Body{}
					if !citem.SrlgName.IsNull() && !citem.SrlgName.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "srlg-name", citem.SrlgName.ValueString())
					}
					cBody = helpers.SetRawFromXPath(cBody, "names/name", ccBody.Res())
				}
			}
			if len(item.Groups) > 0 {
				for _, citem := range item.Groups {
					ccBody := netconf.Body{}
					if !citem.IndexNumber.IsNull() && !citem.IndexNumber.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "index-number", strconv.FormatInt(citem.IndexNumber.ValueInt64(), 10))
					}
					if !citem.GroupName.IsNull() && !citem.GroupName.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "group-name", citem.GroupName.ValueString())
					}
					cBody = helpers.SetRawFromXPath(cBody, "groups/group", ccBody.Res())
				}
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"interfaces/interface", cBody.Res())
		}
	}
	if len(data.Groups) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.Groups {
			cBody := netconf.Body{}
			if !item.GroupName.IsNull() && !item.GroupName.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "group-name", item.GroupName.ValueString())
			}
			if len(item.Indexes) > 0 {
				for _, citem := range item.Indexes {
					ccBody := netconf.Body{}
					if !citem.IndexNumber.IsNull() && !citem.IndexNumber.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "index-number", strconv.FormatInt(citem.IndexNumber.ValueInt64(), 10))
					}
					if !citem.Value.IsNull() && !citem.Value.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "value", strconv.FormatInt(citem.Value.ValueInt64(), 10))
					}
					if !citem.Priority.IsNull() && !citem.Priority.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "priority", citem.Priority.ValueString())
					}
					cBody = helpers.SetRawFromXPath(cBody, "indexes/index", ccBody.Res())
				}
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"groups/group", cBody.Res())
		}
	}
	if len(data.InheritLocations) > 0 {
		// Build all list items and append them using AppendFromXPath
		for _, item := range data.InheritLocations {
			cBody := netconf.Body{}
			if !item.LocationName.IsNull() && !item.LocationName.IsUnknown() {
				cBody = helpers.SetFromXPath(cBody, "location-name", item.LocationName.ValueString())
			}
			if len(item.Indexes) > 0 {
				for _, citem := range item.Indexes {
					ccBody := netconf.Body{}
					if !citem.IndexNumber.IsNull() && !citem.IndexNumber.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "index-number", strconv.FormatInt(citem.IndexNumber.ValueInt64(), 10))
					}
					if !citem.Value.IsNull() && !citem.Value.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "value", strconv.FormatInt(citem.Value.ValueInt64(), 10))
					}
					if !citem.Priority.IsNull() && !citem.Priority.IsUnknown() {
						ccBody = helpers.SetFromXPath(ccBody, "priority", citem.Priority.ValueString())
					}
					cBody = helpers.SetRawFromXPath(cBody, "indexes/index", ccBody.Res())
				}
			}
			// Append each list item to the parent path using AppendFromXPath with raw XML
			body = helpers.AppendRawFromXPath(body, data.getXPath()+"/"+"inherit-locations/inherit-location", cBody.Res())
		}
	}
	bodyString, err := body.String()
	if err != nil {
		tflog.Error(ctx, fmt.Sprintf("Error converting body to string: %s", err))
	}
	return bodyString
}

// End of section. //template:end toBodyXML
// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBodyXML

func (data *SRLG) updateFromBodyXML(ctx context.Context, res xmldot.Result) {
	for i := range data.Names {
		keys := [...]string{ "srlg-name",  }
		keyValues := [...]string{ data.Names[i].SrlgName.ValueString(),  }

		var r xmldot.Result
		helpers.GetFromXPath(res, "data" + data.getXPath() + "/names/name").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "srlg-name"); value.Exists() {
			data.Names[i].SrlgName = types.StringValue(value.String())
		} else if data.Names[i].SrlgName.IsNull() {
			data.Names[i].SrlgName = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "value"); value.Exists() {
			data.Names[i].Value = types.Int64Value(value.Int())
		} else if data.Names[i].Value.IsNull() {
			data.Names[i].Value = types.Int64Null()
		}
		if value := helpers.GetFromXPath(r, "description"); value.Exists() {
			data.Names[i].Description = types.StringValue(value.String())
		} else if data.Names[i].Description.IsNull() {
			data.Names[i].Description = types.StringNull()
		}
	}
	for i := range data.Interfaces {
		keys := [...]string{ "interface-name",  }
		keyValues := [...]string{ data.Interfaces[i].InterfaceName.ValueString(),  }

		var r xmldot.Result
		helpers.GetFromXPath(res, "data" + data.getXPath() + "/interfaces/interface").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "interface-name"); value.Exists() {
			data.Interfaces[i].InterfaceName = types.StringValue(value.String())
		} else if data.Interfaces[i].InterfaceName.IsNull() {
			data.Interfaces[i].InterfaceName = types.StringNull()
		}
		if value := helpers.GetFromXPath(r, "include-optical"); value.Exists() {
			data.Interfaces[i].IncludeOptical = types.BoolValue(true)
		} else {
			// If config has false and device doesn't have the field, keep false (don't set to null)
			// Only set to null if it was already null
			if data.Interfaces[i].IncludeOptical.IsNull() {
				data.Interfaces[i].IncludeOptical = types.BoolNull()
			}
		}
		if value := helpers.GetFromXPath(r, "include-optical/priority"); value.Exists() {
			data.Interfaces[i].IncludeOpticalPriority = types.StringValue(value.String())
		} else if data.Interfaces[i].IncludeOpticalPriority.IsNull() {
			data.Interfaces[i].IncludeOpticalPriority = types.StringNull()
		}
		for ci := range data.Interfaces[i].Indexes {
			keys := [...]string{ "index-number",  }
			keyValues := [...]string{ strconv.FormatInt(data.Interfaces[i].Indexes[ci].IndexNumber.ValueInt64(), 10),  }

			var cr xmldot.Result
			helpers.GetFromXPath(r, "indexes/index").ForEach(
				func(_ int, v xmldot.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := helpers.GetFromXPath(cr, "index-number"); value.Exists() {
				data.Interfaces[i].Indexes[ci].IndexNumber = types.Int64Value(value.Int())
			} else {
				data.Interfaces[i].Indexes[ci].IndexNumber = types.Int64Null()
			}
			if value := helpers.GetFromXPath(cr, "value"); value.Exists() {
				data.Interfaces[i].Indexes[ci].Value = types.Int64Value(value.Int())
			} else {
				data.Interfaces[i].Indexes[ci].Value = types.Int64Null()
			}
			if value := helpers.GetFromXPath(cr, "priority"); value.Exists() {
				data.Interfaces[i].Indexes[ci].Priority = types.StringValue(value.String())
			} else {
				data.Interfaces[i].Indexes[ci].Priority = types.StringNull()
			}
		}
		for ci := range data.Interfaces[i].Names {
			keys := [...]string{ "srlg-name",  }
			keyValues := [...]string{ data.Interfaces[i].Names[ci].SrlgName.ValueString(),  }

			var cr xmldot.Result
			helpers.GetFromXPath(r, "names/name").ForEach(
				func(_ int, v xmldot.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := helpers.GetFromXPath(cr, "srlg-name"); value.Exists() {
				data.Interfaces[i].Names[ci].SrlgName = types.StringValue(value.String())
			} else {
				data.Interfaces[i].Names[ci].SrlgName = types.StringNull()
			}
		}
		for ci := range data.Interfaces[i].Groups {
			keys := [...]string{ "index-number",  }
			keyValues := [...]string{ strconv.FormatInt(data.Interfaces[i].Groups[ci].IndexNumber.ValueInt64(), 10),  }

			var cr xmldot.Result
			helpers.GetFromXPath(r, "groups/group").ForEach(
				func(_ int, v xmldot.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := helpers.GetFromXPath(cr, "index-number"); value.Exists() {
				data.Interfaces[i].Groups[ci].IndexNumber = types.Int64Value(value.Int())
			} else {
				data.Interfaces[i].Groups[ci].IndexNumber = types.Int64Null()
			}
			if value := helpers.GetFromXPath(cr, "group-name"); value.Exists() {
				data.Interfaces[i].Groups[ci].GroupName = types.StringValue(value.String())
			} else {
				data.Interfaces[i].Groups[ci].GroupName = types.StringNull()
			}
		}
	}
	for i := range data.Groups {
		keys := [...]string{ "group-name",  }
		keyValues := [...]string{ data.Groups[i].GroupName.ValueString(),  }

		var r xmldot.Result
		helpers.GetFromXPath(res, "data" + data.getXPath() + "/groups/group").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "group-name"); value.Exists() {
			data.Groups[i].GroupName = types.StringValue(value.String())
		} else if data.Groups[i].GroupName.IsNull() {
			data.Groups[i].GroupName = types.StringNull()
		}
		for ci := range data.Groups[i].Indexes {
			keys := [...]string{ "index-number",  }
			keyValues := [...]string{ strconv.FormatInt(data.Groups[i].Indexes[ci].IndexNumber.ValueInt64(), 10),  }

			var cr xmldot.Result
			helpers.GetFromXPath(r, "indexes/index").ForEach(
				func(_ int, v xmldot.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := helpers.GetFromXPath(cr, "index-number"); value.Exists() {
				data.Groups[i].Indexes[ci].IndexNumber = types.Int64Value(value.Int())
			} else {
				data.Groups[i].Indexes[ci].IndexNumber = types.Int64Null()
			}
			if value := helpers.GetFromXPath(cr, "value"); value.Exists() {
				data.Groups[i].Indexes[ci].Value = types.Int64Value(value.Int())
			} else {
				data.Groups[i].Indexes[ci].Value = types.Int64Null()
			}
			if value := helpers.GetFromXPath(cr, "priority"); value.Exists() {
				data.Groups[i].Indexes[ci].Priority = types.StringValue(value.String())
			} else {
				data.Groups[i].Indexes[ci].Priority = types.StringNull()
			}
		}
	}
	for i := range data.InheritLocations {
		keys := [...]string{ "location-name",  }
		keyValues := [...]string{ data.InheritLocations[i].LocationName.ValueString(),  }

		var r xmldot.Result
		helpers.GetFromXPath(res, "data" + data.getXPath() + "/inherit-locations/inherit-location").ForEach(
			func(_ int, v xmldot.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := helpers.GetFromXPath(r, "location-name"); value.Exists() {
			data.InheritLocations[i].LocationName = types.StringValue(value.String())
		} else if data.InheritLocations[i].LocationName.IsNull() {
			data.InheritLocations[i].LocationName = types.StringNull()
		}
		for ci := range data.InheritLocations[i].Indexes {
			keys := [...]string{ "index-number",  }
			keyValues := [...]string{ strconv.FormatInt(data.InheritLocations[i].Indexes[ci].IndexNumber.ValueInt64(), 10),  }

			var cr xmldot.Result
			helpers.GetFromXPath(r, "indexes/index").ForEach(
				func(_ int, v xmldot.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := helpers.GetFromXPath(cr, "index-number"); value.Exists() {
				data.InheritLocations[i].Indexes[ci].IndexNumber = types.Int64Value(value.Int())
			} else {
				data.InheritLocations[i].Indexes[ci].IndexNumber = types.Int64Null()
			}
			if value := helpers.GetFromXPath(cr, "value"); value.Exists() {
				data.InheritLocations[i].Indexes[ci].Value = types.Int64Value(value.Int())
			} else {
				data.InheritLocations[i].Indexes[ci].Value = types.Int64Null()
			}
			if value := helpers.GetFromXPath(cr, "priority"); value.Exists() {
				data.InheritLocations[i].Indexes[ci].Priority = types.StringValue(value.String())
			} else {
				data.InheritLocations[i].Indexes[ci].Priority = types.StringNull()
			}
		}
	}
}

// End of section. //template:end updateFromBodyXML
// Section below is generated&owned by "gen/generator.go". //template:begin fromBody

func (data *SRLG) fromBody(ctx context.Context, res gjson.Result) {
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	if value := res.Get(prefix+"names.name"); value.Exists() {
		data.Names = make([]SRLGNames, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := SRLGNames{}
			if cValue := v.Get("srlg-name"); cValue.Exists() {
				item.SrlgName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("value"); cValue.Exists() {
				item.Value = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("description"); cValue.Exists() {
				item.Description = types.StringValue(cValue.String())
			}
			data.Names = append(data.Names, item)
			return true
		})
	}
	if value := res.Get(prefix+"interfaces.interface"); value.Exists() {
		data.Interfaces = make([]SRLGInterfaces, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := SRLGInterfaces{}
			if cValue := v.Get("interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("include-optical"); cValue.Exists() {
				item.IncludeOptical = types.BoolValue(true)
			} else {
				item.IncludeOptical = types.BoolValue(false)
			}
			if cValue := v.Get("include-optical.priority"); cValue.Exists() {
				item.IncludeOpticalPriority = types.StringValue(cValue.String())
			}
			if cValue := v.Get("indexes.index"); cValue.Exists() {
				item.Indexes = make([]SRLGInterfacesIndexes, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := SRLGInterfacesIndexes{}
				if ccValue := cv.Get("index-number"); ccValue.Exists() {
					cItem.IndexNumber = types.Int64Value(ccValue.Int())
				}
				if ccValue := cv.Get("value"); ccValue.Exists() {
					cItem.Value = types.Int64Value(ccValue.Int())
				}
					if ccValue := cv.Get("priority"); ccValue.Exists() {
						cItem.Priority = types.StringValue(ccValue.String())
					}
				item.Indexes = append(item.Indexes, cItem)
				return true
			})
		}
			if cValue := v.Get("names.name"); cValue.Exists() {
				item.Names = make([]SRLGInterfacesNames, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := SRLGInterfacesNames{}
					if ccValue := cv.Get("srlg-name"); ccValue.Exists() {
						cItem.SrlgName = types.StringValue(ccValue.String())
					}
				item.Names = append(item.Names, cItem)
				return true
			})
		}
			if cValue := v.Get("groups.group"); cValue.Exists() {
				item.Groups = make([]SRLGInterfacesGroups, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := SRLGInterfacesGroups{}
				if ccValue := cv.Get("index-number"); ccValue.Exists() {
					cItem.IndexNumber = types.Int64Value(ccValue.Int())
				}
					if ccValue := cv.Get("group-name"); ccValue.Exists() {
						cItem.GroupName = types.StringValue(ccValue.String())
					}
				item.Groups = append(item.Groups, cItem)
				return true
			})
		}
			data.Interfaces = append(data.Interfaces, item)
			return true
		})
	}
	if value := res.Get(prefix+"groups.group"); value.Exists() {
		data.Groups = make([]SRLGGroups, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := SRLGGroups{}
			if cValue := v.Get("group-name"); cValue.Exists() {
				item.GroupName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("indexes.index"); cValue.Exists() {
				item.Indexes = make([]SRLGGroupsIndexes, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := SRLGGroupsIndexes{}
				if ccValue := cv.Get("index-number"); ccValue.Exists() {
					cItem.IndexNumber = types.Int64Value(ccValue.Int())
				}
				if ccValue := cv.Get("value"); ccValue.Exists() {
					cItem.Value = types.Int64Value(ccValue.Int())
				}
					if ccValue := cv.Get("priority"); ccValue.Exists() {
						cItem.Priority = types.StringValue(ccValue.String())
					}
				item.Indexes = append(item.Indexes, cItem)
				return true
			})
		}
			data.Groups = append(data.Groups, item)
			return true
		})
	}
	if value := res.Get(prefix+"inherit-locations.inherit-location"); value.Exists() {
		data.InheritLocations = make([]SRLGInheritLocations, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := SRLGInheritLocations{}
			if cValue := v.Get("location-name"); cValue.Exists() {
				item.LocationName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("indexes.index"); cValue.Exists() {
				item.Indexes = make([]SRLGInheritLocationsIndexes, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := SRLGInheritLocationsIndexes{}
				if ccValue := cv.Get("index-number"); ccValue.Exists() {
					cItem.IndexNumber = types.Int64Value(ccValue.Int())
				}
				if ccValue := cv.Get("value"); ccValue.Exists() {
					cItem.Value = types.Int64Value(ccValue.Int())
				}
					if ccValue := cv.Get("priority"); ccValue.Exists() {
						cItem.Priority = types.StringValue(ccValue.String())
					}
				item.Indexes = append(item.Indexes, cItem)
				return true
			})
		}
			data.InheritLocations = append(data.InheritLocations, item)
			return true
		})
	}
}

// End of section. //template:end fromBody
// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyData

func (data *SRLGData) fromBody(ctx context.Context, res gjson.Result) {
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	if value := res.Get(prefix+"names.name"); value.Exists() {
		data.Names = make([]SRLGNames, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := SRLGNames{}
			if cValue := v.Get("srlg-name"); cValue.Exists() {
				item.SrlgName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("value"); cValue.Exists() {
				item.Value = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("description"); cValue.Exists() {
				item.Description = types.StringValue(cValue.String())
			}
			data.Names = append(data.Names, item)
			return true
		})
	}
	if value := res.Get(prefix+"interfaces.interface"); value.Exists() {
		data.Interfaces = make([]SRLGInterfaces, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := SRLGInterfaces{}
			if cValue := v.Get("interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("include-optical"); cValue.Exists() {
				item.IncludeOptical = types.BoolValue(true)
			} else {
				item.IncludeOptical = types.BoolNull()
			}
			if cValue := v.Get("include-optical.priority"); cValue.Exists() {
				item.IncludeOpticalPriority = types.StringValue(cValue.String())
			}
			if cValue := v.Get("indexes.index"); cValue.Exists() {
				item.Indexes = make([]SRLGInterfacesIndexes, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := SRLGInterfacesIndexes{}
					if ccValue := cv.Get("index-number"); ccValue.Exists() {
						cItem.IndexNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("value"); ccValue.Exists() {
						cItem.Value = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("priority"); ccValue.Exists() {
						cItem.Priority = types.StringValue(ccValue.String())
					}
					item.Indexes = append(item.Indexes, cItem)
					return true
				})
			}
			if cValue := v.Get("names.name"); cValue.Exists() {
				item.Names = make([]SRLGInterfacesNames, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := SRLGInterfacesNames{}
					if ccValue := cv.Get("srlg-name"); ccValue.Exists() {
						cItem.SrlgName = types.StringValue(ccValue.String())
					}
					item.Names = append(item.Names, cItem)
					return true
				})
			}
			if cValue := v.Get("groups.group"); cValue.Exists() {
				item.Groups = make([]SRLGInterfacesGroups, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := SRLGInterfacesGroups{}
					if ccValue := cv.Get("index-number"); ccValue.Exists() {
						cItem.IndexNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("group-name"); ccValue.Exists() {
						cItem.GroupName = types.StringValue(ccValue.String())
					}
					item.Groups = append(item.Groups, cItem)
					return true
				})
			}
			data.Interfaces = append(data.Interfaces, item)
			return true
		})
	}
	if value := res.Get(prefix+"groups.group"); value.Exists() {
		data.Groups = make([]SRLGGroups, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := SRLGGroups{}
			if cValue := v.Get("group-name"); cValue.Exists() {
				item.GroupName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("indexes.index"); cValue.Exists() {
				item.Indexes = make([]SRLGGroupsIndexes, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := SRLGGroupsIndexes{}
					if ccValue := cv.Get("index-number"); ccValue.Exists() {
						cItem.IndexNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("value"); ccValue.Exists() {
						cItem.Value = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("priority"); ccValue.Exists() {
						cItem.Priority = types.StringValue(ccValue.String())
					}
					item.Indexes = append(item.Indexes, cItem)
					return true
				})
			}
			data.Groups = append(data.Groups, item)
			return true
		})
	}
	if value := res.Get(prefix+"inherit-locations.inherit-location"); value.Exists() {
		data.InheritLocations = make([]SRLGInheritLocations, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := SRLGInheritLocations{}
			if cValue := v.Get("location-name"); cValue.Exists() {
				item.LocationName = types.StringValue(cValue.String())
			}
			if cValue := v.Get("indexes.index"); cValue.Exists() {
				item.Indexes = make([]SRLGInheritLocationsIndexes, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := SRLGInheritLocationsIndexes{}
					if ccValue := cv.Get("index-number"); ccValue.Exists() {
						cItem.IndexNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("value"); ccValue.Exists() {
						cItem.Value = types.Int64Value(ccValue.Int())
					}
					if ccValue := cv.Get("priority"); ccValue.Exists() {
						cItem.Priority = types.StringValue(ccValue.String())
					}
					item.Indexes = append(item.Indexes, cItem)
					return true
				})
			}
			data.InheritLocations = append(data.InheritLocations, item)
			return true
		})
	}
}

// End of section. //template:end fromBodyData
// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyXML

func (data *SRLG) fromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/names/name"); value.Exists() {
		data.Names = make([]SRLGNames, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := SRLGNames{}
			if cValue := helpers.GetFromXPath(v, "srlg-name"); cValue.Exists() {
				item.SrlgName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "value"); cValue.Exists() {
				item.Value = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "description"); cValue.Exists() {
				item.Description = types.StringValue(cValue.String())
			}
			data.Names = append(data.Names, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/interfaces/interface"); value.Exists() {
		data.Interfaces = make([]SRLGInterfaces, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := SRLGInterfaces{}
			if cValue := helpers.GetFromXPath(v, "interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "include-optical"); cValue.Exists() {
				item.IncludeOptical = types.BoolValue(true)
			} else {
				item.IncludeOptical = types.BoolValue(false)
			}
			if cValue := helpers.GetFromXPath(v, "include-optical/priority"); cValue.Exists() {
				item.IncludeOpticalPriority = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "indexes/index"); cValue.Exists() {
				item.Indexes = make([]SRLGInterfacesIndexes, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := SRLGInterfacesIndexes{}
					if ccValue := helpers.GetFromXPath(cv, "index-number"); ccValue.Exists() {
						cItem.IndexNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "value"); ccValue.Exists() {
						cItem.Value = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "priority"); ccValue.Exists() {
						cItem.Priority = types.StringValue(ccValue.String())
					}
					item.Indexes = append(item.Indexes, cItem)
					return true
				})
			}
			if cValue := helpers.GetFromXPath(v, "names/name"); cValue.Exists() {
				item.Names = make([]SRLGInterfacesNames, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := SRLGInterfacesNames{}
					if ccValue := helpers.GetFromXPath(cv, "srlg-name"); ccValue.Exists() {
						cItem.SrlgName = types.StringValue(ccValue.String())
					}
					item.Names = append(item.Names, cItem)
					return true
				})
			}
			if cValue := helpers.GetFromXPath(v, "groups/group"); cValue.Exists() {
				item.Groups = make([]SRLGInterfacesGroups, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := SRLGInterfacesGroups{}
					if ccValue := helpers.GetFromXPath(cv, "index-number"); ccValue.Exists() {
						cItem.IndexNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "group-name"); ccValue.Exists() {
						cItem.GroupName = types.StringValue(ccValue.String())
					}
					item.Groups = append(item.Groups, cItem)
					return true
				})
			}
			data.Interfaces = append(data.Interfaces, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/groups/group"); value.Exists() {
		data.Groups = make([]SRLGGroups, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := SRLGGroups{}
			if cValue := helpers.GetFromXPath(v, "group-name"); cValue.Exists() {
				item.GroupName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "indexes/index"); cValue.Exists() {
				item.Indexes = make([]SRLGGroupsIndexes, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := SRLGGroupsIndexes{}
					if ccValue := helpers.GetFromXPath(cv, "index-number"); ccValue.Exists() {
						cItem.IndexNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "value"); ccValue.Exists() {
						cItem.Value = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "priority"); ccValue.Exists() {
						cItem.Priority = types.StringValue(ccValue.String())
					}
					item.Indexes = append(item.Indexes, cItem)
					return true
				})
			}
			data.Groups = append(data.Groups, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/inherit-locations/inherit-location"); value.Exists() {
		data.InheritLocations = make([]SRLGInheritLocations, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := SRLGInheritLocations{}
			if cValue := helpers.GetFromXPath(v, "location-name"); cValue.Exists() {
				item.LocationName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "indexes/index"); cValue.Exists() {
				item.Indexes = make([]SRLGInheritLocationsIndexes, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := SRLGInheritLocationsIndexes{}
					if ccValue := helpers.GetFromXPath(cv, "index-number"); ccValue.Exists() {
						cItem.IndexNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "value"); ccValue.Exists() {
						cItem.Value = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "priority"); ccValue.Exists() {
						cItem.Priority = types.StringValue(ccValue.String())
					}
					item.Indexes = append(item.Indexes, cItem)
					return true
				})
			}
			data.InheritLocations = append(data.InheritLocations, item)
			return true
		})
	}
}

// End of section. //template:end fromBodyXML
// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyDataXML

func (data *SRLGData) fromBodyXML(ctx context.Context, res xmldot.Result) {
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/names/name"); value.Exists() {
		data.Names = make([]SRLGNames, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := SRLGNames{}
			if cValue := helpers.GetFromXPath(v, "srlg-name"); cValue.Exists() {
				item.SrlgName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "value"); cValue.Exists() {
				item.Value = types.Int64Value(cValue.Int())
			}
			if cValue := helpers.GetFromXPath(v, "description"); cValue.Exists() {
				item.Description = types.StringValue(cValue.String())
			}
			data.Names = append(data.Names, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/interfaces/interface"); value.Exists() {
		data.Interfaces = make([]SRLGInterfaces, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := SRLGInterfaces{}
			if cValue := helpers.GetFromXPath(v, "interface-name"); cValue.Exists() {
				item.InterfaceName = types.StringValue(cValue.String())
			}
		if cValue := helpers.GetFromXPath(v, "include-optical"); cValue.Exists() {
			item.IncludeOptical = types.BoolValue(true)
		} else {
			item.IncludeOptical = types.BoolValue(false)
		}
			if cValue := helpers.GetFromXPath(v, "include-optical/priority"); cValue.Exists() {
				item.IncludeOpticalPriority = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "indexes/index"); cValue.Exists() {
				item.Indexes = make([]SRLGInterfacesIndexes, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := SRLGInterfacesIndexes{}
					if ccValue := helpers.GetFromXPath(cv, "index-number"); ccValue.Exists() {
						cItem.IndexNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "value"); ccValue.Exists() {
						cItem.Value = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "priority"); ccValue.Exists() {
						cItem.Priority = types.StringValue(ccValue.String())
					}
					item.Indexes = append(item.Indexes, cItem)
					return true
				})
			}
			if cValue := helpers.GetFromXPath(v, "names/name"); cValue.Exists() {
				item.Names = make([]SRLGInterfacesNames, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := SRLGInterfacesNames{}
					if ccValue := helpers.GetFromXPath(cv, "srlg-name"); ccValue.Exists() {
						cItem.SrlgName = types.StringValue(ccValue.String())
					}
					item.Names = append(item.Names, cItem)
					return true
				})
			}
			if cValue := helpers.GetFromXPath(v, "groups/group"); cValue.Exists() {
				item.Groups = make([]SRLGInterfacesGroups, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := SRLGInterfacesGroups{}
					if ccValue := helpers.GetFromXPath(cv, "index-number"); ccValue.Exists() {
						cItem.IndexNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "group-name"); ccValue.Exists() {
						cItem.GroupName = types.StringValue(ccValue.String())
					}
					item.Groups = append(item.Groups, cItem)
					return true
				})
			}
			data.Interfaces = append(data.Interfaces, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/groups/group"); value.Exists() {
		data.Groups = make([]SRLGGroups, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := SRLGGroups{}
			if cValue := helpers.GetFromXPath(v, "group-name"); cValue.Exists() {
				item.GroupName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "indexes/index"); cValue.Exists() {
				item.Indexes = make([]SRLGGroupsIndexes, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := SRLGGroupsIndexes{}
					if ccValue := helpers.GetFromXPath(cv, "index-number"); ccValue.Exists() {
						cItem.IndexNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "value"); ccValue.Exists() {
						cItem.Value = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "priority"); ccValue.Exists() {
						cItem.Priority = types.StringValue(ccValue.String())
					}
					item.Indexes = append(item.Indexes, cItem)
					return true
				})
			}
			data.Groups = append(data.Groups, item)
			return true
		})
	}
	if value := helpers.GetFromXPath(res, "data" + data.getXPath() + "/inherit-locations/inherit-location"); value.Exists() {
		data.InheritLocations = make([]SRLGInheritLocations, 0)
		value.ForEach(func(_ int, v xmldot.Result) bool {
			item := SRLGInheritLocations{}
			if cValue := helpers.GetFromXPath(v, "location-name"); cValue.Exists() {
				item.LocationName = types.StringValue(cValue.String())
			}
			if cValue := helpers.GetFromXPath(v, "indexes/index"); cValue.Exists() {
				item.Indexes = make([]SRLGInheritLocationsIndexes, 0)
				cValue.ForEach(func(_ int, cv xmldot.Result) bool {
					cItem := SRLGInheritLocationsIndexes{}
					if ccValue := helpers.GetFromXPath(cv, "index-number"); ccValue.Exists() {
						cItem.IndexNumber = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "value"); ccValue.Exists() {
						cItem.Value = types.Int64Value(ccValue.Int())
					}
					if ccValue := helpers.GetFromXPath(cv, "priority"); ccValue.Exists() {
						cItem.Priority = types.StringValue(ccValue.String())
					}
					item.Indexes = append(item.Indexes, cItem)
					return true
				})
			}
			data.InheritLocations = append(data.InheritLocations, item)
			return true
		})
	}
}

// End of section. //template:end fromBodyDataXML
// Section below is generated&owned by "gen/generator.go". //template:begin getDeletedItems

func (data *SRLG) getDeletedItems(ctx context.Context, state SRLG) []string {
	deletedItems := make([]string, 0)
	for i := range state.InheritLocations {
		keys := [...]string{ "location-name",  }
		stateKeyValues := [...]string{ state.InheritLocations[i].LocationName.ValueString(),  }
		keyString := ""
		for ki := range keys {
			keyString += "["+keys[ki]+"="+stateKeyValues[ki]+"]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.InheritLocations[i].LocationName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.InheritLocations {
			found = true
			if state.InheritLocations[i].LocationName.ValueString() != data.InheritLocations[j].LocationName.ValueString() {
				found = false
			}
		if found {
				for ci := range state.InheritLocations[i].Indexes {
					ckeys := [...]string{ "index-number",  }
					cstateKeyValues := [...]string{ strconv.FormatInt(state.InheritLocations[i].Indexes[ci].IndexNumber.ValueInt64(), 10),  }
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "["+ckeys[cki]+"="+cstateKeyValues[cki]+"]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.InheritLocations[i].Indexes[ci].IndexNumber.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.InheritLocations[j].Indexes {
						found = true
						if state.InheritLocations[i].Indexes[ci].IndexNumber.ValueInt64() != data.InheritLocations[j].Indexes[cj].IndexNumber.ValueInt64() {
							found = false
						}
					if found {
						if !state.InheritLocations[i].Indexes[ci].Priority.IsNull() && data.InheritLocations[j].Indexes[cj].Priority.IsNull() {
							deletedItems = append(deletedItems, fmt.Sprintf("%v/inherit-locations/inherit-location%v/indexes/index%v/priority", state.getPath(), keyString, ckeyString))
						}
						if !state.InheritLocations[i].Indexes[ci].Value.IsNull() && data.InheritLocations[j].Indexes[cj].Value.IsNull() {
							deletedItems = append(deletedItems, fmt.Sprintf("%v/inherit-locations/inherit-location%v/indexes/index%v/value", state.getPath(), keyString, ckeyString))
						}
						break
					}
				}
				if !found {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/inherit-locations/inherit-location%v/indexes/index%v", state.getPath(), keyString, ckeyString))
				}
			}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/inherit-locations/inherit-location%v", state.getPath(), keyString))
		}
	}
	for i := range state.Groups {
		keys := [...]string{ "group-name",  }
		stateKeyValues := [...]string{ state.Groups[i].GroupName.ValueString(),  }
		keyString := ""
		for ki := range keys {
			keyString += "["+keys[ki]+"="+stateKeyValues[ki]+"]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.Groups[i].GroupName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Groups {
			found = true
			if state.Groups[i].GroupName.ValueString() != data.Groups[j].GroupName.ValueString() {
				found = false
			}
		if found {
				for ci := range state.Groups[i].Indexes {
					ckeys := [...]string{ "index-number",  }
					cstateKeyValues := [...]string{ strconv.FormatInt(state.Groups[i].Indexes[ci].IndexNumber.ValueInt64(), 10),  }
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "["+ckeys[cki]+"="+cstateKeyValues[cki]+"]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.Groups[i].Indexes[ci].IndexNumber.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.Groups[j].Indexes {
						found = true
						if state.Groups[i].Indexes[ci].IndexNumber.ValueInt64() != data.Groups[j].Indexes[cj].IndexNumber.ValueInt64() {
							found = false
						}
					if found {
						if !state.Groups[i].Indexes[ci].Priority.IsNull() && data.Groups[j].Indexes[cj].Priority.IsNull() {
							deletedItems = append(deletedItems, fmt.Sprintf("%v/groups/group%v/indexes/index%v/priority", state.getPath(), keyString, ckeyString))
						}
						if !state.Groups[i].Indexes[ci].Value.IsNull() && data.Groups[j].Indexes[cj].Value.IsNull() {
							deletedItems = append(deletedItems, fmt.Sprintf("%v/groups/group%v/indexes/index%v/value", state.getPath(), keyString, ckeyString))
						}
						break
					}
				}
				if !found {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/groups/group%v/indexes/index%v", state.getPath(), keyString, ckeyString))
				}
			}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/groups/group%v", state.getPath(), keyString))
		}
	}
	for i := range state.Interfaces {
		keys := [...]string{ "interface-name",  }
		stateKeyValues := [...]string{ state.Interfaces[i].InterfaceName.ValueString(),  }
		keyString := ""
		for ki := range keys {
			keyString += "["+keys[ki]+"="+stateKeyValues[ki]+"]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.Interfaces[i].InterfaceName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Interfaces {
			found = true
			if state.Interfaces[i].InterfaceName.ValueString() != data.Interfaces[j].InterfaceName.ValueString() {
				found = false
			}
		if found {
				for ci := range state.Interfaces[i].Groups {
					ckeys := [...]string{ "index-number",  }
					cstateKeyValues := [...]string{ strconv.FormatInt(state.Interfaces[i].Groups[ci].IndexNumber.ValueInt64(), 10),  }
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "["+ckeys[cki]+"="+cstateKeyValues[cki]+"]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.Interfaces[i].Groups[ci].IndexNumber.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.Interfaces[j].Groups {
						found = true
						if state.Interfaces[i].Groups[ci].IndexNumber.ValueInt64() != data.Interfaces[j].Groups[cj].IndexNumber.ValueInt64() {
							found = false
						}
					if found {
						if !state.Interfaces[i].Groups[ci].GroupName.IsNull() && data.Interfaces[j].Groups[cj].GroupName.IsNull() {
							deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/groups/group%v/group-name", state.getPath(), keyString, ckeyString))
						}
						break
					}
				}
				if !found {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/groups/group%v", state.getPath(), keyString, ckeyString))
				}
			}
				for ci := range state.Interfaces[i].Names {
					ckeys := [...]string{ "srlg-name",  }
					cstateKeyValues := [...]string{ state.Interfaces[i].Names[ci].SrlgName.ValueString(),  }
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "["+ckeys[cki]+"="+cstateKeyValues[cki]+"]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.Interfaces[i].Names[ci].SrlgName.ValueString()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.Interfaces[j].Names {
						found = true
						if state.Interfaces[i].Names[ci].SrlgName.ValueString() != data.Interfaces[j].Names[cj].SrlgName.ValueString() {
							found = false
						}
					if found {
						break
					}
				}
				if !found {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/names/name%v", state.getPath(), keyString, ckeyString))
				}
			}
				for ci := range state.Interfaces[i].Indexes {
					ckeys := [...]string{ "index-number",  }
					cstateKeyValues := [...]string{ strconv.FormatInt(state.Interfaces[i].Indexes[ci].IndexNumber.ValueInt64(), 10),  }
					ckeyString := ""
					for cki := range ckeys {
						ckeyString += "["+ckeys[cki]+"="+cstateKeyValues[cki]+"]"
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.Interfaces[i].Indexes[ci].IndexNumber.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.Interfaces[j].Indexes {
						found = true
						if state.Interfaces[i].Indexes[ci].IndexNumber.ValueInt64() != data.Interfaces[j].Indexes[cj].IndexNumber.ValueInt64() {
							found = false
						}
					if found {
						if !state.Interfaces[i].Indexes[ci].Priority.IsNull() && data.Interfaces[j].Indexes[cj].Priority.IsNull() {
							deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/indexes/index%v/priority", state.getPath(), keyString, ckeyString))
						}
						if !state.Interfaces[i].Indexes[ci].Value.IsNull() && data.Interfaces[j].Indexes[cj].Value.IsNull() {
							deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/indexes/index%v/value", state.getPath(), keyString, ckeyString))
						}
						break
					}
				}
				if !found {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/indexes/index%v", state.getPath(), keyString, ckeyString))
				}
			}
			if !state.Interfaces[i].IncludeOpticalPriority.IsNull() && data.Interfaces[j].IncludeOpticalPriority.IsNull() {
				deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/include-optical/priority", state.getPath(), keyString))
			}
			if !state.Interfaces[i].IncludeOptical.IsNull() && data.Interfaces[j].IncludeOptical.IsNull() {
				deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v/include-optical", state.getPath(), keyString))
			}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/interfaces/interface%v", state.getPath(), keyString))
		}
	}
	for i := range state.Names {
		keys := [...]string{ "srlg-name",  }
		stateKeyValues := [...]string{ state.Names[i].SrlgName.ValueString(),  }
		keyString := ""
		for ki := range keys {
			keyString += "["+keys[ki]+"="+stateKeyValues[ki]+"]"
		}

		emptyKeys := true
		if !reflect.ValueOf(state.Names[i].SrlgName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Names {
			found = true
			if state.Names[i].SrlgName.ValueString() != data.Names[j].SrlgName.ValueString() {
				found = false
			}
		if found {
			if !state.Names[i].Description.IsNull() && data.Names[j].Description.IsNull() {
				deletedItems = append(deletedItems, fmt.Sprintf("%v/names/name%v/description", state.getPath(), keyString))
			}
			if !state.Names[i].Value.IsNull() && data.Names[j].Value.IsNull() {
				deletedItems = append(deletedItems, fmt.Sprintf("%v/names/name%v/value", state.getPath(), keyString))
			}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/names/name%v", state.getPath(), keyString))
		}
	}
	return deletedItems
}

// End of section. //template:end getDeletedItems
// Section below is generated&owned by "gen/generator.go". //template:begin getEmptyLeafsDelete

func (data *SRLG) getEmptyLeafsDelete(ctx context.Context, state *SRLG) []string {
	emptyLeafsDelete := make([]string, 0)
	for i := range data.InheritLocations {
		keys := [...]string{ "location-name",  }
		keyValues := [...]string{ data.InheritLocations[i].LocationName.ValueString(),  }
		keyString := ""
		for ki := range keys {
			keyString += "["+keys[ki]+"="+keyValues[ki]+"]"
		}
		for ci := range data.InheritLocations[i].Indexes {
			ckeys := [...]string{ "index-number",  }
			ckeyValues := [...]string{ strconv.FormatInt(data.InheritLocations[i].Indexes[ci].IndexNumber.ValueInt64(), 10),  }
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "["+ckeys[cki]+"="+ckeyValues[cki]+"]"
			}
		}
	}
	for i := range data.Groups {
		keys := [...]string{ "group-name",  }
		keyValues := [...]string{ data.Groups[i].GroupName.ValueString(),  }
		keyString := ""
		for ki := range keys {
			keyString += "["+keys[ki]+"="+keyValues[ki]+"]"
		}
		for ci := range data.Groups[i].Indexes {
			ckeys := [...]string{ "index-number",  }
			ckeyValues := [...]string{ strconv.FormatInt(data.Groups[i].Indexes[ci].IndexNumber.ValueInt64(), 10),  }
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "["+ckeys[cki]+"="+ckeyValues[cki]+"]"
			}
		}
	}
	for i := range data.Interfaces {
		keys := [...]string{ "interface-name",  }
		keyValues := [...]string{ data.Interfaces[i].InterfaceName.ValueString(),  }
		keyString := ""
		for ki := range keys {
			keyString += "["+keys[ki]+"="+keyValues[ki]+"]"
		}
		for ci := range data.Interfaces[i].Groups {
			ckeys := [...]string{ "index-number",  }
			ckeyValues := [...]string{ strconv.FormatInt(data.Interfaces[i].Groups[ci].IndexNumber.ValueInt64(), 10),  }
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "["+ckeys[cki]+"="+ckeyValues[cki]+"]"
			}
		}
		for ci := range data.Interfaces[i].Names {
			ckeys := [...]string{ "srlg-name",  }
			ckeyValues := [...]string{ data.Interfaces[i].Names[ci].SrlgName.ValueString(),  }
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "["+ckeys[cki]+"="+ckeyValues[cki]+"]"
			}
		}
		for ci := range data.Interfaces[i].Indexes {
			ckeys := [...]string{ "index-number",  }
			ckeyValues := [...]string{ strconv.FormatInt(data.Interfaces[i].Indexes[ci].IndexNumber.ValueInt64(), 10),  }
			ckeyString := ""
			for cki := range ckeys {
				ckeyString += "["+ckeys[cki]+"="+ckeyValues[cki]+"]"
			}
		}
		// Only delete if state has true and plan has false
		if !data.Interfaces[i].IncludeOptical.IsNull() && !data.Interfaces[i].IncludeOptical.ValueBool() {
			// Check if corresponding state item exists and has true value
			if state != nil && i < len(state.Interfaces) && !state.Interfaces[i].IncludeOptical.IsNull() && state.Interfaces[i].IncludeOptical.ValueBool() {
				emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/interfaces/interface%v/include-optical", data.getXPath(), keyString))
			}
		}
	}
	for i := range data.Names {
		keys := [...]string{ "srlg-name",  }
		keyValues := [...]string{ data.Names[i].SrlgName.ValueString(),  }
		keyString := ""
		for ki := range keys {
			keyString += "["+keys[ki]+"="+keyValues[ki]+"]"
		}
	}
	return emptyLeafsDelete
}

// End of section. //template:end getEmptyLeafsDelete
// Section below is generated&owned by "gen/generator.go". //template:begin getDeletePaths

func (data *SRLG) getDeletePaths(ctx context.Context) []string {
	var deletePaths []string
	for i := range data.InheritLocations {
		keyValues := [...]string{ data.InheritLocations[i].LocationName.ValueString(),  }

		deletePaths = append(deletePaths, fmt.Sprintf("%v/inherit-locations/inherit-location=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	for i := range data.Groups {
		keyValues := [...]string{ data.Groups[i].GroupName.ValueString(),  }

		deletePaths = append(deletePaths, fmt.Sprintf("%v/groups/group=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	for i := range data.Interfaces {
		keyValues := [...]string{ data.Interfaces[i].InterfaceName.ValueString(),  }

		deletePaths = append(deletePaths, fmt.Sprintf("%v/interfaces/interface=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	for i := range data.Names {
		keyValues := [...]string{ data.Names[i].SrlgName.ValueString(),  }

		deletePaths = append(deletePaths, fmt.Sprintf("%v/names/name=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}

	return deletePaths
}

// End of section. //template:end getDeletePaths
// Section below is generated&owned by "gen/generator.go". //template:begin addDeletedItemsXML

func (data *SRLG) addDeletedItemsXML(ctx context.Context, state SRLG, body string) string {
	deleteXml := ""
	deletedPaths := make(map[string]bool)
	_ = deletedPaths // Avoid unused variable error when no delete_parent attributes exist
	for i := range state.InheritLocations {
		stateKeys := [...]string{ "location-name",  }
		stateKeyValues := [...]string{ state.InheritLocations[i].LocationName.ValueString(),  }
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.InheritLocations[i].LocationName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.InheritLocations {
			found = true
			if state.InheritLocations[i].LocationName.ValueString() != data.InheritLocations[j].LocationName.ValueString() {
				found = false
			}
			if found {
			for ci := range state.InheritLocations[i].Indexes {
					cstateKeys := [...]string{ "index-number",  }
					cstateKeyValues := [...]string{ strconv.FormatInt(state.InheritLocations[i].Indexes[ci].IndexNumber.ValueInt64(), 10),  }
					cpredicates := ""
					for i := range cstateKeys {
						cpredicates += fmt.Sprintf("[%s='%s']", cstateKeys[i], cstateKeyValues[i])
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.InheritLocations[i].Indexes[ci].IndexNumber.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.InheritLocations[j].Indexes {
						found = true
						if state.InheritLocations[i].Indexes[ci].IndexNumber.ValueInt64() != data.InheritLocations[j].Indexes[cj].IndexNumber.ValueInt64() {
							found = false
						}
						if found {
							if !state.InheritLocations[i].Indexes[ci].Priority.IsNull() && data.InheritLocations[j].Indexes[cj].Priority.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/inherit-locations/inherit-location%v/indexes/index%v/priority", predicates, cpredicates))
							}
							if !state.InheritLocations[i].Indexes[ci].Value.IsNull() && data.InheritLocations[j].Indexes[cj].Value.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/inherit-locations/inherit-location%v/indexes/index%v/value", predicates, cpredicates))
							}
							break
						}
					}
					if !found {
						deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/inherit-locations/inherit-location%v/indexes/index%v", predicates, cpredicates))
					}
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/inherit-locations/inherit-location%v", predicates))
		}
	}
	for i := range state.Groups {
		stateKeys := [...]string{ "group-name",  }
		stateKeyValues := [...]string{ state.Groups[i].GroupName.ValueString(),  }
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.Groups[i].GroupName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Groups {
			found = true
			if state.Groups[i].GroupName.ValueString() != data.Groups[j].GroupName.ValueString() {
				found = false
			}
			if found {
			for ci := range state.Groups[i].Indexes {
					cstateKeys := [...]string{ "index-number",  }
					cstateKeyValues := [...]string{ strconv.FormatInt(state.Groups[i].Indexes[ci].IndexNumber.ValueInt64(), 10),  }
					cpredicates := ""
					for i := range cstateKeys {
						cpredicates += fmt.Sprintf("[%s='%s']", cstateKeys[i], cstateKeyValues[i])
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.Groups[i].Indexes[ci].IndexNumber.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.Groups[j].Indexes {
						found = true
						if state.Groups[i].Indexes[ci].IndexNumber.ValueInt64() != data.Groups[j].Indexes[cj].IndexNumber.ValueInt64() {
							found = false
						}
						if found {
							if !state.Groups[i].Indexes[ci].Priority.IsNull() && data.Groups[j].Indexes[cj].Priority.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/groups/group%v/indexes/index%v/priority", predicates, cpredicates))
							}
							if !state.Groups[i].Indexes[ci].Value.IsNull() && data.Groups[j].Indexes[cj].Value.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/groups/group%v/indexes/index%v/value", predicates, cpredicates))
							}
							break
						}
					}
					if !found {
						deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/groups/group%v/indexes/index%v", predicates, cpredicates))
					}
				}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/groups/group%v", predicates))
		}
	}
	for i := range state.Interfaces {
		stateKeys := [...]string{ "interface-name",  }
		stateKeyValues := [...]string{ state.Interfaces[i].InterfaceName.ValueString(),  }
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.Interfaces[i].InterfaceName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Interfaces {
			found = true
			if state.Interfaces[i].InterfaceName.ValueString() != data.Interfaces[j].InterfaceName.ValueString() {
				found = false
			}
			if found {
			for ci := range state.Interfaces[i].Groups {
					cstateKeys := [...]string{ "index-number",  }
					cstateKeyValues := [...]string{ strconv.FormatInt(state.Interfaces[i].Groups[ci].IndexNumber.ValueInt64(), 10),  }
					cpredicates := ""
					for i := range cstateKeys {
						cpredicates += fmt.Sprintf("[%s='%s']", cstateKeys[i], cstateKeyValues[i])
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.Interfaces[i].Groups[ci].IndexNumber.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.Interfaces[j].Groups {
						found = true
						if state.Interfaces[i].Groups[ci].IndexNumber.ValueInt64() != data.Interfaces[j].Groups[cj].IndexNumber.ValueInt64() {
							found = false
						}
						if found {
							if !state.Interfaces[i].Groups[ci].GroupName.IsNull() && data.Interfaces[j].Groups[cj].GroupName.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/groups/group%v/group-name", predicates, cpredicates))
							}
							break
						}
					}
					if !found {
						deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/groups/group%v", predicates, cpredicates))
					}
				}
			for ci := range state.Interfaces[i].Names {
					cstateKeys := [...]string{ "srlg-name",  }
					cstateKeyValues := [...]string{ state.Interfaces[i].Names[ci].SrlgName.ValueString(),  }
					cpredicates := ""
					for i := range cstateKeys {
						cpredicates += fmt.Sprintf("[%s='%s']", cstateKeys[i], cstateKeyValues[i])
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.Interfaces[i].Names[ci].SrlgName.ValueString()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.Interfaces[j].Names {
						found = true
						if state.Interfaces[i].Names[ci].SrlgName.ValueString() != data.Interfaces[j].Names[cj].SrlgName.ValueString() {
							found = false
						}
						if found {
							break
						}
					}
					if !found {
						deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/names/name%v", predicates, cpredicates))
					}
				}
			for ci := range state.Interfaces[i].Indexes {
					cstateKeys := [...]string{ "index-number",  }
					cstateKeyValues := [...]string{ strconv.FormatInt(state.Interfaces[i].Indexes[ci].IndexNumber.ValueInt64(), 10),  }
					cpredicates := ""
					for i := range cstateKeys {
						cpredicates += fmt.Sprintf("[%s='%s']", cstateKeys[i], cstateKeyValues[i])
					}

					cemptyKeys := true
					if !reflect.ValueOf(state.Interfaces[i].Indexes[ci].IndexNumber.ValueInt64()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.Interfaces[j].Indexes {
						found = true
						if state.Interfaces[i].Indexes[ci].IndexNumber.ValueInt64() != data.Interfaces[j].Indexes[cj].IndexNumber.ValueInt64() {
							found = false
						}
						if found {
							if !state.Interfaces[i].Indexes[ci].Priority.IsNull() && data.Interfaces[j].Indexes[cj].Priority.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/indexes/index%v/priority", predicates, cpredicates))
							}
							if !state.Interfaces[i].Indexes[ci].Value.IsNull() && data.Interfaces[j].Indexes[cj].Value.IsNull() {
								deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/indexes/index%v/value", predicates, cpredicates))
							}
							break
						}
					}
					if !found {
						deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/indexes/index%v", predicates, cpredicates))
					}
				}
			if !state.Interfaces[i].IncludeOpticalPriority.IsNull() && data.Interfaces[j].IncludeOpticalPriority.IsNull() {
				deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/include-optical/priority", predicates))
			}
			// For boolean fields, only delete if state was true (presence container was set)
			if !state.Interfaces[i].IncludeOptical.IsNull() && state.Interfaces[i].IncludeOptical.ValueBool() && data.Interfaces[j].IncludeOptical.IsNull() {
				deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v/include-optical", predicates))
			}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/interfaces/interface%v", predicates))
		}
	}
	for i := range state.Names {
		stateKeys := [...]string{ "srlg-name",  }
		stateKeyValues := [...]string{ state.Names[i].SrlgName.ValueString(),  }
		predicates := ""
		for i := range stateKeys {
			predicates += fmt.Sprintf("[%s='%s']", stateKeys[i], stateKeyValues[i])
		}

		emptyKeys := true
		if !reflect.ValueOf(state.Names[i].SrlgName.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.Names {
			found = true
			if state.Names[i].SrlgName.ValueString() != data.Names[j].SrlgName.ValueString() {
				found = false
			}
			if found {
			if !state.Names[i].Description.IsNull() && data.Names[j].Description.IsNull() {
				deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/names/name%v/description", predicates))
			}
			if !state.Names[i].Value.IsNull() && data.Names[j].Value.IsNull() {
				deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/names/name%v/value", predicates))
			}
				break
			}
		}
		if !found {
			deleteXml += helpers.RemoveFromXPathString(netconf.Body{}, fmt.Sprintf(state.getXPath()+"/names/name%v", predicates))
		}
	}

	b := netconf.NewBody(deleteXml)
	b = helpers.CleanupRedundantRemoveOperations(b)
	return b.Res()
}

// End of section. //template:end addDeletedItemsXML
// Section below is generated&owned by "gen/generator.go". //template:begin addDeletePathsXML

func (data *SRLG) addDeletePathsXML(ctx context.Context, body string) string {
	b := netconf.NewBody(body)
	for i := range data.InheritLocations {
		keys := [...]string{ "location-name",  }
		keyValues := [...]string{ data.InheritLocations[i].LocationName.ValueString(),  }
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/inherit-locations/inherit-location%v", predicates))
	}
	for i := range data.Groups {
		keys := [...]string{ "group-name",  }
		keyValues := [...]string{ data.Groups[i].GroupName.ValueString(),  }
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/groups/group%v", predicates))
	}
	for i := range data.Interfaces {
		keys := [...]string{ "interface-name",  }
		keyValues := [...]string{ data.Interfaces[i].InterfaceName.ValueString(),  }
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/interfaces/interface%v", predicates))
	}
	for i := range data.Names {
		keys := [...]string{ "srlg-name",  }
		keyValues := [...]string{ data.Names[i].SrlgName.ValueString(),  }
		predicates := ""
		for i := range keys {
			predicates += fmt.Sprintf("[%s='%s']", keys[i], keyValues[i])
		}

		b = helpers.RemoveFromXPath(b, fmt.Sprintf(data.getXPath()+"/names/name%v", predicates))
	}

	b = helpers.CleanupRedundantRemoveOperations(b)
	return b.Res()
}

// End of section. //template:end addDeletePathsXML
