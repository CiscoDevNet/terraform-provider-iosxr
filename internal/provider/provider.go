// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin provider
import (
	"context"
	"fmt"
	"os"
	"slices"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/CiscoDevNet/terraform-provider-iosxr/internal/provider/helpers"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/provider"
	"github.com/hashicorp/terraform-plugin-framework/provider/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/netascode/go-gnmi"
	"github.com/netascode/go-netconf"
)

func New() provider.Provider {
	return &iosxrProvider{}
}

// provider satisfies the tfsdk.Provider interface and usually is included
// with all Resource and DataSource implementations.
type iosxrProvider struct{}

// providerData can be used to store data from the Terraform configuration.
type providerData struct {
	Username           types.String         `tfsdk:"username"`
	Password           types.String         `tfsdk:"password"`
	Host               types.String         `tfsdk:"host"`
	Protocol           types.String         `tfsdk:"protocol"`
	VerifyCertificate  types.Bool           `tfsdk:"verify_certificate"`
	Tls                types.Bool           `tfsdk:"tls"`
	Certificate        types.String         `tfsdk:"certificate"`
	Key                types.String         `tfsdk:"key"`
	CaCertificate      types.String         `tfsdk:"ca_certificate"`
	Retries            types.Int64          `tfsdk:"retries"`
	LockReleaseTimeout types.Int64          `tfsdk:"lock_release_timeout"`
	ReuseConnection    types.Bool           `tfsdk:"reuse_connection"`
	SelectedDevices    types.List           `tfsdk:"selected_devices"`
	Devices            []providerDataDevice `tfsdk:"devices"`
}

type providerDataDevice struct {
	Name    types.String `tfsdk:"name"`
	Host    types.String `tfsdk:"host"`
	Managed types.Bool   `tfsdk:"managed"`
}

type IosxrProviderData struct {
	Devices         map[string]*IosxrProviderDataDevice
	ReuseConnection bool
}

type IosxrProviderDataDevice struct {
	GnmiClient      *gnmi.Client
	NetconfClient   *netconf.Client
	Protocol        string
	ReuseConnection bool
	Managed         bool
	NetconfOpMutex  sync.Mutex // Serializes NETCONF operations (all ops when reuse disabled, writes only when reuse enabled)
}

// Metadata returns the provider type name.
func (p *iosxrProvider) Metadata(_ context.Context, _ provider.MetadataRequest, resp *provider.MetadataResponse) {
	resp.TypeName = "iosxr"
}

func (p *iosxrProvider) Schema(ctx context.Context, req provider.SchemaRequest, resp *provider.SchemaResponse) {
	resp.Schema = schema.Schema{
		Attributes: map[string]schema.Attribute{
			"username": schema.StringAttribute{
				MarkdownDescription: "Username for the IOS-XR device. This can also be set as the IOSXR_USERNAME environment variable.",
				Optional:            true,
			},
			"password": schema.StringAttribute{
				MarkdownDescription: "Password for the IOS-XR device. This can also be set as the IOSXR_PASSWORD environment variable.",
				Optional:            true,
				Sensitive:           true,
			},
			"host": schema.StringAttribute{
				MarkdownDescription: "Hostname or IP address of the Cisco IOS-XR device. Optionally a port can be added with `:port`. Default port is `57400` for gNMI and `830` for NETCONF. This can also be set as the IOSXR_HOST environment variable.",
				Optional:            true,
			},
			"protocol": schema.StringAttribute{
				MarkdownDescription: "Protocol to use for device communication. Either `gnmi` or `netconf` (SSH). This can also be set as the IOSXR_PROTOCOL environment variable. Defaults to `gnmi`.",
				Optional:            true,
				Validators: []validator.String{
					stringvalidator.OneOf("gnmi", "netconf"),
				},
			},
			"verify_certificate": schema.BoolAttribute{
				MarkdownDescription: "Verify target certificate. This can also be set as the IOSXR_VERIFY_CERTIFICATE environment variable. Defaults to `false`.",
				Optional:            true,
			},
			"tls": schema.BoolAttribute{
				MarkdownDescription: "Use TLS. This can also be set as the IOSXR_TLS environment variable. Defaults to `true`.",
				Optional:            true,
			},
			"certificate": schema.StringAttribute{
				MarkdownDescription: "TLS certificate content. This can also be set as the IOSXR_CERTIFICATE environment variable.",
				Optional:            true,
			},
			"key": schema.StringAttribute{
				MarkdownDescription: "TLS private key content. This can also be set as the IOSXR_KEY environment variable.",
				Optional:            true,
			},
			"ca_certificate": schema.StringAttribute{
				MarkdownDescription: "TLS CA certificate content. This can also be set as the IOSXR_CA_CERTIFICATE environment variable.",
				Optional:            true,
			},
			"retries": schema.Int64Attribute{
				MarkdownDescription: "Number of retries for API calls. This can also be set as the IOSXR_RETRIES environment variable. Defaults to `3`.",
				Optional:            true,
				Validators: []validator.Int64{
					int64validator.Between(0, 99),
				},
			},
			"lock_release_timeout": schema.Int64Attribute{
				MarkdownDescription: "Number of seconds to wait for the device database lock to be released. This can also be set as the IOSXR_LOCK_RELEASE_TIMEOUT environment variable. Defaults to `120`.",
				Optional:            true,
				Validators: []validator.Int64{
					int64validator.Between(0, 600),
				},
			},
			"reuse_connection": schema.BoolAttribute{
				MarkdownDescription: "Keep connections open between operations for better performance. When disabled, connections are closed and reopened for each operation. Only applies to NETCONF protocol. This can also be set as the IOSXR_REUSE_CONNECTION environment variable. Defaults to `true`.",
				Optional:            true,
			},
			"selected_devices": schema.ListAttribute{
				MarkdownDescription: "This can be used to select a list of devices to manage from the `devices` list. Selected devices will be managed while other devices will be skipped and their state will be frozen. This can be used to deploy changes to a subset of devices. Defaults to all devices.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"devices": schema.ListNestedAttribute{
				MarkdownDescription: "This can be used to manage a list of devices from a single provider. All devices must use the same credentials. Each resource and data source has an optional attribute named `device`, which can then select a device by its name from this list.",
				Optional:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							MarkdownDescription: "Device name.",
							Required:            true,
						},
						"host": schema.StringAttribute{
							MarkdownDescription: "IP of the Cisco IOS-XR device.",
							Required:            true,
						},
						"managed": schema.BoolAttribute{
							MarkdownDescription: "Enable or disable device management. This can be used to temporarily skip a device due to maintenance for example. Defaults to `true`.",
							Optional:            true,
						},
					},
				},
			},
		},
	}
}

func (p *iosxrProvider) Configure(ctx context.Context, req provider.ConfigureRequest, resp *provider.ConfigureResponse) {
	// Retrieve provider data from configuration
	var config providerData
	diags := req.Config.Get(ctx, &config)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// User must provide a username to the provider
	var username string
	if config.Username.IsUnknown() {
		// Cannot connect to client with an unknown value
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as username",
		)
		return
	}

	if config.Username.IsNull() {
		username = os.Getenv("IOSXR_USERNAME")
	} else {
		username = config.Username.ValueString()
	}

	if username == "" {
		// Error vs warning - empty value must stop execution
		resp.Diagnostics.AddError(
			"Unable to find username",
			"Username cannot be an empty string",
		)
		return
	}

	// User must provide a password to the provider
	var password string
	if config.Password.IsUnknown() {
		// Cannot connect to client with an unknown value
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as password",
		)
		return
	}

	if config.Password.IsNull() {
		password = os.Getenv("IOSXR_PASSWORD")
	} else {
		password = config.Password.ValueString()
	}

	if password == "" {
		// Error vs warning - empty value must stop execution
		resp.Diagnostics.AddError(
			"Unable to find password",
			"Password cannot be an empty string",
		)
		return
	}

	// Determine protocol
	var protocol string
	if config.Protocol.IsUnknown() {
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as protocol",
		)
		return
	}

	if config.Protocol.IsNull() {
		protocol = os.Getenv("IOSXR_PROTOCOL")
		if protocol == "" {
			protocol = "gnmi" // default
		}
	} else {
		protocol = config.Protocol.ValueString()
	}

	// Validate protocol
	if protocol != "gnmi" && protocol != "netconf" {
		resp.Diagnostics.AddError(
			"Invalid protocol",
			fmt.Sprintf("Protocol must be 'gnmi' or 'netconf', got: %s", protocol),
		)
		return
	}

	// User must provide a host to the provider
	var host string
	if config.Host.IsUnknown() {
		// Cannot connect to client with an unknown value
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as host",
		)
		return
	}

	if config.Host.IsNull() {
		host = os.Getenv("IOSXR_HOST")
		if host == "" && len(config.Devices) > 0 {
			host = config.Devices[0].Host.ValueString()
		}
	} else {
		host = config.Host.ValueString()
	}

	if host == "" {
		// Error vs warning - empty value must stop execution
		resp.Diagnostics.AddError(
			"Unable to find host",
			"Host cannot be an empty string",
		)
		return
	}

	var verifyCertificate bool
	if config.VerifyCertificate.IsUnknown() {
		// Cannot connect to client with an unknown value
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as verify_certificate",
		)
		return
	}

	if config.VerifyCertificate.IsNull() {
		verifyCertificateStr := os.Getenv("IOSXR_VERIFY_CERTIFICATE")
		if verifyCertificateStr == "" {
			verifyCertificate = false
		} else {
			var err error
			verifyCertificate, err = strconv.ParseBool(verifyCertificateStr)
			if err != nil {
				resp.Diagnostics.AddError(
					"Invalid verify_certificate value",
					"IOSXR_VERIFY_CERTIFICATE must be a valid boolean (true/false/1/0), got: "+verifyCertificateStr,
				)
				return
			}
		}
	} else {
		verifyCertificate = config.VerifyCertificate.ValueBool()
	}

	var tls bool
	if config.Tls.IsUnknown() {
		// Cannot connect to client with an unknown value
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as tls",
		)
		return
	}

	if config.Tls.IsNull() {
		tlsStr := os.Getenv("IOSXR_TLS")
		if tlsStr == "" {
			tls = true
		} else {
			var err error
			tls, err = strconv.ParseBool(tlsStr)
			if err != nil {
				resp.Diagnostics.AddError(
					"Invalid tls value",
					"IOSXR_TLS must be a valid boolean (true/false/1/0), got: "+tlsStr,
				)
				return
			}
		}
	} else {
		tls = config.Tls.ValueBool()
	}

	var certificate string
	if config.Certificate.IsUnknown() {
		// Cannot connect to client with an unknown value
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as certificate",
		)
		return
	}

	if config.Certificate.IsNull() {
		certificate = os.Getenv("IOSXR_CERTIFICATE")
	} else {
		certificate = config.Certificate.ValueString()
	}

	var key string
	if config.Key.IsUnknown() {
		// Cannot connect to client with an unknown value
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as key",
		)
		return
	}

	if config.Key.IsNull() {
		key = os.Getenv("IOSXR_KEY")
	} else {
		key = config.Key.ValueString()
	}

	var caCertificate string
	if config.CaCertificate.IsUnknown() {
		// Cannot connect to client with an unknown value
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as ca_certificate",
		)
		return
	}

	if config.CaCertificate.IsNull() {
		caCertificate = os.Getenv("IOSXR_CA_CERTIFICATE")
	} else {
		caCertificate = config.CaCertificate.ValueString()
	}

	var retries int64
	if config.Retries.IsUnknown() {
		// Cannot connect to client with an unknown value
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as retries",
		)
		return
	}

	if config.Retries.IsNull() {
		retriesStr := os.Getenv("IOSXR_RETRIES")
		if retriesStr == "" {
			retries = 3
		} else {
			retries, _ = strconv.ParseInt(retriesStr, 0, 64)
		}
	} else {
		retries = config.Retries.ValueInt64()
	}

	var lockReleaseTimeout int64
	if config.LockReleaseTimeout.IsUnknown() {
		// Cannot connect to client with an unknown value
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as lockReleaseTimeout",
		)
		return
	}

	if config.LockReleaseTimeout.IsNull() {
		lockReleaseTimeoutStr := os.Getenv("IOSXR_LOCK_RELEASE_TIMEOUT")
		if lockReleaseTimeoutStr == "" {
			lockReleaseTimeout = 120
		} else {
			lockReleaseTimeout, _ = strconv.ParseInt(lockReleaseTimeoutStr, 0, 64)
		}
	} else {
		lockReleaseTimeout = config.LockReleaseTimeout.ValueInt64()
	}

	var reuseConnection bool
	if config.ReuseConnection.IsUnknown() {
		// Cannot connect to client with an unknown value
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as reuse_connection",
		)
		return
	}

	if config.ReuseConnection.IsNull() {
		reuseConnectionStr := os.Getenv("IOSXR_REUSE_CONNECTION")
		if reuseConnectionStr == "" {
			reuseConnection = true
		} else {
			var err error
			reuseConnection, err = strconv.ParseBool(reuseConnectionStr)
			if err != nil {
				resp.Diagnostics.AddError(
					"Invalid reuse_connection value",
					"IOSXR_REUSE_CONNECTION must be a valid boolean (true/false/1/0), got: "+reuseConnectionStr,
				)
				return
			}
		}
	} else {
		reuseConnection = config.ReuseConnection.ValueBool()
	}

	var selectedDevices []string
	if config.SelectedDevices.IsUnknown() {
		// Cannot connect to client with an unknown value
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as selected_devices",
		)
		return
	}

	if config.SelectedDevices.IsNull() {
		selectedDevicesStr := os.Getenv("IOSXR_SELECTED_DEVICES")
		if selectedDevicesStr != "" {
			parts := strings.Split(selectedDevicesStr, ",")
			for _, part := range parts {
				trimmed := strings.TrimSpace(part)
				if trimmed != "" {
					selectedDevices = append(selectedDevices, trimmed)
				}
			}
		}
	} else {
		diags = config.SelectedDevices.ElementsAs(ctx, &selectedDevices, false)
		resp.Diagnostics.Append(diags...)
		if resp.Diagnostics.HasError() {
			return
		}
	}

	// Validate selected_devices references
	if len(selectedDevices) > 0 {
		deviceMap := make(map[string]bool)
		for _, device := range config.Devices {
			deviceMap[device.Name.ValueString()] = true
		}

		var invalidDevices []string
		for _, selectedName := range selectedDevices {
			if !deviceMap[selectedName] {
				invalidDevices = append(invalidDevices, selectedName)
			}
		}

		if len(invalidDevices) > 0 {
			resp.Diagnostics.AddWarning(
				"Unknown devices in selected_devices",
				"The following device names from selected_devices do not exist in the devices list: "+strings.Join(invalidDevices, ", "),
			)
		}
	}

	data := IosxrProviderData{}
	data.Devices = make(map[string]*IosxrProviderDataDevice)
	data.ReuseConnection = reuseConnection

	// Create default device client based on protocol
	if protocol == "gnmi" {
		// Create TflogAdapter for automatic Terraform logging integration
		logger := helpers.NewTflogAdapter("gnmi")

		// Build options for go-gnmi client
		opts := []func(*gnmi.Client){
			gnmi.Username(username),
			gnmi.Password(password),
			gnmi.TLS(tls),
			gnmi.VerifyCertificate(verifyCertificate),
			gnmi.MaxRetries(int(retries)),
			gnmi.WithLogger(logger),
		}

		if certificate != "" {
			opts = append(opts, gnmi.TLSCert(certificate))
		}
		if key != "" {
			opts = append(opts, gnmi.TLSKey(key))
		}
		if caCertificate != "" {
			opts = append(opts, gnmi.TLSCA(caCertificate))
		}

		// Create default client
		var defaultClient *gnmi.Client
		var err error
		if host != "" {
			defaultClient, err = gnmi.NewClient(host, opts...)
			if err != nil {
				resp.Diagnostics.AddError(
					"Unable to create gNMI client",
					"Unable to create gNMI client:\n\n"+err.Error(),
				)
				return
			}
		}
		data.Devices[""] = &IosxrProviderDataDevice{GnmiClient: defaultClient, Protocol: "gnmi", ReuseConnection: reuseConnection, Managed: true}
	} else {
		// NETCONF
		// Parse host and port - netconf library appends :830 if only hostname is given
		// To use custom port, we need to pass hostname only and use Port() option
		netconfHost := host
		netconfPort := 830
		if strings.Contains(host, ":") {
			parts := strings.SplitN(host, ":", 2)
			netconfHost = parts[0]
			if len(parts) > 1 {
				if p, err := strconv.Atoi(parts[1]); err == nil {
					netconfPort = p
				}
			}
		}

		logger := helpers.NewTflogAdapter("netconf")
		opts := []func(*netconf.Client){
			netconf.Username(username),
			netconf.Password(password),
			netconf.Port(netconfPort),
			netconf.MaxRetries(int(retries)),
			netconf.LockReleaseTimeout(time.Duration(lockReleaseTimeout) * time.Second),
			netconf.WithLogger(logger),
		}
		if !verifyCertificate {
			opts = append(opts, netconf.InsecureSkipHostKeyVerification())
		}
		c, err := netconf.NewClient(netconfHost, opts...)
		if err != nil {
			resp.Diagnostics.AddError(
				"Unable to create NETCONF client",
				"Unable to create NETCONF client:\n\n"+err.Error(),
			)
			return
		}
		data.Devices[""] = &IosxrProviderDataDevice{NetconfClient: c, Protocol: "netconf", ReuseConnection: reuseConnection, Managed: true}
	}

	// Add all devices with their managed status
	// Add all devices with their managed status
	for _, device := range config.Devices {
		deviceName := device.Name.ValueString()
		var managed bool
		if len(selectedDevices) > 0 {
			if slices.Contains(selectedDevices, deviceName) {
				managed = true
			} else {
				managed = false
			}
		} else {
			if device.Managed.IsUnknown() || device.Managed.IsNull() {
				managed = true
			} else {
				managed = device.Managed.ValueBool()
			}
		}

		deviceHost := device.Host.ValueString()

		// Create device client based on protocol
		if protocol == "gnmi" {
			logger := helpers.NewTflogAdapter("gnmi")
			opts := []func(*gnmi.Client){
				gnmi.Username(username),
				gnmi.Password(password),
				gnmi.TLS(tls),
				gnmi.VerifyCertificate(verifyCertificate),
				gnmi.MaxRetries(int(retries)),
				gnmi.WithLogger(logger),
			}

			if certificate != "" {
				opts = append(opts, gnmi.TLSCert(certificate))
			}
			if key != "" {
				opts = append(opts, gnmi.TLSKey(key))
			}
			if caCertificate != "" {
				opts = append(opts, gnmi.TLSCA(caCertificate))
			}

			var deviceClient *gnmi.Client
			var err error
			if managed {
				deviceClient, err = gnmi.NewClient(deviceHost, opts...)
				if err != nil {
					resp.Diagnostics.AddError(
						"Unable to create gNMI client",
						fmt.Sprintf("Unable to create gNMI client for device '%s':\n\n%s", deviceName, err.Error()),
					)
					return
				}
				data.Devices[deviceName] = &IosxrProviderDataDevice{GnmiClient: deviceClient, Protocol: "gnmi", ReuseConnection: reuseConnection, Managed: managed}
			} else {
				data.Devices[deviceName] = &IosxrProviderDataDevice{GnmiClient: nil, Protocol: "gnmi", ReuseConnection: reuseConnection, Managed: managed}
			}
		} else {
			// NETCONF
			logger := helpers.NewTflogAdapter("netconf")
			opts := []func(*netconf.Client){
				netconf.Username(username),
				netconf.Password(password),
				netconf.MaxRetries(int(retries)),
				netconf.LockReleaseTimeout(time.Duration(lockReleaseTimeout) * time.Second),
				netconf.WithLogger(logger),
			}
			if !verifyCertificate {
				opts = append(opts, netconf.InsecureSkipHostKeyVerification())
			}

			if managed {
				c, err := netconf.NewClient(deviceHost, opts...)
				if err != nil {
					resp.Diagnostics.AddError(
						"Unable to create NETCONF client",
						fmt.Sprintf("Unable to create NETCONF client for device '%s':\n\n%s", deviceName, err.Error()),
					)
					return
				}
				data.Devices[deviceName] = &IosxrProviderDataDevice{NetconfClient: c, Protocol: "netconf", ReuseConnection: reuseConnection, Managed: managed}
			} else {
				data.Devices[deviceName] = &IosxrProviderDataDevice{NetconfClient: nil, Protocol: "netconf", ReuseConnection: reuseConnection, Managed: managed}
			}
		}
	}

	resp.DataSourceData = &data
	resp.ResourceData = &data
}

func (p *iosxrProvider) Resources(ctx context.Context) []func() resource.Resource {
	return []func() resource.Resource{
		NewGnmiResource,
		NewCliResource,
		NewAAAResource,
		NewAAAAccountingResource,
		NewAAAAuthenticationResource,
		NewAAAAuthorizationResource,
		NewASPathSetResource,
		NewBannerResource,
		NewBFDResource,
		NewBGPASFormatResource,
		NewBMPServerResource,
		NewCallHomeResource,
		NewCDPResource,
		NewCEFResource,
		NewCEFLoadBalancing8000Resource,
		NewCEFPBTSForwardClassResource,
		NewClassMapQoSResource,
		NewClassMapTrafficResource,
		NewCLIAliasResource,
		NewCommunitySetResource,
		NewControlPlaneResource,
		NewControllerOpticsResource,
		NewCryptoResource,
		NewDomainResource,
		NewDomainVRFResource,
		NewErrorDisableRecoveryResource,
		NewESISetResource,
		NewEtagSetResource,
		NewEthernetCFMResource,
		NewEthernetSLAResource,
		NewEVPNResource,
		NewEVPNEVIResource,
		NewEVPNInterfaceResource,
		NewEVPNRouteSyncEVIResource,
		NewEVPNRouteSyncStitchingEVIResource,
		NewEVPNSegmentRoutingSRv6EVIResource,
		NewEVPNSegmentRoutingSRv6StitchingEVIResource,
		NewEVPNStitchingEVIResource,
		NewEVPNStitchingVNIResource,
		NewEVPNVNIResource,
		NewExtcommunityBandwidthSetResource,
		NewExtcommunityCostSetResource,
		NewExtcommunityEVPNLinkBandwidthSetResource,
		NewExtcommunityOpaqueSetResource,
		NewExtcommunityRTSetResource,
		NewExtcommunitySegNHSetResource,
		NewExtcommunitySOOSetResource,
		NewFlowExporterMapResource,
		NewFlowMonitorMapResource,
		NewFlowSamplerMapResource,
		NewFPDResource,
		NewFrequencySynchronizationResource,
		NewFTPResource,
		NewGenericInterfaceListResource,
		NewHostnameResource,
		NewHWModuleProfileResource,
		NewHWModuleProfile8000Resource,
		NewHWModuleShutdownResource,
		NewICMPResource,
		NewInterfaceBundleEtherResource,
		NewInterfaceBundleEtherSubinterfaceResource,
		NewInterfaceBVIResource,
		NewInterfaceEthernetResource,
		NewInterfaceEthernetSubinterfaceResource,
		NewInterfaceLoopbackResource,
		NewInterfaceTunnelIPResource,
		NewInterfaceTunnelTEResource,
		NewIPSLAResource,
		NewIPSLAResponderResource,
		NewIPv4AccessListResource,
		NewIPv4AccessListOptionsResource,
		NewIPv4PrefixListResource,
		NewIPv6Resource,
		NewIPv6AccessListResource,
		NewIPv6AccessListOptionsResource,
		NewIPv6PrefixListResource,
		NewKeyChainResource,
		NewL2VPNResource,
		NewL2VPNBridgeGroupBridgeDomainResource,
		NewL2VPNBridgeGroupBridgeDomainAccessVFIResource,
		NewL2VPNBridgeGroupBridgeDomainNeighborResource,
		NewL2VPNBridgeGroupBridgeDomainVFIResource,
		NewL2VPNPWClassResource,
		NewL2VPNXconnectGroupResource,
		NewLACPResource,
		NewLargeCommunitySetResource,
		NewLineConsoleResource,
		NewLineDefaultResource,
		NewLineTemplateResource,
		NewLinuxNetworkingResource,
		NewLLDPResource,
		NewLoggingResource,
		NewLoggingVRFResource,
		NewLPTSPuntPoliceResource,
		NewMacSetResource,
		NewMACSecResource,
		NewMACSecPolicyResource,
		NewMonitorSessionResource,
		NewMPLSLDPResource,
		NewMPLSLDPAddressFamilyResource,
		NewMPLSLDPInterfaceResource,
		NewMPLSLDPMLDPResource,
		NewMPLSLDPVRFResource,
		NewMPLSOAMResource,
		NewMPLSTrafficEngResource,
		NewNetconfAgentTTYResource,
		NewNetconfYangAgentResource,
		NewNTPResource,
		NewOSPFAreaSetResource,
		NewPCEResource,
		NewPerformanceMeasurementResource,
		NewPerformanceMeasurementDelayProfileResource,
		NewPerformanceMeasurementEndpointIPv4Resource,
		NewPerformanceMeasurementEndpointIPv6Resource,
		NewPerformanceMeasurementInterfaceResource,
		NewPerformanceMeasurementLivenessProfileResource,
		NewPolicyGlobalSetResource,
		NewPolicyMapPBRResource,
		NewPolicyMapQoSResource,
		NewPrefixSetResource,
		NewPTPResource,
		NewPTPProfileResource,
		NewRadiusServerResource,
		NewRadiusSourceInterfaceResource,
		NewRDSetResource,
		NewRoutePolicyResource,
		NewRouterBGPResource,
		NewRouterBGPAddressFamilyResource,
		NewRouterBGPAFGroupResource,
		NewRouterBGPNeighborAddressFamilyResource,
		NewRouterBGPNeighborGroupResource,
		NewRouterBGPSessionGroupResource,
		NewRouterBGPVRFResource,
		NewRouterBGPVRFAddressFamilyResource,
		NewRouterBGPVRFNeighborAddressFamilyResource,
		NewRouterHSRPInterfaceResource,
		NewRouterHSRPInterfaceIPv4GroupV1Resource,
		NewRouterHSRPInterfaceIPv4GroupV2Resource,
		NewRouterHSRPInterfaceIPv6GroupV2Resource,
		NewRouterIGMPResource,
		NewRouterIGMPInterfaceResource,
		NewRouterIGMPVRFResource,
		NewRouterIGMPVRFInterfaceResource,
		NewRouterISISResource,
		NewRouterISISAddressFamilyResource,
		NewRouterISISInterfaceResource,
		NewRouterISISInterfaceAddressFamilyResource,
		NewRouterMLDResource,
		NewRouterMLDInterfaceResource,
		NewRouterMLDVRFResource,
		NewRouterMLDVRFInterfaceResource,
		NewRouterOSPFResource,
		NewRouterOSPFAreaResource,
		NewRouterOSPFAreaInterfaceResource,
		NewRouterOSPFVRFResource,
		NewRouterOSPFVRFAreaResource,
		NewRouterOSPFVRFAreaInterfaceResource,
		NewRouterPIMIPv4Resource,
		NewRouterPIMIPv6Resource,
		NewRouterPIMVRFIPv4Resource,
		NewRouterPIMVRFIPv6Resource,
		NewRouterStaticIPv4MulticastResource,
		NewRouterStaticIPv4UnicastResource,
		NewRouterStaticIPv6MulticastResource,
		NewRouterStaticIPv6UnicastResource,
		NewRouterStaticVRFIPv4MulticastResource,
		NewRouterStaticVRFIPv4UnicastResource,
		NewRouterStaticVRFIPv6MulticastResource,
		NewRouterStaticVRFIPv6UnicastResource,
		NewRouterVRRPInterfaceResource,
		NewRouterVRRPInterfaceIPv4Resource,
		NewRouterVRRPInterfaceIPv6Resource,
		NewRSVPResource,
		NewRSVPInterfaceResource,
		NewSegmentRoutingResource,
		NewSegmentRoutingMappingServerResource,
		NewSegmentRoutingTEResource,
		NewSegmentRoutingTEOnDemandColorResource,
		NewSegmentRoutingTEPolicyResource,
		NewSegmentRoutingV6Resource,
		NewServiceTimestampsResource,
		NewSNMPServerResource,
		NewSNMPServerMIBResource,
		NewSNMPServerVRFHostResource,
		NewSRLGResource,
		NewSSHResource,
		NewTACACSServerResource,
		NewTACACSSourceInterfaceResource,
		NewTagSetResource,
		NewTCPResource,
		NewTelemetryModelDrivenResource,
		NewTelnetResource,
		NewTFTPClientResource,
		NewTFTPServerResource,
		NewTPAResource,
		NewTrackResource,
		NewVRFResource,
		NewVTYPoolResource,
		NewXMLAgentResource,
	}
}

func (p *iosxrProvider) DataSources(ctx context.Context) []func() datasource.DataSource {
	return []func() datasource.DataSource{
		//NewGnmiDataSource,
		NewAAADataSource,
		NewAAAAccountingDataSource,
		NewAAAAuthenticationDataSource,
		NewAAAAuthorizationDataSource,
		NewASPathSetDataSource,
		NewBannerDataSource,
		NewBFDDataSource,
		NewBGPASFormatDataSource,
		NewBMPServerDataSource,
		NewCallHomeDataSource,
		NewCDPDataSource,
		NewCEFDataSource,
		NewCEFLoadBalancing8000DataSource,
		NewCEFPBTSForwardClassDataSource,
		NewClassMapQoSDataSource,
		NewClassMapTrafficDataSource,
		NewCLIAliasDataSource,
		NewCommunitySetDataSource,
		NewControlPlaneDataSource,
		NewControllerOpticsDataSource,
		NewCryptoDataSource,
		NewDomainDataSource,
		NewDomainVRFDataSource,
		NewErrorDisableRecoveryDataSource,
		NewESISetDataSource,
		NewEtagSetDataSource,
		NewEthernetCFMDataSource,
		NewEthernetSLADataSource,
		NewEVPNDataSource,
		NewEVPNEVIDataSource,
		NewEVPNInterfaceDataSource,
		NewEVPNRouteSyncEVIDataSource,
		NewEVPNRouteSyncStitchingEVIDataSource,
		NewEVPNSegmentRoutingSRv6EVIDataSource,
		NewEVPNSegmentRoutingSRv6StitchingEVIDataSource,
		NewEVPNStitchingEVIDataSource,
		NewEVPNStitchingVNIDataSource,
		NewEVPNVNIDataSource,
		NewExtcommunityBandwidthSetDataSource,
		NewExtcommunityCostSetDataSource,
		NewExtcommunityEVPNLinkBandwidthSetDataSource,
		NewExtcommunityOpaqueSetDataSource,
		NewExtcommunityRTSetDataSource,
		NewExtcommunitySegNHSetDataSource,
		NewExtcommunitySOOSetDataSource,
		NewFlowExporterMapDataSource,
		NewFlowMonitorMapDataSource,
		NewFlowSamplerMapDataSource,
		NewFPDDataSource,
		NewFrequencySynchronizationDataSource,
		NewFTPDataSource,
		NewGenericInterfaceListDataSource,
		NewHostnameDataSource,
		NewHWModuleProfileDataSource,
		NewHWModuleProfile8000DataSource,
		NewHWModuleShutdownDataSource,
		NewICMPDataSource,
		NewInterfaceBundleEtherDataSource,
		NewInterfaceBundleEtherSubinterfaceDataSource,
		NewInterfaceBVIDataSource,
		NewInterfaceEthernetDataSource,
		NewInterfaceEthernetSubinterfaceDataSource,
		NewInterfaceLoopbackDataSource,
		NewInterfaceTunnelIPDataSource,
		NewInterfaceTunnelTEDataSource,
		NewIPSLADataSource,
		NewIPSLAResponderDataSource,
		NewIPv4AccessListDataSource,
		NewIPv4AccessListOptionsDataSource,
		NewIPv4PrefixListDataSource,
		NewIPv6DataSource,
		NewIPv6AccessListDataSource,
		NewIPv6AccessListOptionsDataSource,
		NewIPv6PrefixListDataSource,
		NewKeyChainDataSource,
		NewL2VPNDataSource,
		NewL2VPNBridgeGroupBridgeDomainDataSource,
		NewL2VPNBridgeGroupBridgeDomainAccessVFIDataSource,
		NewL2VPNBridgeGroupBridgeDomainNeighborDataSource,
		NewL2VPNBridgeGroupBridgeDomainVFIDataSource,
		NewL2VPNPWClassDataSource,
		NewL2VPNXconnectGroupDataSource,
		NewLACPDataSource,
		NewLargeCommunitySetDataSource,
		NewLineConsoleDataSource,
		NewLineDefaultDataSource,
		NewLineTemplateDataSource,
		NewLinuxNetworkingDataSource,
		NewLLDPDataSource,
		NewLoggingDataSource,
		NewLoggingVRFDataSource,
		NewLPTSPuntPoliceDataSource,
		NewMacSetDataSource,
		NewMACSecDataSource,
		NewMACSecPolicyDataSource,
		NewMonitorSessionDataSource,
		NewMPLSLDPDataSource,
		NewMPLSLDPAddressFamilyDataSource,
		NewMPLSLDPInterfaceDataSource,
		NewMPLSLDPMLDPDataSource,
		NewMPLSLDPVRFDataSource,
		NewMPLSOAMDataSource,
		NewMPLSTrafficEngDataSource,
		NewNetconfAgentTTYDataSource,
		NewNetconfYangAgentDataSource,
		NewNTPDataSource,
		NewOSPFAreaSetDataSource,
		NewPCEDataSource,
		NewPerformanceMeasurementDataSource,
		NewPerformanceMeasurementDelayProfileDataSource,
		NewPerformanceMeasurementEndpointIPv4DataSource,
		NewPerformanceMeasurementEndpointIPv6DataSource,
		NewPerformanceMeasurementInterfaceDataSource,
		NewPerformanceMeasurementLivenessProfileDataSource,
		NewPolicyGlobalSetDataSource,
		NewPolicyMapPBRDataSource,
		NewPolicyMapQoSDataSource,
		NewPrefixSetDataSource,
		NewPTPDataSource,
		NewPTPProfileDataSource,
		NewRadiusServerDataSource,
		NewRadiusSourceInterfaceDataSource,
		NewRDSetDataSource,
		NewRoutePolicyDataSource,
		NewRouterBGPDataSource,
		NewRouterBGPAddressFamilyDataSource,
		NewRouterBGPAFGroupDataSource,
		NewRouterBGPNeighborAddressFamilyDataSource,
		NewRouterBGPNeighborGroupDataSource,
		NewRouterBGPSessionGroupDataSource,
		NewRouterBGPVRFDataSource,
		NewRouterBGPVRFAddressFamilyDataSource,
		NewRouterBGPVRFNeighborAddressFamilyDataSource,
		NewRouterHSRPInterfaceDataSource,
		NewRouterHSRPInterfaceIPv4GroupV1DataSource,
		NewRouterHSRPInterfaceIPv4GroupV2DataSource,
		NewRouterHSRPInterfaceIPv6GroupV2DataSource,
		NewRouterIGMPDataSource,
		NewRouterIGMPInterfaceDataSource,
		NewRouterIGMPVRFDataSource,
		NewRouterIGMPVRFInterfaceDataSource,
		NewRouterISISDataSource,
		NewRouterISISAddressFamilyDataSource,
		NewRouterISISInterfaceDataSource,
		NewRouterISISInterfaceAddressFamilyDataSource,
		NewRouterMLDDataSource,
		NewRouterMLDInterfaceDataSource,
		NewRouterMLDVRFDataSource,
		NewRouterMLDVRFInterfaceDataSource,
		NewRouterOSPFDataSource,
		NewRouterOSPFAreaDataSource,
		NewRouterOSPFAreaInterfaceDataSource,
		NewRouterOSPFVRFDataSource,
		NewRouterOSPFVRFAreaDataSource,
		NewRouterOSPFVRFAreaInterfaceDataSource,
		NewRouterPIMIPv4DataSource,
		NewRouterPIMIPv6DataSource,
		NewRouterPIMVRFIPv4DataSource,
		NewRouterPIMVRFIPv6DataSource,
		NewRouterStaticIPv4MulticastDataSource,
		NewRouterStaticIPv4UnicastDataSource,
		NewRouterStaticIPv6MulticastDataSource,
		NewRouterStaticIPv6UnicastDataSource,
		NewRouterStaticVRFIPv4MulticastDataSource,
		NewRouterStaticVRFIPv4UnicastDataSource,
		NewRouterStaticVRFIPv6MulticastDataSource,
		NewRouterStaticVRFIPv6UnicastDataSource,
		NewRouterVRRPInterfaceDataSource,
		NewRouterVRRPInterfaceIPv4DataSource,
		NewRouterVRRPInterfaceIPv6DataSource,
		NewRSVPDataSource,
		NewRSVPInterfaceDataSource,
		NewSegmentRoutingDataSource,
		NewSegmentRoutingMappingServerDataSource,
		NewSegmentRoutingTEDataSource,
		NewSegmentRoutingTEOnDemandColorDataSource,
		NewSegmentRoutingTEPolicyDataSource,
		NewSegmentRoutingV6DataSource,
		NewServiceTimestampsDataSource,
		NewSNMPServerDataSource,
		NewSNMPServerMIBDataSource,
		NewSNMPServerVRFHostDataSource,
		NewSRLGDataSource,
		NewSSHDataSource,
		NewTACACSServerDataSource,
		NewTACACSSourceInterfaceDataSource,
		NewTagSetDataSource,
		NewTCPDataSource,
		NewTelemetryModelDrivenDataSource,
		NewTelnetDataSource,
		NewTFTPClientDataSource,
		NewTFTPServerDataSource,
		NewTPADataSource,
		NewTrackDataSource,
		NewVRFDataSource,
		NewVTYPoolDataSource,
		NewXMLAgentDataSource,
	}
}

// End of section. //template:end provider
